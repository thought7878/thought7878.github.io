在 JavaScript 里，`0.1 + 0.2 !== 0.3` 这一现象的出现，是由 JavaScript 使用的 IEEE 754 双精度 64 位浮点数表示法所导致的。以下是详细解释：

### 1. 十进制小数转二进制

计算机内部以二进制形式存储数字，然而，部分十进制小数无法精准地转换为二进制小数。例如，`0.1` 和 `0.2` 在转换为二进制时会变成无限循环小数。

`0.1` 转换为二进制：

```plaintext
0.1 * 2 = 0.2  整数部分为 0
0.2 * 2 = 0.4  整数部分为 0
0.4 * 2 = 0.8  整数部分为 0
0.8 * 2 = 1.6  整数部分为 1
0.6 * 2 = 1.2  整数部分为 1
0.2 * 2 = 0.4  整数部分为 0（开始循环）
...
```

最终得到 `0.1` 的二进制表示是一个无限循环小数 `0.0001100110011...`。

同理，`0.2` 转换为二进制也是无限循环小数。

### 2. IEEE 754 双精度 64 位浮点数表示

IEEE 754 双精度 64 位浮点数格式中，用 1 位表示符号位，11 位表示指数位，52 位表示尾数位。由于尾数位长度有限，无限循环的二进制小数只能被截断，从而产生精度损失。

### 3. 计算与精度损失

`0.1` 和 `0.2` 转换为二进制并截断后，进行加法运算，得到的结果再转换回十进制时，就和精确的 `0.3` 有了差异。

下面是验证代码：

```javascript
console.log(0.1 + 0.2);
console.log(0.1 + 0.2 === 0.3);
```

上述代码中，第一行输出 `0.1 + 0.2` 的计算结果，第二行输出比较 `0.1 + 0.2` 是否等于 `0.3` 的布尔值。

代码运行结果：

```plaintext
0.30000000000000004
false
```

### 解决方案

在进行浮点数比较时，可以设定一个误差范围（通常称作“机器精度”），当两个数的差值小于这个误差范围时，就认为它们相等。示例代码如下：

```javascript
function isApproximatelyEqual(num1, num2) {
  const epsilon = Number.EPSILON;
  return Math.abs(num1 - num2) < epsilon;
}

console.log(isApproximatelyEqual(0.1 + 0.2, 0.3));
```

此代码定义了 `isApproximatelyEqual` 函数，用来比较两个数是否在误差范围内相等，最后输出 `0.1 + 0.2` 和 `0.3` 是否近似相等的结果。
