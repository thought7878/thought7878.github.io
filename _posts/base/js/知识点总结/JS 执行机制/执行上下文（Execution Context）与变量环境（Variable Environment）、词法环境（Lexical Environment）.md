JavaScript 的执行上下文（Execution Context）、变量环境（Variable Environment）和词法环境（Lexical Environment）是代码执行的核心机制。以下是它们的详细解释及关系：

---

### **1. 执行上下文（Execution Context）**
执行上下文是 JavaScript 代码执行时的抽象环境，包含代码运行所需的所有信息。每当函数被调用或全局代码执行时，都会创建一个新的执行上下文。它分为三个阶段：
- **创建阶段**：初始化作用域链、变量环境、词法环境和 `this`。
- **执行阶段**：逐行执行代码，修改变量值。
- **销毁阶段**：执行完毕，上下文被移出调用栈。

执行上下文分为三种类型：
- **全局执行上下文**：浏览器中是 `window`，Node.js 中是 `global`。
- **函数执行上下文**：每次函数调用时创建。
- **Eval 执行上下文**（较少使用）。

---

### **2. 变量环境（Variable Environment）**
变量环境是执行上下文的一部分，**专门存储 `var` 声明的变量和函数声明**。其特点包括：
- **变量提升**：`var` 变量在创建阶段被初始化为 `undefined`，函数声明整体提升。
- **函数作用域**：`var` 变量的作用域是整个函数，而非块级。
- **与词法环境的关系**：在 ES6 之前，变量环境是唯一的环境记录；ES6 后，它成为词法环境的一个特例。

**示例：**
```javascript
function example() {
  var a = 1; // 存储在变量环境
  function inner() {} // 函数声明也存储在变量环境
}
```

---

### **3. 词法环境（Lexical Environment）**
词法环境是 ES6 引入的概念，**管理 `let`、`const` 声明和块级作用域**。其核心特性：
- **块级作用域**：`let` 和 `const` 的作用域仅限于代码块（如 `{}`）。
- **暂时性死区（TDZ）**：声明前访问会报错。
- **环境记录结构**：
  - **环境记录（Environment Record）**：存储当前作用域的变量绑定。
  - **对外部词法环境的引用**：构成作用域链。

**示例：**
```javascript
function blockExample() {
  let b = 2; // 存储在词法环境
  if (true) {
    const c = 3; // 新的块级词法环境
  }
}
```

---

### **4. 三者的关系与协作**
#### **(1) 执行上下文中的结构**
每个执行上下文包含：
- **变量环境（Variable Environment）**：处理 `var` 和函数声明。
- **词法环境（Lexical Environment）**：处理 `let`、`const` 和块级作用域。
- **this 绑定**：由调用方式决定。

#### **(2) 作用域链的构建**
作用域链通过词法环境的**外部引用**串联。变量查找顺序为：
1. 当前词法环境 → 2. 变量环境 → 3. 外部词法环境 → ... → 全局词法环境。

#### **(3) 执行流程示例**
```javascript
function outer() {
  var x = 10; // 变量环境
  let y = 20; // 词法环境
  function inner() {
    console.log(x + y); // 通过作用域链查找
  }
  return inner;
}
const closure = outer();
closure(); // 输出 30
```
- `outer` 的变量环境存储 `x` 和 `inner`。
- 词法环境存储 `y`。
- `inner` 的作用域链保留对 `outer` 环境的引用（闭包）。

---

### **5. 关键差异总结**
| **特性**               | 变量环境（Variable Environment）      | 词法环境（Lexical Environment）       |
|------------------------|--------------------------------------|---------------------------------------|
| **存储内容**           | `var` 变量、函数声明                 | `let`、`const`、块级作用域变量        |
| **作用域**             | 函数作用域                           | 块级作用域                            |
| **变量提升**           | 提升并初始化为 `undefined`           | 提升但处于暂时性死区（TDZ）           |
| **环境记录的动态性**   | 静态（函数级）                       | 动态（可嵌套块级环境）                |
| **闭包依赖**           | 直接参与                             | 通过作用域链引用                      |

---

### **6. 常见问题解析**
#### **Q1: 为什么 `var` 能穿透块级作用域？**
因为 `var` 存储在变量环境中，变量环境的作用域是函数级，而非块级。块级作用域仅由词法环境管理。

#### **Q2: 闭包如何保留变量？**
闭包通过作用域链保留对外部词法环境的引用。即使外部函数执行完毕，只要闭包存在，其引用的词法环境不会被销毁。

#### **Q3: `let` 和 `var` 在 for 循环中的表现差异？**
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i)); // 输出 3, 3, 3
}
for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j)); // 输出 0, 1, 2
}
```
- `var` 的 `i` 存储在变量环境，循环结束后值为 `3`。
- `let` 的 `j` 每次迭代创建一个新的词法环境，形成独立绑定。

---

### **7. 总结**
- **执行上下文**是代码执行的容器，包含变量环境、词法环境和 `this`。
- **变量环境**处理传统的作用域（`var` 和函数声明），**词法环境**实现块级作用域（`let`、`const`）。
- **作用域链**通过词法环境的外部引用串联，实现变量查找和闭包。

理解这些概念可深入掌握 JavaScript 的作用域、闭包和异步行为，避免变量污染、内存泄漏等问题。