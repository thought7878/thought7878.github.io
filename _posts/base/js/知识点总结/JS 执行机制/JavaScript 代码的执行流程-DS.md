JavaScript 代码的执行流程是一个分阶段的过程，涉及单线程、事件循环和异步处理机制。以下是其核心执行流程的分步说明：

---

### 一、代码解析阶段
#### 语法解析  
JavaScript 引擎逐行读取代码，检查语法错误，生成**抽象语法树（AST）**。

- **词法分析**：将*代码*分解为一个个的*词法单元（tokens）*，例如变量名、操作符等。
- **语法分析**：将*词法单元*转换为*抽象语法树（Abstract Syntax Tree, AST）*。
- **代码生成**：根据 *AST* 生成可执行的*字节码或机器码*。

**示例：**
```javascript
let a = 10;
function foo() {
  console.log(a);
}
foo();
```

在解析阶段，引擎会识别出变量 `a` 和函数 `foo`，并构建 AST。


#### 预编译（变量提升）  
   - `var` 声明的变量会被提升到作用域顶部（初始值为 `undefined`）。
   - `function` 声明的函数整体提升。
   - `let/const` 变量在提升后会被放入「暂时性死区」，直到声明语句执行。
参考：[[07.变量提升：JavaScript代码是按顺序执行的吗？#1. 编译阶段]]

---

### 二、执行上下文创建阶段
**在代码执行前，** 引擎创建`全局执行上下文（Global Execution Context）`并推入调用栈：
#### 创建阶段  
   - 创建变量环境（Variable Environment）：*存储变量和函数声明*。一个存储变量的对象
   - 建立作用域链（Scope Chain）：用于查找变量。
   - 确定 `this` 指向。

#### 函数调用时  
   每次函数调用会创建新的**函数执行上下文**，处理方式同上。

---

### 三、代码执行阶段
引擎开始逐行执行代码：
1. **同步代码执行**  
   - 修改变量值。
   - 执行函数调用（创建新的执行上下文）。
   - 遇到 `return` 或函数结束，弹出当前执行上下文。

2. **异步代码处理**  
   - **Web APIs**（如 `setTimeout`, DOM 事件）会被交给浏览器线程处理。
   - 异步任务完成时，回调函数被放入对应的队列：
     - **宏任务队列**（MacroTask Queue）：`setTimeout`、`setInterval`、I/O。
     - **微任务队列**（MicroTask Queue）：`Promise.then`、`MutationObserver`。

---

### 四、事件循环（Event Loop）
1. **主线程空闲时**，检查调用栈是否为空。
2. **优先处理微任务队列**，清空所有微任务。
3. **取一个宏任务**执行，重复此过程。

```javascript
// 示例执行顺序
console.log('1'); // 同步

setTimeout(() => console.log('2'), 0); // 宏任务

Promise.resolve().then(() => console.log('3')); // 微任务

console.log('4'); // 同步

// 输出顺序：1 → 4 → 3 → 2
```

---

### 五、关键概念总结
- **调用栈（Call Stack）**：后进先出的执行上下文容器。
- **任务队列（Task Queues）**：微任务优先级高于宏任务。
- **单线程特性**：JavaScript 同一时间只能处理一个任务，异步通过事件循环实现非阻塞。

理解这一流程能帮助开发者避免常见陷阱（如异步顺序问题），写出更高效的代码。

### 相关资料
- [[07.变量提升：JavaScript代码是按顺序执行的吗？]]
- [[JavaScript 代码的执行流程-QW]]