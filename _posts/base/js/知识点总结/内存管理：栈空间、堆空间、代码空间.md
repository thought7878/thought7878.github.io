在 JavaScript 中，内存管理是理解程序运行机制的重要部分。JavaScript 的内存模型可以分为 **栈空间（Stack）**、**堆空间（Heap）** 和 **代码空间（Code Space）** 三个主要部分。以下是对这三者的详细解释。

---

## 1. 栈空间（Stack）

### 是什么？

`栈空间`是一种用于**存储基本数据类型、函数调用时的执行上下文**的内存区域。它按照“后进先出”（LIFO, Last In First Out）的原则进行管理。

### 特点

- **存储内容**：
  - *基本数据类型*（如 `number`、`string`、`boolean`、`undefined`、`null` 等）。
  - *函数调用时的执行上下文*（包括局部变量、参数等）。
- **分配方式**：自动分配和释放，速度快。
- **大小有限**：栈空间通常较小，容易发生*栈溢出（Stack Overflow）*，例如*递归调用过深*。

### 示例

```javascript
function foo() {
  let a = 10; // 基本数据类型存放在栈中
  let b = "hello"; // 字符串也存放在栈中
  console.log(a, b);
}

foo();
```

在这个例子中，变量 `a` 和 `b` 都存储在栈空间中。

```js
function foo() {
  var a = " 极客时间 ";
  var b = a;
  var c = { name: " 极客时间 " };
  var d = c;
}
foo();
```

![[_posts/browser/教程/浏览器工作原理与实践/04-V8工作原理 (3讲)/media/c283365e37b90c60c9a1e62e39c776b7_MD5.png]]

				执行到第 3 行时的调用栈状态图

---

## 2. 堆空间（Heap）

### 是什么？

`堆空间`是一种用于存储复杂数据类型的内存区域。与栈空间不同，堆空间的大小更大且动态分配。

### 特点

- **存储内容**：
  - *引用/对象类型*（如对象、数组、函数等）。
  - *数据的实际值存储在堆中*，而*栈中只存储指向堆中数据的地址、引用（指针）*。
- **分配方式**：手动或由垃圾回收器（Garbage Collector, GC）管理。
- **大小较大**：堆空间可以存储大量数据，但访问速度较慢。

### 示例

```javascript
let obj = { name: "Alice", age: 25 }; // 对象存储在堆中
let arr = [1, 2, 3]; // 数组存储在堆中

console.log(obj.name); // 栈中的引用指向堆中的对象
console.log(arr[0]); // 栈中的引用指向堆中的数组
```

在这个例子中，`obj` 和 `arr` 的实际数据存储在堆空间中，而栈中只存储了它们的引用。


```js
function foo() {
  var a = " 极客时间 ";
  var b = a;
  var c = { name: " 极客时间 " };
  var d = c;
}
foo();
```

**对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址**。*将对象分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值*。

![[_posts/browser/教程/浏览器工作原理与实践/04-V8工作原理 (3讲)/media/6716cb6dff7d15dc60e65f97f26d8a3b_MD5.png]]

				对象类型是“堆”来存储
### 引用类型的赋值
在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

所以`d=c`的操作就是把 c 的引用地址赋值给 d，你可以参考下图：

![[_posts/browser/教程/浏览器工作原理与实践/04-V8工作原理 (3讲)/media/42d243c452de5af1cedec6a110235a2d_MD5.png]]

				引用赋值

从图中你可以看到，*变量 c 和变量 d 都指向了同一个堆中的对象*，所以，通过 c 修改 name 的值，变量 d 的值也跟着改变，归根结底它们是同一个对象。

---

## 3. 代码空间（Code Space）

### 是什么？

代码空间是一种用于存储程序代码（即函数定义和指令集）的内存区域。

### 特点

- **存储内容**：
  - 函数体、全局变量声明、类定义等。
  - 编译后的字节码或机器码（在现代 JavaScript 引擎中）。
- **分配方式**：静态分配，通常在整个程序运行期间存在。
- **不可变性**：代码空间的内容通常是只读的，不能被修改。

### 示例

```javascript
function greet(name) {
  console.log(`Hello, ${name}!`);
}

greet("Alice");
```

在这个例子中，`greet` 函数的定义存储在代码空间中，而函数调用时的参数和局部变量则存储在栈空间中。

---

## 4. 栈空间 vs 堆空间 vs 代码空间

| **特性**         | **栈空间（Stack）**              | **堆空间（Heap）**             | **代码空间（Code Space）** |
| ---------------- | -------------------------------- | ------------------------------ | -------------------------- |
| **用途**         | 存储基本数据类型和函数调用上下文 | 存储复杂数据类型               | 存储程序代码               |
| **分配方式**     | 自动分配和释放                   | 动态分配，由垃圾回收器管理     | 静态分配                   |
| **访问速度**     | 快                               | 慢                             | 只读，无需频繁访问         |
| **大小限制**     | 较小                             | 较大                           | 固定                       |
| **存储内容示例** | `let a = 10;`                    | `let obj = { name: "Alice" };` | `function greet() { ... }` |

---

## 5. 内存管理的实际应用

### 栈溢出（Stack Overflow）

如果函数调用层次过深，栈空间可能耗尽，导致栈溢出错误。例如：

```javascript
function recursive() {
  recursive(); // 无限递归调用
}

recursive(); // 报错：Maximum call stack size exceeded
```

### 垃圾回收（Garbage Collection）

JavaScript 引擎会自动回收不再使用的堆内存。例如：

```javascript
let obj = { name: "Alice" };
obj = null; // 原来的对象没有引用，会被垃圾回收
```

### 性能优化

- 尽量减少复杂数据结构的创建和销毁，以降低堆空间的压力。
- 避免不必要的递归调用，以防止栈溢出。

---

## 6. 总结

- **栈空间**：存储基本数据类型和函数调用上下文，速度快但容量有限。
- **堆空间**：存储复杂数据类型，容量大但访问速度较慢，由垃圾回收器管理。
- **代码空间**：存储程序代码，内容通常是静态且只读的。

理解这三种内存区域的工作原理，可以帮助开发者更好地优化代码性能，并避免常见的内存问题（如栈溢出、内存泄漏等）。

## 相关资料

[[12.栈空间和堆空间：数据是如何存储的？]]
