# Question 2

![[_posts/base/js/Test Your JavaScript Knowledge/media/e52c5fb299dc374f7df949d12afccf97_MD5.jpeg]]

# Question 3
参考[[async & await]]
疑问：这里的 async await 的执行
![[_posts/base/js/Test Your JavaScript Knowledge/media/924d3c5b20dd24b95f8e7482df9a0739_MD5.jpeg]]

4 5 1 2 8 7 6 3

```js
async function asyncFunction() {
  console.log(1);
  new Promise(() => console.log(2));
  await new Promise((res) => {
    setTimeout(() => console.log(3), 0);
    res();
  });
}

new Promise((res) => {
  console.log(4);
  (async () => {
    console.log(5);
    await asyncFunction();
    console.log(6);
  })();
  res();
}).then(() => console.log(7));

console.log(8);
```

以下是对这段代码执行流程的详细解释：

**一、全局代码开始执行**：

1. 首先，定义了一个名为 `asyncFunction` 的异步函数。
2. 然后，创建一个新的 `Promise` 对象（从第 10 行开始）。
   - 当这个 `Promise` 对象被创建时，它的构造函数被调用，立即执行 `console.log(4)`，将 `4` 输出到控制台。
   - 接着，一个立即执行的异步函数表达式（从第 12 行开始）被调用。
     - 在这个函数中，`console.log(5)` 被执行，将 `5` 输出到控制台。

**二、调用 `asyncFunction` 函数**：

1. 调用 `asyncFunction` 函数。
   - 首先执行 `console.log(1)`，将 `1` 输出到控制台。
   - 然后创建一个新的 `Promise` 对象（第 3 行）。
     - 这里代码存在错误，正确的写法应该是 `new Promise(() => { console.log(2); });`。按照修正后的代码，会执行 `console.log(2)`，将 `2` 输出到控制台。
   - 接着，遇到 `await new Promise((res) => {...})`（第 4 行）。
     - 这里创建了一个新的 `Promise` 对象，其中包含一个 `setTimeout` 函数，它会将 `console.log(3)` 的执行安排在 0 毫秒后，将其放入宏任务队列。
     - 同时，调用 `res()` 方法，将这个 `Promise` 对象的状态设置为已解决。
     - `await` 会暂停 `asyncFunction` 函数的执行，直到内部的 `Promise` 被解决。

**三、继续执行外层 `Promise` 的代码**：

1. 回到外层的 `Promise` 对象。
   - 由于 `asyncFunction` 函数内部的 `await` 暂停了它的执行，外层 `Promise` 对象的构造函数继续执行。
   - 调用 `res()` 方法，将外层 `Promise` 的状态设置为已解决，将 `.then(() => console.log(7))` 的回调函数添加到微任务队列。
   - 然后执行 `console.log(8)`，将 `8` 输出到控制台。

**四、处理微任务队列**：

1. 当调用栈为空时，事件循环开始处理微任务队列。
   - 首先执行 `.then(() => console.log(7))` 的回调函数，将 `7` 输出到控制台。

**五、处理宏任务队列**：

1. 微任务队列处理完毕后，事件循环开始处理宏任务队列。
   - 执行之前放入宏任务队列的 `setTimeout` 回调函数，将 `3` 输出到控制台。

**六、完成 `asyncFunction` 函数的执行**：

1. `asyncFunction` 函数继续执行 `await` 之后的代码。
   - 执行 `console.log(6)`，将 `6` 输出到控制台。

**修正后的代码**：

```javascript
async function asyncFunction() {
  console.log(1);
  new Promise(() => console.log(2));
  await new Promise((res) => {
    setTimeout(() => console.log(3), 0);
    res();
  });
}

new Promise((res) => {
  console.log(4);
  (async () => {
    console.log(5);
    await asyncFunction();
    console.log(6);
  })();
  res();
}).then(() => console.log(7));

console.log(8);
```

**代码解释**：

- `asyncFunction` 是一个异步函数，使用 `async` 关键字定义。
  - 它首先输出 `1`，然后创建一个 `Promise` 对象，输出 `2`。
  - 遇到 `await` 时，暂停函数的执行，等待内部 `Promise` 解决。
  - 内部 `Promise` 中使用 `setTimeout` 安排 `console.log(3)` 稍后执行，并调用 `res()` 解决 `Promise`。
- 外层 `Promise` 对象在创建时输出 `4`，并执行一个立即执行的异步函数。
  - 这个异步函数输出 `5`，调用 `asyncFunction`，输出 `1`、`2` 等，在 `asyncFunction` 中暂停，等待内部 `Promise`。
  - 调用 `res()` 解决外层 `Promise`，将 `.then` 回调添加到微任务队列。
  - 然后输出 `8`。
- 事件循环先处理微任务，输出 `7`，再处理宏任务，输出 `3`，最后完成 `asyncFunction` 执行，输出 `6`。

总结来说，代码的输出顺序将是 `4`、`5`、`1`、`2`、`8`、`7`、`3`、`6`。

请注意，代码中第 3 行存在错误，已在上述解释中指出正确的写法。通过 `async` 和 `await` 以及 `Promise` 对象，结合事件循环的微任务和宏任务队列，实现了复杂的异步执行顺序控制。
