
以下是一个简单的 React 表格（Table）组件的示例代码，它可以展示表头、表格数据等基本功能，并且支持一些简单的自定义配置。

## 创建组件文件及基本结构

首先创建一个名为 `Table.js` 的 React 组件文件，采用函数式组件结合 React hooks 的方式来构建，初始代码结构如下：

```js
import React from 'react';

const Table = ({ columns, data }) => {
  return (
    <table className="table-container">
      {/* 这里放置表头和表格内容 */}
    </table>
  );
};

export default Table;
```

这里定义了 `Table` 组件，它接收两个主要的属性：

- `columns`：是一个数组，用于描述表格的列信息，比如每列的标题、对应的字段名等。
- `data`：也是一个数组，存放要在表格中展示的实际数据，每个元素是一个对象，对象的属性对应 `columns` 中定义的字段名。

## 渲染表头

接下来，在组件中添加代码来渲染表格的表头部分，根据传入的 `columns` 属性来生成表头的 `<th>` 元素。

```jsx
import React from 'react';

const Table = ({ columns, data }) => {
  return (
    <table className="table-container">
      <thead>
        <tr>
          {columns.map((column) => (
            <th key={column.field}>{column.title}</th>
          ))}
        </tr>
      </thead>
      {/* 后续添加表格内容的渲染 */}
    </table>
  );
};

export default Table;
```

在上述代码中，通过遍历 `columns` 数组，为每个列信息创建一个 `<th>` 元素，并将列的标题（`title`）显示在表头单元格中，同时使用 `column.field` 作为 `key`，方便 React 进行高效的渲染更新。

## 渲染表格内容

接着，根据 `data` 数组以及 `columns` 信息来渲染表格的主体内容（`<tbody>` 部分），为每一条数据创建对应的 `<tr>` 行元素，以及每个数据对应的 `<td>` 单元格元素。

```jsx
import React from 'react';

const Table = ({ columns, data }) => {
  return (
    <table className="table-container">
      <thead>
        <tr>
          {columns.map((column) => (
            <th key={column.field}>{column.title}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((rowData) => (
          <tr key={rowData.id}>
            {columns.map((column) => (
              <td key={`${rowData.id}-${column.field}`}>
                {rowData[column.field]}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default Table;
```

在这段代码里：

- 外层的 `data.map` 循环用于遍历每一条数据记录，为每条数据创建一个 `<tr>` 行元素，使用数据记录中的 `id` 属性（假设数据对象都有 `id` 这个唯一标识字段，你可以根据实际情况替换成合适的唯一标识）作为行的 `key`。
- 内层的 `columns.map` 循环针对每一行数据中的每个列，从当前行数据对象（`rowData`）中取出对应列字段（`column.field`）的值，并将其展示在 `<td>` 单元格中，同时使用数据记录的 `id` 和列字段组合成的字符串作为 `<td>` 单元格的 `key`，保证每个单元格都有唯一的 `key`。

## 添加样式（可选步骤）

可以创建一个对应的 `Table.css` 样式文件来美化表格组件的外观，示例如下：

```css
.table-container {
  width: 100%;
  border-collapse: collapse;
}

.table-container th,
.table-container td {
  border: 1px solid #ccc;
  padding: 8px;
}

.table-container th {
  background-color: #f2f2f2;
  text-align: left;
}
```

上述样式定义了表格的基本外观，比如边框样式、单元格内边距、表头背景色等，你可以根据实际需求进一步丰富和修改样式。

## 使用示例

在其他的 React 组件中，可以这样引入并使用这个 `Table` 组件：

```jsx
import React from 'react';
import Table from './Table';

const App = () => {
  const columns = [
    { title: 'Name', field: 'name' },
    { title: 'Age', field: 'age' },
    { title: 'Email', field: 'email' },
  ];

  const data = [
    { id: 1, name: 'John Doe', age: 30, email: 'johndoe@example.com' },
    { id: 2, name: 'Jane Smith', age: 25, email: 'janesmith@example.com' },
  ];

  return (
    <div>
      <Table columns={columns} data={data} />
    </div>
  );
};

export default App;
```

在上述使用示例中：

- 首先定义了 `columns` 数组，描述了表格有三列，分别是姓名、年龄和邮箱，以及对应的字段名。
- 然后定义了 `data` 数组，包含了两条示例数据记录，每条记录都有 `id` 以及和 `columns` 中对应的字段属性。
- 最后在 `App` 组件的 `return` 语句中引入并使用 `Table` 组件，传入 `columns` 和 `data` 参数，从而在页面上展示出相应的表格。

你可以根据实际项目的需求，对这个表格组件进行更多功能扩展，比如：

- **排序功能**：可以添加对某一列数据进行排序的功能，通过点击表头来切换排序方式（升序、降序等）。
- **分页功能**：结合前面构建的分页组件，实现对大量数据的分页展示。
- **单元格编辑功能**：允许用户直接在表格单元格内编辑数据，并且可以保存修改后的内容等。

# 结合分页组件，实现对大量数据的分页展示

以下是*将前面构建的分页组件与表格组件结合*，实现对大量数据进行分页展示的完整代码示例及详细步骤说明：

### 1. 整合组件（在 `Table.js` 中引入分页组件）

首先，在之前创建的 `Table.js` 文件中引入 `Pagination` 分页组件，并*对整体的结构和逻辑进行调整，使其能够根据分页信息展示对应的数据*。

```jsx
import React, { useState, useEffect } from 'react';
import Pagination from './Pagination'; // 引入分页组件
import './Table.css';

const Table = ({ columns, data }) => {
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(10); // 默认每页显示 10 条数据
  const [displayData, setDisplayData] = useState([]); // 用于存储当前页要展示的数据

  useEffect(() => {
    // 根据当前页和每页显示条数来更新要展示的数据
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    setDisplayData(data.slice(startIndex, endIndex));
  }, [currentPage, itemsPerPage, data]);

  const handlePageChange = (page) => {
    setCurrentPage(page);
  };

  const handlePageSizeChange = (e) => {
    const newPageSize = parseInt(e.target.value);
    setItemsPerPage(newPageSize);
    setCurrentPage(1); // 切换每页显示条数时，重置当前页为 1
  };

  return (
    <div className="table-container">
      <table>
        <thead>
          <tr>
            {columns.map((column) => (
              <th key={column.field}>{column.title}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {displayData.map((rowData) => (
            <tr key={rowData.id}>
              {columns.map((column) => (
                <td key={`${rowData.id}-${column.field}`}>
                  {rowData[column.field]}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
      <Pagination
        totalItems={data.length}
        itemsPerPage={itemsPerPage}
        currentPage={currentPage}
        onPageChange={handlePageChange}
        onPageSizeChange={handlePageSizeChange}
      />
    </div>
  );
};

export default Table;
```

在上述代码中：

- 新增了几个状态：`currentPage` 用于记录当前所在页码，`itemsPerPage` 用于记录当前每页显示的条数，`displayData` 则是根据当前页码和每页显示条数从总数据 `data` 中截取出来的当前页要展示的数据。
- `useEffect` 钩子会在 `currentPage`、`itemsPerPage` 或者 `data` 发生变化时执行，它通过计算起始索引和结束索引，从 `data` 数组中提取出对应的数据赋值给 `displayData`，实现根据分页情况展示不同的数据。
- `handlePageChange` 函数用于处理页码切换的操作，更新 `currentPage` 状态，触发 `useEffect` 重新计算要展示的数据。
- `handlePageSizeChange` 函数处理每页显示条数切换的操作，更新 `itemsPerPage` 状态，并将 `currentPage` 重置为 `1`，同样会触发 `useEffect` 来更新展示数据，然后重新渲染表格和分页组件。
- 在组件的 `return` 部分，在表格下方添加了 `Pagination` 分页组件，并传入了相应的参数，如总数据条数（`totalItems`）、当前每页显示条数（`itemsPerPage`）、当前页码（`currentPage`）以及对应的页码和每页显示条数切换的回调函数。

### 2. 调整分页组件（`Pagination.js`）以接收外部参数和回调

对 `Pagination` 组件进行一些修改，使其能够接收外部传入的当前页码、每页显示条数等状态，以及处理页码和每页显示条数变化的回调函数，方便与表格组件交互。

```jsx
import React, { useState } from 'react';
import './Pagination.css';

const PAGE_SIZES = [5, 10, 20];

const Pagination = ({
  totalItems,
  itemsPerPage,
  currentPage,
  onPageChange,
  onPageSizeChange,
  maxVisiblePages = 5,
  showEllipsis = true,
}) => {
  const totalPages = Math.ceil(totalItems / itemsPerPage);

  const goToPreviousPage = () => {
    if (currentPage > 1) {
      onPageChange(currentPage - 1);
    }
  };

  const goToNextPage = () => {
    if (currentPage < totalPages) {
      onPageChange(currentPage + 1);
    }
  };

  const handlePageSizeChange = (e) => {
    const newPageSize = parseInt(e.target.value);
    onPageSizeChange(newPageSize);
  };

  const calculateVisiblePages = () => {
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);

    if (endPage - startPage + 1 < maxVisiblePages && endPage < totalPages) {
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    return { startPage, endPage };
  };

  const { startPage, endPage } = calculateVisiblePages();

  return (
    <div className="pagination-container">
      <label htmlFor="page-size-select">Show:</label>
      <select
        id="page-size-select"
        value={itemsPerPage}
        onChange={handlePageSizeChange}
      >
        {PAGE_SIZES.map((size) => (
          <option key={size} value={size}>
            {size}
          </option>
        ))}
      </select>
      <button className="pagination-button prev-button" onClick={goToPreviousPage}>
        Prev
      </button>
      {showEllipsis && startPage > 1 && <span className="ellipsis">...</span>}
      {Array.from({ length: endPage - startPage + 1 }, (_, index) => (
        <button
          key={index + startPage}
          className={`pagination-button ${currentPage === index + startPage? 'active' : ''}`}
          onClick={() => onPageChange(index + startPage)}
        >
          {index + startPage}
        </button>
      ))}
      {showEllipsis && endPage < totalPages && <span className="ellipsis">...</span>}
      <button className="pagination-button next-button" onClick={goToNextPage}>
        Next
      </button>
    </div>
  );
};

export default Pagination;
```

在这个修改后的 `Pagination` 组件中：

- 接收了 `currentPage`、`onPageChange`、`onPageSizeChange` 等新的参数，分别用于获取外部传入的当前页码、处理页码变化的回调函数以及处理每页显示条数变化的回调函数。
- 在各个操作函数（如 `goToPreviousPage`、`goToNextPage`、`handlePageSizeChange` 等）中，不再直接更新组件内部的状态，而是调用外部传入的相应回调函数，将控制权交给父组件（也就是 `Table` 组件），由父组件来统一更新状态并重新渲染相关内容。

### 3. 使用示例

以下是在一个简单的 React 应用中使用整合后的 `Table` 组件来展示分页数据的示例：

```jsx
import React from 'react';
import Table from './Table';

const App = () => {
  const columns = [
    { title: 'Name', field: 'name' },
    { title: 'Age', field: 'age' },
    { title: 'Email', field: 'email' },
  ];

  // 模拟大量数据，这里生成 100 条示例数据
  const data = Array.from({ length: 100 }, (_, index) => ({
    id: index + 1,
    name: `User${index + 1}`,
    age: Math.floor(Math.random() * 50 + 18),
    email: `user${index + 1}@example.com`,
  }));

  return (
    <div>
      <Table columns={columns} data={data} />
    </div>
  );
};

export default App;
```

在上述 `App` 组件中：

- 定义了和之前类似的 `columns` 数组，描述表格的列信息。
- 通过 `Array.from` 方法模拟生成了 100 条示例数据，包含姓名、年龄和邮箱等字段。
- 最后引入并使用 `Table` 组件，传入 `columns` 和 `data` 参数，这样就可以看到带有分页功能的表格展示效果了，用户可以通过分页组件切换页码、调整每页显示条数来查看不同的数据内容。

通过以上步骤，就成功地将分页组件与表格组件结合起来，实现了对大量数据的分页展示功能。你可以根据实际需求进一步优化和扩展这个功能，比如*添加数据排序功能*、更完善的样式设计等，使其更好地满足具体的业务场景需求。

请注意，上述代码只是一个基础示例，在实际应用中，可能需要考虑更多的情况，比如数据的动态加载（从后端获取数据而不是模拟数据）、性能优化（避免频繁重新渲染等）等方面的问题。
