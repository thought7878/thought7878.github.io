---
title: "Getting Started: Server and Client Components | Next.js"
source: "https://nextjs.org/docs/app/getting-started/server-and-client-components#on-the-client-first-load"
author:
  - "[[Vercel]]"
published:
created: 2025-12-19
description: "Learn how you can use React Server and Client Components to render parts of your application on the server or the client."
tags:
  - "clippings"
---
## 服务器端和客户端组件
Server and Client Components

Last updated October 22, 2025  

By default, layouts and pages are [Server Components](https://react.dev/reference/rsc/server-components), which lets you fetch data and render parts of your UI on the server, optionally cache the result, and stream it to the client. When you need interactivity or browser APIs, you can use [Client Components](https://react.dev/reference/rsc/use-client) to layer in functionality.  
默认情况下，布局和页面是`服务器组件`，这**允许您在服务器上获取数据并渲染 UI 的一部分，可以选择缓存结果，并将其流式传输到客户端**。
当您**需要交互性或浏览器 API 时**，您可以使用`客户端组件`来添加功能。

This page explains how Server and Client Components work in Next.js and when to use them, with examples of how to compose them together in your application.  
本页面解释了 Next.js 中*服务器组件和客户端组件的工作原理以及何时使用它们*，并提供了*如何在应用程序中组合它们*的示例。

## 何时使用服务器组件和客户端组件？
When to use Server and Client Components?

The client and server environments have different capabilities. Server and Client components allow you to run logic in each environment depending on your use case.  
客户端和服务器环境具有不同的功能。服务器和客户端组件允许你*根据使用情况在每种环境中运行逻辑*。

Use Client Components when you need:  
**当你需要以下功能时使用客户端组件：**
- [State](https://react.dev/learn/managing-state) and [event handlers](https://react.dev/learn/responding-to-events). E.g. `onClick`, `onChange`.  
	*状态和事件处理器*。例如： `onClick` ， `onChange` 。
- [Lifecycle logic](https://react.dev/learn/lifecycle-of-reactive-effects). E.g. `useEffect`.  
	*生命周期逻辑*。例如： `useEffect` 。
- Browser-only APIs. E.g. `localStorage`, `window`, `Navigator.geolocation`, etc.  
	*仅限浏览器的 API*。例如： `localStorage` 、 `window` 、 `Navigator.geolocation` 等。
- [Custom hooks](https://react.dev/learn/reusing-logic-with-custom-hooks).
	*自定义钩子*。

Use Server Components when you need:  
**当你需要时使用服务器组件：**
- Fetch data from databases or APIs close to the source.  
	*从靠近源头的数据库或 API 获取数据*。
- Use API keys, tokens, and other secrets without exposing them to the client.  
	使用 *API 密钥、令牌和其他密钥*，而无需将它们暴露给客户端。
- Reduce the amount of JavaScript sent to the browser.  
	*减少发送到浏览器的 JavaScript 量*。
- Improve the [First Contentful Paint (FCP)](https://web.dev/fcp/), and stream content progressively to the client.  
	*提高首次内容绘制（FCP），并逐步将内容流式传输给客户端*。

For example, the `<Page>` component is a Server Component that fetches data about a post, and passes it as props to the `<LikeButton>` which handles client-side interactivity.  
*例如*， `<Page>` 组件是一个*服务器组件*，它*获取关于帖子的数据*，并将其*作为属性传递*给 `<LikeButton>` ，后者*处理客户端交互*。

app/\[id\]/page.tsx

```tsx
import LikeButton from '@/app/ui/like-button'
import { getPost } from '@/lib/data'
 
export default async function Page({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const post = await getPost(id)
 
  return (
    <div>
      <main>
        <h1>{post.title}</h1>
        {/* ... */}
        <LikeButton likes={post.likes} />
      </main>
    </div>
  )
}
```

app/ui/like-button.tsx

```tsx
'use client'
 
import { useState } from 'react'
 
export default function LikeButton({ likes }: { likes: number }) {
  // ...
}
```

## 在 Next.js 中，服务器端组件和客户端组件是**如何工作的？**
How do Server and Client Components work in Next.js?

### 在服务器端
On the server 

On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments ([layouts and pages](https://nextjs.org/docs/app/getting-started/layouts-and-pages)):  
在服务器端，Next.js *使用 React 的 API* 来协调渲染。**渲染工作被拆分成多个块，由各个路由段（布局和页面）分别处理：**
- Server Components are rendered into a special data format called the `React Server Component Payload (RSC Payload)`.  
	`服务器组件`**被渲染为一种*特殊的数据格式***，称为 `React 服务器组件有效数据（RSC 有效数据）`。
- Client Components and the RSC Payload are used to [pre-render](https://nextjs.org/docs/app/guides/caching#rendering-strategies) HTML.  
	客户端组件和 RSC 有效数据*用于**预渲染** HTML*。

> What is the React Server Component Payload (RSC)?  
> **什么是 React 服务器组件有效数据（RSC）？**
> 
> The RSC Payload is a compact binary representation of the rendered React Server Components tree. It's used by React on the client to update the browser's DOM. The RSC Payload contains:  
> `RSC 有效数据`是**被渲染的 React 服务器组件树的紧凑*二进制*表示**。它**由 React 在客户端用于更新浏览器的 DOM**。
> 
> `RSC Payload包含：`
> - The rendered result of Server Components  
> 	**Server Components 的渲染结果**
> - Placeholders for where Client Components should be rendered and references to their JavaScript files  
> 	Client Components **应渲染的位置占位符**及**其 JavaScript 文件引用**
> - Any props passed from a Server Component to a Client Component  
> 	**从服务器组件传递到客户端组件的任何属性（服务端渲染时获取的数据）**
> 	
> 参考：[[RSC-QW1]]



### 在客户端（首次加载）
On the client (first load)

Then, on the client:  
然后在客户端：

1. `HTML` is used to immediately show a fast non-interactive preview of the route to the user.  
	**使用 HTML 立即向用户展示一个快速的、非交互式的路由预览**。
2. `RSC Payload `is used to reconcile the Client and Server Component trees.  
	**使用 RSC Payload 来同步客户端和服务器组件树**。
3. `JavaScript` is used to hydrate Client Components and make the application interactive.  
	**JavaScript 用于为 Client Components 进行水合处理，使应用程序具有交互性**。

> What is hydration?
> **什么是 hydration？**
> 
> Hydration is React's process for attaching [event handlers](https://react.dev/learn/responding-to-events) to the DOM, to make the static HTML interactive.  
> `hydration` 是 **React 将事件处理器附加到 DOM 的过程（事件绑定），使静态 HTML 变得可交互**。

### 后续导航
Subsequent Navigations 

On subsequent navigations:  
在后续导航中：

- The `RSC Payload` is prefetched and cached for instant navigation.  
	**RSC 有效数据被预取并缓存，以便即时导航**。
- `Client Components` are rendered entirely on the client, without the server-rendered HTML.  
	**客户端组件完全在客户端渲染，没有服务器渲染的 HTML**。

## 示例
Examples

### 使用 Client Components
Using Client Components 

You can create a Client Component by adding the [`"use client"`](https://react.dev/reference/react/use-client) directive at the top of the file, above your imports.  
您可以通过*在文件顶部、导入语句之前*添加 `"use client"` 指令来*创建一个 Client Component*。

app/ui/counter.tsx

```tsx
'use client'
 
import { useState } from 'react'
 
export default function Counter() {
  const [count, setCount] = useState(0)
 
  return (
    <div>
      <p>{count} likes</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}
```

`"use client"` is used to declare a **boundary** between the Server and Client module graphs (trees).  
`"use client"` 用于*声明服务器和客户端模块图（树）之间的边界*。

Once a file is marked with `"use client"`, **all its imports and child components are considered part of the client bundle**. This means you don't need to add the directive to every component that is intended for the client.  
一旦文件被标记为 `"use client"` ，**其所有导入和子组件都被视为客户端包的一部分**。这意味着你*不需要在每个打算用于客户端的组件中添加指令*。

### 减小 JS 包大小
Reducing JS bundle size 

To reduce the size of your client JavaScript bundles, add `'use client'` to specific interactive components instead of marking large parts of your UI as Client Components.  
为了减少客户端 JavaScript 包的大小，将 `'use client'` 添加到特定的交互式组件中，而不是将 UI 的很大一部分标记为客户端组件。

For example, the `<Layout>` component contains mostly static elements like a logo and navigation links, but includes an interactive search bar. `<Search />` is interactive and needs to be a Client Component, however, the rest of the layout can remain a Server Component.  
例如， `<Layout>` 组件主要包含静态元素，如标志和导航链接，但也包含一个交互式搜索栏。 `<Search />` 是交互式的，需要作为客户端组件，但布局的其余部分可以保持为服务器组件。

app/ui/search.tsx

```
'use client'

 

export default function Search() {

  // ...

}
```

### 从服务器向客户端组件传递数据
Passing data from Server to Client Components

You can pass data from Server Components to Client Components using props.  
你可以使用 props 将数据从 Server Components 传递到 Client Components。

app/\[id\]/page.tsx

```
import LikeButton from '@/app/ui/like-button'

import { getPost } from '@/lib/data'

 

export default async function Page({

  params,

}: {

  params: Promise<{ id: string }>

}) {

  const { id } = await params

  const post = await getPost(id)

 

  return <LikeButton likes={post.likes} />

}
```

app/ui/like-button.tsx

```
'use client'

 

export default function LikeButton({ likes }: { likes: number }) {

  // ...

}
```

Alternatively, you can stream data from a Server Component to a Client Component with the [`use` Hook](https://react.dev/reference/react/use). See an [example](https://nextjs.org/docs/app/getting-started/fetching-data#streaming-data-with-the-use-hook).  
或者，您可以使用 `use` Hook 将数据从服务器组件流式传输到客户端组件。查看一个示例。

> **Good to know**: Props passed to Client Components need to be [serializable](https://react.dev/reference/react/use-server#serializable-parameters-and-return-values) by React.  
> 值得了解：传递给客户端组件的属性需要可以被 React 序列化。

### 服务器组件和客户端组件的交错使用
Interleaving Server and Client Components

You can pass Server Components as a prop to a Client Component. This allows you to visually nest server-rendered UI within Client components.  
你可以将服务器组件作为属性传递给客户端组件。这允许你在客户端组件中嵌套服务器渲染的 UI。

A common pattern is to use `children` to create a *slot* in a `<ClientComponent>`. For example, a `<Cart>` component that fetches data on the server, inside a `<Modal>` component that uses client state to toggle visibility.  
一种常见模式是使用 `children` 在 `<ClientComponent>` 中创建一个插槽。例如，一个 `<Cart>` 组件在服务器上获取数据，它位于一个使用客户端状态来切换可见性的 `<Modal>` 组件内部。

app/ui/modal.tsx

```
'use client'

 

export default function Modal({ children }: { children: React.ReactNode }) {

  return <div>{children}</div>

}
```

Then, in a parent Server Component (e.g.`<Page>`), you can pass a `<Cart>` as the child of the `<Modal>`:  
然后，在一个父服务器组件（例如 `<Page>` ）中，你可以将 `<Cart>` 作为 `<Modal>` 的子元素传递：

app/page.tsx

```
import Modal from './ui/modal'

import Cart from './ui/cart'

 

export default function Page() {

  return (

    <Modal>

      <Cart />

    </Modal>

  )

}
```

In this pattern, all Server Components will be rendered on the server ahead of time, including those as props. The resulting RSC payload will contain references of where Client Components should be rendered within the component tree.  
在这个模式中，所有服务器组件将在服务器上进行预渲染，包括作为属性传递的那些。生成的 RSC 负载将包含客户端组件应在组件树中渲染位置的引用。

### Context providers 
上下文提供者

[React context](https://react.dev/learn/passing-data-deeply-with-context) is commonly used to share global state like the current theme. However, React context is not supported in Server Components.  
React 上下文通常用于共享全局状态，如当前主题。然而，React 上下文在服务器组件中不受支持。

To use context, create a Client Component that accepts `children`:  
要使用上下文，创建一个接受 `children` 的客户端组件：

app/theme-provider.tsx

```
'use client'

 

import { createContext } from 'react'

 

export const ThemeContext = createContext({})

 

export default function ThemeProvider({

  children,

}: {

  children: React.ReactNode

}) {

  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>

}
```

Then, import it into a Server Component (e.g. `layout`):  
然后，将其导入到服务器组件中（例如 `layout` ）：

app/layout.tsx

```
import ThemeProvider from './theme-provider'

 

export default function RootLayout({

  children,

}: {

  children: React.ReactNode

}) {

  return (

    <html>

      <body>

        <ThemeProvider>{children}</ThemeProvider>

      </body>

    </html>

  )

}
```

Your Server Component will now be able to directly render your provider, and all other Client Components throughout your app will be able to consume this context.  
现在，您的服务器组件可以直接渲染您的提供者，而您的应用中所有其他客户端组件都将能够消费这个上下文。

> **Good to know**: You should render providers as deep as possible in the tree – notice how `ThemeProvider` only wraps `{children}` instead of the entire `<html>` document. This makes it easier for Next.js to optimize the static parts of your Server Components.  
> 值得注意：您应该尽可能深地渲染提供者——请注意 `ThemeProvider` 仅包装了 `{children}` 而不是整个 `<html>` 文档。这使 Next.js 更容易优化您的服务器组件的静态部分。

### Third-party components 
第三方组件

When using a third-party component that relies on client-only features, you can wrap it in a Client Component to ensure it works as expected.  
当使用依赖客户端功能的第三方组件时，您可以用 Client Component 将其包裹起来，以确保其按预期工作。

For example, the `<Carousel />` can be imported from the `acme-carousel` package. This component uses `useState`, but it doesn't yet have the `"use client"` directive.  
例如，可以从 `acme-carousel` 包中导入 `<Carousel />` 组件。该组件使用 `useState` ，但目前还没有 `"use client"` 指令。

If you use `<Carousel />` within a Client Component, it will work as expected:  
如果您在 Client Component 中使用 `<Carousel />` ，它将按预期工作：

app/gallery.tsx

```
'use client'

 

import { useState } from 'react'

import { Carousel } from 'acme-carousel'

 

export default function Gallery() {

  const [isOpen, setIsOpen] = useState(false)

 

  return (

    <div>

      <button onClick={() => setIsOpen(true)}>View pictures</button>

      {/* Works, since Carousel is used within a Client Component */}

      {isOpen && <Carousel />}

    </div>

  )

}
```

However, if you try to use it directly within a Server Component, you'll see an error. This is because Next.js doesn't know `<Carousel />` is using client-only features.  
但是，如果你尝试在服务器组件中直接使用它，你会看到一条错误信息。这是因为 Next.js 不知道 `<Carousel />` 正在使用客户端特有的功能。

To fix this, you can wrap third-party components that rely on client-only features in your own Client Components:  
要修复这个问题，你可以将依赖客户端特有功能的第三方组件包裹在你的自己的 Client Components 中：

app/carousel.tsx

```
'use client'

 

import { Carousel } from 'acme-carousel'

 

export default Carousel
```

Now, you can use `<Carousel />` directly within a Server Component:  
现在，您可以直接在服务器组件中使用 `<Carousel />` ：

app/page.tsx

```
import Carousel from './carousel'

 

export default function Page() {

  return (

    <div>

      <p>View pictures</p>

      {/*  Works, since Carousel is a Client Component */}

      <Carousel />

    </div>

  )

}
```

> **Advice for Library Authors  
> 给库作者的建议**
> 
> If you’re building a component library, add the `"use client"` directive to entry points that rely on client-only features. This lets your users import components into Server Components without needing to create wrappers.  
> 如果你正在构建一个组件库，将 `"use client"` 指令添加到依赖客户端特性的入口点。这允许你的用户无需创建包装器即可将组件导入服务器组件。
> 
> It's worth noting some bundlers might strip out `"use client"` directives. You can find an example of how to configure esbuild to include the `"use client"` directive in the [React Wrap Balancer](https://github.com/shuding/react-wrap-balancer/blob/main/tsup.config.ts#L10-L13) and [Vercel Analytics](https://github.com/vercel/analytics/blob/main/packages/web/tsup.config.js#L26-L30) repositories.  
> 值得注意的是，某些打包器可能会移除 `"use client"` 指令。你可以在 React Wrap Balancer 和 Vercel Analytics 存储库中找到一个配置 esbuild 以包含 `"use client"` 指令的示例。

### 防止环境污染
Preventing environment poisoning

JavaScript modules can be shared between both Server and Client Components modules. This means it's possible to accidentally import server-only code into the client. For example, consider the following function:  
JavaScript 模块可以在服务器组件和客户端组件模块之间共享。这意味着可能会意外地将仅限服务器的代码导入客户端。例如，考虑以下函数：

This function contains an `API_KEY` that should never be exposed to the client.  
这个函数包含一个 `API_KEY` ，这个不应该暴露给客户端。

In Next.js, only environment variables prefixed with `NEXT_PUBLIC_` are included in the client bundle. If variables are not prefixed, Next.js replaces them with an empty string.  
在 Next.js 中，只有以 `NEXT_PUBLIC_` 开头的环境变量会被包含在客户端包中。如果变量没有前缀，Next.js 会将其替换为空字符串。

As a result, even though `getData()` can be imported and executed on the client, it won't work as expected.  
因此，尽管 `getData()` 可以在客户端导入和执行，但它不会按预期工作。

To prevent accidental usage in Client Components, you can use the [`server-only` package](https://www.npmjs.com/package/server-only).  
为了防止在客户端组件中意外使用，你可以使用 `server-only` 包。

Then, import the package into a file that contains server-only code:  
然后，将包导入包含服务器端代码的文件中：

Now, if you try to import the module into a Client Component, there will be a build-time error.  
现在，如果你尝试将模块导入客户端组件，将会在构建时出现错误。

The corresponding [`client-only` package](https://www.npmjs.com/package/client-only) can be used to mark modules that contain client-only logic like code that accesses the `window` object.  
可以使用相应的 `client-only` 包来标记包含客户端逻辑的模块，例如访问 `window` 对象的代码。

In Next.js, installing `server-only` or `client-only` is **optional**. However, if your linting rules flag extraneous dependencies, you may install them to avoid issues.  
在 Next.js 中，安装 `server-only` 或 `client-only` 是可选的。但是，如果你的代码检查规则标记了多余的依赖项，你可以安装它们以避免问题。


```shell
pnpm add server-only
```

Next.js handles `server-only` and `client-only` imports internally to provide clearer error messages when a module is used in the wrong environment. The contents of these packages from NPM are not used by Next.js.  
Next.js 内部处理 `server-only` 和 `client-only` 的导入，以便在模块使用环境不正确时提供更清晰的错误消息。Next.js 不使用来自 NPM 的这些包的内容。

Next.js also provides its own type declarations for `server-only` and `client-only`, for TypeScript configurations where [`noUncheckedSideEffectImports`](https://www.typescriptlang.org/tsconfig/#noUncheckedSideEffectImports) is active.  
Next.js 还为 `server-only` 和 `client-only` 提供自己的类型声明，用于 `noUncheckedSideEffectImports` 激活时的 TypeScript 配置。

---

Learn more about the APIs mentioned in this page.  
了解更多本页提到的 API。
[学习如何使用 use client 指令在客户端渲染组件。](https://nextjs.org/docs/app/api-reference/directives/use-client)
