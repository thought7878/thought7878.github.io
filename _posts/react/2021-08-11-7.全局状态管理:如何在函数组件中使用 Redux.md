---
layout: post
title: 全局状态管理:如何在函数组件中使用 Redux
subtitle:
categories: react
tags: [hooks]
# top: 2
---

Redux 作为一款状态管理框架啊，是公认的 React 开发中最大的一个门槛，但同时呢，它 也是 React 开发人员必须掌握的一项技能。因为只有熟练应用 Redux，你才能更加灵活地 使用 React，来从容应对大型项目的开发难题。
这里我要说句题外话。Redux 诞生于 2015 年，也就是 React 出现之后一年多。虽然一开 始是由第三方开发者开源，不是 Facebook 官方，但是也迅速成为了最为主流的 React 状
态管理库。而且，之后 Redux 跟它的开发者 Dan Abbramov 和 Andrew Clark 一起，都 被 Facebook 收编，成为 React 官方生态的一部分。侧面可以看到 Redux 在 React 中的 重要作用。
需要说明的是，Redux 作为一套独立的框架，虽然可以和任何 UI 框架结合起来使用。但 是因为它基于不可变数据的机制，可以说，基本上就是为 React 量身定制的。
不过你可能会说，Redux 上手比较难，该怎么办呢?的确是这样，因 Redux 引入了一些 新的编程思想，还有比较繁琐的样板代码，确实带来了一定的上手难度。
但是你不要担心，今天这节课，我会通过具体的例子带你上手 Redux。而且我会讲解 Redux 要解决什么问题，引入了什么样的新概念，争取能从本质上去理解 Redux 的理念 和使用方法，提高你举一反三的能力。

## Redux 出现的背景

很多同学一开始可能不太明白状态管理框架的作用。但是如果随着对 React 使用的深入， 你会发现组件级别的 state，和从上而下传递的 props 这两个状态机制，无法满足复杂功 能的需要。例如跨层级之间的组件的数据共享和传递。我们可以从下图的对比去理解:
![图 0](/assets/images/react/d8ba766a99a4c5a4414efc99e4686e23dfc2c879987500743c94f705c4a19223.png)

其中左图是单个 React 组件，它的状态可以用内部的 state 来维护，而且这个 state 在组 件外部是无法访问的。而右图则是使用 Redux 的场景，用全局唯一的 Store 维护了整个应 用程序的状态。可以说，对于页面的多个组件，都是从这个 Store 来获取状态的，保证组 件之间能够共享状态。
所以从这张对比图，我们可以看到 Redux Store 的两个特点:

1. Redux Store 是全局唯一的。即整个应用程序一般只有一个 Store。
2. Redux Store 是树状结构，可以更天然地映射到组件树的结构，虽然不是必须的。

我们通过把状态放在组件之外，就可以让 React 组件成为更加纯粹的表现层，那么很多对 于业务数据和状态数据的管理，就都可以在组件之外去完成(后面课程会介绍的 Reducer 和 Action)。同时这也天然提供了状态共享的能力，有两个场景可以典型地体现出这一 点。

1. 跨组件的状态共享:当某个组件发起一个请求时，将某个 Loading 的数据状态设为 True，另一个全局状态组件则显示 Loading 的状态。
2. 同组件多个实例的状态共享:某个页面组件初次加载时，会发送请求拿回了一个数据， 切换到另外一个页面后又返回。这时数据已经存在，无需重新加载。设想如果是本地的 组件 state，那么组件销毁后重新创建，state 也会被重置，就还需要重新获取数据。

因此，学会 Redux ，才能真正用 React 去灵活解决问题。下面我们就来了解下 Redux 中 的一些基本概念。
理解 Redux 的三个基本概念
Redux 引入的概念其实并不多，主要就是三个:State、Action 和 Reducer。
其中 State 即 Store，一般就是一个纯 JavaScript Object。 Action 也是一个 Object，用于描述发生的动作。
而 Reducer 则是一个函数，接收 Action 和 State 并作为参数，通过计算得到新的 Store。
它们三者之间的关系可以用下图来表示:
![图 1](/assets/images/react/587418605a43a9b3cf44a7ba3503ad07ef0c6611ba98d9aa26705f641ea43761.png)

在 Redux 中，所有对于 Store 的修改都必须通过这样一个公式去完成，即通过 Reducer 完成，而不是直接修改 Store。这样的话，一方面可以保证数据的不可变性 (Immutable)，同时也能带来两个非常大的好处。

1. 可预测性(Predictable):即给定一个初始状态和一系列的 Action，一定能得到一致 的结果，同时这也让代码更容易测试。
2. 易于调试:可以跟踪 Store 中数据的变化，甚至暂停和回放。因为每次 Action 产生的 变化都会产生新的对象，而我们可以缓存这些对象用于调试。Redux 的基于浏览器插件 的开发工具就是基于这个机制，非常有利于调试。

这么抽象的解释，你可能不好理解，别着急，我给你举个例子，来帮助你理解这几个概 念。这个例子是开发一个计数器的逻辑。比如说要实现“加一”和“减一”这两个功能， 对于 Redux 来说，我们需要如下代码:

```javascript
import { createStore } from "redux"; // 定义 Store 的初始值
const initialState = { value: 0 };
// Reducer，处理 Action 返回新的 State
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case "counter/incremented":
      return { value: state.value + 1 };
    case "counter/decremented":
      return { value: state.value - 1 };
    default:
      return state;
  }
}
// 利用 Redux API 创建一个 Store，参数就是 Reducer
const store = createStore(counterReducer);
// Store 提供了 subscribe 用于监听数据变化
store.subscribe(() => console.log(store.getState()));
// 计数器加 1，用 Store 的 dispatch 方法分发一个 Action，由 Reducer 处理
const incrementAction = { type: "counter/incremented" };
store.dispatch(incrementAction);
// 监听函数输出：{value: 1}
// 计数器减 1
const decrementAction = { type: "counter/decremented" };
store.dispatch(decrementAction);
// 监听函数输出：{value: 0}
```

通过这段代码，我们就用三个步骤完成了一个完整的 Redux 的逻辑：

1.  先创建 Store；
2.  再利用 Action 和 Reducer 修改 Store；
3.  最后利用 subscribe 监听 Store 的变化。

需要注意的是，在 Reducer 中，我们每次都必须返回一个新的对象，确保不可变数据
（Immutable）的原则。一般来说，我们可以用延展操作符（Spread Operator）来简单
地实现不可变数据的操作，例如：
