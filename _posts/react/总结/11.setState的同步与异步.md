## setState 要解决的问题

### 避免频繁的 re-render
*假如说“一次 setState 就触发一个完整的更新流程”这个结论成立。一个用户交互的事件处理函数中，会有多个setState，那么每一次 setState 的调用都会触发一次 re-render，UI很可能没刷新几次就卡死了*

**setState 异步的一个重要的动机，setState 异步要解决的问题——避免频繁的 re-render**

### 批量更新
**setState 异步的实现方式**有点类似于 Vue 的 $nextTick 和浏览器里的 Event-Loop：**每来一个 setState，就把它塞进一个任务队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。这个过程，叫作“批量更新”**

批量更新的过程正如下面代码中的箭头流程图所示：
```jsx
    this.setState({
      count: this.state.count + 1    ===>    入队，[count+1的任务]
    });
    this.setState({
      count: this.state.count + 1    ===>    入队，[count+1的任务，count+1的任务]
    });
    this.setState({
      count: this.state.count + 1    ===>    入队, [count+1的任务，count+1的任务, count+1的任务]
    });
                                              ↓
                                             合并 state，[count+1的任务]
                                              ↓
                                             执行 count+1的任务
```
注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。*比如这里对于相同属性的设置，React 只会为其保留最后一次的更新*。

值得注意的是，只要我们的同步代码还在执行，“攒起来”这个动作就不会停止。*因此就算我们在 React 中写了这样一个 100 次的 setState 循环：*
```jsx
    test = () => {
      console.log('循环100次 setState前的count', this.state.count)
      for(let i=0;i<100;i++) {
        this.setState({
          count: this.state.count + 1
        })
      }
      console.log('循环100次 setState后的count', this.state.count)
    }
```
*也只是会增加 state 任务入队的次数，并不会带来频繁的 re-render*。当 100 次调用结束后，仅仅是 state 的任务队列内容发生了变化， state 本身并不会立刻改变：
![[react/总结/media/246edb130ccaf253b8b9424d6d158ffc_MD5.png]]


## setState 工作流
主流程图：
![[react/总结/media/44ecaf2bf6fe856c1138e177deb3a28c_MD5.png]]

