如果我们不清楚 React 15 的运作机制，就无从把握它的局限性；如果我们不能确切地把握 React 15 的局限性，就无法从根本上理解 React 16 大改版背后的设计动机

根据 Diff 实现形式的不同，调和过程被划分为了**以 React 15 为代表**的 *“栈调和”* 以及 **React 16** 以来的 *“Fiber 调和”*。

### 调和是什么 & 调和与 Diff 的关系

**Reconciliation**，“调和”又译为“**使一致**、协调”。

*调和过程的官方定义*，藏在 React 官网对虚拟 DOM 这一概念的解释中，原文如下：
> Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 库*使 Virtual DOM 与“真实的” DOM 同步*。这一过程叫作[协调](https://zh-hans.reactjs.org/docs/reconciliation.html)（调和）。

- **调和是“使一致”的过程，使虚拟DOM和真实DOM一致。**
- **Diff 是“找不同”的过程，找新和旧的虚拟DOM的不同，它只是“使一致”过程中的一个环节。**

**React 的源码结构佐证了这一点**：React 从大的板块上将源码划分为了 Core、Renderer 和 Reconciler 三部分。其中 Reconciler（调和器）的源码位于[src/renderers/shared/stack/reconciler](https://github.com/facebook/react/tree/15-stable/src/renderers/shared/stack/reconciler)这个路径，调和器所做的工作是一系列的，包括组件的挂载、更新、卸载等过程，其中*更新过程涉及对 Diff 算法的调用*。

所以说`调和 !== Diff`这个结论，是站得住脚的，如果你持有这个观点，说明你很专业，为你点赞！
*但是！在如今大众的认知里，当我们讨论调和的时候，其实就是在讨论 Diff*。
这样的认知也有其合理性，因为**Diff 确实是调和过程中最具代表性的一环**：根据 Diff 实现形式的不同，调和过程被划分为了**以 React 15 为代表**的 *“栈调和”* 以及 **React 16** 以来的 *“Fiber 调和”*。在实际的面试过程中，当面试官抛出 Reconciliation 相关问题时，也多半是为了了解候选人对 Diff 的掌握程度。**因此在本讲中，“栈调和”指的就是 React 15 的 Diff 算法**。










