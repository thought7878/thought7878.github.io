React调度器的执行流程如下：

## 初始化阶段
1. 获取当前时间的方法被初始化，优先使用`performance.now()`，否则使用`Date.now()`
2. *定义各种优先级常量和对应的超时时间*
3. *创建两个队列*：[taskQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L58-L58)（待执行任务）和[timerQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L59-L59)（延迟任务）
4. *设置初始状态变量*，如[currentTask](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L64-L64)为null，[currentPriorityLevel](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L65-L65)为NormalPriority等

## 任务调度阶段
当调用[unstable_scheduleCallback](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L425-L499)时：

1. *计算任务的开始时间和过期时间*
2. *如果任务有延迟*（startTime > currentTime），则将其放入[timerQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L59-L59)
3. *如果任务无延迟*，则将其放入[taskQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L58-L58)
4. 如果是立即执行的任务且没有正在调度的回调，则**调用[requestHostCallback](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L647-L655)启动工作循环**

## 任务执行阶段
**当浏览器准备好执行任务时**，会触发以下流程：

1. [performWorkUntilDeadline](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L608-L630)函数被调用
2. [performWorkUntilDeadline](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L608-L630)调用[flushWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L161-L196)函数
3. [flushWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L161-L196)函数调用[workLoop](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L208-L268)函数

## 工作循环阶段
[workLoop](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L208-L268)函数执行以下步骤：

1. 调用[advanceTimers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L116-L137)*处理已到期的延迟任务*，将它们从[timerQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L59-L59)移动到[taskQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L58-L58)
2. 获取队列中的第一个任务（根据过期时间和优先级排序）
3. **在while循环中持续执行任务，直到满足以下条件之一：**
   - 队列中没有更多任务
   - 当前任务尚未过期且时间片用完（需要让出控制权给浏览器）
   - 调试模式下调度器暂停

## 任务执行细节
对于每个任务：

1. 检查任务回调函数是否存在
2. 更新当前优先级为任务优先级
3. 执行任务回调函数
4. 如果回调返回的是函数（表示任务未完成），则将其作为新的回调存储起来
5. 如果任务已完成，则从队列中移除
6. 再次调用[advanceTimers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L116-L137)处理可能在执行过程中到期的新任务

## 时间管理
- [shouldYieldToHost](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L564-L606)函数决定是否需要让出控制权给浏览器
- 通过[navigator.scheduling.isInputPending](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/dom-event-testing-library/testHelpers.js#L46-L53)检测是否有用户输入待处理
- 根据[frameInterval](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L557-L557)参数控制每帧的时间分配

## 延迟任务处理
如果[taskQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L58-L58)为空但[timerQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L59-L59)中有任务，调度器会设置一个超时定时器，在延迟时间结束后调用[handleTimeout](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%99/react/react-18.2.0/packages/scheduler/src/forks/Scheduler.js#L139-L156)函数，将延迟任务移动到执行队列。

整个调度系统的核心目标是在保证用户界面响应性的前提下，高效地执行不同类型的任务。