

本视频讲述了实现**最小堆删除堆顶元素**的操作及向下调整过程，包括*删除逻辑、堆结构维护、代码实现与边界条件处理*，并通过测试用例验证算法正确性，强调了*最小堆在动态数据中高效获取最小值的应用场景*。

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/6093c56ca1850e4c0fd5ee0e80792bb1_MD5.webp]]

## 最小堆删除操作与实现 
[00:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=0)

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/1f97572dae2cb3ff3438539bb86653de_MD5.webp]]

### 核心概念

- 最小堆：一种完全二叉树结构，每个节点都小于等于其子节点
- 删除操作：**只能删除堆顶元素**（最小值）
- 数组实现：**使用数组存储堆结构**，父节点i的左子节点为2i+1，右子节点为2i+2

### 删除操作步骤

1. 获取堆顶元素
    - `const first = heap[0]`
2. 处理空堆情况
    
    ```typescript
    if (heap.length === 0) {
      return null;
    }
    ```
    
3. 获取尾部元素
    
    ```typescript
    const last = heap.pop()!;
    ```
    
4. 处理单元素情况
    
    ```typescript
    if (first !== last) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }
    ```
    
5. 返回被删除元素
    
    ```typescript
    return first;
    ```
    

## 删除后的向下调整过程 
[01:12](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=72)

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/661bc0de5c67af9e8ef19fd206695065_MD5.webp]]

### 向下调整(siftDown)逻辑

1. 初始化参数
    
    ```typescript
    let index = i;
    const length = heap.length;
    const halfLength = length >>> 1;
    ```
    
2. 循环调整条件
    
    ```typescript
    while (index < halfLength) {
      // 调整逻辑
    }
    ```
    
3. 获取子节点索引
    
    ```typescript
    const leftIndex = (index + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];
    ```
    
4. 比较与交换逻辑
    
    ```typescript
    if (compare(left, node) < 0) {
      // 处理左子节点更小的情况
    } else if (rightIndex < length && compare(right, node) < 0) {
      // 处理右子节点更小的情况
    } else {
      // 根节点最小，无需调整
      break;
    }
    ```
    

### **示例图解**
![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/1f97572dae2cb3ff3438539bb86653de_MD5.webp]]

初始堆结构：

```
      3
    /   \
   7     4
  / \   / \
10  12 9   6
/ \       
15 14        
```

删除3后调整过程：

```
      14
    /   \
   7     4
  / \   / \
10  12 9   6
/
15
```

第一次交换后：

```
      4
    /   \
   7     14
  / \   / \
10  12 9   6
/
15
```

最终调整完成：

```
      4
    /   \
   7     6
  / \   / \
10  12 9  14
/
15
```

## 删除函数的代码实现 
[02:42](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=162)

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/f2fc595031e27865aa703161b4858c26_MD5.webp]]

### 完整代码实现

```typescript
export function pop<T extends Node>(heap: Heap<T>): T | null {
  if (heap.length === 0) {
    return null;
  }
  
  const first = heap[0];
  const last = heap.pop()!;
  
  if (first !== last) {
    heap[0] = last;
    siftDown(heap, last, 0);
  }
  
  return first;
}
function siftDown<T extends Node>(heap: Heap<T>, node: T, i: number): void {
  let index = i;
  const length = heap.length;
  const halfLength = length >>> 1;
  
  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];
    
    if (compare(left, node) < 0) {
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      break;
    }
  }
}
function compare(a: Node, b: Node): number {
  const diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}
```

## 测试用例与算法总结 
[12:48](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=768)

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/b81c25974ca7de6f24bad87582f8abef_MD5.webp]]

### 测试用例

```typescript
describe("test min heap", () => {
  let idCounter = 0;
  
  function createNode(val: number): Node {
    return { id: idCounter++, sortIndex: val };
  }
  
  it("empty heap return null", () => {
    const tasks: Heap<Node> = [];
    expect(peek(tasks)).toBeNull();
  });
  
  it("heap length === 1", () => {
    const tasks: Heap<Node> = [createNode(1)];
    expect(peek(tasks)?.sortIndex).toEqual(1);
  });
  
  it("heap length > 1", () => {
    const tasks: Heap<Node> = [createNode(1)];
    push(tasks, createNode(2));
    push(tasks, createNode(3));
    expect(peek(tasks)?.sortIndex).toEqual(1);
    
    push(tasks, createNode(0));
    expect(peek(tasks)?.sortIndex).toEqual(0);
    
    pop(tasks);
    expect(peek(tasks)?.sortIndex).toEqual(1);
  });
});
```

### 算法总结

1. 时间复杂度
    - 插入操作：O(log n)
    - 删除操作：O(log n)
    - 获取最小值：O(1)
2. 空间复杂度
    - O(n)，需要线性空间存储堆元素
3. 应用场景
    - 任务调度系统
    - 数据流中找K大/小元素
    - 图算法中的Dijkstra算法
    - 哈夫曼编码
4. 优势
    - 高效的最小值获取
    - 动态数据处理效率高
    - 空间利用率高
5. 局限性
    - 不支持快速查找任意元素
    - 不支持快速合并两个堆

### 拓展思考

- 对于动态数组频繁找最小值的问题，最小堆相比数组排序有显著优势
- LeetCode 703题（数据流中的第K大元素）是本算法的典型应用
- 最小堆是React任务调度算法的基础数据结构
- 二叉堆是实现优先队列的经典数据结构