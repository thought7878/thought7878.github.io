

本视频讲述了**时间切片的概念、其解决的高优先级任务延迟处理问题**，以及*如何通过实现任务调度中的回调函数、任务封装、工作单元循环（work loop）和控制权交还机制来完成时间切片的代码逻辑*。

参考源码：https://github.dev/thought7878/mini-react/tree/v2-lesson5

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/3ed5d40562de20cf442649a9d7fd3ede_MD5.webp]]

### 时间切片
[00:25](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=25)

- 什么是时间切片 [00:29](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=29)  
    `时间切片`是*一个固定的**时间段**，例如5毫秒，在该时间段内执行部分任务*。
- ***时间切片解决的问题*** [00:37](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=37)  
    解决**长时间运行（低优先级）任务阻塞主线程导致高优先级任务（如用户交互）无法及时响应**的问题。
![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/f572944d57f800bfce5cd43c4148ef88_MD5.webp]]
![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/b342315c3985e8ed1b5de45b88159863_MD5.webp]]

#### 无时间切片的任务执行模型 
[00:41](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=41)

- **任务执行顺序与优先级冲突** [00:45](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=45)
    - *上图的横线表示任务执行时间，长任务先执行会阻塞后续高优先级短任务*。
    - **即使调度算法已安排当前任务执行（低优先级）**，**动态新增的高优先级任务仍需等待**。
- **用户体验问题** [01:53](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=113)  
    *用户交互任务因主线程被占用而无法及时响应，造成页面卡顿*。

#### 引入时间切片后的任务调度模型 
[02:20](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=140)

- ***时间切片的工作方式*** [02:24](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=144)
    - **规定一个时间段（如5毫秒），在此期间可执行多个或单个任务**。
    - **到达时间上限后中断当前任务（即使未完成），不立即销毁，而是保留在任务池（任务队列）中**。
- ***重新调度机制*** [02:43](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=163)
    - **每个时间切片结束后，调度器重新评估任务池中的任务优先级**。
    - **高优先级任务可在下一个时间切片中被优先执行**。

### 核心概念解析：Callback、Task 与 Work 
[03:56](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=236)

- Callback 的定义 [04:28](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=268)  
    `Callback` 是**任务的初始值，本质上是一个待执行的函数**。
- Task 的封装结构 [04:37](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=277)  
    `Task` 是**调度器内部使用的任务对象，封装了Callback，增加了需要的其他数据，包含以下字段：**
    - 唯一 ID：标识任务。
    - Callback 函数：上面的Callback。
    - 优先级：任务的优先级。
    - 开始时间（startTime）：记录*任务进入调度器的开始时间*，*区分相同优先级的任务*。
    - 过期时间（expirationTime）：
    - 排序依据（sortIndex）：由优先级、开始时间、过期时间，共同决定。
- Work 的定义 [06:32](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=392)  
    `Work` 表示**一个时间切片内的工作单元，1个Work=1个时间切片内执行的Task**，包含**在该时间段内执行的一个或多个 Task**。
    - **多个 Task 在一个 Work 中，需循环执行Task**。
    - Work 是时间切片的具体体现，需循环进行以实现调度灵活性。

### 控制权交还机制的实现 
[07:53](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=473)

- **记录当前时间切片的起始时间** [08:09](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=489)  
    定义全局变量 `startTime`，初始值为 -1，在 Work 开始时记录时间戳。
- **指定时间切片长度** [08:32](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=512)  
    设定时间切片为固定毫秒数（如5毫秒）。
- **获取当前时间的方法** [08:47](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=527)  
    使用 `performance.now()` *获取更高精度的时间戳*，优于 `Date.now()`。
- **检查是否需要让出控制权** [08:42](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=522)  
    实现函数 `shouldYieldToHost`，用于*判断是否应将控制权交还给主线程*。
![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/4b0d12ab3a2744aa73a791cd431a0498_MD5.webp]]

### Work Loop 的实现逻辑 
[09:53](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=593)


***workLoop，work要循环，时间切片要循环，时间切片内的Task要循环执行。在当前时间切片内，循环执行任务。***

- 定义全局锁变量 `isPerformingWork` [10:26](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=626)
    - 初始值为 false，表示未进入 Work 状态。
    - 执行 Work 前设为 true，**防止重复调度**；执行完毕后恢复为 false。
- Work Loop 的循环条件 [14:50](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=890)  
	- 循环条件为 currentTask !== null，即*存在待处理任务*。
- **时间切片结束判断** [15:24](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=924)  
    - *在每次执行任务前，检查是否超过时间切片限制*：if (currentTime≥expirationTime) then breakif (currentTime≥expirationTime) then break
    - *若超时则中断循环，交还控制权*。
- 任务有效性校验 [16:29](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=989)  
    - *检查 callback 是否为函数类型，若不是，则视为无效任务并从任务池中移除*。
- 有效任务的执行流程 [17:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1020)
    - 将当前任务的 callback 置为 null，**防止重复执行**。
    - *提取任务优先级赋值给全局变量*。
    - *检查任务过期状态，并传入 callback 执行*。
- Continuation 回调处理 [17:45](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1065)
    - *若 callback 执行后返回一个新的函数（continuationCallback）*，**说明任务未完成，continuationCallback由scheduler的使用者（外部使用者）控制**。
    - *将原任务重新放回任务池*，并更新其 callback = continuationCallback。
    - **workLoop返回 true** 表示**任务队列中还有任务没有执行完**，需继续执行。
- 任务完成后的清理 [19:07](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1147)
    - 若 callback 无返回值，表示*任务已完成*。
    - 需判断当前任务是否仍是堆顶任务，若是则安全删除，否则留待后续处理。
- **获取下一个任务** [20:05](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1205)  
    在循环末尾调用 currentTask = peek(taskQueue) ，*获取下一个任务继续执行*。
- 循环结束判断 [20:09](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1209)
    - *若仍有 currentTask 存在，返回 true*。
    - 否则返回 false，表示所有任务已处理完毕。

### 总结与课程回顾 
[20:26](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1226)

- 重点理解 Work 与 Work Loop [20:36](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1236)  
    Work 是时间切片的核心抽象，Work Loop 是其实现机制。
- 注意不同模块中的 loop 差异 [20:47](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1247)  
    React Reconciler 中的 loop 与本课实现的调度器 loop 并非同一概念。
- 尚未完成的部分 [21:17](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1277)
    - `startTime` 的具体赋值时机将在后续课程中补充。
    - 当前代码尚不可独立运行，需结合完整调度流程才能生效。
- 本节课目标达成 [21:39](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1299)  
    掌握时间切片的概念、其所解决问题及核心代码实现思路。