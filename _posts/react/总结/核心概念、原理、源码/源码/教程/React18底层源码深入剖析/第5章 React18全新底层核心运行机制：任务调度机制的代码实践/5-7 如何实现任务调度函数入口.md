

本视频讲述了**任务调度函数入口**的实现过程，包括*如何根据回调和优先级创建任务、生成任务ID、计算过期时间及排序索引，并通过最小堆管理任务执行顺序*，同时*强调主线程调度的互斥控制*。

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/8acecb00595a790232a9912ac6be856a_MD5.webp]]

### 任务调度函数入口概述 
[00:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=0)

- **核心功能**
    `scheduleCallback` 是*任务调度的入口*，负责**接收任务**（带 callback 和 priority level）并**将其封装为 task**，**加入任务池**进行后续调度。
- **关键步骤**  
    *创建新任务（new task），填充其属性，放入最小堆中*；
    *若主线程未被占用，则触发调度*。

### New Task 的构建 
[00:44](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=44)

- **任务ID生成** [00:52](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=52)  
    每个任务需唯一 ID，*通过累加器 `taskIDCounter`实现*。初始值可设为 0 或 1，*每次创建任务时自增*。
- **Callback 与 Priority Level 设置** [01:31](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=91)  
    直接使用传入的 callback 和 priority level 作为任务字段，无需额外处理。
- **开始时间记录** [01:45](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=105)  
    使用 getCurrentTime() 获取当前时间戳作为 startTime，表示**任务到达时间**。
![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/ed5c95c154feedaa7f5c722ab779d0cb_MD5.webp]]

#### 过期时间（Expiration Time）计算 
[02:06](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=126)

- 概念解释  
    `expiration time` 表示**任务理论上应被执行的时间点**，*等于 start time + timeout*。不同于立即执行，它体现**等待时长**。
- Timeout 值依据优先级确定 [03:33](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=213)  
    根据 priority level 使用 switch 判断对应 `timeout`：
    - Immediate 执行：`timeout = -1`，表示**任务尚未到达即已过期，需立刻执行**。
    - User Blocking：`timeout = 250`（来自源码常量 USER_BLOCKING_PRIORITY_TIMEOUT）。
    - Normal / Default：使用 NORMAL_PRIORITY_TIMEOUT 常量值。
    - Low：`timeout = 10000`，*等待时间较长*。
    - Idle：timeout = MAX_SIGNED_31_BIT_VALUE（如 231−1231−1），*表示永不超时，仅在空闲时执行*。
- 最终 expiration time 计算公式
    expiration time=start time+timeoutexpiration time=start time+timeout
    
```ts
// packages/scheduler/src/SchedulerPriorities.ts

export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;

// 任务优先级
// 优先级越高，值越小
export const NoPriority = 0;
export const ImmediatePriority = 1;
export const UserBlockingPriority = 2;
export const NormalPriority = 3;
export const LowPriority = 4;
export const IdlePriority = 5;

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
const maxSigned31BitInt = 1073741823;

// Times out immediately
export const IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
export const USER_BLOCKING_PRIORITY_TIMEOUT = 250;
export const NORMAL_PRIORITY_TIMEOUT = 5000;
export const LOW_PRIORITY_TIMEOUT = 10000;
// Never times out
export const IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

export function getTimeoutByPriorityLevel(priorityLevel: PriorityLevel) {
  let timeout: number;

  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  return timeout;
}

```
### Sorting Index 的赋值 
[07:50](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=470)

- 作用说明  
    `sorting index` 是任务在最小堆中的排序依据，决定任务执行优先级。
- 取值逻辑  
    使用 `expiration time` 作为 `sorting index` 的值。
- 原因分析  
    最小堆保证 `sorting index` 最小的任务最先执行。越早过期（即 `expiration time` 越小）的任务越优先，符合调度目标。

### 任务入堆与调度触发 
[09:08](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=548)

- 任务入堆操作  
    将构建好的 `task` 通过 `push` 操作插入最小堆任务队列。
- 调度条件判断 [09:15](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=555)  
    只有当以下两个条件同时满足时才可发起调度：
    - 主线程未处于调度状态（无锁）。
    - 当前没有正在运行的时间切片（time slice）。
- 全局锁变量设置 [09:29](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=569)  
    定义布尔变量 `isHostCallbackScheduled`，用于标识主线程是否已被调度占用。
- 加锁机制  
    在触发调度前将 `isHostCallbackScheduled`设为 `true`，防止重复调度。

### 调度请求函数 requestHostCallback 
[10:35](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=635)

- 函数声明 [10:48](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=648)  
    定义函数 `requestHostCallback`，作为实际触发主线程处理任务的接口。
- 暂未实现细节  
    具体实现留待下节课讲解，当前仅搭建函数框架。

### 课程总结与回顾 
[10:58](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=658)

- 主要目的重申  
    本节课核心是实现 `schedule callback` 入口，完成 `task` 构建流程。
- 关键点回顾
    - 正确生成 `task ID` 并递增。
    - 准确设置 `start time`、`expiration time`。
    - 使用 `expiration time` 作为 `sorting index` 以支持最小堆排序。
    - 成功将任务推入任务池后，合理判断并触发调度。
- 注意事项提醒  
    必须通过 `isHostCallbackScheduled` 锁机制确保同一时间只有一个调度请求生效，保障主线程安全。