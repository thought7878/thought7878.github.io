

本视频讲述了**React调度器中延迟任务的处理逻辑**，包括*延迟任务与非延迟任务分池存储、开始时间计算、倒计时机制及锁控制下的单任务倒计时调度*，并*补充了work loop中对延迟任务的检查与推进逻辑*。

![[_posts/react/总结/核心概念、原理、源码/源码/教程/React18底层源码深入剖析/第5章 React18全新底层核心运行机制：任务调度机制的代码实践/media/1e18767ba0847c9e0afe7ee167355991_MD5.webp]]

- 延迟任务处理的代码现状说明 [00:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=0)
    
    - 当前React版本源码中，`scheduleCallback` 函数调用均未传入第三个参数（即 `options`），因此延迟任务相关逻辑实际未被使用。
    - 但源码中仍保留该逻辑，可作为拓展内容学习。
- 延迟任务的定义与参数解析 [00:39](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=39)
    
    - `scheduleCallback` 可接收一个可选的 `options` 参数。
    - 若传入 `options`，其可能包含 `delay` 字段，类型为 `number`，表示该任务具有延迟执行需求。
    - 只有当 `delay` 为有效数字且大于0时，才视为有效的延迟时间。
- 任务池分离设计：textQ 与 timerQueue [01:07](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=67)
    
    - 无延迟任务 存储在 `taskQueue`（最小堆）中，按过期时间排序。
    - 有延迟任务 存储在 `timerQueue`（最小堆）中，按 `startTime`（开始时间）排序。
    - 分离原因：避免将当前无需处理的延迟任务纳入主调度堆，减少堆调整开销，提升性能。
- 任务开始时间（startTime）的计算逻辑 [03:57](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=237)
    
    - 定义变量 `currentTime` 表示当前时间。
    - `startTime` 的取值根据是否存在有效 `delay` 决定：
        - 若无延迟，则 `startTime = currentTime`。
        - 若有延迟，则 `startTime = currentTime + delay`。
- 任务入队路径判断 [05:10](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=310)
    
    - 根据 `startTime > currentTime` 判断任务是否具有延迟。
    - 若成立，则将新任务（`newTask`）加入 `timerQueue`。
    - 否则，按原有逻辑加入 `taskQueue`。
- timerQueue 的排序依据 [07:15](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=435)
    
    - `timerQueue` 中的任务按 `startTime` 构建最小堆。
    - 堆顶任务为最早到达 `startTime` 的任务，应优先被处理。
- 倒计时机制的设计与单任务限制 [08:23](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=503)
    
    - 需通过倒计时机制，在任务到达 `startTime`时将其从 `timerQueue` 移至 `taskQueue`。
    - 因调度器为单线程，每次仅需倒计时一个任务（即堆顶任务）。
    - 引入全局布尔变量 `isHostTimeoutActive` 作为锁，确保同一时刻只有一个倒计时任务运行。
- 倒计时触发条件 [09:57](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=597)
    
    - 触发倒计时需同时满足以下条件：
        - `taskQueue` 为空（主线程空闲）。
        - `timerQueue` 非空。
        - 当前任务是 `timerQueue` 的堆顶任务（最早可执行）。
        - 无其他倒计时任务正在运行（`!isHostTimeoutActive`）。
- 倒计时函数实现：requestHostTimeout 与 cancelHostTimeout [13:01](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=781)
    
    - `requestHostTimeout(callback, delay)`：注册一个原生定时器（如 `setTimeout`），在指定延迟后执行回调。
    - 使用全局变量 `hostTimeoutID` 存储定时器ID（初始值为-1）。
    - `cancelHostTimeout()`：取消当前倒计时，调用 `clearTimeout(hostTimeoutID)` 并重置 `hostTimeoutID` 为-1 和 `isHostTimeoutActive` 为 `false`。
- 倒计时回调处理：handleTimeout [14:52](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=892)
    
    - `handleTimeout(currentTime)` 是倒计时结束后执行的函数。
    - 执行时，先将 `isHostTimeoutActive` 置为 `false`（释放锁）。
    - 调用 `advanceTimers(currentTime)` 将已到期的延迟任务移至主任务队列。
- 推进延迟任务：advanceTimers 函数 [15:48](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=948)
    
    - 功能：遍历 `timerQueue`，将所有 `startTime <= currentTime` 的任务从 `timerQueue` 移出，并加入 `taskQueue`。
    - 实现逻辑：
        - 使用循环调用 `peek()` 获取堆顶任务。
        - 若堆顶任务无效（null），则跳出循环。
        - 检查任务的 `startTime` 是否小于等于当前时间。
            - 若是，则 `pop()` 移除该任务，并修改其排序依据为过期时间（`expirationTime`），然后 `push()` 入 `taskQueue`。
            - 若否，则 `break` 结束循环（后续任务均未到期）。
- 任务迁移后的调度决策 [18:30](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1110)
    
    - 在 `advanceTimers` 或 `workLoop` 中将任务推入 `taskQueue` 后，需检查主线程状态：
        - 若 `!isHostCallbackActive`（主线程空闲），则立即调用 `requestHostCallback(workLoop)`启动调度。
        - 否则，等待当前调度周期结束。
- workLoop 中集成 advanceTimers [20:22](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1222)
    
    - 在 `workLoop` 开始执行每个工作单元前，应调用 `advanceTimers(currentTime)`。
    - 目的：确保在处理高优先级任务前，所有已到期的延迟任务能及时进入 `taskQueue` 参与调度。
- currentTime 的动态更新 [20:58](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1258)
    
    - `workLoop` 中的 `currentTime` 应在每次循环迭代时重新获取最新时间戳，以保证 `advanceTimers` 判断的准确性。
- workLoop 结尾的倒计时检查 [22:26](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1346)
    
    - 在 `workLoop` 的循环结束后，若主线程即将进入空闲状态，应检查 `timerQueue`。
    - 若存在堆顶任务，应为其启动倒计时（`requestHostTimeout(handleTimeout, delay)`），以便在未来时间点唤醒调度器。
- 完整流程总结 [23:31](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=649abdd1fba04df493057be1e8facc1d#?seek_t=1411)
    
    - 新任务根据 `delay` 决定存入 `taskQueue`或 `timerQueue`。
    - `timerQueue` 按 `startTime` 排序，仅在主线程空闲时对堆顶任务启动倒计时。
    - 倒计时结束后，通过 `advanceTimers` 将所有到期任务移至 `taskQueue`。
    - 若移动后 `taskQueue` 非空且主线程空闲，则立即启动 `workLoop` 进行调度。
    - `workLoop` 自身也会在每轮工作中检查并推进到期的延迟任务，形成闭环。