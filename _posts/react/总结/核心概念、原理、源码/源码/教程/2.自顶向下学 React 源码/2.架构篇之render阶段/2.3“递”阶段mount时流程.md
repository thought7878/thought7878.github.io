本视频讲述了React架构中render阶段的beginWork流程，重点解析了Fiber节点的双缓存机制、深度优先遍历过程、reconcile children的协调逻辑及effect tag的二进制标记机制，并说明mount时子Fiber节点的创建过程。

![[_posts/react/总结/核心概念、原理、源码/源码/教程/2.自顶向下学 React 源码/2.架构篇之render阶段/media/875d3db5491f64e335a7b05333b86b2f_MD5.webp]]

## 学习目标 
[00:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=0)

- 架构篇引入  
    从本节开始正式进入React架构篇的学习。
- 本章内容概览  
    接下来四节将详细介绍render阶段的工作流程，包括beginWork与completeWork两个阶段。
- render与commit阶段起点回顾  
    render阶段起始于render root sink，commit阶段起始于commit root。

## render阶段整体流程概述 
[00:24](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=24)

- 递归模型：递阶段与归阶段  
    render阶段通过“可中断的递归”实现，分为：
    - **递阶段（向下遍历）**：执行`beginWork`
    - **归阶段（向上回溯）**：执行`completeWork`
- **mount与update的区别**
    - mount时，首次渲染，无对应的current Fiber树
    - update时，首次渲染后的更新，存在current Fiber树  
        因此，beginWork与completeWork在两种模式下的行为不同。
- 后续章节结构安排  
    将分别讲解：
    - mount时递阶段流程
    - update时递阶段流程
    - mount时归阶段流程
    - update时归阶段流程

### render阶段执行流程演示 
[01:23](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=83)

- 测试环境准备  
    去除service worker和strict mode等无关特性，聚焦核心流程。
- 断点设置  
    在`beginWork`和`completeWork`函数处设置断点进行调试。
- 首先进入beginWork的节点  
    第一个节点tag为3，对应类型为`HostRoot`，即应用根节点。
- 深度优先遍历过程演示
    - 当前working in progress为APP组件
    - APP的子节点为DIV
    - 下一个进入`beginWork`的是div节点
    - div的子节点是header
    - header的子节点依次为image、p、a
    - image无子节点 → 进入`completeWork`
- 遍历策略确认  
    整个流程符合深度优先遍历（DFS）特征。

## completeWork执行流程分析 
[03:31](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=211)

- image节点处理
    - 执行`completeWork`，当前working progress为image
    - 完成后查找兄弟节点，发现p节点 → 进入p的`beginWork`
- p节点及其子节点处理
    - p有三个子节点：文本节点"Edit", code, 文本节点
    - 下一个进入`beginWork`的是"Edit"文本节点
    - "Edit"无子节点 → 进入其`completeWork`
- code节点优化处理
    - code有一个文本子节点
    - React对此类情况做了优化：不为单一文本子节点创建独立fiber节点
    - 因此直接进入code的`completeWork`
- 后续流程
    - code完成后处理其兄弟文本节点 → 执行该文本节点的`completeWork`
    - 该文本节点无兄弟节点 → 回到父节点p的`completeWork`
    - p完成后查找兄弟节点a → 进入a的`beginWork`

### a节点与header的completeWork处理 
[06:03](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=363)

- a节点处理
    - a的唯一子节点为文本节点，属于优化路径
    - 不创建独立fiber节点 → 直接进入a的`completeWork`
- a无兄弟节点  
    → 回到父节点header的`completeWork`
- header无兄弟节点  
    → 回到父节点div的`completeWork`
- div的父节点为APP  
    → 进入APP function component的`completeWork`
- APP的父节点为HostRoot（tag=3）  
    → 最终完成render阶段

## render阶段结束（commit阶段启动）
[07:26](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=446)

- render阶段完成标志  
    所有Fiber节点完成`beginWork`与`completeWork`遍历。
- 进入commit阶段  
    开始执行DOM更新操作，渲染页面。

## beginWork核心功能
[07:31](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=451)

- 以div节点为例分析beginWork逻辑
    - div为host component类型
    - 进入`updateHostComponent`逻辑分支
- isDirectTextChild判断  
    检测当前fiber节点是否仅有唯一文本子节点（如a标签内纯文本），若是则启用优化路径。
- reconcileChildren方法调用
    - 调用前：当前workInProgress.child为null
    - 功能：为当前workInProgress创建子Fiber节点
    - 名称来源：render阶段发生在协调器（reconciler）中

## reconcileChildren内部机制 
[09:19](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=559)

- 根据current是否存在选择路径
    - 若current === null → 走`mountChildFibers`路径（mount阶段）
    - 否则 → 走`reconcileChildFibers`路径（update阶段）
- 二者共用childReconciler函数  
    差异仅在于传入的布尔参数：`shouldTrackSideEffects`
    - 控制是否追踪副作用（如插入、删除）

## 副作用（Side Effects）机制解析 
[10:38](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=638)

- 什么是副作用？  
    指需要在commit阶段执行的实际DOM操作，如插入、删除、更新。
- deletion副作用处理
    - 若不追踪副作用 → 直接return
    - 若需追踪 → 将对应fiber节点的`effectTag`设为`Deletion`
- placement副作用处理
    - 若不追踪副作用 → 直接跳过
    - 若需追踪 → 设置`effectTag`为`Placement`

### effectTag的二进制设计原理 
[11:23](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=683)

- render阶段职责  
    不执行实际DOM操作，仅为需要操作的fiber节点打标记。
- 多副作用并存问题  
    一个fiber节点可能同时需要插入（placement）和更新（update）。
- 解决方案：二进制掩码  
    使用按位或（`|`）操作组合多个effectTag：
    
    effectTag=NoEffect∣Placement∣UpdateeffectTag=NoEffect∣Placement∣Update
    
- 验证方式  
    使用按位与（`&`）判断是否包含某类副作用：
    
    (effectTag&Placement&Update)≠NoEffect(effectTag&Placement&Update)=NoEffect
    

## **总结**：mount阶段fiber创建流程 
[16:57](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=1017)

- beginWork的核心目的  
    当fiber节点（workInProgress）进入beginWork后，创建当前fiber节点的第一个子fiber节点（workInProgress.child）。
- 执行流程
    - 判断当前fiber节点的tag类型 → 进入相应update逻辑（`updateHostRoot/updateHostComponent/updateFunctionComponent`）
    - ~~根据是否存在current fiber决定是否标记副作用~~
    - 进入reconcile逻辑（reconcileChildFibers/mountChildFibers），判断children的ReactElement类型：
        - object → 单一React Element
        - string/number → 文本节点
        - array → 子节点数组
    - 调用`reconcileSingleElement/reconcileChildrenArray/reconcileSingleTextNode`等具体方法**创建子fiber**
- createFiberFromElement流程
    - 进入`createFiberFromTypeAndProps`
    - 根据type类型（如string表示host component）创建对应fiber节点
- 每次beginWork只创建一个fiber节点  
    数组类型的children会在后续遍历中逐个处理。

### 数组类型children处理验证 
[17:55](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=24a5c265c54f495bba51ddb53eeec646#?seek_t=1075)

- 断点验证  
    header节点的children为数组，包含image、p、a三个元素。
- 注意点  
    `reconcileChildrenArray`执行结果仅创建header的直接子fiber（如image），而非整个子树。
- 结论  
    首屏渲染时，每个`beginWork`调用仅负责创建一个子fiber节点，完整过程遵循深度优先遍历顺序。