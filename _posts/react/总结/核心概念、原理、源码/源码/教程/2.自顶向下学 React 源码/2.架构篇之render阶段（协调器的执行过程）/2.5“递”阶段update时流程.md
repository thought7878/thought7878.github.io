本视频讲述了React Fiber架构中双缓存机制与更新流程（update阶段）的工作原理，重点解析了首次渲染与状态更新时create workInProgress、reconcile children等核心逻辑的差异，并说明了beginWork阶段的任务调度、副作用处理及优化路径。

![[b2038dda8aab35f898ce5a5ee855a01b_MD5.webp]]

- 复习Fiber双缓存机制 [00:04](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=4)
    
    - 双缓存结构回顾 [00:58](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=58)
        - 应用根节点为`FiberRootNode`，其`current`指针指向当前渲染完成的`current Fiber`树。
        - 首屏渲染时，基于`current Fiber`创建`workInProgress Fiber`树，用于构建更新后的视图。
    - createWorkInProgress函数的作用 [01:27](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=87)
        - 调用栈中第一个执行的是`createWorkInProgress`，传入参数为`root.current`。
        - `root`即`FiberRootNode`，`root.current`指向`current Fiber`（初始状态为`null alternate`）。
    - 首屏渲染时的创建逻辑 [02:07](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=127)
        - 若`current Fiber.alternate === null`，则`workInProgress`不存在，进入新建分支。
        - 创建新的`Fiber`节点，并复制其`current Fiber`同名字段。
        - 进入构建`workInProgress`树流程。
- 首屏渲染中的子节点协调过程 [02:50](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=170)
    
    - Fiber树结构示例 [02:50](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=170)
        - 根节点为`APP function Fiber` → 其`child`为`DIV host component`→ `child`为`header`。
        - `root Fiber`的`sibling`为`APP`，`APP.child`为`DIV`。
    - updateHostComponent阶段 [03:04](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=184)
        - 执行`reconcileChildren`方法生成子节点。
        - 首次渲染时，`workInProgress.child`为`null`；执行后生成新的`Fiber`节点。
        - `reconcileChildren`目的即生成`workInProgress.child`。
    - commit阶段与视图切换 [04:18](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=258)
        - `render`阶段完成后进入`commit`阶段，渲染页面。
        - 更新完成后，`FiberRootNode.current`指向原`workInProgress Fiber`。
        - 原`workInProgress`树变为新的`current`树。
- 第一次状态更新流程分析 [04:39](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=279)
    
    - 再次进入createWorkInProgress [04:48](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=288)
        - 点击P标签触发更新，断点命中`createWorkInProgress`。
        - 参数仍为`root.current`，此时`root.current`指向右侧已完成的`Fiber`树。
        - 当前`current Fiber`存在`alternate`指针，指向左侧的`workInProgress Fiber`。
    - 复用workInProgress节点 [05:13](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=313)
        - 因`current.alternate`存在，判定`workInProgress`已存在。
        - 复用该节点，将其字段更新为`current Fiber`的对应值。
    - 以DIV节点为例说明协调差异 [05:37](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=337)
        - 首次渲染：仅有`workInProgress DIV`，无`current`。
        - 更新时：同时存在`current DIV`与`workInProgress DIV`，且通过`alternate`相互指向。
        - 在执行`reconcileChildren`前，`workInProgress.child`已有`header Fiber`节点。
    - 为何更新前已有子节点 [06:19](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=379)
        - 创建`workInProgress DIV`时，会复用`current DIV`的部分字段。
        - 包括`child`指针，因此新`workInProgress DIV.child`直接指向`current DIV.child`（即`header`节点）。
        - 故在调用`reconcileChildren`前，`workInProgress.child`已存在。
- 第二次更新的特点 [07:32](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=452)
    
    - 所有节点均存在alternate [07:42](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=462)
        - 第二次更新时，每个`current Fiber`均已拥有`alternate`指针。
        - 每次进入`createWorkInProgress`的节点都有对应的`alternate`。
    - 验证各层级节点的alternate存在性 [08:02](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=482)
        - `root Fiber`（tag为3）有`alternate`。
        - `APP function component`有`alternate`。
        - `DIV host component`有`alternate`。
        - `header`子节点也有`alternate`。
    - 双缓存机制总结 [08:35](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=515)
        - React通过双缓存Fiber树实现高效更新：交替使用两棵树，避免重复创建。
- Update D阶段：beginWork流程详解 [08:39](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=519)
    
    - D阶段起点：beginWork [08:44](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=524)
        - 在`beginWork`打断点，触发更新可观察执行流程。
        - 首个进入的节点为`root Fiber`（tag为3）。
    - didReceiveUpdate变量的判断逻辑 [09:00](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=540)
        - 进入`current !== null`分支，根据条件设置`didReceiveUpdate`。
        - 该变量表示当前Fiber节点在本次更新中是否有变化。
    - 决定是否更新的条件 [09:24](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=564)
        - 判断依据包括：
            - 新旧`props`是否相等。
            - 是否存在`context`变化。
            - `type`是否改变。
        - 综合判断当前Fiber是否有待执行任务。
    - root Fiber的处理路径 [09:43](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=583)
        - 对于`root Fiber`，本次更新无实际任务。
        - 跳过具体`update`逻辑，进入`bailoutOnAlreadyFinishedWork`。
        - 最终执行`cloneChildFibers`。
- 克隆子节点与跳过更新逻辑 [10:09](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=609)
    
    - cloneChildFibers方法解析 [10:09](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=609)
        - 内部调用`createWorkInProgress`为子节点创建或复用`workInProgress`。
        - 返回的`workInProgress Fiber`作为当前节点的`child`。
    - 无任务节点的处理方式 [10:46](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=646)
        - 若某Fiber在`beginWork`中无需工作，则不进入`reconcileChildren`。
        - 直接克隆子Fiber并返回，进入`bailout`逻辑。
- Function Component的更新流程 [11:05](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=665)
    
    - 进入updateFunctionComponent [11:16](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=676)
        - 下一节点为`APP function component`，进入`updateFunctionComponent`逻辑。
        - 最终调用`reconcileChildren`进入协调流程。
    - renderWithHooks的调用 [11:34](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=694)
        - 执行`renderWithHooks`方法（细节将在hooks章节讲解）。
        - 该方法内会调用`component`函数。
    - component函数的含义 [12:03](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=723)
        - `component`即`function component.type`，对应函数本身。
        - 即执行`APP()`函数。
    - JSX对象的生成与传递 [12:11](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=731)
        - 函数执行返回JSX对象。
        - 返回的`children`赋值给`nextChildren`，传入`reconcileChildren`。
    - reconcileChildren的输入与输出 [13:02](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=782)
        - 输入为：当前`workInProgress`对应的`current Fiber`和子节点JSX对象。
        - 输出为：新的`workInProgress.child`。
    - reconcileChildren的不同路径 [13:21](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=801)
        - 首次渲染：`current === null`，进入`mountChildFibers`。
        - 更新阶段：`current !== null`，进入`reconcileChildFibers`。
    - 不同类型进入不同协调逻辑 [13:34](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=814)
        - 根据JSX类型进入相应协调函数。
        - 此处进入`reconcileSingleElement`。
        - 返回值传给`placeSingleChild`。
- 副作用标记的差异 [13:56](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=836)
    
    - shouldTrackSideEffects的变化 [13:56](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=836)
        - 首屏渲染：`shouldTrackSideEffects = false`。
        - 更新阶段：`shouldTrackSideEffects = true`。
    - 可能触发副作用标记 [14:08](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=848)
        - 当前更新可能进入`flag effect tag`逻辑。
    - 本次更新未触发挂载的原因 [14:14](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=854)
        - 尽管`shouldTrackSideEffects = true`，但`newFiber.alternate !== null`。
        - `newFiber.alternate === null`表示该节点是本次新增（需挂载）。
        - 当前节点在上次更新中已存在，故无需挂载。
- Update D阶段总结 [15:13](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=913)
    
    - 与首屏渲染的两点主要区别 [15:13](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=913)
        - 优化路径判断 [15:22](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=922)
            - 在`beginWork`开始时判断是否可跳过更新（`bailout`）。
            - 若满足条件（如props未变），进入`bailoutOnAlreadyFinishedWork`。
            - 在该函数中直接调用`createWorkInProgress`生成子节点。
        - 未命中优化时的处理 [15:48](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=948)
            - 否则继续走对应Fiber类型的`update`逻辑。
            - 进入`reconcileChildren`，对比`current Fiber`与JSX对象。
            - 创建新的`Fiber`节点并返回。
    - 完整流程总结 [16:10](https://b.quark.cn/apps/5AZ7aRopS/routes/quark-video-ai-summary/pc?debug=0&fid=bb3fc3ec569540d3b6008cdc98e0ef75#?seek_t=970)
        - Update D阶段的核心在于差异化协调与优化跳过机制。
        - 利用双缓存结构复用节点，减少重建开销。
        - 通过`alternate`指针管理新旧树关系，精确标记副作用。