[整体流程解读](https://www.bilibili.com/video/BV15wNWetE2W/?p=2&share_source=copy_web&vd_source=9c1e19a73fa7bd23bb37aa8d7467d862)

## 00:00 React应用创建与渲染流程详解  
对话深入探讨了React应用的创建流程，从导入ReactDOM到调用createRoot方法，详细解析了root对象及其属性的作用，包括并发模式、时间分片、优先级管理等核心概念。此外，还介绍了root fiber的创建及其在渲染过程中的重要性，为理解React的渲染机制提供了全面视角。  
  
## 05:20 React Fiber节点结构解析  
讨论了React中Fiber节点的不同类型及其属性，包括tag、mode、type、stateNode等，以及节点间的关联和更新机制，如return、child、sibling指针，memories的属性和更新队列，最后提及了事件监听和DOM实例的创建。  
  
## 10:46 虚拟DOM与React更新机制详解  
对话深入探讨了虚拟DOM的构建过程及其在React框架中的应用。首先介绍了如何将GSX语法编译成JavaScript代码，形成虚拟DOM结构，包括type、props等属性。接着，解析了React更新机制，特别是updateContainer方法中获取更新时间、优先级的逻辑，以及区分离散型与连续型事件对更新策略的影响，展现了React处理用户交互时的优化策略。  
  
## 15:58 React中烂模型与更新优先级机制详解  
对话介绍了React中烂模型的概念及其在更新优先级中的应用。烂模型通过二进制数值标识不同更新的优先级，数值越小优先级越高。更新时，会创建update对象并加入到root fiber的update队列中。通过追加当前更新的烂值到相关fiber节点的length上，实现对需更新子树的快速识别，从而优化遍历性能。  
  
## 21:38 React调度机制与优先级更新解析  
讨论了React中调度机制的运作流程，重点在于如何处理高优先级与低优先级更新任务。通过mark root update更新root节点信息，调用ensure root is schedule方法确保调度执行，使用get next length获取当前更新对应的长度值，以及get highest priority line获取最高优先级的长度值，避免重复调度，实现高效任务调度与渲染更新。  
  
## 28:58 React调度逻辑与异步任务分析  
对话深入探讨了React调度逻辑，重点分析了同步与异步任务在渲染过程中的执行顺序。通过代码示例，解释了同步更新与并发模式下任务调度的差异，以及宏任务和微任务在渲染流程中的作用，揭示了React渲染过程的异步特性。  
  
## 33:52 React渲染流程与异步代码执行  
讨论了React中同步与异步代码执行流程，重点解析了perform seek work on root方法，以及render阶段和commit阶段的工作机制。在render阶段，prepare fresh stack初始化并创建或更新fiber节点，work loop遍历fiber树，begin work处理节点，complete unit of work收集更新。commit阶段则处理更新并提交到真实DOM，通过flex值标识更新，实现高效渲染。  
  
## 40:08 React Commit阶段详解：DOM更新与副作用处理  
对话详细介绍了React在Commit阶段的主要操作，包括DOM元素更新、useLayoutEffect副作用处理以及useEffect副作用的异步执行机制。通过commitMutationEffects、commitLayoutEffects和flashPassiveEffects方法，系统遍历Fiber树，对有更新的节点进行DOM操作，确保渲染前后页面的正确性。此外，useEffect的执行可能同步或异步，影响页面渲染，其复杂性需后续深入探讨。  
  
## 46:25 并发模式下的渲染流程解析  
对话详细阐述了在并发模式下，系统如何根据烂的优先级判断是进入同步渲染还是异步可中断的渲染流程。高优先级烂或有未过期的烂时，将进入同步渲染，否则将采用时间分片的异步渲染，其中work loop concurrent方法负责执行渲染流程，并在时间分片达到时暂停执行，等待下一次调度继续，这是并发模式的核心功能。  
  
## 50:09 React异步可中断并发模式解析  
讨论了同步代码执行的局限性，提出通过宏任务拆分代码以实现异步执行，避免长时间阻塞浏览器和用户交互。介绍了React中使用时间分片和message channel实现异步可中断的并发模式，通过每5毫秒检查一次是否达到时间切片，从而控制宏任务的执行和调度，优化了代码执行效率和用户体验。