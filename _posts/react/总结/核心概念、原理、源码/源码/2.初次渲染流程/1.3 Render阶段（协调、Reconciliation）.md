>3. Render阶段（协调/Reconciliation），这个详细介绍一下。比如，函数的调用流程，每个函数的功能

# React 18 Render阶段（协调/Reconciliation）详解

Render阶段是React 18渲染流程的核心，负责**创建/更新Fiber树、执行组件逻辑、比较变化和收集副作用**。这个阶段*采用深度优先遍历策略*，分为`"beginWork（向下）"`和`"completeWork（向上）"`两个子阶段，*且在并发模式下可以被中断和恢复*。

## 1. Render阶段整体流程

```
performConcurrentWorkOnRoot()
  └── renderRootConcurrent() / renderRootSync()
      └── prepareFreshStack()          // 初始化工作栈
      └── workLoopConcurrent()         // 工作循环（可中断）
          └── performUnitOfWork()      // 执行单个工作单元
              ├── beginWork()          // 递归处理子树
              └── completeUnitOfWork() // 完成当前节点
                  └── completeWork()   // 创建DOM节点
```

## 2. 核心函数详解

### (1) renderRootConcurrent 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  // 1. 检查是否需要重新开始
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 初始化或重新开始渲染
    prepareFreshStack(root, lanes);
  }
  
  // 2. 全局上下文设置
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();
  
  // 3. 执行工作循环，允许中断
  workLoopConcurrent();
  
  // 4. 恢复上下文
  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;
  
  // 5. 检查完成状态
  if (workInProgress !== null) {
    // 被中断，未完成
    return RootInProgress;
  } else {
    // 完成渲染
    return workInProgressRootExitStatus;
  }
}
```
**功能**：
- 初始化或重置渲染环境
- 设置执行上下文和调度器Dispatcher
- 启动可中断的工作循环
- 处理上下文恢复
- 返回渲染状态（完成/中断/错误）

### (2) prepareFreshStack 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes) {
  // 1. 重置全局变量
  workInProgress = root.current.alternate;
  if (workInProgress === null) {
    // 初次渲染，创建workInProgress树
    workInProgress = createWorkInProgress(root.current, null);
  }
  
  // 2. 重置工作循环状态
  workInProgressRoot = root;
  workInProgressRootRenderLanes = lanes;
  
  // 3. 重置副作用列表
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;
  
  // 4. 重置全局指针
  subtreeRenderLanes = NoLanes;
  renderLanes = lanes;
  
  // 5. 初始化调度状态
  ensureRootIsScheduled(root, now());
}
```
**功能**：
- 创建或重用workInProgress树
- 重置全局工作状态
- 初始化副作用收集
- 设置渲染优先级
- 确保根节点被调度

### (3) workLoopConcurrent 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function workLoopConcurrent() {
  // 可中断的工作循环
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```
**功能**：
- 实现协作式调度的核心循环
- 检查`shouldYield()`决定是否让出主线程
- 持续处理工作单元直到完成或需要中断
- 与浏览器的requestIdleCallback协作

### (4) performUnitOfWork 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  // 1. 获取下一个工作单元
  const current = unitOfWork.alternate;
  let next;
  
  // 2. 处理Fiber节点
  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  
  // 3. 清除过期的props
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  // 4. 检查是否需要继续处理子节点
  if (next === null) {
    // 没有子节点，完成当前单元
    completeUnitOfWork(unitOfWork);
  } else {
    // 有子节点，继续处理
    workInProgress = next;
  }
}
```
**功能**：
- 处理单个工作单元(Fiber节点)
- 调用beginWork处理当前节点
- 根据结果决定是继续向下还是向上完成
- 管理Fiber树的遍历流程

## 3. beginWork 阶段（自顶向下）

### (1) beginWork 函数
**源码位置**：`react-reconciler/src/ReactFiberBeginWork.js`
```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 1. 检查是否可以复用
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    
    if (
      oldProps !== newProps || 
      hasLegacyContextChanged() ||
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // props或context变化，需要更新
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      // 无需更新
      didReceiveUpdate = false;
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      didReceiveUpdate = false;
    }
  } else {
    didReceiveUpdate = true;
  }
  
  // 2. 根据Fiber类型分发处理
  switch (workInProgress.tag) {
    case IndeterminateComponent:
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    case FunctionComponent:
      return updateFunctionComponent(current, workInProgress, Component, renderLanes);
    case ClassComponent:
      return updateClassComponent(current, workInProgress, Component, renderLanes);
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    // ...其他类型
    default:
      throw new Error('Unknown unit of work tag');
  }
}
```
**功能**：
- 决定是否需要更新当前Fiber
- 处理 bailout（复用已完成工作的优化）
- 根据Fiber类型分发到具体更新函数
- 管理组件更新生命周期

### (2) 关键beginWork处理函数

#### a. updateHostRoot 函数
**源码位置**：`react-reconciler/src/ReactFiberBeginWork.js`
```javascript
function updateHostRoot(current, workInProgress, renderLanes) {
  // 1. 更新状态
  pushHostRootContext(workInProgress);
  
  // 2. 处理更新队列
  const updateQueue = workInProgress.updateQueue;
  const nextProps = workInProgress.pendingProps;
  const prevState = workInProgress.memoizedState;
  
  // 3. 计算新状态
  const nextState = processUpdateQueue(
    workInProgress,
    nextProps,
    null,
    renderLanes,
  );
  
  // 4. 比较状态变化
  if (prevState === nextState) {
    // 状态未变，尝试复用子树
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  
  // 5. 更新memoizedState
  workInProgress.memoizedState = nextState;
  
  // 6. 创建子Fiber
  const nextChildren = nextState.element;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  return workInProgress.child;
}
```
**功能**：
- 处理根节点特殊上下文
- 处理更新队列和状态计算
- 协调子节点
- 为整个应用树构建起点

#### b. updateFunctionComponent 函数
**源码位置**：`react-reconciler/src/ReactFiberBeginWork.js`
```javascript
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  renderLanes,
) {
  // 1. 准备hooks上下文
  const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
  const context = getMaskedContext(workInProgress, unmaskedContext);
  
  let nextChildren;
  let hasId;
  
  // 2. 设置hooks环境
  prepareToReadContext(workInProgress, renderLanes);
  const instance = readContext(CurrentOwner);
  
  // 3. 执行函数组件
  let result;
  if (__DEV__) {
    // 开发环境特殊处理
    result = renderWithHooks(
      current,
      workInProgress,
      Component,
      workInProgress.pendingProps,
      context,
      renderLanes,
    );
  } else {
    result = renderWithHooks(
      current,
      workInProgress,
      Component,
      workInProgress.pendingProps,
      context,
      renderLanes,
    );
  }
  
  // 4. 处理组件返回结果
  nextChildren = result;
  
  // 5. 检测并处理useId
  if (hasId) {
    pushTreeId(workInProgress, instance.treeId, instance.siblingIndex);
  }
  
  // 6. 协调子节点
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  return workInProgress.child;
}
```
**功能**：
- 设置函数组件执行环境
- 初始化Hooks系统
- 执行组件函数获取JSX
- 处理特殊Hook如useId
- 协调子节点

#### c. renderWithHooks 函数
**源码位置**：`react-reconciler/src/ReactFiberHooks.js`
```javascript
export function renderWithHooks(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  props: any,
  secondArg: any,
  nextRenderLanes: Lanes,
): any {
  // 1. 保存当前Fiber
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  
  // 2. 重置hooks链表
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;
  
  // 3. 设置hooks分发器
  ReactCurrentDispatcher.current =
    current === null || current.memoizedState === null
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  
  // 4. 执行组件函数
  let children;
  try {
    children = Component(props, secondArg);
  } finally {
    // 5. 重置hooks环境
    ReactCurrentDispatcher.current = ContextOnlyDispatcher;
    currentlyRenderingFiber = (null: any);
    renderLanes = NoLanes;
  }
  
  return children;
}
```
**功能**：
- 初始化Hooks执行环境
- 根据mount/update设置不同的dispatcher
- 执行组件函数
- 捕获异常并重置状态
- 处理Hooks链表

#### d. reconcileChildren 函数
**源码位置**：`react-reconciler/src/ReactChildFiber.js`
```javascript
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    // 初次渲染，挂载子节点
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 更新，协调子节点
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```
**功能**：
- 决定使用mount还是update逻辑
- 调用diff算法
- 构建子Fiber链表
- 为completeWork阶段准备

## 4. completeWork 阶段（自底向上）

### (1) completeUnitOfWork 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function completeUnitOfWork(unitOfWork: Fiber): void {
  let completedWork = unitOfWork;
  
  do {
    // 1. 获取兄弟节点
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    
    // 2. 完成当前工作
    completeWork(current, completedWork, subtreeRenderLanes);
    
    // 3. 收集副作用
    collectEffectList(current, completedWork);
    
    // 4. 获取兄弟节点
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      // 有兄弟节点，处理兄弟
      workInProgress = siblingFiber;
      return;
    }
    
    // 5. 返回父节点
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
  
  // 6. 根节点完成
  if (workInProgressRootExitStatus === RootInProgress) {
    workInProgressRootExitStatus = RootCompleted;
  }
}
```
**功能**：
- 迭代完成当前子树
- 调用completeWork处理具体节点
- 收集副作用列表
- 处理兄弟节点
- 向上返回到父节点

### (2) completeWork 函数
**源码位置**：`react-reconciler/src/ReactFiberCompleteWork.js`
```javascript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
      return null;
    case ClassComponent: {
      // 类组件完成工作
      const Component = workInProgress.type;
      
      // 调用componentDidMount/Update
      if (current === null && finishedWork.effectTag & Update) {
        workInProgress.effectTag |= Update;
      }
      
      return null;
    }
    case HostRoot: {
      // 根节点完成
      const fiberRoot = (workInProgress.stateNode: FiberRoot);
      popHostContainer(workInProgress);
      
      // 更新容器属性
      updateHostContainer(current, workInProgress);
      
      return null;
    }
    case HostComponent: {
      // 原生DOM节点完成
      popHostContext(workInProgress);
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      
      if (current !== null && workInProgress.stateNode != null) {
        // 更新现有节点
        updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);
        
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        // 创建新节点
        const currentHostContext = getHostContext();
        const instance = createInstance(
          type,
          newProps,
          rootContainerInstance,
          currentHostContext,
          workInProgress,
        );
        
        // 设置子节点
        appendAllChildren(instance, workInProgress, false, false);
        
        // 完成节点初始化
        finalizeInitialChildren(instance, type, newProps, rootContainerInstance);
        
        // 保存到stateNode
        workInProgress.stateNode = instance;
        
        // 标记更新
        if (workInProgress.ref !== null) {
          markRef(workInProgress);
        }
      }
      
      return null;
    }
    case HostText: {
      // 文本节点完成
      const newText = newProps;
      
      if (current && workInProgress.stateNode != null) {
        // 更新文本
        const oldText = current.memoizedProps;
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      } else {
        // 创建文本节点
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        workInProgress.stateNode = createTextInstance(
          newText,
          rootContainerInstance,
          currentHostContext,
          workInProgress,
        );
      }
      
      return null;
    }
    // ... 其他类型
    default:
      throw new Error('Unknown unit of work tag');
  }
}
```
**功能**：
- 根据Fiber类型处理完成逻辑
- 创建/更新真实DOM节点
- 设置DOM属性和事件
- 处理引用(ref)
- 收集副作用
- 完成Fiber节点初始化

### (3) 关键DOM操作函数

#### a. createInstance 函数
**源码位置**：`react-dom/src/client/ReactDOMHostConfig.js`
```javascript
export function createInstance(
  type: string,
  props: Props,
  rootContainerInstance: Container,
  hostContext: HostContext,
  internalInstanceHandle: Object,
): Instance {
  // 1. 创建DOM元素
  let parentNamespace: string;
  if (__DEV__) {
    // 开发环境命名空间验证
    parentNamespace = hostContext;
  } else {
    parentNamespace = hostContext;
  }
  
  const domElement: Instance = createElement(
    type,
    props,
    rootContainerInstance,
    parentNamespace,
  );
  
  // 2. 设置初始属性
  finalizeInitialChildren(domElement, type, props, rootContainerInstance);
  
  return domElement;
}
```
**功能**：
- 创建真实DOM元素
- 处理命名空间（SVG等）
- 调用平台特定的创建逻辑
- 为后续属性设置做准备

#### b. finalizeInitialChildren 函数
**源码位置**：`react-dom/src/client/ReactDOMHostConfig.js`
```javascript
export function finalizeInitialChildren(
  domElement: Instance,
  type: string,
  props: Props,
  rootContainerInstance: Container,
): boolean {
  // 1. 设置初始属性
  setInitialProperties(domElement, type, props, rootContainerInstance);
  
  // 2. 检查是否需要自动聚焦
  return shouldAutoFocusHostComponent(type, props);
}
```
**功能**：
- 设置DOM节点初始属性
- 处理特殊属性（如value、checked）
- 配置事件监听器
- 处理自动聚焦

## 5. Diff算法核心

### (1) reconcileChildFibers 函数
**源码位置**：`react-reconciler/src/ReactChildFiber.js`
```javascript
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // 1. 处理文本节点
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    return reconcileSingleTextNode(
      returnFiber,
      currentFirstChild,
      '' + newChild,
      lanes,
    );
  }
  
  // 2. 处理单个React元素
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return reconcileSingleElement(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
      case REACT_PORTAL_TYPE:
        return reconcileSinglePortal(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes,
        );
    }
  }
  
  // 3. 处理多个子节点（数组或迭代器）
  if (isArray(newChild)) {
    return reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes,
    );
  }
  
  // 4. 处理迭代器
  if (getIteratorFn(newChild)) {
    return reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes,
    );
  }
  
  // 5. 无效子节点，清空
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```
**功能**：
- 根据子节点类型选择不同策略
- 处理单个元素、文本、门户等特殊情况
- 调用不同diff算法
- 清理多余子节点

### (2) reconcileChildrenArray 函数（核心Diff算法）
**源码位置**：`react-reconciler/src/ReactChildFiber.js`
```javascript
function reconcileChildrenArray(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChildren: Array<*>,
  lanes: Lanes,
): Fiber | null {
  // 1. 初始化变量
  let resultingFirstChild: Fiber | null = null;
  let previousNewFiber: Fiber | null = null;
  
  let oldFiber = currentFirstChild;
  let lastPlacedIndex = 0;
  let newIdx = 0;
  let nextOldFiber = null;
  
  // 2. 第一遍：处理相同key的节点
  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
    if (oldFiber.index > newIdx) {
      nextOldFiber = oldFiber;
      oldFiber = null;
    } else {
      nextOldFiber = oldFiber.sibling;
    }
    
    const newFiber = updateSlot(
      returnFiber,
      oldFiber,
      newChildren[newIdx],
      lanes,
    );
    
    if (newFiber === null) {
      if (oldFiber === null) {
        oldFiber = nextOldFiber;
      }
      break;
    }
    
    // 标记放置
    if (shouldTrackSideEffects) {
      if (oldFiber && newFiber.alternate === null) {
        deleteChild(returnFiber, oldFiber);
      }
    }
    
    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    previousNewFiber = newFiber;
    oldFiber = nextOldFiber;
  }
  
  // 3. 处理剩余情况
  if (newIdx === newChildren.length) {
    // 新节点已处理完，删除剩余旧节点
    deleteRemainingChildren(returnFiber, oldFiber);
    return resultingFirstChild;
  }
  
  if (oldFiber === null) {
    // 旧节点已处理完，创建新节点
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
      if (newFiber === null) {
        continue;
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  
  // 4. 最后一遍：使用map处理剩余节点
  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
  
  for (; newIdx < newChildren.length; newIdx++) {
    const newFiber = updateFromMap(
      existingChildren,
      returnFiber,
      newChildren[newIdx],
      lanes,
    );
    
    if (newFiber !== null) {
      if (shouldTrackSideEffects) {
        if (newFiber.alternate !== null) {
          existingChildren.delete(
            newFiber.key === null ? newIdx : newFiber.key,
          );
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
    }
  }
  
  // 5. 删除未使用的旧节点
  if (shouldTrackSideEffects) {
    existingChildren.forEach(child => deleteChild(returnFiber, child));
  }
  
  return resultingFirstChild;
}
```
**功能**：
- 实现React核心Diff算法
- 通过key优化节点复用
- 三轮遍历策略：
  1. 处理相同位置相同key的节点
  2. 处理新增/删除节点
  3. 使用map处理剩余节点
- 最小化DOM操作
- 标记节点移动、插入、删除

## 6. 副作用收集

### (1) collectEffectList 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function collectEffectList(current, completedWork) {
  let child = completedWork.child;
  
  // 1. 初始化effect列表
  if (completedWork.subtreeFlags & (PassiveMask | LayoutMask | MutationMask)) {
    if (completedWork.child !== null) {
      // 2. 传递子节点effects
      let child = completedWork.child;
      do {
        if (child.subtreeFlags & (PassiveMask | LayoutMask | MutationMask) ||
            child.memoizedProps !== child.pendingProps ||
            (child.flags & (Placement | Update))) {
          mergeEffectList(
            completedWork,
            child,
            child.return,
          );
        }
        child = child.sibling;
      } while (child !== null);
    }
  }
  
  // 3. 收集当前节点effect
  if (completedWork.flags & (PassiveMask | LayoutMask | MutationMask)) {
    if (completedWork.effectTag !== 0) {
      if (completedWork.return !== null) {
        if (completedWork.return.firstEffect === null) {
          completedWork.return.firstEffect = completedWork.firstEffect;
        }
        if (completedWork.return.lastEffect !== null) {
          completedWork.return.lastEffect.nextEffect = completedWork.firstEffect;
        }
        completedWork.return.lastEffect = completedWork.lastEffect;
      }
    }
  }
}
```
**功能**：
- 从叶子节点向上收集副作用
- 合并子树的effect列表
- 构建effect链表（firstEffect -> nextEffect -> lastEffect）
- 为commit阶段准备

## 7. 关键特性与优化

1. **可中断渲染**：通过workLoopConcurrent和shouldYield实现
2. **优先级调度**：根据lane优先级决定更新顺序
3. **双缓冲技术**：使用current和workInProgress两棵树
4. **Fiber架构**：增量处理，避免长时间阻塞主线程
5. **精细的diff算法**：通过key优化节点复用
6. **副作用收集**：构建effect列表，集中处理DOM操作
7. **bailout优化**：跳过无需更新的子树
8. **context优化**：避免不必要的重新渲染

Render阶段是React 18并发特性的核心体现，通过精细的工作单元划分、优先级调度和可中断机制，在保证UI响应性的同时完成复杂的UI更新。这一阶段不仅处理初次渲染，也处理所有后续更新，为React应用提供了高性能的渲染基础。