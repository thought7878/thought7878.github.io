>4. 提交阶段（Commit，不可中断），这个详细介绍一下。比如，函数的调用流程，每个函数的功能

# React 18提交阶段（Commit）详解

提交阶段是React 18渲染流程的最后一个主要阶段，负责将Render阶段准备好的Fiber树应用到真实DOM上。这个阶段是**同步且不可中断**的，确保DOM更新的原子性和一致性，避免用户看到中间状态。提交阶段分为三个子阶段：before mutation、mutation和layout，每个阶段处理不同类型的副作用。

## 1. 提交阶段整体流程

```
commitRoot()
  └── commitRootImpl()
      ├── flushPassiveEffects()              // 清除之前未完成的useEffect
      ├── commitBeforeMutationEffects()     // before mutation阶段
      ├── commitMutationEffects()           // mutation阶段
      │   └── commitMutationEffectsOnFiber() // 递归处理DOM变更
      ├── commitLayoutEffects()             // layout阶段
      │   └── commitLayoutEffectOnFiber()    // 递归处理生命周期
      ├── flushSyncCallbacks()               // 执行同步回调
      └── flushPassiveEffects()              // 调度useEffect
```

## 2. 核心函数详解

### (1) commitRoot 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function commitRoot(root) {
  // 1. 获取最高优先级更新
  const renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority(ImmediatePriority, () => {
    commitRootImpl(root, renderPriorityLevel);
  });
  
  return null;
}
```
**功能**：
- 以最高优先级(ImmediatePriority)执行提交
- 确保提交过程不会被其他更新中断
- 调用核心实现commitRootImpl
- 作为提交阶段的入口函数

### (2) commitRootImpl 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function commitRootImpl(root, renderPriorityLevel) {
  // 1. 保存当前上下文
  const prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  
  // 2. 获取已完成的Fiber树
  const finishedWork = root.finishedWork;
  const lanes = root.finishedLanes;
  
  // 3. 重置根节点状态
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  
  // 4. 保存备用树
  const current = root.current;
  const alternate = current.alternate;
  
  // 5. 检查是否需要提交
  if (finishedWork === null) {
    return null;
  }
  
  // 6. 初始化effect链表指针
  let firstEffect = finishedWork.firstEffect;
  
  // 7. 三个提交子阶段
  if (firstEffect !== null) {
    // 7.1 before mutation阶段
    commitBeforeMutationEffects(root, finishedWork);
    
    // 7.2 mutation阶段
    commitMutationEffects(root, finishedWork, lanes);
    
    // 7.3 切换current树
    root.current = finishedWork;
    
    // 7.4 layout阶段
    commitLayoutEffects(finishedWork, root, lanes);
  }
  
  // 8. 重置effect标记
  recursivelyTraverseLayoutEffects(finishedWork);
  
  // 9. 触发提交完成回调
  root.callbackNode = null;
  root.callbackPriority = NoLane;
  
  // 10. 调度useEffect
  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
      (finishedWork.flags & PassiveMask) !== NoFlags) {
    root.effectRemainingLanes = mergeLanes(root.effectRemainingLanes, lanes);
  }
  
  // 11. 调度被动效果
  if (root.effectRemainingLanes !== NoLanes) {
    scheduleCallback(NormalSchedulerPriority, () => {
      flushPassiveEffects();
      return null;
    });
  }
  
  return null;
}
```
**功能**：
- 管理提交阶段的整体流程
- 保存和清理工作状态
- 按顺序执行三个子阶段
- 切换current树指针
- 调度useEffect
- 触发提交回调

## 3. before mutation阶段

### (1) commitBeforeMutationEffects 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitBeforeMutationEffects(root, firstChild) {
  // 1. 遍历effect链表
  nextEffect = firstChild;
  while (nextEffect !== null) {
    const current = nextEffect.alternate;
    const flags = nextEffect.flags;
    
    // 2. 处理快照效果
    if ((flags & Snapshot) !== NoFlags) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }
    
    // 3. 处理被动效果标记
    if ((flags & Passive) !== NoFlags) {
      rootDoesHavePassiveEffects = true;
    }
    
    nextEffect = nextEffect.nextEffect;
  }
}
```
**功能**：
- 遍历所有带有副作用的Fiber节点
- 处理Snapshot标记（getSnapshotBeforeUpdate）
- 标记存在被动效果（useEffect）的树
- 为mutation阶段做准备

### (2) commitBeforeMutationEffectOnFiber 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitBeforeMutationEffectOnFiber(current, fiber) {
  switch (fiber.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 函数组件不需要before mutation
      return;
    }
    case ClassComponent: {
      if ((fiber.flags & Snapshot) !== NoFlags) {
        if (current !== null) {
          const prevProps = current.memoizedProps;
          const prevState = current.memoizedState;
          
          // 调用getSnapshotBeforeUpdate
          const instance = fiber.stateNode;
          const snapshot = instance.getSnapshotBeforeUpdate(
            prevProps,
            prevState,
          );
          
          // 保存快照
          instance.__reactInternalSnapshotBeforeUpdate = snapshot;
        }
      }
      return;
    }
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      return;
  }
}
```
**功能**：
- 为类组件调用getSnapshotBeforeUpdate生命周期
- 保存快照结果供后续使用
- 针对不同Fiber类型进行处理

## 4. mutation阶段

### (1) commitMutationEffects 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitMutationEffects(root, finishedWork, committedLanes) {
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const primaryFlags = nextEffect.flags & (Placement | Update | Deletion | Hydrating);
    
    if (primaryFlags !== NoFlags) {
      commitMutationEffectsOnFiber(nextEffect, root);
    }
    
    nextEffect = nextEffect.nextEffect;
  }
}
```
**功能**：
- 遍历effect链表
- 识别需要处理的主要副作用（插入、更新、删除、水合）
- 调用commitMutationEffectsOnFiber处理每个节点

### (2) commitMutationEffectsOnFiber 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitMutationEffectsOnFiber(finishedWork, root) {
  const flags = finishedWork.flags;
  
  // 1. 处理文本节点
  if (finishedWork.tag === HostText) {
    if (flags & Update) {
      const textInstance = finishedWork.stateNode;
      const newText = finishedWork.memoizedProps;
      commitTextUpdate(textInstance, newText);
    }
    return;
  }
  
  // 2. 处理原生组件
  if (finishedWork.tag === HostComponent) {
    // 2.1 处理插入
    if (flags & Placement) {
      commitPlacement(finishedWork);
      finishedWork.flags &= ~Placement;
    }
    
    // 2.2 处理更新
    const current = finishedWork.alternate;
    if (flags & Update && current !== null) {
      const oldProps = current.memoizedProps;
      const newProps = finishedWork.memoizedProps;
      const instance = finishedWork.stateNode;
      
      commitUpdate(
        instance,
        oldProps,
        newProps,
        finishedWork.type,
        finishedWork,
      );
    }
    
    // 2.3 处理删除
    if (flags & Deletion) {
      commitDeletion(root, finishedWork, nearestMountedAncestor);
    }
    
    return;
  }
  
  // 3. 处理类组件ref
  if (flags & Ref) {
    commitAttachRef(finishedWork);
  }
  
  // 4. 递归处理子树
  const child = finishedWork.child;
  if (child !== null && (child.flags & Deletion)) {
    commitMutationEffectsOnFiber(child, root);
  }
}
```
**功能**：
- 按Fiber类型分派处理
- 处理文本节点更新
- 处理原生DOM节点的插入、更新、删除
- 处理ref附加
- 递归处理子树

### (3) 关键DOM操作函数

#### a. commitPlacement 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitPlacement(finishedWork) {
  // 1. 查找父容器
  const parentFiber = getHostParentFiber(finishedWork);
  const parentStateNode = parentFiber.stateNode;
  
  // 2. 查找插入位置
  const before = getHostSibling(finishedWork);
  
  // 3. 插入节点
  insertOrAppendPlacementNode(finishedWork, before, parentStateNode);
}
```
**功能**：
- 确定DOM节点的父容器
- 查找插入位置（before节点）
- 调用平台特定的插入方法
- 处理子节点插入

#### b. commitUpdate 函数
**源码位置**：`react-dom/src/client/ReactDOMHostConfig.js`
```javascript
export function commitUpdate(
  domElement: Instance,
  oldProps: Props,
  newProps: Props,
  type: string,
  finishedWork: Fiber,
): void {
  // 1. 更新属性
  updateProperties(domElement, oldProps, newProps, type);
  
  // 2. 更新子节点
  updateChildren(domElement, oldProps.children, newProps.children);
  
  // 3. 处理特殊属性
  if (type === 'input' && newProps.type === 'radio' && newProps.name != null) {
    updateValueIfRequired(domElement, newProps);
  }
}
```
**功能**：
- 更新DOM元素属性
- 设置样式
- 更新事件监听器
- 处理特殊元素（如input）的值

#### c. commitDeletion 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitDeletion(root, returnFiber, childToDelete) {
  // 1. 递归删除子树
  recursivelyDeleteChildren(childToDelete);
  
  // 2. 从父节点移除
  const parentStateNode = returnFiber.stateNode;
  const childStateNode = childToDelete.stateNode;
  
  removeFromParent(parentStateNode, childStateNode);
  
  // 3. 清理ref
  detachFiberMutation(childToDelete);
}
```
**功能**：
- 递归清理子树
- 从DOM中移除节点
- 清理ref
- 重置Fiber状态

## 5. layout阶段

### (1) commitLayoutEffects 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitLayoutEffects(finishedWork, root, committedLanes) {
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const flags = nextEffect.flags;
    
    // 1. 处理插入和更新
    if ((flags & (Update | Callback)) !== NoFlags) {
      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);
    }
    
    // 2. 处理ref
    if ((flags & Ref) !== NoFlags) {
      commitAttachRef(nextEffect);
    }
    
    nextEffect = nextEffect.nextEffect;
  }
}
```
**功能**：
- 遍历effect链表
- 处理Update和Callback标记
- 处理ref附加
- 调用commitLayoutEffectOnFiber

### (2) commitLayoutEffectOnFiber 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitLayoutEffectOnFiber(
  finishedRoot,
  current,
  finishedWork,
  committedLanes,
) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 1. 执行useLayoutEffect
      recursivelyTraverseLayoutEffects(finishedWork);
      
      // 2. 提交当前节点effects
      if (flags & Update) {
        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      }
      
      return;
    }
    case ClassComponent: {
      // 1. 递归处理子树
      recursivelyTraverseLayoutEffects(finishedWork);
      
      // 2. 处理组件生命周期
      const instance = finishedWork.stateNode;
      
      if (finishedWork.flags & Update) {
        if (current === null) {
          // 组件挂载
          instance.componentDidMount();
        } else {
          // 组件更新
          const prevProps = current.memoizedProps;
          const prevState = current.memoizedState;
          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
        }
      }
      
      return;
    }
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal: {
      // 原生节点不需要特殊layout效果
      recursivelyTraverseLayoutEffects(finishedWork);
      return;
    }
  }
}
```
**功能**：
- 按Fiber类型分派处理
- 执行useLayoutEffect
- 调用类组件生命周期
- 递归处理子树

### (3) commitHookEffectListMount 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    
    do {
      if ((effect.tag & flags) === flags) {
        // 1. 创建ref
        const create = effect.create;
        effect.destroy = create();
      }
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
```
**功能**：
- 遍历hooks的effect链表
- 执行useLayoutEffect的create函数
- 保存destroy函数
- 处理错误边界

## 6. 提交阶段关键特性

### (1) effect链表结构
```javascript
// Fiber节点上的effect链表
fiber.firstEffect ──► effect1 ──► effect2 ──► effect3 ──► ... ──► fiber.lastEffect
                         │          │          │
                         ▼          ▼          ▼
                      nextEffect  nextEffect  nextEffect
```
**功能**：
- 通过链表高效收集所有需要处理的副作用
- 避免递归遍历整个Fiber树
- 标记需要处理的副作用类型（Placement、Update、Deletion等）

### (2) Fiber标志(Flags)系统
```javascript
// 常见标志位
export const Placement = 0b0000000000000000000000000000010; // 插入
export const Update = 0b0000000000000000000000000000100; // 更新
export const Deletion = 0b0000000000000000000000000001000; // 删除
export const Ref = 0b0000000000000000000000000010000; // ref
export const Snapshot = 0b0000000000000000000000000100000; // 快照
export const Passive = 0b0000000000000000000000001000000; // useEffect
export const Hydrating = 0b0000000000000000000000010000000; // 水合
```
**功能**：
- 使用位掩码高效标识副作用类型
- 组合多个副作用（flags = Placement | Update）
- 通过位运算快速检查（flags & Update）

### (3) 三层提交架构
```
┌───────────────────┐    ┌───────────────────┐    ┌───────────────────┐
│  Before Mutation  │───▶│     Mutation      │───▶│      Layout       │
└───────────────────┘    └───────────────────┘    └───────────────────┘
      │                          │                        │
      ▼                          ▼                        ▼
读取DOM状态                 修改DOM结构              读取新DOM状态
getSnapshotBeforeUpdate      插入/更新/删除          useLayoutEffect
                             ref分离                componentDidMount
```
**功能**：
- 分离不同类型的副作用
- 确保DOM操作的原子性
- 允许在DOM更新前后读取布局信息
- 避免布局抖动

## 7. 提交后处理

### (1) flushPassiveEffects 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function flushPassiveEffects() {
  // 1. 检查是否存在被动效果
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }
  
  // 2. 执行useEffect
  const root = rootWithPendingPassiveEffects;
  const remainingLanes = root.effectRemainingLanes;
  
  // 3. 执行effect
  commitPassiveEffects(root, finishedWork, committedLanes);
  
  // 4. 清理状态
  rootWithPendingPassiveEffects = null;
  root.effectRemainingLanes = NoLanes;
  
  return true;
}
```
**功能**：
- 作为微任务调度useEffect
- 避免阻塞关键渲染路径
- 批量执行被动效果
- 清理状态

### (2) commitPassiveEffects 函数
**源码位置**：`react-reconciler/src/ReactFiberCommitWork.js`
```javascript
function commitPassiveEffects(root, finishedWork) {
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const flags = nextEffect.flags;
    
    if ((flags & Passive) !== NoFlags) {
      switch (nextEffect.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          commitHookEffectListMount(HookPassive | HookHasEffect, nextEffect);
          break;
        case HostRoot:
          // 渲染完成回调
          const callbacks = finishedWork.stateNode.pendingPassiveEffects;
          finishedWork.stateNode.pendingPassiveEffects = null;
          for (let i = 0; i < callbacks.length; i++) {
            const callback = callbacks[i];
            callback();
          }
          break;
      }
    }
    
    nextEffect = nextEffect.nextEffect;
  }
  
  // 清理被动效果
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const flags = nextEffect.flags;
    
    if ((flags & Passive) !== NoFlags) {
      switch (nextEffect.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          commitHookEffectListUnmount(HookPassive | HookHasEffect, nextEffect);
          break;
      }
    }
    
    nextEffect = nextEffect.nextEffect;
  }
}
```
**功能**：
- 执行useEffect
- 处理根组件回调
- 清理之前的effect
- 支持异步执行

## 8. 提交阶段关键优化

1. **effect链表**：避免遍历整棵树，只处理有副作用的节点
2. **三个子阶段**：分离不同类型的副作用，避免布局抖动
3. **双缓冲Fiber树**：在commit后切换current指针，保证一致性
4. **批量DOM操作**：在mutation阶段集中处理DOM变更
5. **错误边界**：在每个阶段捕获错误，防止整个应用崩溃
6. **优先级处理**：同步处理layout，异步处理passive effect
7. **ref分离**：在mutation阶段移除旧ref，在layout阶段附加新ref

## 9. 提交阶段流程示例

假设初次渲染一个简单应用`<App><Header/><Main/><Footer/></App>`，提交阶段流程如下：

1. **before mutation**：
   - 检查是否有getSnapshotBeforeUpdate（初次渲染无）
   - 标记存在useEffect

2. **mutation**：
   - 为<App>创建DOM容器
   - 为<Header>创建并插入DOM节点
   - 为<Main>创建并插入DOM节点
   - 为<Footer>创建并插入DOM节点
   - 将整个树添加到容器

3. **切换current树**：
   - root.current指向新的Fiber树
   - 释放旧的Fiber树内存

4. **layout**：
   - 为<App>调用useLayoutEffect
   - 为<Header>调用useLayoutEffect和componentDidMount
   - 为<Main>调用useLayoutEffect和componentDidMount
   - 为<Footer>调用useLayoutEffect和componentDidMount
   - 附加所有ref

5. **提交后**：
   - 调度flushPassiveEffects作为微任务
   - 执行useEffect
   - 触发渲染完成回调

提交阶段是React渲染流程的最后一步，它确保了UI更新的原子性和一致性。通过精心设计的三阶段架构，React 18能够在保证性能的同时，提供丰富的生命周期和hooks能力，为开发者创造流畅的用户体验。