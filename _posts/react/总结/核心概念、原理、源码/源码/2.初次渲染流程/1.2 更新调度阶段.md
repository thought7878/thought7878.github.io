# React 18更新调度阶段详解

更新调度阶段是React 18渲染流程的核心环节，负责**将更新按优先级排序并安排合适的执行时机**。本阶段*充分利用了Scheduler包的协作式调度能力，结合React自研的优先级(Lane)模型实现精细的优先级管理*。

## 1. 调度阶段整体流程

更新调度阶段始于`updateContainer`函数，主要流程如下：
```
updateContainer()
  └── scheduleUpdateOnFiber()
      ├── markUpdateLaneFromFiberToRoot()  // 标记更新路径
      ├── ensureRootIsScheduled()          // 确保根节点被调度
      │   ├── scheduleCallback()            // 与Scheduler交互
      │   └── requestHostCallback()         // 请求宿主环境回调
      └── performSyncWorkOnRoot()           // 立即执行同步更新(特殊情况)
```

## 2. 核心函数详解
参考：[[2.3 scheduleUpdateOnFiber]]

### (1) scheduleUpdateOnFiber 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
): FiberRoot | null {
  // 1. 检查嵌套更新
  checkForNestedUpdates();
  
  // 2. 将更新标记从当前fiber向上冒泡到根节点（react18.2.0没有这个了）
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  if (root === null) {
    return null;
  }
  
  // 3. 标记根节点拥有该优先级的更新
  markRootUpdated(root, lane, eventTime);
  
  // 4. 确保根节点被正确调度
  ensureRootIsScheduled(root, eventTime);
  
  // 5. 处理同步更新特殊情况
  if (
    lane === SyncLane ||
    enableLegacySyncScheduling ||
    (executionContext & (RenderContext | CommitContext)) !== NoContext
  ) {
    if (root.tag === LegacyRoot) {
      flushSyncCallbacks();
    } else {
      // 并发模式下，同步更新会立即执行
      if (root === rootWithPendingPassiveEffects) {
        flushPassiveEffects();
      }
    }
  }
  
  return root;
}
```
**功能**：
- 验证嵌套更新深度*防止无限循环*
- *将更新标记从触发点冒泡至根Fiber*
- *更新根节点的优先级标记*
- 启动调度流程
- 处理同步优先级特殊情况

### (2) ~~markUpdateLaneFromFiberToRoot 函数~~
参考：[[markUpdateLaneFromFiberToRoot]]

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function markUpdateLaneFromFiberToRoot(
  sourceFiber: Fiber,
  lane: Lane,
): FiberRoot | null {
  // 1. 从当前fiber向上遍历至根节点
  let node = sourceFiber;
  let parent = node.return;
  
  while (parent !== null) {
    // 2. 更新子树优先级
    const isFiberSuspense = parent.tag === SuspenseComponent;
    if (!isFiberSuspense || parent.memoizedState === null) {
      parent.childLanes = mergeLanes(parent.childLanes, lane);
    }
    node = parent;
    parent = node.return;
  }
  
  // 3. 标记根节点
  if (node.tag === HostRoot) {
    const root: FiberRoot = node.stateNode;
    return root;
  } else {
    return null;
  }
}
```
**功能**：
- *从触发更新的fiber向上遍历到根节点*
- *为路径上每个fiber更新childLanes（子树优先级）*
- 处理Suspense边界特殊情况
- 返回FiberRoot对象

### (3) markRootUpdated 函数
参考：[[2.3.1 markRootUpdated]]

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function markRootUpdated(
  root: FiberRoot,
  updateLane: Lane,
  eventTime: number,
) {
  // 1. 将更新标记到根节点
  root.pendingLanes = mergeLanes(root.pendingLanes, updateLane);
  
  // 2. 更新优先级到期时间
  markStarvedLanesAsExpired(root, eventTime);
  
  // 3. 更新事件时间映射
  root.eventTimes = updateEventTimes(root.eventTimes, updateLane, eventTime);
}
```
**功能**：
- *将新更新的优先级合并到根节点的pendingLanes*
- 更新优先级到期时间处理饥饿问题
- 记录每个优先级对应的事件时间戳
- *为调度器提供优先级决策依据*

### (4) ensureRootIsScheduled 函数
参考：[[2.3.2 ensureRootIsScheduled]]

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  // 1. 取消已存在的回调
  const existingCallbackNode = root.callbackNode;
  if (existingCallbackNode !== null) {
    cancelCallback(existingCallbackNode);
  }
  
  // 2. 计算下一次要处理的优先级
  let nextLanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  
  // 3. 无更新需要处理，清除所有回调
  if (nextLanes === NoLanes) {
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  
  // 4. 根据优先级选择调度方式
  let newCallbackPriority = getHighestPriorityLane(nextLanes);
  let schedulerPriorityLevel;
  
  // 5. 优先级映射到Scheduler优先级
  switch (newCallbackPriority) {
    case SyncLane:
      schedulerPriorityLevel = ImmediateSchedulerPriority;
      break;
    case InputContinuousLane:
      schedulerPriorityLevel = UserBlockingPriority;
      break;
    case DefaultLane:
      schedulerPriorityLevel = NormalSchedulerPriority;
      break;
    case IdleLane:
      schedulerPriorityLevel = IdlePriority;
      break;
    default:
      schedulerPriorityLevel = NormalSchedulerPriority;
  }
  
  // 6. 创建调度回调函数
  let newCallbackNode;
  if (newCallbackPriority === SyncLane) {
    // 同步更新，立即执行
    newCallbackNode = scheduleSyncCallback(
      performSyncWorkOnRoot.bind(null, root),
    );
  } else {
    // 并发更新，使用Scheduler安排
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
  
  // 7. 更新根节点调度状态
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
```
**功能**：
- 取消已存在的调度回调
- 计算下一个要处理的更新优先级
- 将React优先级映射到Scheduler优先级
- 为不同优先级选择不同的执行策略
- 创建并注册新的调度回调
- 更新根节点调度状态

### (5) getNextLanes 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
  // 1. 获取待处理的lanes
  const pendingLanes = root.pendingLanes;
  if (pendingLanes === NoLanes) {
    return NoLanes;
  }
  
  let nextLanes = NoLanes;
  
  // 2. 优先处理过期的更新
  const expiredLanes = root.expiredLanes;
  if (expiredLanes !== NoLanes) {
    nextLanes = expiredLanes;
    return nextLanes;
  }
  
  // 3. 优先处理同步和连续优先级
  const suspendedLanes = root.suspendedLanes;
  const pingedLanes = root.pingedLanes;
  
  // 4. 根据策略选择合适的lanes
  const schedulerPriority = getCurrentPriorityLevel();
  
  let lanes = schedulerPriority !== IdleSchedulerPriority
    ? getHighestPriorityLanes(pendingLanes)
    : pickArbitraryLane(pendingLanes);
  
  // 5. 处理特殊优先级规则
  if ((lanes & InputContinuousLane) !== NoLanes) {
    // 连续输入优先级需要批量处理
    nextLanes = lanes;
  } else if ((lanes & DefaultLane) !== NoLanes) {
    // 默认优先级
    nextLanes = lanes;
  } else if ((lanes & IdleLane) !== NoLanes) {
    // 空闲优先级
    nextLanes = lanes;
  }
  
  return nextLanes;
}
```
**功能**：
- 确定下一个应处理的更新优先级
- 优先处理已过期的更新
- 处理被挂起(suspended)和被唤醒(pinged)的更新
- 考虑当前执行上下文的优先级
- 实现复杂的优先级排序策略

## 3. 调度器交互核心

### (1) scheduleCallback 函数
**源码位置**：`react-reconciler/src/Scheduler.js`
```javascript
export function scheduleCallback(
  reactPriorityLevel: ReactPriorityLevel,
  callback: SchedulerCallback,
  options?: SchedulerCallbackOptions,
) {
  // 1. 将React优先级转换为Scheduler优先级
  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  
  // 2. 通过Scheduler包调度回调
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}
```
**功能**：
- 优先级映射转换
- 代理到Scheduler包
- 为React与Scheduler提供适配层

### (2) performConcurrentWorkOnRoot 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function performConcurrentWorkOnRoot(root, didTimeout) {
  // 1. 确保执行上下文正确
  const originalCallbackNode = root.callbackNode;
  
  // 2. 获取下一个要处理的优先级
  const lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  
  // 3. 无更新需要处理
  if (lanes === NoLanes) {
    return null;
  }
  
  // 4. 准备渲染上下文
  const exitStatus = renderRootConcurrent(root, lanes);
  
  // 5. 处理不同渲染结果
  if (exitStatus !== RootInProgress) {
    if (exitStatus === RootErrored) {
      // 错误处理
      return handleRootError(root, lanes);
    } else if (exitStatus === RootSuspended) {
      // Suspense挂起处理
      return handleRootSuspended(root, lanes);
    } else if (exitStatus === RootCompleted) {
      // 渲染完成，准备提交
      return commitRoot(root);
    }
  }
  
  // 6. 需要更多时间，返回自身继续调度
  return performConcurrentWorkOnRoot.bind(null, root);
}
```
**功能**：
- 执行并发模式下的渲染工作
- 处理渲染中断和恢复
- 管理Suspense边界
- 决定是否需要提交或继续调度
- 实现协作式多任务调度

### (3) renderRootConcurrent 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  // 1. 准备工作循环
  prepareFreshStack(root, lanes);
  
  // 2. 设置执行上下文
  workLoopConcurrent();
  
  // 3. 检查是否完成或被中断
  if (workInProgress !== null) {
    // 未完成，被中断
    return RootInProgress;
  } else {
    // 完成渲染
    return workInProgressRootExitStatus;
  }
}

function workLoopConcurrent() {
  // 并发模式下可中断的工作循环
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```
**功能**：
- 初始化工作循环
- 实现可中断的渲染过程
- 响应浏览器的请求空闲时间(shouldYield)
- 在时间片用尽前暂停工作
- 保留工作进度以便后续恢复

## 4. 车道(Lane)模型详解

React 18使用31位bitmask**实现优先级管理**，替代了React 17及以前的过期时间模型：

```javascript
// 优先级常量定义 (react-reconciler/src/ReactFiberLane.js)
export const SyncLane = 0b0000000000000000000000000000001;
export const InputContinuousLane = 0b0000000000000000000000000000010;
export const DefaultLane = 0b0000000000000000000000000000100;
export const TransitionLanes = 0b0000000000001111111111110000000;
export const IdleLane = 0b0000000000010000000000000000000;

// 车道模型优势：
// 1. 31位可以表示31个不同的优先级
// 2. 位运算效率高
// 3. 支持批处理多个相似优先级
// 4. 更精细的优先级控制
// 5. 处理优先级饥饿问题
```

## 5. **调度流程示例**

假设初次渲染App组件，调度流程如下：
1. `root.render(<App/>)` 调用 `updateContainer`
2. 创建更新对象，优先级为DefaultLane
3. `scheduleUpdateOnFiber` 标记根节点有更新
4. `ensureRootIsScheduled` 计算需要处理DefaultLane
5. 通过Scheduler以Normal优先级调度`performConcurrentWorkOnRoot`
6. Scheduler在合适的时机调用回调
7. 进入Render阶段，开始协调(Reconciliation)

## 6. 关键机制

1. **任务分片**：通过工作循环和shouldYield()实现可中断渲染
2. **优先级反转**：高优先级更新可中断低优先级更新
3. **批处理优化**：相似优先级的更新会被合并处理
4. **过期机制**：防止低优先级更新长时间饥饿
5. **时间切片**：每次执行不超过5ms，保证主线程响应性

更新调度阶段是React 18并发特性的核心，通过精细的优先级管理和与浏览器的协作式调度，实现了流畅的用户体验。这一阶段不仅处理初次渲染，也为后续的增量更新、Suspense、Transition等高级特性奠定了基础。