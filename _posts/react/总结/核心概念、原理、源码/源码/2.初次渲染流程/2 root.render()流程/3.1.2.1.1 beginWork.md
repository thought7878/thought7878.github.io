## beginWork

调用：`packages/react-reconciler/src/ReactFiberWorkLoop.new.js`
源码：`packages/react-reconciler/src/ReactFiberBeginWork.new.js`

---

这是 React 渲染过程中*处理 Fiber 节点的核心函数*。

### 功能概述：
[beginWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3539-L3539) 函数是 React 渲染过程中的关键函数之一，它**负责处理 Fiber 节点的渲染逻辑**。**它是`深度优先遍历算法`的 *"向下"* 部分，负责*构建或更新子树***。

### 主要功能：

1. **比较 props 和上下文**：*检查`组件`的 props 或上下文是否发生变化，以确定是否需要更新组件*
2. **提前退出优化**：如果没有更新计划，会尝试提前退出，*避免不必要的渲染*
3. **根据 Fiber 类型处理不同组件**：通过 switch 语句*处理不同类型的组件*
4. **设置更新标志**：设置 [didReceiveUpdate](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L65-L65) 标志，*指示组件是否收到了更新*

### 关键逻辑：

1. **首次渲染 vs 更新渲染**：函数首先*判断是首次渲染（current 为 null）还是更新渲染（current 不为 null）*
2. **Props 比较**：对于*更新渲染*，比较*新旧 props 是否相等*，以及*上下文是否发生变化*
3. **早期退出优化**：如果没有更新计划，尝试提前退出，提升性能
4. **组件类型分发**：根据 Fiber 的类型（tag）调用相应的处理函数

这个函数是 React 渲染算法的核心部分，它与 [completeUnitOfWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1918-L1968) 函数配合，*实现了 React 的深度优先遍历渲染机制*。


```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 在开发环境下，如果需要重新挂载组件
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // 这将使用新 fiber 重新启动开始阶段
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // 如果当前节点存在（不是首次渲染）
  if (current !== null) {
    // 获取旧的 props 和新的 props
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    // 检查 props 或上下文是否发生变化
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // 如果由于热重载导致实现发生变化，强制重新渲染：
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // 如果 props 或上下文发生变化，标记 fiber 为已执行工作
      // 如果稍后确定 props 相等，这可能会被取消设置（memo）
      didReceiveUpdate = true;
    } else {
      // props 和旧上下文都没有变化。检查是否有待处理的更新或上下文变化
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      // 如果没有计划的更新或上下文变化，且当前 fiber 没有被捕获标志
      if (
        !hasScheduledUpdateOrContext &&
        // 如果这是错误或 Suspense 边界的第二次传递，
        // 可能在 [current](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactCreateRef.js#L13-L13) 上没有计划工作，所以我们检查此标志
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // 没有待处理的更新或上下文。立即退出。
        didReceiveUpdate = false;
        // 尝试提前退出，如果没有计划的更新
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      // 专门针对 legacy 模式下的 Suspense 组件
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      } else {
        // 在这个 fiber 上计划了更新，但没有新的 props 或旧上下文
        // 设置为 false。如果更新队列或上下文消费者产生更改的值，
        // 它将设置为 true。否则，组件将假定子项没有更改并退出。
        didReceiveUpdate = false;
      }
    }
  } else {
    // 首次渲染
    didReceiveUpdate = false;

    // 如果正在水合且这是分支子节点
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      // 检查这个孩子是否属于其父级的多个孩子的列表
      //
      // 在真正的多线程实现中，我们将在并行线程上渲染子项。
      // 这将代表此子树的新渲染线程的开始。
      //
      // 我们只在水合期间用于 ID 生成，这就是为什么逻辑位于这个特殊分支中的原因
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  // 在进入开始阶段之前，清除待处理的更新优先级
  workInProgress.lanes = NoLanes;

  // 根据 Fiber 的类型进行不同的处理
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      // ！！！挂载未确定类型的组件（首次渲染时还不知道是函数组件还是类组件。首次渲染，除了rootFiber即下面的HostRoot，其他类型组件、ReactElement应都走这个分支）
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case LazyComponent: {
      // 懒加载组件
      const elementType = workInProgress.elementType;
      return mountLazyComponent(
        current,
        workInProgress,
        elementType,
        renderLanes,
      );
    }
    case FunctionComponent: {
      // ！！！函数组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      // 类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      // 根节点
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      // 原生 DOM 组件
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      // 文本节点
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      // Suspense 组件
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case HostPortal:
      // Portal 组件
      return updatePortalComponent(current, workInProgress, renderLanes);
    case ForwardRef: {
      // ForwardRef 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === type
          ? unresolvedProps
          : resolveDefaultProps(type, unresolvedProps);
      return updateForwardRef(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case Fragment:
      // Fragment 组件
      return updateFragment(current, workInProgress, renderLanes);
    case Mode:
      // Mode 组件
      return updateMode(current, workInProgress, renderLanes);
    case Profiler:
      // Profiler 组件
      return updateProfiler(current, workInProgress, renderLanes);
    case ContextProvider:
      // Context Provider
      return updateContextProvider(current, workInProgress, renderLanes);
    case ContextConsumer:
      // Context Consumer
      return updateContextConsumer(current, workInProgress, renderLanes);
    case MemoComponent: {
      // Memo 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      // 先解析外层 props，然后解析内层 props
      let resolvedProps = resolveDefaultProps(type, unresolvedProps);
      if (__DEV__) {
        if (workInProgress.type !== workInProgress.elementType) {
          const outerPropTypes = type.propTypes;
          if (outerPropTypes) {
            checkPropTypes(
              outerPropTypes,
              resolvedProps, // 仅解析外层
              'prop',
              getComponentNameFromType(type),
            );
          }
        }
      }
      resolvedProps = resolveDefaultProps(type.type, resolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case SimpleMemoComponent: {
      // 简单 Memo 组件
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes,
      );
    }
    case IncompleteClassComponent: {
      // 不完整的类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return mountIncompleteClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case SuspenseListComponent: {
      // Suspense 列表组件
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    }
    case ScopeComponent: {
      // 作用域组件
      if (enableScopeAPI) {
        return updateScopeComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case OffscreenComponent: {
      // 离屏组件
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    }
    case LegacyHiddenComponent: {
      // Legacy Hidden 组件
      if (enableLegacyHidden) {
        return updateLegacyHiddenComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
    case CacheComponent: {
      // 缓存组件
      if (enableCache) {
        return updateCacheComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case TracingMarkerComponent: {
      // 追踪标记组件
      if (enableTransitionTracing) {
        return updateTracingMarkerComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
  }

  // 如果 fiber tag 未知，抛出错误
  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```


## updateHostRoot：根节点

这是 React 渲染过程中*处理 Host Root 节点的核心函数*。

### 功能概述：

[updateHostRoot](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1311-L1439) 函数*专门处理 React 应用的`根节点`更新*。它的*主要职责*包括：

1. **上下文管理**：推送宿主根上下文到上下文栈
2. **状态更新**：处理根节点的状态更新
3. **缓存处理**：管理根节点的缓存状态
4. **水合作用**：处理服务端渲染的水合过程
5. **子节点协调**：协调根节点的子元素。
	1. 获取ReactElement，赋值在[[2.0 updateContainer]]中的`update.payload = {element}`，参考：[[createUpdate()#8. 实际示例：首次渲染流程]]

### 关键步骤：

1. **上下文设置**：调用 [pushHostRootContext](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1254-L1267) 设置根节点的上下文
2. **更新队列处理**：克隆和处理更新队列，执行状态更新
3. **缓存管理**：如果启用了缓存功能，推送缓存提供者并传播上下文变更
4. **水合处理**：根据是否为脱水状态，决定是否进行水合或跳过水合
5. **协调子节点**：协调新旧子节点

### 水合逻辑：
函数根据 [prevState.isDehydrated](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberRoot.js#L94-L94) 决定执行哪种处理路径：
- 如果是脱水状态，可能执行水合或跳过水合（在错误或提前更新的情况下）
- 如果不是脱水状态，执行正常的协调流程

这个函数是 React 应用渲染流程的起点，它决定了整个应用树的更新方式。


```javascript
function updateHostRoot(current, workInProgress, renderLanes) {
  // 推送宿主根上下文到上下文栈
  pushHostRootContext(workInProgress);

  // 确保当前 fiber 存在（因为根节点不可能是首次挂载）
  if (current === null) {
    throw new Error('Should have a current fiber. This is a bug in React.');
  }

  // 获取新的 props（即要渲染的 React 元素）
  const nextProps = workInProgress.pendingProps;
  // 获取之前的状态
  const prevState = workInProgress.memoizedState;
  // 获取之前渲染的子元素
  const prevChildren = prevState.element;
  
  // 克隆更新队列，将当前节点的更新队列复制到工作中的节点
  cloneUpdateQueue(current, workInProgress);
  // 处理更新队列，执行状态更新
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);

  // 获取处理更新后的状态
  const nextState: RootState = workInProgress.memoizedState;
  // 获取 Fiber 根实例
  const root: FiberRoot = workInProgress.stateNode;
  // 推送根过渡状态
  pushRootTransition(workInProgress, root, renderLanes);

  // 如果启用了缓存功能
  if (enableCache) {
    const nextCache: Cache = nextState.cache;
    // 推送缓存提供者到缓存栈
    pushCacheProvider(workInProgress, nextCache);
    // 如果缓存发生了变化，传播上下文变更
    if (nextCache !== prevState.cache) {
      // 根缓存已刷新
      propagateContextChange(workInProgress, CacheContext, renderLanes);
    }
  }

  // ！！！提取rootFiber.updateQueue中的update.payload.element的值（根组件ReactElement，如<App/>）。赋值在updateContainer中的update.payload = {element}，element被保存到了update对象中。参考：[[createUpdate()#8. 实际示例：首次渲染流程]]
  // 注意：React DevTools 当前依赖此属性名为 "element"
  const nextChildren = nextState.element;
  
  // 如果支持水合（hydration）且当前状态是脱水状态
  if (supportsHydration && prevState.isDehydrated) {
    // 这是一个尚未水合的脱水根节点。我们应该尝试进行水合
    
    // 将 isDehydrated 设置为 false，表示当此次渲染完成时，
    // 根节点将不再是脱水状态
    const overrideState: RootState = {
      element: nextChildren,
      isDehydrated: false,
      cache: nextState.cache,
      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
      transitions: nextState.transitions,
    };
    const updateQueue: UpdateQueue<RootState> = (workInProgress.updateQueue: any);
    // `baseState` 总是可以是最后一个状态，因为根节点没有 reducer 函数，
    // 所以不需要重新基化
    updateQueue.baseState = overrideState;
    workInProgress.memoizedState = overrideState;

    // 如果设置了强制客户端渲染标志
    if (workInProgress.flags & ForceClientRender) {
      // 在之前的水合尝试中发生了错误，所以我们强制进行客户端渲染
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'There was an error while hydrating. Because the error happened outside ' +
            'of a Suspense boundary, the entire root will switch to ' +
            'client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } 
    // 如果新子元素与之前的子元素不同
    else if (nextChildren !== prevChildren) {
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'This root received an early update, before anything was able ' +
            'hydrate. Switched the entire root to client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } else {
      // 最外层的壳尚未水合。开始水合过程
      enterHydrationState(workInProgress);
      
      // 如果启用了可变源功能
      if (enableUseMutableSource) {
        const mutableSourceEagerHydrationData =
          root.mutableSourceEagerHydrationData;
        if (mutableSourceEagerHydrationData != null) {
          // 遍历可变源数据并设置工作中的版本
          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
            const mutableSource = ((mutableSourceEagerHydrationData[
              i
            ]: any): MutableSource<any>);
            const version = mutableSourceEagerHydrationData[i + 1];
            setWorkInProgressVersion(mutableSource, version);
          }
        }
      }

      // 挂载子节点（水合模式下）
      const child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderLanes,
      );
      workInProgress.child = child;

      // 遍历所有子节点，将它们标记为正在水合
      let node = child;
      while (node) {
        // 标记每个子节点为正在水合。这是一个快速路径，用于知道
        // 这棵树是否是正在水合的树的一部分。这用于确定子节点
        // 是否已完全挂载，以及调度事件重放。
        // 概念上类似于 Placement，因为新的子树在此处插入到
        // React 树中。只是它恰好不需要 DOM 操作，因为它已经存在
        node.flags = (node.flags & ~Placement) | Hydrating;
        node = node.sibling;
      }
    }
  } else {
    // 根节点不是脱水状态。这要么是纯客户端根节点，
    // 要么已经完成了水合
    resetHydrationState();
    
    // 如果新子元素与之前的子元素相同，可以跳过
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    
    // 协调子节点，处理更新
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  
  // 返回子节点，供 workLoop 继续处理
  return workInProgress.child;
}
```


## updateFunctionComponent

### 功能概述：

[updateFunctionComponent](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L950-L1046) 函数*专门处理函数组件的更新过程*。它的*主要职责*是：

1. **props 验证**：在开发模式下验证传入组件的 props 是否符合类型要求
2. **上下文获取**：*获取组件所需的上下文信息*
3. **组件渲染**：*调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 执行函数组件，处理其中的 Hooks*
4. **严格模式处理**：在严格模式下二次渲染以检测副作用
5. **优化处理**：如果没有更新，则跳过渲染以提高性能
6. **子树协调**：*将渲染结果与现有的 Fiber 子树进行协调*

### 关键步骤：

1. **Prop 验证**：在开发环境中检查传入的 props 是否符合组件定义的类型要求
2. **上下文处理**：获取组件需要的上下文信息（如果有的话）
3. **Hooks 执行**：调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 函数执行组件函数并处理其中的 Hooks
4. **严格模式**：在开发模式下，为检测渲染阶段的副作用，可能执行两次组件函数
5. **bailout 优化**：如果组件没有更新，则跳过渲染过程，复用之前的 Fiber 树
6. **子树协调**：调用 [reconcileChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L109-L139) 来协调新渲染的子元素和现有的子 Fiber 节点

这个函数是 React 函数组件渲染流程中的核心部分，它确保了 Hooks 被正确执行，同时进行了各种优化以提高性能。


```javascript
function updateFunctionComponent(
  current,                    // 当前已渲染的 Fiber 节点（可能是 null，表示首次渲染）
  workInProgress,            // 正在处理的 Fiber 节点
  Component,                 // 要渲染的函数组件
  nextProps: any,           // 传入组件的新 props
  renderLanes,              // 当前渲染的优先级通道
) {
  // 在开发模式下，检查组件的 prop types 是否有效
  if (__DEV__) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy 组件的 props 不能在 createElement 中验证
      // 因为它们只能在这里保证被解析
      const innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        checkPropTypes(
          innerPropTypes,
          nextProps, // 已解析的 props
          'prop',
          getComponentNameFromType(Component),
        );
      }
    }
  }

  // 获取组件上下文（仅在不禁用旧版上下文的情况下）
  let context;
  if (!disableLegacyContext) {
    // 获取未遮蔽的上下文
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    // 获取遮蔽后的上下文（仅包含组件声明的上下文）
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let nextChildren;  // 组件渲染后得到的子元素
  let hasId;         // 检查组件是否渲染了 useId Hook
  
  // 准备读取上下文
  prepareToReadContext(workInProgress, renderLanes);
  
  // 如果启用了调度分析器，标记组件渲染开始
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress);
  }
  
  // 在开发模式下，设置当前渲染的所有者，并处理严格模式下的双重调用
  if (__DEV__) {
    // 设置当前渲染的 Fiber，用于错误边界的错误堆栈追踪
    ReactCurrentOwner.current = workInProgress;
    // 标记当前处于渲染状态
    setIsRendering(true);
    
    // 第一次渲染函数组件，执行所有 Hooks
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    // 检查组件是否使用了 useId Hook
    hasId = checkDidRenderIdHook();
    
    // 如果开启了严格模式副作用检查，并且组件处于严格模式下
    if (
      debugRenderPhaseSideEffectsForStrictMode &&
      workInProgress.mode & StrictLegacyMode
    ) {
      // 启用严格模式的开发者工具
      setIsStrictModeForDevtools(true);
      try {
        // 在严格模式下再次渲染组件，用于检测渲染阶段的副作用
        nextChildren = renderWithHooks(
          current,
          workInProgress,
          Component,
          nextProps,
          context,
          renderLanes,
        );
        hasId = checkDidRenderIdHook();
      } finally {
        // 重置严格模式的开发者工具状态
        setIsStrictModeForDevtools(false);
      }
    }
    // 结束渲染状态
    setIsRendering(false);
  } else {
    // 生产环境下的处理：只渲染一次
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    hasId = checkDidRenderIdHook();
  }
  
  // 如果启用了调度分析器，标记组件渲染结束
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }

  // 如果当前节点存在且没有接收到更新，则可以跳过此组件及其子树
  if (current !== null && !didReceiveUpdate) {
    // 跳过 hooks 的处理
    bailoutHooks(current, workInProgress, renderLanes);
    // 跳过已完成的工作，复用之前的渲染结果
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // 如果当前正在水合（hydration）过程中，并且组件使用了 useId Hook
  if (getIsHydrating() && hasId) {
    // 推送 materialized tree id
    pushMaterializedTreeId(workInProgress);
  }

  // 设置 Fiber 标志，表明已执行工作
  // React DevTools 会读取此标志
  workInProgress.flags |= PerformedWork;
  
  // 协调子元素：比较新旧子元素，生成新的 Fiber 子树
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  // 返回子节点，用于 workLoop 继续处理
  return workInProgress.child;
}
```


## reconcileChildren

我来详细解释这段 [reconcileChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L301-L309) 函数的代码，它位于 React 的 reconciler 中，*是 React 协调算法的关键部分*。

这段代码*是 React 协调算法的核心部分*，负责**比较新旧子节点并决定如何更新 DOM**。

让我详细说明：
1. 参数解释：
   - [current](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3079-L3079): *当前已存在的 Fiber 节点，首次渲染时为 null*
   - [workInProgress](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3080-L3080): *正在处理的 Fiber 节点*，代表*未来要更新的 Fiber 节点*
   - [nextChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3081-L3081): *组件本次渲染产生的新 children*
   - [renderLanes](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3082-L3082): *渲染优先级*

2. **两种情况的处理**：
   - **首次渲染**（[current](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3079-L3079) 为 null）：使用 [mountChildFibers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1367-L1367) 函数***创建新的子节点，无需比较，因为没有先前的节点。rootFiber特殊，不走这个，走下面更新的流程***
   - **更新渲染**（[current](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3079-L3079) 不为 null）：使用 [reconcileChildFibers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1369-L1369) 函数***比较新旧子节点，找出差异并应用必要的更新***

3. **优化策略**：
   - 首次渲染时，由于不存在之前的节点，因此可以跳过比较逻辑，直接创建子节点
   - 更新时，会进行完整的协调算法，包括 key 比较、节点复用等

4. **重要性**：
   - 这个函数是 React 高效更新 UI 的关键所在，它确保只更新实际发生变化的部分
   - 通过避免不必要的 DOM 操作，提高了应用性能

总之，[reconcileChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L301-L309) 函数是 React 协调过程中的核心部分，负责决定如何从旧的子节点过渡到新的子节点，是 React 高效性的关键组成部分。

```javascript
export function reconcileChildren(
  current: Fiber | null,        // 当前已存在的 Fiber 节点，如果是首次渲染则为 null
  workInProgress: Fiber,        // 正在处理的 Fiber 节点（将来的 Fiber）
  nextChildren: any,            // 组件本次渲染产生的新 children
  renderLanes: Lanes,           // 渲染优先级
) {
  // ！！！首次渲染。rootFiber特殊，即使是首次渲染（首次渲染已有两个rootFiber），也不走首次渲染，走下面更新渲染；除了rootFiber，其他fiber正常
  if (current === null) {
    // 如果是尚未渲染过的新组件，我们不会通过应用最小副作用来更新其子集
    // 相反，我们会在渲染前将它们全部添加到子节点中
    // 这意味着我们可以通过不追踪副作用来优化此次协调过程
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,                     // 没有之前的兄弟节点
      nextChildren,             // 新的子节点
      renderLanes,              // 渲染优先级
    );
  } else {
    // ！！！更新渲染
    // 如果当前子节点与正在进行的工作相同，这意味着我们还没有开始对这些子节点进行任何工作
    // 因此，我们使用克隆算法创建所有当前子节点的副本
    
    // 如果我们有任何已经进行的工作，此时它是无效的，所以让我们丢弃它
    workInProgress.child = reconcileChildFibers(
      workInProgress,           // 当前正在处理的 Fiber 节点
      current.child,            // 之前渲染的子节点
      nextChildren,             // 新的子节点
      renderLanes,              // 渲染优先级
    );
  }
}
```

## reconcileChildFibers/mountChildFibers
reconcileChildFibers/mountChildFibers与ChildReconciler的关系：

```js
// 更新渲染，调用  
export const reconcileChildFibers = ChildReconciler(true);
// 首次渲染，调用
export const mountChildFibers = ChildReconciler(false);

```

---

### ChildReconciler

这段代码定义了一个叫 [ChildReconciler](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L259-L1365) 的工厂函数，*这是 React 协调算法的核心部分*。
*它创建了两个具体的函数：*[reconcileChildFibers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1369-L1369) 和 [mountChildFibers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1367-L1367)，**用于处理 React 组件的子节点协调（reconciliation）**。

`协调`是 React 的核心概念之一，指的是**比较虚拟 DOM 树的变化并更新真实 DOM 的过程**。

---

```javascript
// 这个包装函数存在是因为我们需要为每个路径克隆代码
// 以便通过早期分支单独优化每个路径。这需要一个编译器或者我们可以手动完成。
// 不需要这种分支的辅助函数位于此函数之外。
function ChildReconciler(shouldTrackSideEffects) {
```

这个函数接收一个布尔参数 `shouldTrackSideEffects`，**用于控制是否需要追踪副作用（side effects），首次渲染为false，更新渲染为true**。副作用包括*插入、删除、移动节点*等操作。

---

以下是该函数中一些关键的辅助函数：

#### 1. 删除相关函数

```javascript
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
  if (!shouldTrackSideEffects) {
    // 首次渲染，什么都不做
    return;
  }
  const deletions = returnFiber.deletions;
  if (deletions === null) {
    returnFiber.deletions = [childToDelete];
    returnFiber.flags |= ChildDeletion;
  } else {
    deletions.push(childToDelete);
  }
}

function deleteRemainingChildren(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
): null {
  if (!shouldTrackSideEffects) {
    // 首次渲染，什么都不做
    return null;
  }

  // 遍历并删除所有剩余的子节点
  let childToDelete = currentFirstChild;
  while (childToDelete !== null) {
    deleteChild(returnFiber, childToDelete);
    childToDelete = childToDelete.sibling;
  }
  return null;
}
```

#### 2. 创建和更新节点的函数

```javascript
function updateTextNode(
  returnFiber: Fiber,
  current: Fiber | null,
  textContent: string,
  lanes: Lanes,
) {
  if (current === null || current.tag !== HostText) {
    // 插入新文本节点
    const created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  } else {
    // 更新现有文本节点
    const existing = useFiber(current, textContent);
    existing.return = returnFiber;
    return existing;
  }
}

function updateElement(
  returnFiber: Fiber,
  current: Fiber | null,
  element: ReactElement,
  lanes: Lanes,
): Fiber {
  // ...
}
```

#### 3. 协调不同类型的子节点

React 支持多种类型的子节点，包括：
- 单个 React 元素
- 文本节点
- 数组/迭代器
- Portal
- Fragment
- Lazy 组件

针对每种类型都有相应的处理函数：

```javascript
function reconcileSingleElement(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  element: ReactElement,
  lanes: Lanes,
): Fiber {
  // 处理单个 React 元素
  // ...
}

function reconcileSingleTextNode(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  textContent: string,
  lanes: Lanes,
): Fiber {
  // 处理单个文本节点
  // ...
}

function reconcileChildrenArray(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChildren: Array<*>,
  lanes: Lanes,
): Fiber | null {
  // 处理数组类型的子节点
  // 实现了复杂的协调算法，包括 key 比较、移动、插入和删除操作
  // ...
}
```

#### 4. 核心的 reconcileChildFibers 函数

```javascript
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // 这个函数不是递归的
  
  // 处理顶级未指定 key 的 Fragment，将其视为数组
  const isUnkeyedTopLevelFragment =
    typeof newChild === 'object' &&
    newChild !== null &&
    newChild.type === REACT_FRAGMENT_TYPE &&
    newChild.key === null;
  if (isUnkeyedTopLevelFragment) {
    newChild = newChild.props.children;
  }

  // 处理对象类型
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
        // 处理 Portal
        // ...
      case REACT_LAZY_TYPE:
        // 处理懒加载组件
        // ...
    }

    if (isArray(newChild)) {
      // 处理数组
      return reconcileChildrenArray(...)
    }

    if (getIteratorFn(newChild)) {
      // 处理可迭代对象
      return reconcileChildrenIterator(...)
    }

    throwOnInvalidObjectType(returnFiber, newChild);
  }

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    // 处理文本节点
    return placeSingleChild(
      reconcileSingleTextNode(...)
    );
  }

  // 其他情况都被视为空
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

#### 关键特性

1. **副作用追踪**：通过 [shouldTrackSideEffects](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L259-L1365) 参数*控制是否追踪副作用*，**首次挂载时不追踪，更新时才追踪**。

2. **高效协调算法**：对于数组类型的子节点，实现了 React 的经典 diff 算法，包括：
   - 使用 key 来识别节点的身份
   - 处理节点的插入、删除、移动
   - 针对常见场景进行优化

3. **多种节点类型支持**：能够处理各种类型的 React 子节点，包括元素、文本、Fragment、Portal 等。

这个协调器是 React 高效更新 UI 的关键部分，通过智能地比较前后两次的子节点，只更新真正变化的部分，避免不必要的 DOM 操作。

#### placeSingleChild
[placeSingleChild](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L358-L365) 函数的代码，它是 React 协调算法中处理单个子节点的关键部分。

##### 代码详解：
1. **函数目的**：这个函数用于*处理单个子节点的放置逻辑*。当 React 协调算法*发现需要插入一个新的单个子节点时*，会调用这个函数。

2. **参数说明**：
   - [newFiber](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L177-L177): 需要处理的新的 Fiber 节点

3. **条件判断**：
   - [shouldTrackSideEffects](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L259-L1365)：这是一个在 [ChildReconciler](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L259-L1365) 函数中定义的参数，用于控制是否追踪副作用（如节点插入、删除、移动等）
   - [newFiber.alternate === null](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L187-L187)：检查新 Fiber 是否没有对应的 alternate 节点，alternate 为 null 表示这是一个新创建的节点，而不是复用的节点

4. **Placement 标志**：当满足条件时，使用按位或运算（`|=`）将 [Placement](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberFlags.js#L84-L84) 标志添加到 [newFiber.flags](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L212-L212) 中。Placement 标志告诉 React 这个节点需要被插入到 DOM 中。

5. **返回值**：返回处理后的 Fiber 节点。

##### 作用：
这个函数的**作用**是*在协调单个子节点时，判断是否需要将新节点标记为"插入"操作*。如果一个节点是新创建的（没有对应的 alternate），并且当前处于需要追踪副作用的模式下（更新阶段而非初始挂载），那么就需要设置 Placement 标志，这样在提交阶段 React 就知道需要将这个节点插入到实际的 DOM 中。

这是 React 高效更新 UI 的关键机制之一，通过准确地标记需要插入、更新或删除的节点，React 可以最小化 DOM 操作，提高渲染性能。

```javascript
function placeSingleChild(newFiber: Fiber): Fiber {
  // This is simpler for the single child case. We only need to do a
  // placement for inserting new children.
  // 对于单个子节点的情况，这更简单。我们只需要为插入新子节点执行放置操作。
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    // 检查是否需要追踪副作用并且新 Fiber 没有对应的 alternate（即没有对应的当前 Fiber）
    // 这意味着这是一个新插入的节点，需要标记为 Placement 
    newFiber.flags |= Placement;  // 使用按位或运算设置 Placement 标志
  }
  return newFiber;  // 返回处理后的 Fiber 节点
}
```


### reconcileChildFibers

[reconcileChildFibers](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1269-L1348) 函数的代码，它是 React 协调算法的核心部分。

#### 代码详解：

1. **函数目的**：这个函数是 React 协调算法的核心，*用于比较新旧子节点，确定需要执行的最小更新集合*（如添加、删除、移动节点等）。

2. **Fragment 处理**：首先检查是否为未指定 key 的 Fragment，如果是，则直接获取其子元素进行处理。

3. **对象类型处理**：
   - **REACT_ELEMENT_TYPE**：单个 React 元素，如 `<div />`
   - **REACT_PORTAL_TYPE**：Portal 类型元素
   - **REACT_LAZY_TYPE**：懒加载组件，需要初始化后再处理
   - **数组**：多个子元素，需要进行 diff 算法
   - **迭代器**：可迭代对象，如 Map、Set 等

4. **基本类型处理**：字符串和数字会被转换为文本节点。

5. **兜底处理**：如果新子节点为 null 或其他无效值，则删除所有现有的子节点。

#### 关键特点：

- **非递归**：此函数本身不是递归的，但会调用其他函数来处理子树
- **类型判断**：通过 [$$typeof](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactElement.js#L150-L150) 属性判断 React 元素的类型
- **性能优化**：通过 [placeSingleChild](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L358-L365) 等函数优化单子节点的处理
- **错误处理**：对无效的子节点类型给出明确的错误提示

这个函数是 React 高效更新 UI 的关键部分，它实现了 React 的 diff 算法，确保只对必要的部分进行 DOM 操作。

```javascript
// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(
  returnFiber: Fiber,              // 父级 Fiber 节点
  currentFirstChild: Fiber | null, // 当前的第一个子 Fiber 节点
  newChild: any,                   // 新的子节点（可能是 React 元素、字符串、数组等）
  lanes: Lanes,                    // 优先级相关的 lanes
): Fiber | null {
  // This function is not recursive.
  // If the top level item is an array, we treat it as a set of children,
  // not as a fragment. Nested arrays on the other hand will be treated as
  // fragment nodes. Recursion happens at the normal flow.

  // Handle top level unkeyed fragments as if they were arrays.
  // This leads to an ambiguity between <>{[...]}</> and <>...</>.
  // We treat the ambiguous cases above the same.
  const isUnkeyedTopLevelFragment =
    typeof newChild === 'object' &&
    newChild !== null &&
    newChild.type === REACT_FRAGMENT_TYPE &&
    newChild.key === null;
  if (isUnkeyedTopLevelFragment) {
    // 如果是顶层未指定 key 的 Fragment，将其子元素作为普通数组处理
    newChild = newChild.props.children;
  }

  // Handle object types - 处理对象类型
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // ！！！处理单个 React 元素，如首次渲染的根 React Element <App/>
        return placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_PORTAL_TYPE:
        // 处理 Portal 元素
        return placeSingleChild(
          reconcileSinglePortal(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
      case REACT_LAZY_TYPE:
        // 处理懒加载组件（lazy/Suspense）
        const payload = newChild._payload;
        const init = newChild._init;
        // TODO: This function is supposed to be non-recursive.
        return reconcileChildFibers(
          returnFiber,
          currentFirstChild,
          init(payload),
          lanes,
        );
    }

    // 检查是否为数组
    if (isArray(newChild)) {
      // 处理数组类型的子节点
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    // 检查是否为可迭代对象（如 Map、Set 等）
    if (getIteratorFn(newChild)) {
      // 处理迭代器类型的子节点
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    }

    // 如果是对象类型但不是以上任何一种，抛出错误
    throwOnInvalidObjectType(returnFiber, newChild);
  }

  // 处理字符串和数字类型（将它们转换为文本节点）
  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number'
  ) {
    return placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // 开发环境下处理函数类型的错误情况
  if (__DEV__) {
    if (typeof newChild === 'function') {
      warnOnFunctionType(returnFiber);
    }
  }

  // 剩余的所有情况都被当作空处理，删除所有现有的子节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

### reconcileSingleElement

[reconcileSingleElement](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L1129-L1204) 函数的代码，它是 React 协调算法中*处理单个 React 元素*的核心部分。

#### 代码详解：
1. **函数目的**：这个函数*处理单个 React 元素的协调（如首次渲染的`<App/>`），尝试在现有节点中找到匹配的节点进行复用，如果没有找到则创建新节点*。

2. **Key 匹配**：首先通过*比较 key 值来寻找可复用的节点*，这是 React diff 算法的关键。

3. **类型匹配**：找到 key 匹配的节点后，*进一步检查元素类型是否相同，以确定是否可以复用节点*。

4. **Fragment 特殊处理**：Fragment 类型需要特别处理，因为它不会创建实际的 DOM 节点。

5. **懒加载组件处理**：对于懒加载组件，需要解析其实际类型并与现有节点比较。

6. **节点复用 vs 创建**：
   - 如果找到匹配的节点，使用 [useFiber](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L335-L340) *复用现有节点并更新 props*
   - 如果没找到匹配节点，则使用 [createFiberFromElement](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L436-L459) 或 [createFiberFromFragment](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L474-L479) 创建新节点

7. **删除操作**：对于不匹配的节点或其后续节点，会执行删除操作。

这个函数体现了 React 协调算法的核心思想：通过 key 和类型匹配来复用尽可能多的现有节点，减少不必要的创建和销毁操作，从而提升性能。


```javascript
function reconcileSingleElement(
    returnFiber: Fiber,               // 父级 Fiber 节点
    currentFirstChild: Fiber | null,  // 当前第一个子 Fiber 节点
    element: ReactElement,            // 新的 React 元素
    lanes: Lanes,                     // 优先级相关的 lanes
  ): Fiber {
    // 获取新元素的 key
    const key = element.key;
    // 从当前的第一个子节点开始遍历
    let child = currentFirstChild;
    // 遍历现有的子节点链表（首次渲染child、currentFirstChild为null）
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      // 比较 key 是否匹配，这是 React diff 算法的关键一步
      if (child.key === key) {
        // 获取新元素的类型
        const elementType = element.type;
        // 如果是 Fragment 类型
        if (elementType === REACT_FRAGMENT_TYPE) {
          // 检查现有节点是否也是 Fragment 类型
          if (child.tag === Fragment) {
            // 删除该节点之后的所有兄弟节点
            deleteRemainingChildren(returnFiber, child.sibling);
            // 复用现有节点，只更新 props
            const existing = useFiber(child, element.props.children);
            existing.return = returnFiber;
            // 开发环境下添加调试信息
            if (__DEV__) {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          }
        } else {
          // 非 Fragment 类型的元素
          if (
            // 检查元素类型是否相同
            child.elementType === elementType ||
            // 在开发环境下，为了热重载功能做额外检查
            (__DEV__
              ? isCompatibleFamilyForHotReloading(child, element)
              : false) ||
            // 对于懒加载组件，需要解析实际类型进行比较
            (typeof elementType === 'object' &&
              elementType !== null &&
              elementType.$$typeof === REACT_LAZY_TYPE &&
              resolveLazy(elementType) === child.type)
          ) {
            // 匹配成功，删除该节点之后的所有兄弟节点
            deleteRemainingChildren(returnFiber, child.sibling);
            // 复用现有节点，更新 props
            const existing = useFiber(child, element.props);
            // 处理 ref 更新
            existing.ref = coerceRef(returnFiber, child, element);
            existing.return = returnFiber;
            // 开发环境下添加调试信息
            if (__DEV__) {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          }
        }
        // 没有匹配成功，删除这个节点及其所有兄弟节点
        // Didn't match.
        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        // key 不匹配，删除当前节点
        deleteChild(returnFiber, child);
      }
      // 移动到下一个兄弟节点
      child = child.sibling;
    }

    // 如果遍历完现有节点都没有找到匹配项，创建一个新的 Fiber 节点
    if (element.type === REACT_FRAGMENT_TYPE) {
      // 如果是 Fragment 类型，创建 Fragment Fiber
      const created = createFiberFromFragment(
        element.props.children,  // 子元素
        returnFiber.mode,        // 渲染模式
        lanes,                   // 优先级
        element.key,             // key
      );
      created.return = returnFiber;
      return created;
    } else {
      // ！！！普通元素类型，创建 Element 对应的 Fiber（首次渲染走这里）
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      // 处理 ref
      created.ref = coerceRef(returnFiber, currentFirstChild, element);
      created.return = returnFiber;
      return created;
    }
  }
```

### createFiberFromElement
我来详细解释这段 [createFiberFromElement](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L604-L629) 函数的代码，它是 React 协调算法中创建 Fiber 节点的重要部分。

#### 代码详解：

1. **函数目的**：这个函数的主要作用是**从一个 React 元素（ReactElement）创建一个对应的 Fiber 节点**，这是 React 协调算法中的关键步骤。

2. **参数说明**：
   - [element](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactElement.js#L148-L160): *要转换为 Fiber 节点的 React 元素*
   - [mode](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L144-L144): 渲染模式，*决定 Fiber 如何处理并发*
   - [lanes](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L151-L151): 优先级车道，用于*确定更新的优先级*

3. **开发环境处理**：在开发模式下，保存元素的所有者信息用于调试目的。

4. **信息提取**：从 React 元素中提取关键信息（type、key、props）。

5. **Fiber 创建**：调用 [createFiberFromTypeAndProps](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L530-L592) 函数实际创建 Fiber 节点。

6. **调试信息**：在开发模式下，添加调试相关的信息以帮助开发者定位问题。

这个函数体现了 React 的设计理念：将虚拟 DOM 元素转换为内部的 Fiber 数据结构，以便进行高效的协调和更新。Fiber 节点包含了足够的信息来执行更新、渲染和回收操作。

```javascript
// 导出创建 Fiber 节点的函数，用于从 React 元素创建对应的 Fiber 对象
export function createFiberFromElement(
  element: ReactElement,  // 输入的 React 元素，包含组件类型、props、key 等信息
  mode: TypeOfMode,      // 渲染模式（如 ConcurrentMode、BatchedMode 等）
  lanes: Lanes,          // 优先级相关的 lanes，用于确定更新优先级
): Fiber {
  // 初始化 owner 为 null，默认情况下没有所有者信息
  let owner = null;
  // 在开发环境下，获取元素的所有者信息，用于调试
  if (__DEV__) {
    owner = element._owner;  // 保存创建该元素的组件实例，有助于错误追踪
  }
  // 提取元素的类型（如 'div', 'span' 或自定义组件）
  const type = element.type;
  // 提取元素的 key 属性，用于 diff 算法中的节点匹配
  const key = element.key;
  // 提取元素的 props，包含传递给组件的所有属性
  const pendingProps = element.props;
  // 使用提取的信息创建 Fiber 节点
  const fiber = createFiberFromTypeAndProps(
    type,     // 组件类型
    key,      // 元素的 key
    pendingProps,  // 组件的 props
    owner,    // 元素的所有者（用于调试）
    mode,     // 渲染模式
    lanes,    // 优先级车道
  );
  // 在开发环境下，添加调试信息
  if (__DEV__) {
    fiber._debugSource = element._source;  // 记录元素的源码位置，用于错误定位
    fiber._debugOwner = element._owner;    // 记录元素的所有者，用于调试
  }
  // 返回创建好的 Fiber 节点
  return fiber;
}
```

### createFiberFromTypeAndProps

我将详细解释这段 [createFiberFromTypeAndProps](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L530-L592) 函数的代码，这是 React 协调算法中创建 Fiber 节点的核心部分。

#### 代码详解：
1. **函数目的**：*根据组件类型和属性创建合适的 Fiber 节点*，这是 React 协调算法中的关键步骤。

2. **类型判断**：函数通过检查 [type](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L166-L166) 的类型来确定 Fiber 的标签（tag）：
   - 函数类型：分为类组件和函数组件
   - 字符串类型：原生 DOM 元素
   - 特殊 React 类型：如 Fragment、Suspense、Context 等

3. **特殊处理**：某些类型（如 Fragment、Suspense）会直接创建对应的 Fiber 并返回，而不是继续往下执行。

4. **错误处理**：当遇到无效的组件类型时，会抛出清晰的错误信息，帮助开发者定位问题。

5. **Fiber 创建**：使用 [createFiber](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.new.js#L468-L488) 函数创建基本的 Fiber 节点，并设置相应的属性。

6. **开发环境增强**：在开发环境下，添加调试信息以帮助错误追踪。

这个函数是 React 渲染机制的核心部分，它确保了每种类型的组件都能被正确地映射到相应的 Fiber 标签，从而使得 React 能够正确地协调和更新 UI。

```javascript
export function createFiberFromTypeAndProps(
  type: any, // React$ElementType - 组件类型，如 'div'、MyComponent 等
  key: null | string, // 元素的 key 属性，用于 diff 算法
  pendingProps: any, // 组件的 props
  owner: null | Fiber, // 创建该元素的组件实例（用于调试）
  mode: TypeOfMode, // 渲染模式（如 ConcurrentMode、BatchedMode 等）
  lanes: Lanes, // 优先级相关的 lanes
): Fiber {
  // 初始化 Fiber 标签为不确定组件类型
  let fiberTag = IndeterminateComponent;
  // 解析后的类型，用于热重载等场景
  let resolvedType = type;
  
  // 根据组件类型确定 Fiber 标签
  // 函数类型组件
  if (typeof type === 'function') {
    // 类组件
    if (shouldConstruct(type)) {
      // 如果函数具有构造函数特征（类组件），则标记为 ClassComponent
      fiberTag = ClassComponent;
      if (__DEV__) {
        // 开发环境下进行热重载处理
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      // 函数组件
      if (__DEV__) {
        // 开发环境下进行热重载处理
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === 'string') {
    // 原生 DOM 组件
    fiberTag = HostComponent;
  } else {
    // 处理特殊 React 组件类型
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        // Fragment 类型，直接创建 Fragment Fiber 并返回
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        // 严格模式类型
        fiberTag = Mode;
        mode |= StrictLegacyMode;
        if (enableStrictEffects && (mode & ConcurrentMode) !== NoMode) {
          // 严格模式效果应该永远不会在 legacy 根节点上运行
          mode |= StrictEffectsMode;
        }
        break;
      case REACT_PROFILER_TYPE:
        // 性能分析器类型
        return createFiberFromProfiler(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_TYPE:
        // Suspense 类型
        return createFiberFromSuspense(pendingProps, mode, lanes, key);
      case REACT_SUSPENSE_LIST_TYPE:
        // Suspense List 类型
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
      case REACT_OFFSCREEN_TYPE:
        // 离屏类型
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
      case REACT_LEGACY_HIDDEN_TYPE:
        if (enableLegacyHidden) {
          // Legacy Hidden 类型
          return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
        }
      // 注意：这里没有 break，继续执行到下一个 case
      case REACT_SCOPE_TYPE:
        if (enableScopeAPI) {
          // Scope 类型
          return createFiberFromScope(type, pendingProps, mode, lanes, key);
        }
      // 注意：这里没有 break，继续执行到下一个 case
      case REACT_CACHE_TYPE:
        if (enableCache) {
          // 缓存类型
          return createFiberFromCache(pendingProps, mode, lanes, key);
        }
      // 注意：这里没有 break，继续执行到下一个 case
      case REACT_TRACING_MARKER_TYPE:
        if (enableTransitionTracing) {
          // 追踪标记类型
          return createFiberFromTracingMarker(pendingProps, mode, lanes, key);
        }
      // 注意：这里没有 break，继续执行到下一个 case
      case REACT_DEBUG_TRACING_MODE_TYPE:
        if (enableDebugTracing) {
          // 调试追踪模式
          fiberTag = Mode;
          mode |= DebugTracingMode;
          break;
        }
      // 注意：这里没有 break，继续执行到下一个 case
      default: {
        // 处理对象类型的组件（如 Context、ForwardRef 等）
        if (typeof type === 'object' && type !== null) {
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
              fiberTag = ContextProvider;
              break getTag; // 跳出外层 switch
            case REACT_CONTEXT_TYPE:
              // Context Consumer
              fiberTag = ContextConsumer;
              break getTag;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = ForwardRef;
              if (__DEV__) {
                resolvedType = resolveForwardRefForHotReloading(resolvedType);
              }
              break getTag;
            case REACT_MEMO_TYPE:
              fiberTag = MemoComponent;
              break getTag;
            case REACT_LAZY_TYPE:
              fiberTag = LazyComponent;
              resolvedType = null; // 懒加载组件的类型暂时未知
              break getTag;
          }
        }
        // 如果到这里还没匹配到有效类型，则抛出错误
        let info = '';
        if (__DEV__) {
          if (
            type === undefined ||
            (typeof type === 'object' &&
              type !== null &&
              Object.keys(type).length === 0)
          ) {
            info +=
              ' You likely forgot to export your component from the file ' +
              "it's defined in, or you might have mixed up default and " +
              'named imports.';
          }
          const ownerName = owner ? getComponentNameFromFiber(owner) : null;
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }
        }

        throw new Error(
          'Element type is invalid: expected a string (for built-in ' +
            'components) or a class/function (for composite components) ' +
            `but got: ${type == null ? type : typeof type}.${info}`,
        );
      }
    }
  }

  // 创建基本的 Fiber 节点
  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  // 设置元素类型和解析后的类型
  fiber.elementType = type;
  fiber.type = resolvedType;
  // 设置优先级
  fiber.lanes = lanes;

  // 开发环境下设置调试信息
  if (__DEV__) {
    fiber._debugOwner = owner;
  }

  // 返回创建的 Fiber 节点
  return fiber;
}
```

## mountIndeterminateComponent
内容太多，移到下面的文件
参考：[[3.1.2.1.1.1 mountIndeterminateComponent]]


