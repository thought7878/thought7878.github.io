调用：`packages/react-reconciler/src/ReactFiberWorkLoop.new.js`
源码：`packages/react-reconciler/src/ReactFiberBeginWork.new.js`

这是 React 渲染过程中*处理 Fiber 节点的核心函数*。

### 功能概述：
[beginWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3539-L3539) 函数是 React 渲染过程中的关键函数之一，它**负责处理 Fiber 节点的渲染逻辑**。**它是`深度优先遍历算法`的 *"向下"* 部分，负责*构建或更新子树***。

### 主要功能：

1. **比较 props 和上下文**：*检查组件的 props 或上下文是否发生变化，以确定是否需要更新组件*
2. **提前退出优化**：如果没有更新计划，会尝试提前退出，*避免不必要的渲染*
3. **根据 Fiber 类型处理不同组件**：通过 switch 语句*处理不同类型的组件*
4. **设置更新标志**：设置 [didReceiveUpdate](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L65-L65) 标志，*指示组件是否收到了更新*

### 关键逻辑：

1. **首次渲染 vs 更新渲染**：函数首先*判断是首次渲染（current 为 null）还是更新渲染（current 不为 null）*
2. **Props 比较**：对于*更新渲染*，比较*新旧 props 是否相等*，以及*上下文是否发生变化*
3. **早期退出优化**：如果没有更新计划，尝试提前退出，提升性能
4. **组件类型分发**：根据 Fiber 的类型（tag）调用相应的处理函数

这个函数是 React 渲染算法的核心部分，它与 [completeUnitOfWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1918-L1968) 函数配合，*实现了 React 的深度优先遍历渲染机制*。


```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 在开发环境下，如果需要重新挂载组件
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // 这将使用新 fiber 重新启动开始阶段
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // 如果当前节点存在（不是首次渲染）
  if (current !== null) {
    // 获取旧的 props 和新的 props
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    // 检查 props 或上下文是否发生变化
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // 如果由于热重载导致实现发生变化，强制重新渲染：
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // 如果 props 或上下文发生变化，标记 fiber 为已执行工作
      // 如果稍后确定 props 相等，这可能会被取消设置（memo）
      didReceiveUpdate = true;
    } else {
      // props 和旧上下文都没有变化。检查是否有待处理的更新或上下文变化
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      // 如果没有计划的更新或上下文变化，且当前 fiber 没有被捕获标志
      if (
        !hasScheduledUpdateOrContext &&
        // 如果这是错误或 Suspense 边界的第二次传递，
        // 可能在 [current](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactCreateRef.js#L13-L13) 上没有计划工作，所以我们检查此标志
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // 没有待处理的更新或上下文。立即退出。
        didReceiveUpdate = false;
        // 尝试提前退出，如果没有计划的更新
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      // 专门针对 legacy 模式下的 Suspense 组件
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      } else {
        // 在这个 fiber 上计划了更新，但没有新的 props 或旧上下文
        // 设置为 false。如果更新队列或上下文消费者产生更改的值，
        // 它将设置为 true。否则，组件将假定子项没有更改并退出。
        didReceiveUpdate = false;
      }
    }
  } else {
    // 首次渲染
    didReceiveUpdate = false;

    // 如果正在水合且这是分支子节点
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      // 检查这个孩子是否属于其父级的多个孩子的列表
      //
      // 在真正的多线程实现中，我们将在并行线程上渲染子项。
      // 这将代表此子树的新渲染线程的开始。
      //
      // 我们只在水合期间用于 ID 生成，这就是为什么逻辑位于这个特殊分支中的原因
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  // 在进入开始阶段之前，清除待处理的更新优先级
  workInProgress.lanes = NoLanes;

  // 根据 Fiber 的类型进行不同的处理
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      // 挂载未确定类型的组件（首次渲染时还不知道是函数组件还是类组件）
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case LazyComponent: {
      // 懒加载组件
      const elementType = workInProgress.elementType;
      return mountLazyComponent(
        current,
        workInProgress,
        elementType,
        renderLanes,
      );
    }
    case FunctionComponent: {
      // 函数组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      // 类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      // 根节点
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      // 原生 DOM 组件
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      // 文本节点
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      // Suspense 组件
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case HostPortal:
      // Portal 组件
      return updatePortalComponent(current, workInProgress, renderLanes);
    case ForwardRef: {
      // ForwardRef 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === type
          ? unresolvedProps
          : resolveDefaultProps(type, unresolvedProps);
      return updateForwardRef(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case Fragment:
      // Fragment 组件
      return updateFragment(current, workInProgress, renderLanes);
    case Mode:
      // Mode 组件
      return updateMode(current, workInProgress, renderLanes);
    case Profiler:
      // Profiler 组件
      return updateProfiler(current, workInProgress, renderLanes);
    case ContextProvider:
      // Context Provider
      return updateContextProvider(current, workInProgress, renderLanes);
    case ContextConsumer:
      // Context Consumer
      return updateContextConsumer(current, workInProgress, renderLanes);
    case MemoComponent: {
      // Memo 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      // 先解析外层 props，然后解析内层 props
      let resolvedProps = resolveDefaultProps(type, unresolvedProps);
      if (__DEV__) {
        if (workInProgress.type !== workInProgress.elementType) {
          const outerPropTypes = type.propTypes;
          if (outerPropTypes) {
            checkPropTypes(
              outerPropTypes,
              resolvedProps, // 仅解析外层
              'prop',
              getComponentNameFromType(type),
            );
          }
        }
      }
      resolvedProps = resolveDefaultProps(type.type, resolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case SimpleMemoComponent: {
      // 简单 Memo 组件
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes,
      );
    }
    case IncompleteClassComponent: {
      // 不完整的类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return mountIncompleteClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case SuspenseListComponent: {
      // Suspense 列表组件
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    }
    case ScopeComponent: {
      // 作用域组件
      if (enableScopeAPI) {
        return updateScopeComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case OffscreenComponent: {
      // 离屏组件
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    }
    case LegacyHiddenComponent: {
      // Legacy Hidden 组件
      if (enableLegacyHidden) {
        return updateLegacyHiddenComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
    case CacheComponent: {
      // 缓存组件
      if (enableCache) {
        return updateCacheComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case TracingMarkerComponent: {
      // 追踪标记组件
      if (enableTransitionTracing) {
        return updateTracingMarkerComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
  }

  // 如果 fiber tag 未知，抛出错误
  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```

