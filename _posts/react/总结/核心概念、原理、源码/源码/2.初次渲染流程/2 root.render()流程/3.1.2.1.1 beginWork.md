
构建Fiber树的流程：
workLoopSync第一次循环：
![[_posts/react/总结/核心概念、原理、源码/源码/2.初次渲染流程/2 root.render()流程/media/04e2f7f1431c7b7ea075cab9e9c3b075_MD5.webp]]

处理rootFiber后：
next=App
![[_posts/react/总结/核心概念、原理、源码/源码/2.初次渲染流程/2 root.render()流程/media/1ddaae000d3a4eaca70450968390bef8_MD5.webp]]



## beginWork

调用：`packages/react-reconciler/src/ReactFiberWorkLoop.new.js`
源码：`packages/react-reconciler/src/ReactFiberBeginWork.new.js`

---

这是 React 渲染过程中*处理 Fiber 节点的核心函数*。

### 功能概述：
[beginWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3539-L3539) 函数是 React 渲染过程中的关键函数之一，它负责*处理 Fiber 节点的渲染逻辑*。**它是`深度优先遍历算法`的 *"向下"* 部分，负责构建或更新子树**。

**beginWork的核心目的**：当fiber节点（workInProgress）进入beginWork后，创建当前fiber节点的第一个子fiber节点（workInProgress.child）。

- 执行流程
    - 判断当前fiber节点的tag类型 → 进入相应update逻辑（`updateHostRoot/updateHostComponent/updateFunctionComponent`）
    - ~~根据是否存在current fiber决定是否标记副作用~~
    - 进入reconcile逻辑（reconcileChildFibers/mountChildFibers），判断children的ReactElement类型：
        - object → 单一React Element
        - string/number → 文本节点
        - array → 子节点数组
    - 调用`reconcileSingleElement/reconcileChildrenArray/reconcileSingleTextNode`等具体方法**创建子fiber**
- createFiberFromElement流程
    - 进入`createFiberFromTypeAndProps`
    - 根据type类型（如string表示host component）创建对应fiber节点
- 每次beginWork只创建一个fiber节点  
    数组类型的children会在后续遍历中逐个处理。


### 主要功能：

1. **根据 Fiber 类型（tag）处理不同组件**：通过 switch 语句*处理不同类型的组件*
2. 比较 props 和上下文：*检查`组件`的 props 或上下文是否发生变化，以确定是否需要更新组件*
3. 提前退出优化：如果没有更新计划，会尝试提前退出，*避免不必要的渲染*
4. 设置更新标志：设置 [didReceiveUpdate](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L65-L65) 标志，*指示组件是否收到了更新*

### 关键逻辑：

1. **首次渲染 vs 更新渲染**：函数首先*判断是首次渲染（current 为 null）还是更新渲染（current 不为 null）*
2. Props 比较：对于*更新渲染*，比较*新旧 props 是否相等*，以及*上下文是否发生变化*
3. 早期退出优化：如果没有更新计划，尝试提前退出，提升性能
4. 组件类型分发：根据 Fiber 的类型（tag）调用相应的处理函数

这个函数是 React 渲染算法的核心部分，它与 [completeUnitOfWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1918-L1968) 函数配合，*实现了 React 的深度优先遍历渲染机制*。


```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 在开发环境下，如果需要重新挂载组件
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // 这将使用新 fiber 重新启动开始阶段
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // 如果当前节点存在（不是首次渲染，除了首次渲染的rootFiber/HostRoot）
  if (current !== null) {
    // 获取旧的 props 和新的 props
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    // 检查 props 或上下文是否发生变化
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // 如果由于热重载导致实现发生变化，强制重新渲染：
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // 如果 props 或上下文发生变化，标记 fiber 为已执行工作
      // 如果稍后确定 props 相等，这可能会被取消设置（memo）
      didReceiveUpdate = true;
    } else {
      // props 和旧上下文都没有变化。检查是否有待处理的更新或上下文变化
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      // 如果没有计划的更新或上下文变化，且当前 fiber 没有被捕获标志
      if (
        !hasScheduledUpdateOrContext &&
        // 如果这是错误或 Suspense 边界的第二次传递，
        // 可能在 [current](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactCreateRef.js#L13-L13) 上没有计划工作，所以我们检查此标志
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // 没有待处理的更新或上下文。立即退出。
        didReceiveUpdate = false;
        // 尝试提前退出，如果没有计划的更新
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      // 专门针对 legacy 模式下的 Suspense 组件
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      } else {
        // 在这个 fiber 上计划了更新，但没有新的 props 或旧上下文
        // 设置为 false。如果更新队列或上下文消费者产生更改的值，
        // 它将设置为 true。否则，组件将假定子项没有更改并退出。
        didReceiveUpdate = false;
      }
    }
  } else {
    // 首次渲染
    didReceiveUpdate = false;

    // 如果正在水合且这是分支子节点
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      // 检查这个孩子是否属于其父级的多个孩子的列表
      //
      // 在真正的多线程实现中，我们将在并行线程上渲染子项。
      // 这将代表此子树的新渲染线程的开始。
      //
      // 我们只在水合期间用于 ID 生成，这就是为什么逻辑位于这个特殊分支中的原因
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  // 在进入开始阶段之前，清除待处理的更新优先级
  workInProgress.lanes = NoLanes;

  // 根据 Fiber 的类型进行不同的处理
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      // ！！！挂载未确定类型的组件（首次渲染时还不知道是函数组件还是类组件。首次渲染，除了rootFiber即下面的HostRoot，其他类型组件、ReactElement应都走这个分支）
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case LazyComponent: {
      // 懒加载组件
      const elementType = workInProgress.elementType;
      return mountLazyComponent(
        current,
        workInProgress,
        elementType,
        renderLanes,
      );
    }
    case FunctionComponent: {
      // ！！！函数组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      // 类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      // 根节点
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      // 原生 DOM 组件
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      // 文本节点
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      // Suspense 组件
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case HostPortal:
      // Portal 组件
      return updatePortalComponent(current, workInProgress, renderLanes);
    case ForwardRef: {
      // ForwardRef 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === type
          ? unresolvedProps
          : resolveDefaultProps(type, unresolvedProps);
      return updateForwardRef(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case Fragment:
      // Fragment 组件
      return updateFragment(current, workInProgress, renderLanes);
    case Mode:
      // Mode 组件
      return updateMode(current, workInProgress, renderLanes);
    case Profiler:
      // Profiler 组件
      return updateProfiler(current, workInProgress, renderLanes);
    case ContextProvider:
      // Context Provider
      return updateContextProvider(current, workInProgress, renderLanes);
    case ContextConsumer:
      // Context Consumer
      return updateContextConsumer(current, workInProgress, renderLanes);
    case MemoComponent: {
      // Memo 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      // 先解析外层 props，然后解析内层 props
      let resolvedProps = resolveDefaultProps(type, unresolvedProps);
      if (__DEV__) {
        if (workInProgress.type !== workInProgress.elementType) {
          const outerPropTypes = type.propTypes;
          if (outerPropTypes) {
            checkPropTypes(
              outerPropTypes,
              resolvedProps, // 仅解析外层
              'prop',
              getComponentNameFromType(type),
            );
          }
        }
      }
      resolvedProps = resolveDefaultProps(type.type, resolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case SimpleMemoComponent: {
      // 简单 Memo 组件
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes,
      );
    }
    case IncompleteClassComponent: {
      // 不完整的类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return mountIncompleteClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case SuspenseListComponent: {
      // Suspense 列表组件
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    }
    case ScopeComponent: {
      // 作用域组件
      if (enableScopeAPI) {
        return updateScopeComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case OffscreenComponent: {
      // 离屏组件
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    }
    case LegacyHiddenComponent: {
      // Legacy Hidden 组件
      if (enableLegacyHidden) {
        return updateLegacyHiddenComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
    case CacheComponent: {
      // 缓存组件
      if (enableCache) {
        return updateCacheComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case TracingMarkerComponent: {
      // 追踪标记组件
      if (enableTransitionTracing) {
        return updateTracingMarkerComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
  }

  // 如果 fiber tag 未知，抛出错误
  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```


## updateHostRoot：rootFiber、根节点

这是 React 渲染过程中*处理 rootFiber、Host Root 节点的核心函数*。

### 功能概述：

[updateHostRoot](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1311-L1439) 函数*专门处理 React 应用的`rootFiber/根节点`更新*。它的*主要职责*包括：

1. 上下文管理：推送宿主根上下文到上下文栈
2. 状态更新：处理根节点的状态更新
3. 缓存处理：管理根节点的缓存状态
4. 水合作用：处理服务端渲染的水合过程
5. ***子节点协调***：根据ReactElement <App />，创建（协调）rootFiber的子fiber。
	1. 获取ReactElement，赋值在[[2.0 updateContainer]]中的`update.payload = {element}`，参考：[[createUpdate()#8. 实际示例：首次渲染流程]]

### 关键步骤：

1. 上下文设置：调用 [pushHostRootContext](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1254-L1267) 设置根节点的上下文
2. 更新队列处理：克隆和处理更新队列，执行状态更新
3. 缓存管理：如果启用了缓存功能，推送缓存提供者并传播上下文变更
4. 水合处理：根据是否为脱水状态，决定是否进行水合或跳过水合
5. **协调子节点**：协调新旧子节点

### 水合逻辑：
函数根据 [prevState.isDehydrated](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberRoot.js#L94-L94) 决定执行哪种处理路径：
- 如果是脱水状态，可能执行水合或跳过水合（在错误或提前更新的情况下）
- 如果不是脱水状态，执行正常的协调流程

这个函数是 React 应用渲染流程的起点，它决定了整个应用树的更新方式。


```javascript
function updateHostRoot(current, workInProgress, renderLanes) {
  // 推送宿主根上下文到上下文栈
  pushHostRootContext(workInProgress);

  // 确保当前 fiber 存在（因为根节点不可能是首次挂载）
  if (current === null) {
    throw new Error('Should have a current fiber. This is a bug in React.');
  }

  // 获取新的 props（即要渲染的 React 元素）
  const nextProps = workInProgress.pendingProps;
  // 获取之前的状态
  const prevState = workInProgress.memoizedState;
  // 获取之前渲染的子元素
  const prevChildren = prevState.element;
  
  // 克隆更新队列，将当前节点的更新队列复制到工作中的节点
  cloneUpdateQueue(current, workInProgress);
  // ！！！处理更新队列，执行状态更新
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);

  // 获取处理更新后的状态
  const nextState: RootState = workInProgress.memoizedState;
  // 获取 FiberRoot 实例
  const root: FiberRoot = workInProgress.stateNode;
  // 推送根过渡状态
  pushRootTransition(workInProgress, root, renderLanes);

  // 如果启用了缓存功能
  if (enableCache) {
    const nextCache: Cache = nextState.cache;
    // 推送缓存提供者到缓存栈
    pushCacheProvider(workInProgress, nextCache);
    // 如果缓存发生了变化，传播上下文变更
    if (nextCache !== prevState.cache) {
      // 根缓存已刷新
      propagateContextChange(workInProgress, CacheContext, renderLanes);
    }
  }

  // ！！！提取rootFiber.updateQueue中的update.payload.element的值（根组件ReactElement，如<App/>）。赋值在updateContainer中的update.payload = {element}，element被保存到了update对象中。参考：[[createUpdate()#8. 实际示例：首次渲染流程]]
  // 注意：React DevTools 当前依赖此属性名为 "element"
  const nextChildren = nextState.element;
  
  // 如果支持水合（hydration）且当前状态是脱水状态
  if (supportsHydration && prevState.isDehydrated) {
    // 这是一个尚未水合的脱水根节点。我们应该尝试进行水合
    
    // 将 isDehydrated 设置为 false，表示当此次渲染完成时，
    // 根节点将不再是脱水状态
    const overrideState: RootState = {
      element: nextChildren,
      isDehydrated: false,
      cache: nextState.cache,
      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
      transitions: nextState.transitions,
    };
    const updateQueue: UpdateQueue<RootState> = (workInProgress.updateQueue: any);
    // `baseState` 总是可以是最后一个状态，因为根节点没有 reducer 函数，
    // 所以不需要重新基化
    updateQueue.baseState = overrideState;
    workInProgress.memoizedState = overrideState;

    // 如果设置了强制客户端渲染标志
    if (workInProgress.flags & ForceClientRender) {
      // 在之前的水合尝试中发生了错误，所以我们强制进行客户端渲染
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'There was an error while hydrating. Because the error happened outside ' +
            'of a Suspense boundary, the entire root will switch to ' +
            'client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } 
    // 如果新子元素与之前的子元素不同
    else if (nextChildren !== prevChildren) {
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'This root received an early update, before anything was able ' +
            'hydrate. Switched the entire root to client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } else {
      // 最外层的壳尚未水合。开始水合过程
      enterHydrationState(workInProgress);
      
      // 如果启用了可变源功能
      if (enableUseMutableSource) {
        const mutableSourceEagerHydrationData =
          root.mutableSourceEagerHydrationData;
        if (mutableSourceEagerHydrationData != null) {
          // 遍历可变源数据并设置工作中的版本
          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
            const mutableSource = ((mutableSourceEagerHydrationData[
              i
            ]: any): MutableSource<any>);
            const version = mutableSourceEagerHydrationData[i + 1];
            setWorkInProgressVersion(mutableSource, version);
          }
        }
      }

      // 挂载子节点（水合模式下）
      const child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderLanes,
      );
      workInProgress.child = child;

      // 遍历所有子节点，将它们标记为正在水合
      let node = child;
      while (node) {
        // 标记每个子节点为正在水合。这是一个快速路径，用于知道
        // 这棵树是否是正在水合的树的一部分。这用于确定子节点
        // 是否已完全挂载，以及调度事件重放。
        // 概念上类似于 Placement，因为新的子树在此处插入到
        // React 树中。只是它恰好不需要 DOM 操作，因为它已经存在
        node.flags = (node.flags & ~Placement) | Hydrating;
        node = node.sibling;
      }
    }
  } else {
    // 根节点不是脱水状态。这要么是纯客户端根节点，
    // 要么已经完成了水合
    resetHydrationState();
    
    // 如果新子元素与之前的子元素相同，可以跳过
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    
    // ！！！协调子节点，处理更新
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  
  // 返回子节点，供 workLoop 继续处理
  return workInProgress.child;
}
```


## updateFunctionComponent

### 功能概述：

[updateFunctionComponent](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L950-L1046) 函数*专门处理函数组件的更新过程*。它的*主要职责*是：

1. **props 验证**：在开发模式下验证传入组件的 props 是否符合类型要求
2. **上下文获取**：*获取组件所需的上下文信息*
3. **组件渲染**：*调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 执行函数组件，处理其中的 Hooks*
4. **严格模式处理**：在严格模式下二次渲染以检测副作用
5. **优化处理**：如果没有更新，则跳过渲染以提高性能
6. **子树协调**：*将渲染结果与现有的 Fiber 子树进行协调*

### 关键步骤：

1. **Prop 验证**：在开发环境中检查传入的 props 是否符合组件定义的类型要求
2. **上下文处理**：获取组件需要的上下文信息（如果有的话）
3. **Hooks 执行**：调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 函数执行组件函数并处理其中的 Hooks
4. **严格模式**：在开发模式下，为检测渲染阶段的副作用，可能执行两次组件函数
5. **bailout 优化**：如果组件没有更新，则跳过渲染过程，复用之前的 Fiber 树
6. **子树协调**：调用 [reconcileChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L109-L139) 来协调新渲染的子元素和现有的子 Fiber 节点

这个函数是 React 函数组件渲染流程中的核心部分，它确保了 Hooks 被正确执行，同时进行了各种优化以提高性能。


```javascript
function updateFunctionComponent(
  current,                    // 当前已渲染的 Fiber 节点（可能是 null，表示首次渲染）
  workInProgress,            // 正在处理的 Fiber 节点
  Component,                 // 要渲染的函数组件
  nextProps: any,           // 传入组件的新 props
  renderLanes,              // 当前渲染的优先级通道
) {
  // 在开发模式下，检查组件的 prop types 是否有效
  if (__DEV__) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy 组件的 props 不能在 createElement 中验证
      // 因为它们只能在这里保证被解析
      const innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        checkPropTypes(
          innerPropTypes,
          nextProps, // 已解析的 props
          'prop',
          getComponentNameFromType(Component),
        );
      }
    }
  }

  // 获取组件上下文（仅在不禁用旧版上下文的情况下）
  let context;
  if (!disableLegacyContext) {
    // 获取未遮蔽的上下文
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    // 获取遮蔽后的上下文（仅包含组件声明的上下文）
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let nextChildren;  // 组件渲染后得到的子元素
  let hasId;         // 检查组件是否渲染了 useId Hook
  
  // 准备读取上下文
  prepareToReadContext(workInProgress, renderLanes);
  
  // 如果启用了调度分析器，标记组件渲染开始
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress);
  }
  
  // 在开发模式下，设置当前渲染的所有者，并处理严格模式下的双重调用
  if (__DEV__) {
    // 设置当前渲染的 Fiber，用于错误边界的错误堆栈追踪
    ReactCurrentOwner.current = workInProgress;
    // 标记当前处于渲染状态
    setIsRendering(true);
    
    // 第一次渲染函数组件，执行所有 Hooks
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    // 检查组件是否使用了 useId Hook
    hasId = checkDidRenderIdHook();
    
    // 如果开启了严格模式副作用检查，并且组件处于严格模式下
    if (
      debugRenderPhaseSideEffectsForStrictMode &&
      workInProgress.mode & StrictLegacyMode
    ) {
      // 启用严格模式的开发者工具
      setIsStrictModeForDevtools(true);
      try {
        // 在严格模式下再次渲染组件，用于检测渲染阶段的副作用
        nextChildren = renderWithHooks(
          current,
          workInProgress,
          Component,
          nextProps,
          context,
          renderLanes,
        );
        hasId = checkDidRenderIdHook();
      } finally {
        // 重置严格模式的开发者工具状态
        setIsStrictModeForDevtools(false);
      }
    }
    // 结束渲染状态
    setIsRendering(false);
  } else {
    // 生产环境下的处理：只渲染一次
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    hasId = checkDidRenderIdHook();
  }
  
  // 如果启用了调度分析器，标记组件渲染结束
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }

  // 如果当前节点存在且没有接收到更新，则可以跳过此组件及其子树
  if (current !== null && !didReceiveUpdate) {
    // 跳过 hooks 的处理
    bailoutHooks(current, workInProgress, renderLanes);
    // 跳过已完成的工作，复用之前的渲染结果
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // 如果当前正在水合（hydration）过程中，并且组件使用了 useId Hook
  if (getIsHydrating() && hasId) {
    // 推送 materialized tree id
    pushMaterializedTreeId(workInProgress);
  }

  // 设置 Fiber 标志，表明已执行工作
  // React DevTools 会读取此标志
  workInProgress.flags |= PerformedWork;
  
  // 协调子元素：比较新旧子元素，生成新的 Fiber 子树
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  // 返回子节点，用于 workLoop 继续处理
  return workInProgress.child;
}
```


## reconcileChildren
参考：[[reconcileChildren]]


## mountIndeterminateComponent
内容太多，移到下面的文件
参考：[[3.1.2.1.1.2 mountIndeterminateComponent]]


