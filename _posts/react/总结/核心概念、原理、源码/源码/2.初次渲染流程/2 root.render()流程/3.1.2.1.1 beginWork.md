
构建Fiber树的流程：
workLoopSync第一次循环：
![[_posts/react/总结/核心概念、原理、源码/源码/2.初次渲染流程/2 root.render()流程/media/04e2f7f1431c7b7ea075cab9e9c3b075_MD5.webp]]

处理rootFiber后：
next=App
![[_posts/react/总结/核心概念、原理、源码/源码/2.初次渲染流程/2 root.render()流程/media/1ddaae000d3a4eaca70450968390bef8_MD5.webp]]



## beginWork

调用：`packages/react-reconciler/src/ReactFiberWorkLoop.new.js`
源码：`packages/react-reconciler/src/ReactFiberBeginWork.new.js`

---

这是 React 渲染过程中*处理 Fiber 节点的核心函数*。

### 功能概述：
[beginWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3539-L3539) 函数是 React 渲染过程中的关键函数之一，它负责*处理 Fiber 节点的渲染逻辑*。**它是`深度优先遍历算法`的 *"向下"* 部分，负责构建或更新子树**。

**beginWork的核心目的**：当fiber节点（workInProgress）进入beginWork后，创建当前fiber节点的第一个子fiber节点（workInProgress.child）。

- 执行流程
    - 判断当前fiber节点的tag类型 → 进入相应update逻辑（`updateHostRoot/updateHostComponent/updateFunctionComponent`）
    - ~~根据是否存在current fiber决定是否标记副作用~~
    - 进入reconcile逻辑（reconcileChildFibers/mountChildFibers），判断children的ReactElement类型：
        - object → 单一React Element
        - string/number → 文本节点
        - array → 子节点数组
    - 调用`reconcileSingleElement/reconcileChildrenArray/reconcileSingleTextNode`等具体方法**创建子fiber**
- createFiberFromElement流程
    - 进入`createFiberFromTypeAndProps`
    - 根据type类型（如string表示host component）创建对应fiber节点
- 每次beginWork只创建一个fiber节点  
    数组类型的children会在后续遍历中逐个处理。


### 主要功能：

1. **根据 Fiber 类型（tag）处理不同组件**：通过 switch 语句*处理不同类型的组件*
2. 比较 props 和上下文：*检查`组件`的 props 或上下文是否发生变化，以确定是否需要更新组件*
3. 提前退出优化：如果没有更新计划，会尝试提前退出，*避免不必要的渲染*
4. 设置更新标志：设置 [didReceiveUpdate](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L65-L65) 标志，*指示组件是否收到了更新*

### 关键逻辑：

1. **首次渲染 vs 更新渲染**：函数首先*判断是首次渲染（current 为 null）还是更新渲染（current 不为 null）*
2. Props 比较：对于*更新渲染*，比较*新旧 props 是否相等*，以及*上下文是否发生变化*
3. 早期退出优化：如果没有更新计划，尝试提前退出，提升性能
4. 组件类型分发：根据 Fiber 的类型（tag）调用相应的处理函数

这个函数是 React 渲染算法的核心部分，它与 [completeUnitOfWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1918-L1968) 函数配合，*实现了 React 的深度优先遍历渲染机制*。


```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 在开发环境下，如果需要重新挂载组件
  if (__DEV__) {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // 这将使用新 fiber 重新启动开始阶段
      return remountFiber(
        current,
        workInProgress,
        createFiberFromTypeAndProps(
          workInProgress.type,
          workInProgress.key,
          workInProgress.pendingProps,
          workInProgress._debugOwner || null,
          workInProgress.mode,
          workInProgress.lanes,
        ),
      );
    }
  }

  // ！！！更新渲染，如果当前节点存在（不是首次渲染，除了首次渲染的rootFiber/HostRoot）
  if (current !== null) {
    // 获取旧的 props 和新的 props
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;

    // 检查 props 或上下文是否发生变化
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      // 如果由于热重载导致实现发生变化，强制重新渲染：
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // 如果 props 或上下文发生变化，标记 fiber 为已执行工作
      // 如果稍后确定 props 相等，这可能会被取消设置（memo）
      didReceiveUpdate = true;
    } else {
      // props 和旧上下文都没有变化。检查是否有待处理的更新或上下文变化
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      // 如果没有计划的更新或上下文变化，且当前 fiber 没有被捕获标志
      if (
        !hasScheduledUpdateOrContext &&
        // 如果这是错误或 Suspense 边界的第二次传递，
        // 可能在 [current](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react/src/ReactCreateRef.js#L13-L13) 上没有计划工作，所以我们检查此标志
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // 没有待处理的更新或上下文。立即退出。
        didReceiveUpdate = false;
        // 尝试提前退出，如果没有计划的更新
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      // 专门针对 legacy 模式下的 Suspense 组件
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        didReceiveUpdate = true;
      } else {
        // 在这个 fiber 上计划了更新，但没有新的 props 或旧上下文
        // 设置为 false。如果更新队列或上下文消费者产生更改的值，
        // 它将设置为 true。否则，组件将假定子项没有更改并退出。
        didReceiveUpdate = false;
      }
    }
  } else {
    // ！！！首次渲染
    didReceiveUpdate = false;

    // 如果正在水合且这是分支子节点
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      // 检查这个孩子是否属于其父级的多个孩子的列表
      //
      // 在真正的多线程实现中，我们将在并行线程上渲染子项。
      // 这将代表此子树的新渲染线程的开始。
      //
      // 我们只在水合期间用于 ID 生成，这就是为什么逻辑位于这个特殊分支中的原因
      const slotIndex = workInProgress.index;
      const numberOfForks = getForksAtLevel(workInProgress);
      pushTreeId(workInProgress, numberOfForks, slotIndex);
    }
  }

  // 在进入开始阶段之前，清除待处理的更新优先级
  workInProgress.lanes = NoLanes;

  // 根据 Fiber 的类型进行不同的处理
  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      // ！！！挂载未确定类型的组件（首次渲染时还不知道是函数组件还是类组件。首次渲染，除了rootFiber即下面的HostRoot，其他类型组件、ReactElement应都走这个分支）
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }
    case LazyComponent: {
      // 懒加载组件
      const elementType = workInProgress.elementType;
      return mountLazyComponent(
        current,
        workInProgress,
        elementType,
        renderLanes,
      );
    }
    case FunctionComponent: {
      // ！！！函数组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case ClassComponent: {
      // 类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      // 根节点
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      // 原生 DOM 组件
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      // 文本节点
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      // Suspense 组件
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case HostPortal:
      // Portal 组件
      return updatePortalComponent(current, workInProgress, renderLanes);
    case ForwardRef: {
      // ForwardRef 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === type
          ? unresolvedProps
          : resolveDefaultProps(type, unresolvedProps);
      return updateForwardRef(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case Fragment:
      // Fragment 组件
      return updateFragment(current, workInProgress, renderLanes);
    case Mode:
      // Mode 组件
      return updateMode(current, workInProgress, renderLanes);
    case Profiler:
      // Profiler 组件
      return updateProfiler(current, workInProgress, renderLanes);
    case ContextProvider:
      // Context Provider
      return updateContextProvider(current, workInProgress, renderLanes);
    case ContextConsumer:
      // Context Consumer
      return updateContextConsumer(current, workInProgress, renderLanes);
    case MemoComponent: {
      // Memo 组件
      const type = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      // 先解析外层 props，然后解析内层 props
      let resolvedProps = resolveDefaultProps(type, unresolvedProps);
      if (__DEV__) {
        if (workInProgress.type !== workInProgress.elementType) {
          const outerPropTypes = type.propTypes;
          if (outerPropTypes) {
            checkPropTypes(
              outerPropTypes,
              resolvedProps, // 仅解析外层
              'prop',
              getComponentNameFromType(type),
            );
          }
        }
      }
      resolvedProps = resolveDefaultProps(type.type, resolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    case SimpleMemoComponent: {
      // 简单 Memo 组件
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes,
      );
    }
    case IncompleteClassComponent: {
      // 不完整的类组件
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return mountIncompleteClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case SuspenseListComponent: {
      // Suspense 列表组件
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    }
    case ScopeComponent: {
      // 作用域组件
      if (enableScopeAPI) {
        return updateScopeComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case OffscreenComponent: {
      // 离屏组件
      return updateOffscreenComponent(current, workInProgress, renderLanes);
    }
    case LegacyHiddenComponent: {
      // Legacy Hidden 组件
      if (enableLegacyHidden) {
        return updateLegacyHiddenComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
    case CacheComponent: {
      // 缓存组件
      if (enableCache) {
        return updateCacheComponent(current, workInProgress, renderLanes);
      }
      break;
    }
    case TracingMarkerComponent: {
      // 追踪标记组件
      if (enableTransitionTracing) {
        return updateTracingMarkerComponent(
          current,
          workInProgress,
          renderLanes,
        );
      }
      break;
    }
  }

  // 如果 fiber tag 未知，抛出错误
  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```


## updateHostRoot：rootFiber、根节点

这是 React 渲染过程中*处理 rootFiber、Host Root 节点的核心函数*。

### 功能概述：

[updateHostRoot](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1311-L1439) 函数*专门处理 React 应用的`rootFiber/根节点`更新*。它的*主要职责*包括：

1. 上下文管理：推送宿主根上下文到上下文栈
2. 状态更新：处理根节点的状态更新
3. 缓存处理：管理根节点的缓存状态
4. 水合作用：处理服务端渲染的水合过程
5. ***子节点协调***：根据ReactElement <App />，创建（协调）rootFiber的子fiber。
	1. 获取ReactElement，赋值在[[2.0 updateContainer]]中的`update.payload = {element}`，参考：[[createUpdate()#8. 实际示例：首次渲染流程]]

### 关键步骤：

1. 上下文设置：调用 [pushHostRootContext](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1254-L1267) 设置根节点的上下文
2. 更新队列处理：克隆和处理更新队列，执行状态更新
3. 缓存管理：如果启用了缓存功能，推送缓存提供者并传播上下文变更
4. 水合处理：根据是否为脱水状态，决定是否进行水合或跳过水合
5. **协调子节点**：协调新旧子节点

### 水合逻辑：
函数根据 [prevState.isDehydrated](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberRoot.js#L94-L94) 决定执行哪种处理路径：
- 如果是脱水状态，可能执行水合或跳过水合（在错误或提前更新的情况下）
- 如果不是脱水状态，执行正常的协调流程

这个函数是 React 应用渲染流程的起点，它决定了整个应用树的更新方式。


```javascript
function updateHostRoot(current, workInProgress, renderLanes) {
  // 推送宿主根上下文到上下文栈
  pushHostRootContext(workInProgress);

  // 确保当前 fiber 存在（因为根节点不可能是首次挂载）
  if (current === null) {
    throw new Error('Should have a current fiber. This is a bug in React.');
  }

  // 获取新的 props（即要渲染的 React 元素）
  const nextProps = workInProgress.pendingProps;
  // 获取之前的状态
  const prevState = workInProgress.memoizedState;
  // 获取之前渲染的子元素
  const prevChildren = prevState.element;
  
  // 克隆更新队列，将当前节点的更新队列复制到工作中的节点
  cloneUpdateQueue(current, workInProgress);
  // ！！！处理更新队列，执行状态更新
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);

  // 获取处理更新后的状态
  const nextState: RootState = workInProgress.memoizedState;
  // 获取 FiberRoot 实例
  const root: FiberRoot = workInProgress.stateNode;
  // 推送根过渡状态
  pushRootTransition(workInProgress, root, renderLanes);

  // 如果启用了缓存功能
  if (enableCache) {
    const nextCache: Cache = nextState.cache;
    // 推送缓存提供者到缓存栈
    pushCacheProvider(workInProgress, nextCache);
    // 如果缓存发生了变化，传播上下文变更
    if (nextCache !== prevState.cache) {
      // 根缓存已刷新
      propagateContextChange(workInProgress, CacheContext, renderLanes);
    }
  }

  // ！！！提取rootFiber.updateQueue中的update.payload.element的值（根组件ReactElement，如<App/>）。赋值在updateContainer中的update.payload = {element}，element被保存到了update对象中。参考：[[createUpdate()#8. 实际示例：首次渲染流程]]
  // 注意：React DevTools 当前依赖此属性名为 "element"
  const nextChildren = nextState.element;
  
  // 如果支持水合（hydration）且当前状态是脱水状态
  if (supportsHydration && prevState.isDehydrated) {
    // 这是一个尚未水合的脱水根节点。我们应该尝试进行水合
    
    // 将 isDehydrated 设置为 false，表示当此次渲染完成时，
    // 根节点将不再是脱水状态
    const overrideState: RootState = {
      element: nextChildren,
      isDehydrated: false,
      cache: nextState.cache,
      pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
      transitions: nextState.transitions,
    };
    const updateQueue: UpdateQueue<RootState> = (workInProgress.updateQueue: any);
    // `baseState` 总是可以是最后一个状态，因为根节点没有 reducer 函数，
    // 所以不需要重新基化
    updateQueue.baseState = overrideState;
    workInProgress.memoizedState = overrideState;

    // 如果设置了强制客户端渲染标志
    if (workInProgress.flags & ForceClientRender) {
      // 在之前的水合尝试中发生了错误，所以我们强制进行客户端渲染
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'There was an error while hydrating. Because the error happened outside ' +
            'of a Suspense boundary, the entire root will switch to ' +
            'client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } 
    // 如果新子元素与之前的子元素不同
    else if (nextChildren !== prevChildren) {
      const recoverableError = createCapturedValueAtFiber(
        new Error(
          'This root received an early update, before anything was able ' +
            'hydrate. Switched the entire root to client rendering.',
        ),
        workInProgress,
      );
      // 不进行水合，直接挂载宿主根节点
      return mountHostRootWithoutHydrating(
        current,
        workInProgress,
        nextChildren,
        renderLanes,
        recoverableError,
      );
    } else {
      // 最外层的壳尚未水合。开始水合过程
      enterHydrationState(workInProgress);
      
      // 如果启用了可变源功能
      if (enableUseMutableSource) {
        const mutableSourceEagerHydrationData =
          root.mutableSourceEagerHydrationData;
        if (mutableSourceEagerHydrationData != null) {
          // 遍历可变源数据并设置工作中的版本
          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
            const mutableSource = ((mutableSourceEagerHydrationData[
              i
            ]: any): MutableSource<any>);
            const version = mutableSourceEagerHydrationData[i + 1];
            setWorkInProgressVersion(mutableSource, version);
          }
        }
      }

      // 挂载子节点（水合模式下）
      const child = mountChildFibers(
        workInProgress,
        null,
        nextChildren,
        renderLanes,
      );
      workInProgress.child = child;

      // 遍历所有子节点，将它们标记为正在水合
      let node = child;
      while (node) {
        // 标记每个子节点为正在水合。这是一个快速路径，用于知道
        // 这棵树是否是正在水合的树的一部分。这用于确定子节点
        // 是否已完全挂载，以及调度事件重放。
        // 概念上类似于 Placement，因为新的子树在此处插入到
        // React 树中。只是它恰好不需要 DOM 操作，因为它已经存在
        node.flags = (node.flags & ~Placement) | Hydrating;
        node = node.sibling;
      }
    }
  } else {
    // 根节点不是脱水状态。这要么是纯客户端根节点，
    // 要么已经完成了水合
    resetHydrationState();
    
    // 如果新子元素与之前的子元素相同，可以跳过
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    
    // ！！！协调子节点，处理更新
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  
  // 返回子节点，供 workLoop 继续处理
  return workInProgress.child;
}
```


## updateFunctionComponent

### 功能概述：

[updateFunctionComponent](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L950-L1046) 函数*专门处理函数组件的更新过程*。它的*主要职责*是：

1. **props 验证**：在开发模式下验证传入组件的 props 是否符合类型要求
2. **上下文获取**：*获取组件所需的上下文信息*
3. **组件渲染**：*调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 执行函数组件，处理其中的 Hooks*
4. **严格模式处理**：在严格模式下二次渲染以检测副作用
5. **优化处理**：如果没有更新，则跳过渲染以提高性能
6. **子树协调**：*将渲染结果与现有的 Fiber 子树进行协调*

### 关键步骤：

1. **Prop 验证**：在开发环境中检查传入的 props 是否符合组件定义的类型要求
2. **上下文处理**：获取组件需要的上下文信息（如果有的话）
3. **Hooks 执行**：调用 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L3697-L3740) 函数执行组件函数并处理其中的 Hooks
4. **严格模式**：在开发模式下，为检测渲染阶段的副作用，可能执行两次组件函数
5. **bailout 优化**：如果组件没有更新，则跳过渲染过程，复用之前的 Fiber 树
6. **子树协调**：调用 [reconcileChildren](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactChildFiber.new.js#L109-L139) 来协调新渲染的子元素和现有的子 Fiber 节点

这个函数是 React 函数组件渲染流程中的核心部分，它确保了 Hooks 被正确执行，同时进行了各种优化以提高性能。


```javascript
function updateFunctionComponent(
  current,                    // 当前已渲染的 Fiber 节点（可能是 null，表示首次渲染）
  workInProgress,            // 正在处理的 Fiber 节点
  Component,                 // 要渲染的函数组件
  nextProps: any,           // 传入组件的新 props
  renderLanes,              // 当前渲染的优先级通道
) {
  // 在开发模式下，检查组件的 prop types 是否有效
  if (__DEV__) {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy 组件的 props 不能在 createElement 中验证
      // 因为它们只能在这里保证被解析
      const innerPropTypes = Component.propTypes;
      if (innerPropTypes) {
        checkPropTypes(
          innerPropTypes,
          nextProps, // 已解析的 props
          'prop',
          getComponentNameFromType(Component),
        );
      }
    }
  }

  // 获取组件上下文（仅在不禁用旧版上下文的情况下）
  let context;
  if (!disableLegacyContext) {
    // 获取未遮蔽的上下文
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    // 获取遮蔽后的上下文（仅包含组件声明的上下文）
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  let nextChildren;  // 组件渲染后得到的子元素
  let hasId;         // 检查组件是否渲染了 useId Hook
  
  // 准备读取上下文
  prepareToReadContext(workInProgress, renderLanes);
  
  // 如果启用了调度分析器，标记组件渲染开始
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress);
  }
  
  // 在开发模式下，设置当前渲染的所有者，并处理严格模式下的双重调用
  if (__DEV__) {
    // 设置当前渲染的 Fiber，用于错误边界的错误堆栈追踪
    ReactCurrentOwner.current = workInProgress;
    // 标记当前处于渲染状态
    setIsRendering(true);
    
    // 第一次渲染函数组件，执行所有 Hooks
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    // 检查组件是否使用了 useId Hook
    hasId = checkDidRenderIdHook();
    
    // 如果开启了严格模式副作用检查，并且组件处于严格模式下
    if (
      debugRenderPhaseSideEffectsForStrictMode &&
      workInProgress.mode & StrictLegacyMode
    ) {
      // 启用严格模式的开发者工具
      setIsStrictModeForDevtools(true);
      try {
        // 在严格模式下再次渲染组件，用于检测渲染阶段的副作用
        nextChildren = renderWithHooks(
          current,
          workInProgress,
          Component,
          nextProps,
          context,
          renderLanes,
        );
        hasId = checkDidRenderIdHook();
      } finally {
        // 重置严格模式的开发者工具状态
        setIsStrictModeForDevtools(false);
      }
    }
    // 结束渲染状态
    setIsRendering(false);
  } else {
    // 生产环境下的处理：只渲染一次
    nextChildren = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderLanes,
    );
    hasId = checkDidRenderIdHook();
  }
  
  // 如果启用了调度分析器，标记组件渲染结束
  if (enableSchedulingProfiler) {
    markComponentRenderStopped();
  }

  // 如果当前节点存在且没有接收到更新，则可以跳过此组件及其子树
  if (current !== null && !didReceiveUpdate) {
    // 跳过 hooks 的处理
    bailoutHooks(current, workInProgress, renderLanes);
    // 跳过已完成的工作，复用之前的渲染结果
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // 如果当前正在水合（hydration）过程中，并且组件使用了 useId Hook
  if (getIsHydrating() && hasId) {
    // 推送 materialized tree id
    pushMaterializedTreeId(workInProgress);
  }

  // 设置 Fiber 标志，表明已执行工作
  // React DevTools 会读取此标志
  workInProgress.flags |= PerformedWork;
  
  // 协调子元素：比较新旧子元素，生成新的 Fiber 子树
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  // 返回子节点，用于 workLoop 继续处理
  return workInProgress.child;
}
```


## reconcileChildren
参考：[[reconcileChildren]]


## mountIndeterminateComponent
内容太多，移到下面的文件
参考：[[3.1.2.1.1.2 mountIndeterminateComponent]]


# react 18.2.0的源码中，beginWork的调用流程

## React 18.2.0 beginWork调用流程详解

`beginWork`是React 18.2.0协调(Reconciliation)阶段的核心函数，它通过精心设计的调用链被触发。以下是完整的调用流程，从应用入口到`beginWork`的执行。

## 1. 完整调用链总览

```
createRoot(container).render(<App/>)
  │
  ├─→ updateContainer()
  │     │
  │     ├─→ requestEventTime()
  │     ├─→ requestUpdateLane()
  │     ├─→ createUpdate()
  │     ├─→ enqueueUpdate()
  │     └─→ scheduleUpdateOnFiber()
  │           │
  │           ├─→ checkForNestedUpdates()
  │           ├─→ markUpdateLaneFromFiberToRoot()
  │           ├─→ markRootUpdated()
  │           └─→ ensureRootIsScheduled()
  │                 │
  │                 ├─→ getNextLanes()
  │                 ├─→ getHighestPriorityLane()
  │                 └─→ scheduleCallback()
  │                       │
  │                       └─→ performConcurrentWorkOnRoot()  [异步]
  │                         或
  │                       └─→ performSyncWorkOnRoot()        [同步]
  │                             │
  │                             └─→ renderRootConcurrent() 或 renderRootSync()
  │                                   │
  │                                   ├─→ prepareFreshStack()
  │                                   ├─→ pushDispatcher()
  │                                   └─→ workLoopConcurrent() 或 workLoopSync()
  │                                         │
  │                                         └─→ performUnitOfWork()
  │                                               │
  │                                               └─→ beginWork()  ← 核心函数
  │
  └─→ (后续) completeUnitOfWork()
        └─→ completeWork()
```

## 2. 详细调用流程

### 2.1 阶段一：应用入口

#### (1) createRoot().render() 调用

**源码位置**：`react-dom/src/client/ReactDOMRoot.js`

```javascript
// 应用代码
const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

```javascript
// ReactDOMRoot.prototype.render
ReactDOMRoot.prototype.render = function(children) {
  const root = this._internalRoot;
  if (root === null) {
    throw new Error('Cannot update an unmounted root.');
  }
  
  updateContainer(children, root, null, null);
};
```

**功能**：
- 获取内部FiberRoot引用
- 调用`updateContainer`启动渲染流程
- 传递根组件(`<App/>`)作为children

---

### 2.2 阶段二：创建更新

#### (2) updateContainer 函数

**源码位置**：`react-reconciler/src/ReactFiberReconciler.new.js`

```javascript
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  const current = container.current;
  
  // 1. 获取事件时间戳
  const eventTime = requestEventTime();
  
  // 2. 确定更新优先级
  const lane = requestUpdateLane(current);
  
  // 3. 创建更新对象
  const update = createUpdate(eventTime, lane);
  
  // 4. 设置更新内容
  update.payload = { element };
  
  // 5. 设置回调
  if (callback !== null && callback !== undefined) {
    update.callback = callback;
  }
  
  // 6. 将更新入队
  enqueueUpdate(current, update, lane);
  
  // 7. 调度更新
  const root = scheduleUpdateOnFiber(current, lane, eventTime);
  
  // 8. 处理同步更新
  if (lane === SyncLane) {
    flushSyncCallbacks();
  }
  
  return lane;
}
```

**关键步骤**：
1. **requestEventTime()** - 获取当前时间戳
2. **requestUpdateLane()** - 确定更新优先级（初次渲染通常为DefaultLane）
3. **createUpdate()** - 创建Update对象
4. **enqueueUpdate()** - 将更新添加到Fiber的updateQueue
5. **scheduleUpdateOnFiber()** - 启动调度流程

---

### 2.3 阶段三：调度更新

#### (3) scheduleUpdateOnFiber 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
): FiberRoot | null {
  // 1. 检查嵌套更新深度
  checkForNestedUpdates();
  
  // 2. 从当前fiber向上标记到根节点
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  if (root === null) {
    return null;
  }
  
  // 3. 标记根节点有更新
  markRootUpdated(root, lane, eventTime);
  
  // 4. 确保根节点被调度
  ensureRootIsScheduled(root, eventTime);
  
  // 5. 处理同步更新特殊情况
  if (
    lane === SyncLane ||
    enableLegacySyncScheduling ||
    (executionContext & (RenderContext | CommitContext)) !== NoContext
  ) {
    if (root.tag === LegacyRoot) {
      flushSyncCallbacks();
    }
  }
  
  return root;
}
```

**功能**：
- 验证嵌套更新深度（防止无限循环）
- 将更新标记从触发点冒泡到根节点
- 更新根节点的优先级标记
- 调用`ensureRootIsScheduled`启动调度

---

#### (4) markUpdateLaneFromFiberToRoot 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function markUpdateLaneFromFiberToRoot(
  sourceFiber: Fiber,
  lane: Lane,
): FiberRoot | null {
  // 从当前fiber向上遍历到根节点
  let node = sourceFiber;
  let parent = node.return;
  
  while (parent !== null) {
    const isFiberSuspense = parent.tag === SuspenseComponent;
    if (!isFiberSuspense || parent.memoizedState === null) {
      // 更新子树优先级
      parent.childLanes = mergeLanes(parent.childLanes, lane);
    }
    node = parent;
    parent = node.return;
  }
  
  // 返回FiberRoot
  if (node.tag === HostRoot) {
    const root: FiberRoot = node.stateNode;
    return root;
  } else {
    return null;
  }
}
```

**功能**：
- 向上遍历Fiber树到根节点
- 为路径上的每个Fiber更新`childLanes`
- 处理Suspense边界特殊情况
- 返回FiberRoot对象

---

#### (5) markRootUpdated 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function markRootUpdated(
  root: FiberRoot,
  updateLane: Lane,
  eventTime: number,
) {
  // 1. 将更新标记到根节点
  root.pendingLanes = mergeLanes(root.pendingLanes, updateLane);
  
  // 2. 更新事件时间
  root.eventTimes = updateEventTimes(root.eventTimes, updateLane, eventTime);
  
  // 3. 标记过期的更新
  markStarvedLanesAsExpired(root, eventTime);
}
```

**功能**：
- 合并新的更新优先级到`pendingLanes`
- 记录事件时间戳
- 处理过期更新（防止低优先级更新饥饿）

---

#### (6) ensureRootIsScheduled 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function ensureRootIsScheduled(root: FiberRoot, currentTime: number) {
  // 1. 取消已存在的回调
  const existingCallbackNode = root.callbackNode;
  if (existingCallbackNode !== null) {
    cancelCallback(existingCallbackNode);
  }
  
  // 2. 计算下一个要处理的优先级
  let nextLanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  
  // 3. 无更新需要处理
  if (nextLanes === NoLanes) {
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  
  // 4. 获取最高优先级
  let newCallbackPriority = getHighestPriorityLane(nextLanes);
  
  // 5. 将React优先级映射到Scheduler优先级
  let schedulerPriorityLevel;
  switch (lanesToEventPriority(nextLanes)) {
    case DiscreteEventPriority:
      schedulerPriorityLevel = ImmediateSchedulerPriority;
      break;
    case ContinuousEventPriority:
      schedulerPriorityLevel = UserBlockingPriority;
      break;
    case DefaultEventPriority:
      schedulerPriorityLevel = NormalPriority;
      break;
    case IdleEventPriority:
      schedulerPriorityLevel = IdlePriority;
      break;
    default:
      schedulerPriorityLevel = NormalPriority;
  }
  
  // 6. 创建调度回调
  let newCallbackNode;
  if (newCallbackPriority === SyncLane) {
    // 同步更新，立即执行
    if (root.tag === LegacyRoot) {
      scheduleSyncCallback(
        performSyncWorkOnRoot.bind(null, root),
      );
    } else {
      scheduleCallback(
        schedulerPriorityLevel,
        performSyncWorkOnRoot.bind(null, root),
      );
    }
  } else {
    // 并发更新，使用Scheduler安排
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
  
  // 7. 更新根节点调度状态
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
```

**功能**：
- 取消已存在的调度回调
- 计算下一个要处理的更新优先级
- 将React优先级映射到Scheduler优先级
- 根据优先级选择同步或并发执行
- 创建并注册新的调度回调
- 更新根节点调度状态

---

### 2.4 阶段四：执行工作

#### (7) performConcurrentWorkOnRoot 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function performConcurrentWorkOnRoot(root: FiberRoot, didTimeout: boolean) {
  // 1. 确保执行上下文正确
  const originalCallbackNode = root.callbackNode;
  
  // 2. 获取下一个要处理的优先级
  const lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  
  // 3. 无更新需要处理
  if (lanes === NoLanes) {
    return null;
  }
  
  // 4. 准备渲染上下文
  const exitStatus = renderRootConcurrent(root, lanes);
  
  // 5. 处理不同渲染结果
  if (exitStatus !== RootInProgress) {
    if (exitStatus === RootErrored) {
      // 错误处理
      return handleRootError(root, lanes);
    } else if (exitStatus === RootSuspended) {
      // Suspense挂起处理
      return handleRootSuspended(root, lanes);
    } else if (exitStatus === RootCompleted) {
      // 渲染完成，准备提交
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      
      return commitRoot.bind(null, root);
    }
  }
  
  // 6. 需要更多时间，返回自身继续调度
  return performConcurrentWorkOnRoot.bind(null, root);
}
```

**功能**：
- 执行并发模式下的渲染工作
- 处理渲染中断和恢复
- 管理Suspense边界
- 决定是否需要提交或继续调度
- 实现协作式多任务调度

---

#### (8) renderRootConcurrent 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  // 1. 检查是否需要重新开始
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 初始化或重新开始渲染
    prepareFreshStack(root, lanes);
  }
  
  // 2. 全局上下文设置
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();
  
  // 3. 执行工作循环（可中断）
  workLoopConcurrent();
  
  // 4. 恢复上下文
  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;
  
  // 5. 检查完成状态
  if (workInProgress !== null) {
    // 被中断，未完成
    return RootInProgress;
  } else {
    // 完成渲染
    return workInProgressRootExitStatus;
  }
}
```

**功能**：
- 初始化或重置渲染环境
- 设置执行上下文和调度器Dispatcher
- 启动可中断的工作循环
- 处理上下文恢复
- 返回渲染状态（完成/中断/错误）

---

#### (9) prepareFreshStack 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes) {
  // 1. 重置全局变量
  workInProgress = root.current.alternate;
  if (workInProgress === null) {
    // 初次渲染，创建workInProgress树
    workInProgress = createWorkInProgress(root.current, null);
  }
  
  // 2. 重置工作循环状态
  workInProgressRoot = root;
  workInProgressRootRenderLanes = lanes;
  
  // 3. 重置副作用列表
  workInProgressRootExitStatus = RootInProgress;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;
  
  // 4. 重置全局指针
  subtreeRenderLanes = NoLanes;
  renderLanes = lanes;
  
  // 5. 重置effect链表
  workInProgressRootIncludedLanes = NoLanes;
  workInProgressRootExitStatus = RootInProgress;
  
  // 6. 重置fiber工作循环
  workInProgress = workInProgressRoot.current.alternate;
  
  // 7. 初始化调度状态
  ensureRootIsScheduled(root, now());
}
```

**功能**：
- 创建或重用workInProgress树
- 重置全局工作状态
- 初始化副作用收集
- 设置渲染优先级
- 确保根节点被调度

---

#### (10) workLoopConcurrent 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function workLoopConcurrent() {
  // 可中断的工作循环
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

**功能**：
- 实现协作式调度的核心循环
- 检查`shouldYield()`决定是否让出主线程
- 持续处理工作单元直到完成或需要中断
- 与浏览器的requestIdleCallback协作

**关键点**：
- `shouldYield()`：检查是否需要让出主线程（基于时间片）
- 可中断：允许高优先级更新打断当前工作
- 恢复机制：中断后可以从断点继续

---

### 2.5 阶段五：处理工作单元

#### (11) performUnitOfWork 函数

**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.new.js`

```javascript
function performUnitOfWork(unitOfWork: Fiber): void {
  // 1. 获取当前Fiber的alternate
  const current = unitOfWork.alternate;
  let next;
  
  // 2. 处理Fiber节点（核心：调用beginWork）
  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  
  // 3. 清除过期的props
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  // 4. 检查是否需要继续处理子节点
  if (next === null) {
    // 没有子节点，完成当前单元
    completeUnitOfWork(unitOfWork);
  } else {
    // 有子节点，继续处理
    workInProgress = next;
  }
}
```

**功能**：
- 处理单个工作单元(Fiber节点)
- **调用`beginWork`处理当前节点**
- 根据结果决定是继续向下还是向上完成
- 管理Fiber树的遍历流程

---

### 2.6 阶段六：核心函数

#### (12) beginWork 函数（核心）

**源码位置**：`react-reconciler/src/ReactFiberBeginWork.new.js`

```javascript
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 1. 检查是否需要更新
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // props或context变化，需要更新
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, workInProgress.lanes)) {
      // 无需更新，尝试bailout优化
      didReceiveUpdate = false;
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      didReceiveUpdate = false;
    }
  } else {
    didReceiveUpdate = true;
  }
  
  // 2. 根据Fiber类型分发处理
  switch (workInProgress.tag) {
    case IndeterminateComponent:
      return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
    case FunctionComponent:
      return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case ClassComponent:
      return updateClassComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      return updateHostText(current, workInProgress);
    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    // ...其他类型
    default:
      throw new Error('Unknown unit of work tag');
  }
}
```

**功能**：
- 决定是否需要更新当前Fiber
- 处理bailout（复用已完成工作的优化）
- 根据Fiber类型分发到具体更新函数
- 管理组件更新生命周期

---

## 3. 调用流程图示

```
┌─────────────────────────────────────────────────────────────┐
│  1. 应用入口                                                 │
│  createRoot(container).render(<App/>)                       │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 创建更新                                                 │
│  updateContainer()                                          │
│    ├─ requestEventTime()                                    │
│    ├─ requestUpdateLane()                                   │
│    ├─ createUpdate()                                        │
│    ├─ enqueueUpdate()                                       │
│    └─ scheduleUpdateOnFiber() ───────────────┐              │
└─────────────────┬────────────────────────────┘              │
                  │                                           │
                  ▼                                           │
┌─────────────────────────────────────────────────────────────┤
│  3. 调度更新                                                 │
│  scheduleUpdateOnFiber()                                    │
│    ├─ checkForNestedUpdates()                               │
│    ├─ markUpdateLaneFromFiberToRoot()                       │
│    ├─ markRootUpdated()                                     │
│    └─ ensureRootIsScheduled() ───────────────┐              │
└─────────────────┬────────────────────────────┘              │
                  │                                           │
                  ▼                                           │
┌─────────────────────────────────────────────────────────────┤
│  4. 确保调度                                                 │
│  ensureRootIsScheduled()                                    │
│    ├─ getNextLanes()                                        │
│    ├─ getHighestPriorityLane()                              │
│    └─ scheduleCallback() ───────────────────┐               │
└─────────────────┬────────────────────────────┘               │
                  │                                            │
                  ▼                                            │
┌─────────────────────────────────────────────────────────────┤
│  5. 执行回调                                                 │
│  performConcurrentWorkOnRoot()                              │
│    └─ renderRootConcurrent() ───────────────┐               │
└─────────────────┬────────────────────────────┘               │
                  │                                            │
                  ▼                                            │
┌─────────────────────────────────────────────────────────────┤
│  6. 渲染根节点                                               │
│  renderRootConcurrent()                                     │
│    ├─ prepareFreshStack()                                   │
│    ├─ pushDispatcher()                                      │
│    └─ workLoopConcurrent() ─────────────────┐               │
└─────────────────┬────────────────────────────┘               │
                  │                                            │
                  ▼                                            │
┌─────────────────────────────────────────────────────────────┤
│  7. 工作循环                                                 │
│  workLoopConcurrent()                                       │
│    └─ while (workInProgress && !shouldYield())              │
│         └─ performUnitOfWork() ─────────────┐               │
└─────────────────┬────────────────────────────┘               │
                  │                                            │
                  ▼                                            │
┌─────────────────────────────────────────────────────────────┤
│  8. 执行工作单元                                             │
│  performUnitOfWork()                                        │
│    ├─ beginWork()  ← 核心函数！                             │
│    └─ if (next === null)                                    │
│         └─ completeUnitOfWork()                             │
└─────────────────────────────────────────────────────────────┘
```

## 4. 关键数据流

### 4.1 优先级传递

```
requestUpdateLane() 
  → DefaultLane (初次渲染)
  → createUpdate(eventTime, lane)
  → enqueueUpdate(fiber, update, lane)
  → scheduleUpdateOnFiber(fiber, lane, eventTime)
  → ensureRootIsScheduled(root, eventTime)
  → renderRootConcurrent(root, lanes)
  → beginWork(current, workInProgress, renderLanes)
```

### 4.2 Fiber树构建

```
HostRoot (root.current)
  ↓
beginWork(HostRoot)
  → updateHostRoot()
  → reconcileChildren() → App组件Fiber
  ↓
beginWork(App)
  → updateFunctionComponent()
  → renderWithHooks()
  → reconcileChildren() → Header, Main等
  ↓
beginWork(Header)
  → updateFunctionComponent()
  → ...
```

## 5. 同步与异步路径对比

### 5.1 并发模式（默认）

```javascript
ensureRootIsScheduled()
  └─→ scheduleCallback(NormalPriority, performConcurrentWorkOnRoot)
        └─→ renderRootConcurrent()
              └─→ workLoopConcurrent()  // 可中断
                    └─→ performUnitOfWork()
                          └─→ beginWork()
```

**特点**：
- 使用Scheduler调度
- 可中断和恢复
- 基于时间片协作
- 支持优先级打断

### 5.2 同步模式（Legacy或SyncLane）

```javascript
ensureRootIsScheduled()
  └─→ scheduleSyncCallback(performSyncWorkOnRoot)
        └─→ renderRootSync()
              └─→ workLoopSync()  // 不可中断
                    └─→ performUnitOfWork()
                          └─→ beginWork()
```

**特点**：
- 立即同步执行
- 不可中断
- 阻塞主线程
- 用于高优先级更新

## 6. 初次渲染完整示例

假设代码：
```jsx
const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

### 调用栈（简化版）：

```
1.  ReactDOMRoot.prototype.render(<App/>)
2.  └─→ updateContainer(<App/>, fiberRoot, null, null)
3.      └─→ createUpdate(0, DefaultLane)
4.      └─→ update.payload = { element: <App/> }
5.      └─→ enqueueUpdate(rootFiber, update, DefaultLane)
6.      └─→ scheduleUpdateOnFiber(rootFiber, DefaultLane, 0)
7.          └─→ markUpdateLaneFromFiberToRoot(rootFiber, DefaultLane)
8.          └─→ markRootUpdated(fiberRoot, DefaultLane, 0)
9.          └─→ ensureRootIsScheduled(fiberRoot, 0)
10.             └─→ getNextLanes(fiberRoot) = DefaultLane
11.             └─→ scheduleCallback(NormalPriority, performConcurrentWorkOnRoot)
12.                 └─→ performConcurrentWorkOnRoot(fiberRoot)
13.                     └─→ renderRootConcurrent(fiberRoot, DefaultLane)
14.                         └─→ prepareFreshStack(fiberRoot, DefaultLane)
15.                             └─→ workInProgress = createWorkInProgress(rootFiber)
16.                         └─→ workLoopConcurrent()
17.                             └─→ performUnitOfWork(workInProgress)  // HostRoot
18.                                 └─→ beginWork(null, hostRootFiber, DefaultLane)  ← 第一次调用！
19.                                     └─→ updateHostRoot(null, hostRootFiber, DefaultLane)
20.                                         └─→ processUpdateQueue()
21.                                             └─→ nextState.element = <App/>
22.                                         └─→ reconcileChildren(null, hostRootFiber, <App/>, DefaultLane)
23.                                             └─→ mountChildFibers(hostRootFiber, null, <App/>, DefaultLane)
24.                                                 └─→ createFiberFromElement(<App/>) → appFiber
25.                         └─→ workLoopConcurrent() 继续
26.                             └─→ performUnitOfWork(appFiber)
27.                                 └─→ beginWork(null, appFiber, DefaultLane)  ← 第二次调用！
28.                                     └─→ updateFunctionComponent(null, appFiber, App, props, DefaultLane)
29.                                         └─→ renderWithHooks()
30.                                             └─→ App(props) → <div>...</div>
31.                                         └─→ reconcileChildren(null, appFiber, children, DefaultLane)
32.                                             └─→ ... 继续处理子节点
```

## 7. 关键全局变量

在调用流程中，以下全局变量起关键作用：

```javascript
// 工作循环相关
let workInProgress: Fiber | null = null;           // 当前处理的Fiber
let workInProgressRoot: FiberRoot | null = null;   // 当前渲染的根
let renderLanes: Lanes = NoLanes;                  // 当前渲染优先级
let subtreeRenderLanes: Lanes = NoLanes;           // 子树渲染优先级

// 调度相关
let executionContext: ExecutionContext = NoContext; // 执行上下文
let workInProgressRootRenderLanes: Lanes = NoLanes; // 根渲染优先级

// 副作用相关
let workInProgressRootExitStatus: RootExitStatus = RootInProgress; // 渲染状态
```

## 8. 总结

React 18.2.0中`beginWork`的调用流程体现了React的核心设计理念：

1. **分层架构**：从应用入口到核心函数，层次清晰
2. **优先级调度**：通过车道模型实现精细的优先级控制
3. **可中断渲染**：并发模式下支持中断和恢复
4. **双缓冲机制**：通过current和workInProgress两棵树实现无缝切换
5. **渐进式处理**：通过工作循环逐步处理大型任务

理解这个调用流程，对于掌握React的渲染机制、性能优化和调试技巧至关重要。`beginWork`作为协调阶段的引擎，其调用链的设计充分体现了React在复杂性和性能之间的精妙平衡。