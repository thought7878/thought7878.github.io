# 1
这个函数**用来处理更新队列**。`processUpdateQueue`**在beginWork阶段会被两个地方调用：**
- updateHostRoot()中，packages/react-reconciler/src/ReactFiberBeginWork.new.js
- updateClassInstance()中，packages/react-reconciler/src/ReactFiberClassComponent.new.js

这段代码定义了 [processUpdateQueue](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiberClassUpdateQueue.new.js#L524-L729) 函数，它负责处理类组件的更新队列。

这个函数是。**React 更新处理的核心部分，*它负责：***

1. **将待处理的更新从共享队列shared.pending转移到基础更新队列firstBaseUpdate/lastBaseUpdate**
2. **同步当前(current)和工作进程(workInProgress)Fiber的更新队列**
3. 按优先级处理更新，跳过当前渲染车道无法处理的更新
4. **计算新的组件状态：** 遍历updateQueue，根据这些update计算出新的组件状态
5. **收集需要执行的回调函数**
6. **更新 Fiber 节点的状态和优先级信息**

这是 **React 实现状态更新和优先级调度**的关键函数之一。

```javascript
// 处理更新队列的函数
// workInProgress: 当前正在工作的 Fiber 节点
// props: 当前组件的属性
// instance: 组件实例
// renderLanes: 当前渲染的优先级车道
export function processUpdateQueue<State>(
  workInProgress: Fiber,
  props: any,
  instance: any,
  renderLanes: Lanes,
): void {
  // 获取当前 Fiber 的更新队列（在类组件或宿主根节点上始终非空）
  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);

  // 重置强制更新标志
  hasForceUpdate = false;

  if (__DEV__) {
    // 在开发环境中标记当前正在处理的队列
    currentlyProcessingQueue = queue.shared;
  }

  // 获取基础更新队列的首尾节点
  let firstBaseUpdate = queue.firstBaseUpdate;
  let lastBaseUpdate = queue.lastBaseUpdate;

  // 这里注意pending update不同于baseQueue，pending update只记录了尾节点
  // 检查是否有待处理的更新。如果有，将它们转移到基础队列。
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    // 清空共享队列的待处理部分
    queue.shared.pending = null;

    // 待处理队列是循环链表。断开首尾指针使其变为非循环链表。
    const lastPendingUpdate = pendingQueue;         // 最后一个待处理更新
    const firstPendingUpdate = lastPendingUpdate.next; // 第一个待处理更新
    lastPendingUpdate.next = null;                  // 断开循环链接
    
    // 把pending update转移到base queue上
    // 接下来构建单链表：firstBaseUpdate-->...-->lastBaseUpdate
    // 将待处理更新追加到基础队列
    if (lastBaseUpdate === null) {
      // 如果基础队列为空，直接设置第一个基础更新
      firstBaseUpdate = firstPendingUpdate;
    } else {
      // 如果基础队列非空，将待处理更新连接到基础队列末尾
      lastBaseUpdate.next = firstPendingUpdate;
    }
    // 更新最后基础更新为最后待处理更新
    lastBaseUpdate = lastPendingUpdate;

    // 如果存在当前队列（current）且与基础队列不同，则需要将更新也转移到那个队列
    // 由于基础队列是无循环的单链表，我们可以同时追加到两个列表并利用结构共享
    const current = workInProgress.alternate;  // 获取对应的工作进程 Fiber
    // 如果有current queue，并且它和base queue不同，那么我们也需要把更新转移到那个queue上
    if (current !== null) {
      // 类组件和HostRoot的updateQueue都初始化过，所以这里不会是null
      // 这在类组件或宿主根节点上始终非空
      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);
      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;
      // 如果当前队列的最后基础更新与工作进程队列的不同
      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          // 如果当前队列没有基础更新，设置第一个基础更新
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          // 否则将待处理更新连接到当前队列末尾
          currentLastBaseUpdate.next = firstPendingUpdate;
        }
        // 更新当前队列的最后基础更新
        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  }

  // 这些值在处理队列时可能会改变
  if (firstBaseUpdate !== null) {
    // 遍历更新列表以计算结果
    let newState = queue.baseState;  // 从基准状态开始
    // TODO: 不需要积累这个。相反，我们可以从原始车道中移除 renderLanes
    let newLanes = NoLanes;

    // 新的基础状态和更新队列
    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;

    // 从第一个基础更新开始遍历
    let update = firstBaseUpdate;
    do {
      // TODO: 不再需要这个字段
      const updateEventTime = update.eventTime;

      // 为隐藏树中的更新添加额外的 OffscreenLane 位，
      // 以便我们可以将它们与树隐藏时已存在的更新区分开
      const updateLane = removeLanes(update.lane, OffscreenLane);
      const isHiddenUpdate = updateLane !== update.lane;

      // 检查此更新是否在树被隐藏时进行的
      // 如果是，则这不是"基础"更新，我们应该忽略进入 Offscreen 树时添加到 renderLanes 的额外基础车道
      const shouldSkipUpdate = isHiddenUpdate
        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)  // 检查工作进程根渲染车道
        : !isSubsetOfLanes(renderLanes, updateLane);                       // 检查当前渲染车道

      if (shouldSkipUpdate) {
        // 优先级不足。跳过此更新。如果这是第一个跳过的更新，
        // 则前面的更新/状态是新的基础更新/状态。
        const clone: Update<State> = {
          eventTime: updateEventTime,
          lane: updateLane,

          tag: update.tag,
          payload: update.payload,
          callback: update.callback,

          next: null,
        };
        if (newLastBaseUpdate === null) {
          // 如果新基础更新队列为空，初始化它
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          // 否则将克隆的更新添加到队列末尾
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        // 更新队列中的剩余优先级
        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // 此更新具有足够的优先级。

        if (newLastBaseUpdate !== null) {
          const clone: Update<State> = {
            eventTime: updateEventTime,
            // 此更新将被提交，所以我们永远不想取消提交它
            // 使用 NoLane 是可行的，因为 0 是所有位掩码的子集，
            // 所以永远不会被上面的检查跳过
            lane: NoLane,

            tag: update.tag,
            payload: update.payload,
            callback: update.callback,

            next: null,
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }

        // 处理此更新
        newState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          newState,
          props,
          instance,
        );
        
        // 类组件的setState会在这里存储
        // 获取更新的回调函数
        const callback = update.callback;
        if (
          callback !== null &&
          // 如果更新已经被提交，我们不应再次排队其回调
          update.lane !== NoLane
        ) {
          // 设置回调标志
          workInProgress.flags |= Callback;
          // 获取副作用数组
          const effects = queue.effects;
          if (effects === null) {
            // 如果副作用数组为空，创建新的数组
            queue.effects = [update];
          } else {
            // 否则将更新推送到现有数组
            effects.push(update);
          }
        }
      }
      
      // 移动到下一个更新
      update = update.next;
      if (update === null) {
        // 如果到达队列末尾，检查是否有新添加的待处理更新
        pendingQueue = queue.shared.pending;
        if (pendingQueue === null) {
          // 没有新添加的待处理更新，退出循环
          break;
        } else {
          // 在 reducer 内部调度了更新。将新的待处理更新添加到列表末尾并继续处理。
          const lastPendingUpdate = pendingQueue;
          // 故意不安全。待处理更新形成循环列表，但在将它们转移到基础队列时我们会解开它们。
          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);
          lastPendingUpdate.next = null;
          update = firstPendingUpdate;
          queue.lastBaseUpdate = lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    // 如果没有新的基础更新，将新状态设为基础状态
    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    // 更新队列状态
    queue.baseState = ((newBaseState: any): State);      // 设置新的基准状态
    queue.firstBaseUpdate = newFirstBaseUpdate;          // 设置新的第一个基础更新
    queue.lastBaseUpdate = newLastBaseUpdate;            // 设置新的最后一个基础更新

    if (firstBaseUpdate === null) {
      // `queue.lanes` 用于纠缠过渡。一旦队列为空，我们可以将其设置回零。
      queue.shared.lanes = NoLanes;
    }

    // 设置剩余到期时间为队列中剩余的任何时间
    // 这应该是可行的，因为贡献到期时间的另外两件事是 props 和 context。
    // 我们已经在开始阶段中途开始处理队列，所以我们已经处理了 props。
    // 在指定 shouldComponentUpdate 的组件中的 context 是棘手的；
    // 但我们无论如何都必须考虑这一点。
    markSkippedUpdateLanes(newLanes);     // 标记跳过的更新车道
    workInProgress.lanes = newLanes;      // 设置工作进程节点的车道
    workInProgress.memoizedState = newState; // 设置工作进程节点的记忆状态
  }

  if (__DEV__) {
    // 在开发环境中重置当前处理队列
    currentlyProcessingQueue = null;
  }
}
```

# 2

我来为你详细解释这段 React 源码中的 [processUpdateQueue](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberClassUpdateQueue.new.js#L457-L656) 函数，这是 React 协调算法中处理更新队列的核心函数。

这个函数的主要职责是处理组件的更新队列，具体功能包括：

1. **合并待处理更新**：将新收到的更新（存储在 `fiber.updateQueue.shared.pending` 中）合并到基础更新队列`wip/current.updateQueue`中
2. **优先级处理**：根据当前渲染的优先级 (`renderLanes`) 决定哪些更新可以处理，哪些需要跳过
3. **状态计算**：按顺序应用所有可处理的更新，计算出新的组件状态
4. **基础队列维护**：将跳过的更新保存为新的基础更新队列，以便下次渲染时继续处理
5. **回调处理**：收集需要在提交阶段执行的回调函数
6. **剩余优先级跟踪**：记录未处理更新的优先级，用于后续调度

这是 React 实现并发更新和优先级调度的关键部分，允许 React 根据优先级选择性地处理更新，从而实现可中断渲染和时间切片等功能。

```javascript
export function processUpdateQueue<State>(
  workInProgress: Fiber,     // 当前正在工作的 fiber 节点
  props: any,               // 组件的 props
  instance: any,            // 组件实例（对于类组件来说）
  renderLanes: Lanes,       // 当前渲染的优先级
): void {
  // 获取 fiber 上的更新队列
  // 这个队列总是存在于 ClassComponent 或 HostRoot 上
  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);

  // 重置全局 force update 标志
  hasForceUpdate = false;

  // 开发环境下标记当前正在处理的队列
  if (__DEV__) {
    currentlyProcessingQueue = queue.shared;
  }

  // 获取队列中的第一个和最后一个基础更新
  let firstBaseUpdate = queue.firstBaseUpdate;
  let lastBaseUpdate = queue.lastBaseUpdate;

  // 检查是否存在待处理的更新
  // 如果存在，则将它们转移到基础队列
  let pendingQueue = queue.shared.pending;
  if (pendingQueue !== null) {
    // 清空待处理队列
    queue.shared.pending = null;

    // 待处理队列是循环链表，需要断开首尾连接使其成为普通链表
    const lastPendingUpdate = pendingQueue;
    const firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    
    // 将待处理更新追加到基础队列末尾
    if (lastBaseUpdate === null) {
      // 如果基础队列为空，则将待处理更新作为基础队列
      firstBaseUpdate = firstPendingUpdate;
    } else {
      // 否则将待处理更新接到基础队列后面
      lastBaseUpdate.next = firstPendingUpdate;
    }
    lastBaseUpdate = lastPendingUpdate;

    // 如果存在当前队列（current fiber）且不同于基础队列，
    // 我们也需要将更新转移到那个队列
    // 因为基础队列是一个没有循环的单链表，我们可以同时追加到两个列表并利用结构共享
    const current = workInProgress.alternate;
    if (current !== null) {
      // 这个队列总是存在于 ClassComponent 或 HostRoot 上
      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);
      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;
      
      // 只有当 current 队列与 work-in-progress 队列不同时才转移
      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }
        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  }

  // 如果基础更新队列不为空，则迭代处理队列中的所有更新
  if (firstBaseUpdate !== null) {
    // 从基础状态开始计算新状态
    let newState = queue.baseState;
    // 用于累积那些由于优先级不够而跳过的更新的 lanes
    let newLanes = NoLanes;

    // 用于构建新的基础更新队列
    let newBaseState = null;
    let newFirstBaseUpdate = null;
    let newLastBaseUpdate = null;

    // 从第一个基础更新开始遍历
    let update = firstBaseUpdate;
    do {
      // 获取当前更新的优先级和事件时间
      const updateLane = update.lane;
      const updateEventTime = update.eventTime;
      
      // 检查当前更新的优先级是否足够处理
      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // 优先级不足，跳过这个更新
        // 如果这是第一个被跳过的更新，则之前的更新/状态成为新的基础更新/状态
        
        // 创建当前更新的克隆
        const clone: Update<State> = {
          eventTime: updateEventTime,
          lane: updateLane,

          tag: update.tag,
          payload: update.payload,
          callback: update.callback,

          next: null,
        };
        
        // 将克隆添加到新的基础更新队列
        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }
        
        // 更新队列中剩余的优先级
        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // 这个更新有足够的优先级，需要处理
        
        // 如果已经有跳过的更新，那么当前更新也需要添加到新的基础队列中
        if (newLastBaseUpdate !== null) {
          const clone: Update<State> = {
            eventTime: updateEventTime,
            // 这个更新将被提交，所以我们永远不想取消提交它
            // 使用 NoLane 是有效的，因为 0 是所有位掩码的子集
            // 所以这个更新永远不会被上面的检查跳过
            lane: NoLane,

            tag: update.tag,
            payload: update.payload,
            callback: update.callback,

            next: null,
          };
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        }

        // ！！！处理这个更新，计算新状态
        newState = getStateFromUpdate(
          workInProgress,
          queue,
          update,
          newState,
          props,
          instance,
        );
        
        // 如果更新有回调函数，则将其添加到 effects 队列
        const callback = update.callback;
        if (
          callback !== null &&
          // 如果更新已经被提交，我们不应该再次排队其回调
          update.lane !== NoLane
        ) {
          // 设置 Callback 标志，表示这个 fiber 有需要执行的回调
          workInProgress.flags |= Callback;
          
          // 将更新添加到 effects 队列中
          const effects = queue.effects;
          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }
      
      // 移动到下一个更新
      update = update.next;
      
      // 如果到达队列末尾，检查是否有在处理期间添加的新更新
      if (update === null) {
        pendingQueue = queue.shared.pending;
        if (pendingQueue === null) {
          // 没有新更新，退出循环
          break;
        } else {
          // 在 reducer 内部调度了新更新
          // 将新待处理更新添加到列表末尾并继续处理
          const lastPendingUpdate = pendingQueue;
          // 故意不安全的转换
          // 待处理更新形成一个循环列表，但在将它们转移到基础队列时我们会解开它们
          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);
          lastPendingUpdate.next = null;
          update = firstPendingUpdate;
          queue.lastBaseUpdate = lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    // 如果没有跳过的更新，则新的基础状态就是最后计算出的状态
    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    // 更新队列的状态
    queue.baseState = ((newBaseState: any): State);
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate;

    // 交错更新存储在单独的队列中
    // 我们不会在此渲染期间处理它们，但需要跟踪哪些 lanes 仍然剩余
    const lastInterleaved = queue.shared.interleaved;
    if (lastInterleaved !== null) {
      let interleaved = lastInterleaved;
      do {
        // 合并交错更新的 lanes
        newLanes = mergeLanes(newLanes, interleaved.lane);
        interleaved = ((interleaved: any).next: Update<State>);
      } while (interleaved !== lastInterleaved);
    } else if (firstBaseUpdate === null) {
      // `queue.lanes` 用于纠缠转换
      // 一旦队列为空，我们可以将其设置回零
      queue.shared.lanes = NoLanes;
    }

    // 设置剩余的过期时间，即队列中剩余的任何内容
    // 这应该是可以的，因为另外两个对过期时间有贡献的是 props 和 context
    // 当我们开始处理队列时，我们已经处于 begin 阶段的中间，
    // 所以我们已经处理了 props
    // 在指定 shouldComponentUpdate 的组件中的 context 是棘手的；
    // 但无论如何我们都要考虑这一点
    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;        // 更新 fiber 的剩余 lanes
    workInProgress.memoizedState = newState; // 更新 fiber 的 memoized state
  }

  // 开发环境下清除标记
  if (__DEV__) {
    currentlyProcessingQueue = null;
  }
}
```

# getStateFromUpdate

这段代码是 React 协调算法中的 [getStateFromUpdate](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberClassUpdateQueue.new.js#L374-L456) 函数，它是用来**根据更新对象计算新状态**的核心函数。

这个函数*处理了四种不同类型的更新：*
1. **ReplaceState**: *完全替换当前状态，而不是合并*。如果 payload 是函数，则调用函数获得新状态；如果是对象，则直接使用该对象作为新状态。

2. **CaptureUpdate**: *与错误边界的异常捕获相关*，会设置相应的 fiber 标志，表明组件捕获到了错误。

3. **UpdateState**: *部分状态更新，最常见的更新类型*。如果 payload 是函数，则调用函数获得部分状态；如果是对象，则直接使用。然后将部分状态与当前状态进行合并。

4. **ForceUpdate**: 强制更新，不改变状态但会触发组件重新渲染。

函数*在开发模式下还实现了额外的安全检查*，包括防止在渲染阶段读取上下文以及在严格模式下重复调用函数以检测副作用。

注意在 `CaptureUpdate` 情况下故意省略了 `break` 语句，这样当遇到 `CaptureUpdate` 时，会先设置相应的标志，然后继续执行 `UpdateState` 的逻辑，这符合错误边界处理的预期行为。

```javascript
function getStateFromUpdate<State>(
  workInProgress: Fiber,    // 当前正在工作的 fiber 节点
  queue: UpdateQueue<State>, // 更新队列
  update: Update<State>,    // 当前处理的更新对象
  prevState: State,         // 当前状态
  nextProps: any,           // 新的 props
  instance: any,            // 组件实例（对类组件有效）
): any {
  // 根据更新的类型进行不同的处理
  switch (update.tag) {
    case ReplaceState: { // 替换状态类型
      const payload = update.payload;
      if (typeof payload === 'function') {
        // 如果 payload 是一个函数
        if (__DEV__) {
          // 开发环境下进入不允许的上下文读取模式
          enterDisallowedContextReadInDEV();
        }
        // 调用函数计算新状态，传入当前状态和新 props
        const nextState = payload.call(instance, prevState, nextProps);
        if (__DEV__) {
          // 在严格模式下，为了检测副作用，会再次调用函数
          if (
            debugRenderPhaseSideEffectsForStrictMode &&
            workInProgress.mode & StrictLegacyMode
          ) {
            setIsStrictModeForDevtools(true);
            try {
              payload.call(instance, prevState, nextProps);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          // 退出不允许的上下文读取模式
          exitDisallowedContextReadInDEV();
        }
        return nextState;
      }
      // 如果 payload 不是函数，直接返回 payload 作为新状态（替换整个状态）
      return payload;
    }
    case CaptureUpdate: { // 捕获更新类型，通常与错误边界相关
      // 设置 fiber 标志，清除 ShouldCapture 标志，设置 DidCapture 标志
      workInProgress.flags =
        (workInProgress.flags & ~ShouldCapture) | DidCapture;
    }
    // 注意：这里故意没有 break 语句，执行完 CaptureUpdate 后会继续执行 UpdateState
    case UpdateState: { // 状态更新类型
      const payload = update.payload;
      let partialState;
      if (typeof payload === 'function') {
        // 如果 payload 是函数
        if (__DEV__) {
          enterDisallowedContextReadInDEV();
        }
        // 调用函数获取部分状态
        partialState = payload.call(instance, prevState, nextProps);
        if (__DEV__) {
          // 严格模式下重复调用检测副作用
          if (
            debugRenderPhaseSideEffectsForStrictMode &&
            workInProgress.mode & StrictLegacyMode
          ) {
            setIsStrictModeForDevtools(true);
            try {
              payload.call(instance, prevState, nextProps);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          exitDisallowedContextReadInDEV();
        }
      } else {
        // 如果 payload 是对象，直接使用它作为部分状态
        partialState = payload;
      }
      // 如果部分状态为空（null 或 undefined），则不执行任何操作，返回之前的状态
      if (partialState === null || partialState === undefined) {
        return prevState;
      }
      // 将部分状态与之前的状态合并，返回新状态
      return assign({}, prevState, partialState);
    }
    case ForceUpdate: { // 强制更新类型
      // 设置全局 force update 标志
      hasForceUpdate = true;
      // 强制更新不改变状态，只触发重新渲染
      return prevState;
    }
  }
  // 默认返回之前的状态
  return prevState;
}
```

