# performUnitOfWork

这段代码是 React 源码中的 [completeUnitOfWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1859-L1956) 函数，它是 React 协调算法（Reconciliation）中的一个重要组成部分，负责完成工作单元的处理并移动到下一个待处理的节点。

这个函数的*主要功能*包括：

1. **完成当前工作单元**：*处理当前 fiber 节点的完成阶段*，包括**执行副作用、更新 DOM** 等操作。

2. 处理错误情况：如果在处理过程中发生错误，会调用 [unwindWork](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiberUnwindWork.new.js#L47-L159) 进行错误处理和回退。

3. **遍历 fiber 树**：按照特定顺序遍历 fiber 树，先处理兄弟节点，再返回父节点。

4. 性能分析：在需要的情况下记录组件的渲染时间。

5. **更新状态**：*更新 fiber 节点的状态和标志，为提交阶段做准备*。

这个函数是 *React 协调算法的第二阶段（完成阶段）* 的核心实现，*它从叶子节点开始**向上处理**，直到根节点*。在这个过程中，它会**处理各种副作用**，比如 *DOM 更新、ref 绑定、生命周期调用*等，并在出现错误时进行适当的错误处理。

```javascript
function completeUnitOfWork(unitOfWork: Fiber): void {
  // 尝试完成当前工作单元，然后移动到下一个兄弟节点
  // 如果没有更多兄弟节点，则返回到父 fiber
  let completedWork = unitOfWork;
  do {
    // 当前 fiber 的当前状态（flushed 状态）是 alternate
    // 理想情况下不应有任何依赖于此，但在这里依赖它可以避免
    // 在 work in progress 上增加额外的字段
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;

    // 检查工作是否完成或是否有异常抛出
    if ((completedWork.flags & Incomplete) === NoFlags) {
      // 设置当前调试 fiber（仅在开发环境）
      setCurrentDebugFiberInDEV(completedWork);
      let next;
      if (
        !enableProfilerTimer ||
        (completedWork.mode & ProfileMode) === NoMode
      ) {
        // ！！！如果不需要性能分析，直接执行 completeWork
        next = completeWork(current, completedWork, subtreeRenderLanes);
      } else {
        // 如果需要性能分析，启动计时器
        startProfilerTimer(completedWork);
        // ！！！
        next = completeWork(current, completedWork, subtreeRenderLanes);
        // 更新渲染时间（假设没有错误）
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
      }
      // 重置当前调试 fiber
      resetCurrentDebugFiberInDEV();

      if (next !== null) {
        // 完成此 fiber 产生了新的工作，接下来处理它
        workInProgress = next;
        return;
      }
    } else {
      // 此 fiber 没有完成是因为有异常抛出
      // 从堆栈弹出值而不进入完成阶段
      // 如果这是一个边界组件，尽可能捕获值
      const next = unwindWork(current, completedWork, subtreeRenderLanes);

      // 因为此 fiber 没有完成，不要重置其 lanes

      if (next !== null) {
        // 如果完成这项工作产生了新工作，接下来处理它
        // 我们会回到这里
        // 由于我们正在重启，移除 effect 标签中不是 host effect 的任何内容
        next.flags &= HostEffectMask;
        workInProgress = next;
        return;
      }

      if (
        enableProfilerTimer &&
        (completedWork.mode & ProfileMode) !== NoMode
      ) {
        // 记录出错 fiber 的渲染时间
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);

        // 在继续之前，包括处理失败子项所花费的时间
        let actualDuration = completedWork.actualDuration;
        let child = completedWork.child;
        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }
        completedWork.actualDuration = actualDuration;
      }

      if (returnFiber !== null) {
        // 将父 fiber 标记为不完整并清除其子树标志
        returnFiber.flags |= Incomplete;
        returnFiber.subtreeFlags = NoFlags;
        returnFiber.deletions = null;
      } else {
        // 我们已经回退到了根节点
        workInProgressRootExitStatus = RootDidNotComplete;
        workInProgress = null;
        return;
      }
    }

    // 获取兄弟 fiber
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      // 如果在此 returnFiber 中还有更多工作要做，接下来处理它
      workInProgress = siblingFiber;
      return;
    }
    // 否则，返回到父节点
    completedWork = returnFiber;
    // 更新我们正在处理的下一项，以防出现异常
    workInProgress = completedWork;
  } while (completedWork !== null);

  // 我们已经到达根节点
  if (workInProgressRootExitStatus === RootInProgress) {
    workInProgressRootExitStatus = RootCompleted;
  }
}
```

## completeWork

这段代码是 React 源码中的 [completeWork](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L849-L1598) 函数，*这是 React 协调算法（Reconciliation）中完成阶段（Complete Phase）* 的核心函数之一。它负责**处理 Fiber 节点的完成工作**，包括*创建 DOM 元素、更新属性、处理组件完成后的逻辑*等。

这个函数是 React 协调算法的重要组成部分，*它根据不同的 Fiber 类型执行相应的完成阶段操作：*

1. 对于函数组件、片段等类型，*只需要冒泡属性到父节点*
2. 对于宿主组件（DOM 元素），*创建或更新实际的 DOM 节点*
3. 对于文本节点，创建或更新文本节点
4. 对于 Suspense 组件，处理加载状态和超时逻辑
5. 对于根节点，处理全局上下文和缓存
6. 对于类组件，处理旧版上下文

函数的**核心职责**是*完成当前节点的处理，并为提交阶段做准备*，包括*更新 DOM、处理副作用、冒泡属性（为父fiber收集子fiber的 lanes/flags）*等。

```javascript
function completeWork(
  current: Fiber | null,        // 当前已挂载的 Fiber 节点
  workInProgress: Fiber,        // 正在处理的 Fiber 节点
  renderLanes: Lanes,           // 当前渲染的优先级
): Fiber | null {
  const newProps = workInProgress.pendingProps;  // 获取待处理的 props
  
  // 弹出树上下文
  popTreeContext(workInProgress);
  
  // 根据 Fiber 节点的类型进行不同的处理
  switch (workInProgress.tag) {
    // 以下类型的组件不需要额外处理，只需冒泡属性
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);  // 冒泡属性到父节点
      return null;  // 返回 null 表示当前节点处理完成，继续处理兄弟节点

    case ClassComponent: {
      const Component = workInProgress.type;
      if (isLegacyContextProvider(Component)) {
        popLegacyContext(workInProgress);  // 弹出旧版上下文
      }
      bubbleProperties(workInProgress);
      return null;
    }
    
    case HostRoot: {  // 根节点处理
      const fiberRoot = (workInProgress.stateNode: FiberRoot);

      if (enableTransitionTracing) {
        const transitions = getWorkInProgressTransitions();
        // 设置 Passive 标志，因为如果有新过渡，我们需要调度回调并处理过渡
        if (transitions !== null) {
          workInProgress.flags |= Passive;
        }
      }

      if (enableCache) {
        let previousCache: Cache | null = null;
        if (current !== null) {
          previousCache = current.memoizedState.cache;
        }
        const cache: Cache = workInProgress.memoizedState.cache;
        if (cache !== previousCache) {
          // 运行被动效果来保留/释放缓存
          workInProgress.flags |= Passive;
        }
        popCacheProvider(workInProgress, cache);
      }
      popRootTransition(workInProgress, fiberRoot, renderLanes);
      popHostContainer(workInProgress);
      popTopLevelLegacyContextObject(workInProgress);
      resetMutableSourceWorkInProgressVersions();
      if (fiberRoot.pendingContext) {
        fiberRoot.context = fiberRoot.pendingContext;
        fiberRoot.pendingContext = null;
      }
      if (current === null || current.child === null) {
        // 如果我们进行了水合，弹出以便我们可以删除任何未水合的子节点
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          // 如果我们进行了水合，则需要调度提交阶段的副作用更新
          markUpdate(workInProgress);
        } else {
          if (current !== null) {
            const prevState: RootState = current.memoizedState;
            if (
              // 检查是否是客户端根节点
              !prevState.isDehydrated ||
              // 检查我们是否恢复到客户端渲染（例如由于错误）
              (workInProgress.flags & ForceClientRender) !== NoFlags
            ) {
              // 调度一个效果，在下次提交开始时清除此容器
              workInProgress.flags |= Snapshot;

              // 如果这是强制客户端渲染，第一次水合尝试期间可能会有可恢复的错误
              // 如果是这样，将它们添加到队列中以便我们可以在提交阶段记录它们
              upgradeHydrationErrorsToRecoverable();
            }
          }
        }
      }
      updateHostContainer(current, workInProgress);
      bubbleProperties(workInProgress);
      if (enableTransitionTracing) {
        if ((workInProgress.subtreeFlags & Visibility) !== NoFlags) {
          // 如果任何我们的 Suspense 子级切换可见性，这意味着
          // pending boundaries 数组需要更新，我们只在被动阶段执行此操作
          workInProgress.flags |= Passive;
        }
      }
      return null;
    }
    
    case HostComponent: {  // 原生 DOM 元素组件
      popHostContext(workInProgress);
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      
      if (current !== null && workInProgress.stateNode != null) {
        // 更新现有的 DOM 元素
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          rootContainerInstance,
        );

        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);  // 标记 ref 需要更新
        }
      } else {
        // 首次挂载
        if (!newProps) {
          if (workInProgress.stateNode === null) {
            throw new Error(
              'We must have new props for new mounts. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }

          // 这可能在我们中止工作时发生
          bubbleProperties(workInProgress);
          return null;
        }

        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          // 水合现有 DOM 节点
          if (
            prepareToHydrateHostInstance(
              workInProgress,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            // 如果需要在提交阶段应用对水合节点的更改，我们将其标记为这样
            markUpdate(workInProgress);
          }
        } else {
          // 创建新的 DOM 节点
          const instance = createInstance(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );

          // 将子节点附加到新创建的实例
          appendAllChildren(instance, workInProgress, false, false);

          workInProgress.stateNode = instance;

          // 某些渲染器需要在提交时对初始挂载进行效果处理
          if (
            finalizeInitialChildren(
              instance,
              type,
              newProps,
              rootContainerInstance,
              currentHostContext,
            )
          ) {
            markUpdate(workInProgress);
          }
        }

        if (workInProgress.ref !== null) {
          // 如果主机节点上有 ref，我们需要调度回调
          markRef(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    
    case HostText: {  // 文本节点
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
        const oldText = current.memoizedProps;
        // 如果我们有一个备用项，那意味着这是一个更新，我们需要调度一个副作用来执行更新
        updateHostText(current, workInProgress, oldText, newText);
      } else {
        if (typeof newText !== 'string') {
          if (workInProgress.stateNode === null) {
            throw new Error(
              'We must have new props for new mounts. This error is likely ' +
                'caused by a bug in React. Please file an issue.',
            );
          }
          // 这可能在我们中止工作时发生
        }
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          if (prepareToHydrateHostTextInstance(workInProgress)) {
            markUpdate(workInProgress);
          }
        } else {
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    
    case SuspenseComponent: {  // Suspense 组件
      popSuspenseContext(workInProgress);
      const nextState: null | SuspenseState = workInProgress.memoizedState;

      // 脱水边界特殊情况。我们最终可能会将其移到自己的 Fiber 类型
      if (
        current === null ||
        (current.memoizedState !== null &&
          current.memoizedState.dehydrated !== null)
      ) {
        const fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(
          current,
          workInProgress,
          nextState,
        );
        if (!fallthroughToNormalSuspensePath) {
          if (workInProgress.flags & ShouldCapture) {
            // 特殊情况。还有未水合的节点。我们将其视为不匹配。恢复到客户端渲染。
            return workInProgress;
          } else {
            // 未完成水合，要么是因为这是初始渲染，要么是因为某些东西被挂起了
            return null;
          }
        }
        // 继续常规的 Suspense 路径
      }

      if ((workInProgress.flags & DidCapture) !== NoFlags) {
        // 某些东西被挂起了。使用 fallback 子级重新渲染
        workInProgress.lanes = renderLanes;
        // 不要重置效果列表
        if (
          enableProfilerTimer &&
          (workInProgress.mode & ProfileMode) !== NoMode
        ) {
          transferActualDuration(workInProgress);
        }
        // 在这种情况下不要冒泡属性
        return workInProgress;
      }

      const nextDidTimeout = nextState !== null;
      const prevDidTimeout =
        current !== null &&
        (current.memoizedState: null | SuspenseState) !== null;

      if (enableCache && nextDidTimeout) {
        const offscreenFiber: Fiber = (workInProgress.child: any);
        // ... 处理缓存 ...
      }

      // 如果边界的状态发生变化，我们需要调度被动效果
      if (nextDidTimeout !== prevDidTimeout) {
        if (enableTransitionTracing) {
          const offscreenFiber: Fiber = (workInProgress.child: any);
          offscreenFiber.flags |= Passive;
        }

        // 如果边界的状态发生变化，我们需要调度一个效果来切换子树的可见性
        if (nextDidTimeout) {
          const offscreenFiber: Fiber = (workInProgress.child: any);
          offscreenFiber.flags |= Visibility;

          if ((workInProgress.mode & ConcurrentMode) !== NoMode) {
            const hasInvisibleChildContext =
              current === null &&
              (workInProgress.memoizedProps.unstable_avoidThisFallback !==
                true ||
                !enableSuspenseAvoidThisFallback);
            if (
              hasInvisibleChildContext ||
              hasSuspenseContext(
                suspenseStackCursor.current,
                (InvisibleParentSuspenseContext: SuspenseContext),
              )
            ) {
              renderDidSuspend();
            } else {
              renderDidSuspendDelayIfPossible();
            }
          }
        }
      }

      const wakeables: Set<Wakeable> | null = (workInProgress.updateQueue: any);
      if (wakeables !== null) {
        // 调度一个效果，将重试侦听器附加到 Promise
        workInProgress.flags |= Update;
      }

      if (
        enableSuspenseCallback &&
        workInProgress.updateQueue !== null &&
        workInProgress.memoizedProps.suspenseCallback != null
      ) {
        // 始终通知回调
        workInProgress.flags |= Update;
      }
      bubbleProperties(workInProgress);
      if (enableProfilerTimer) {
        if ((workInProgress.mode & ProfileMode) !== NoMode) {
          if (nextDidTimeout) {
            // 不要将超时的 Suspense 子树中花费的时间计入基本持续时间
            const primaryChildFragment = workInProgress.child;
            if (primaryChildFragment !== null) {
              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);
            }
          }
        }
      }
      return null;
    }
    
    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(current, workInProgress);
      if (current === null) {
        preparePortalMount(workInProgress.stateNode.containerInfo);
      }
      bubbleProperties(workInProgress);
      return null;
      
    case ContextProvider:
      // 弹出提供者 fiber
      const context: ReactContext<any> = workInProgress.type._context;
      popProvider(context, workInProgress);
      bubbleProperties(workInProgress);
      return null;
      
    case IncompleteClassComponent: {
      // 与类组件情况相同。我把它放在这里，以便标签是连续的，确保此开关编译为跳转表
      const Component = workInProgress.type;
      if (isLegacyContextProvider(Component)) {
        popLegacyContext(workInProgress);
      }
      bubbleProperties(workInProgress);
      return null;
    }
    
    case SuspenseListComponent: {  // Suspense 列表组件
      // ... 处理 Suspense 列表的复杂逻辑 ...
    }
    
    case ScopeComponent: {  // 作用域组件
      if (enableScopeAPI) {
        if (current === null) {
          const scopeInstance: ReactScopeInstance = createScopeInstance();
          workInProgress.stateNode = scopeInstance;
          prepareScopeUpdate(scopeInstance, workInProgress);
          if (workInProgress.ref !== null) {
            markRef(workInProgress);
            markUpdate(workInProgress);
          }
        } else {
          if (workInProgress.ref !== null) {
            markUpdate(workInProgress);
          }
          if (current.ref !== workInProgress.ref) {
            markRef(workInProgress);
          }
        }
        bubbleProperties(workInProgress);
        return null;
      }
      break;
    }
    
    case OffscreenComponent:  // 离屏组件
    case LegacyHiddenComponent: {
      popRenderLanes(workInProgress);
      const nextState: OffscreenState | null = workInProgress.memoizedState;
      const nextIsHidden = nextState !== null;

      if (current !== null) {
        const prevState: OffscreenState | null = current.memoizedState;
        const prevIsHidden = prevState !== null;
        if (
          prevIsHidden !== nextIsHidden &&
          // LegacyHidden 不做任何隐藏——它只预渲染
          (!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent)
        ) {
          workInProgress.flags |= Visibility;
        }
      }

      if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {
        bubbleProperties(workInProgress);
      } else {
        // 不要为隐藏的子级冒泡属性，除非我们正在离屏优先级下渲染
        if (includesSomeLane(subtreeRenderLanes, (OffscreenLane: Lane))) {
          bubbleProperties(workInProgress);
          if (supportsMutation) {
            // 检查隐藏子树中是否有插入或更新
            if (
              (!enableLegacyHidden ||
                workInProgress.tag !== LegacyHiddenComponent) &&
              workInProgress.subtreeFlags & (Placement | Update)
            ) {
              workInProgress.flags |= Visibility;
            }
          }
        }
      }

      if (enableCache) {
        let previousCache: Cache | null = null;
        if (
          current !== null &&
          current.memoizedState !== null &&
          current.memoizedState.cachePool !== null
        ) {
          previousCache = current.memoizedState.cachePool.pool;
        }
        let cache: Cache | null = null;
        if (
          workInProgress.memoizedState !== null &&
          workInProgress.memoizedState.cachePool !== null
        ) {
          cache = workInProgress.memoizedState.cachePool.pool;
        }
        if (cache !== previousCache) {
          // 运行被动效果来保留/释放缓存
          workInProgress.flags |= Passive;
        }
      }

      popTransition(workInProgress, current);

      return null;
    }
    
    case CacheComponent: {  // 缓存组件
      if (enableCache) {
        let previousCache: Cache | null = null;
        if (current !== null) {
          previousCache = current.memoizedState.cache;
        }
        const cache: Cache = workInProgress.memoizedState.cache;
        if (cache !== previousCache) {
          // 运行被动效果来保留/释放缓存
          workInProgress.flags |= Passive;
        }
        popCacheProvider(workInProgress, cache);
        bubbleProperties(workInProgress);
      }
      return null;
    }
    
    case TracingMarkerComponent: {  // 跟踪标记组件
      if (enableTransitionTracing) {
        // 先冒泡子树标志，然后我们可以设置标志属性
        bubbleProperties(workInProgress);
      }
      return null;
    }
  }

  // 如果到达这里，说明遇到了未知的 Fiber 类型
  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```

