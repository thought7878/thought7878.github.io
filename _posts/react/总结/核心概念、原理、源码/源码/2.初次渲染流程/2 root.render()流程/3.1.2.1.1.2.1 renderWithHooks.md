# renderWithHooks

`packages/react-reconciler/src/ReactFiberHooks.old.js`

这段代码是 React 源码中的 [renderWithHooks](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%80%93%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L4513-L4527) 函数，它负责在函数组件中渲染带有 hooks 的组件。这个函数是 React hooks 系统的核心部分，*处理函数组件的渲染过程和 hooks 的调度*。

这个函数的*主要功能*包括：

1. 初始化渲染环境：设置当前渲染的优先级和 fiber 节点
2. **设置 hooks 调度器**：根据组件是初次渲染还是更新来选择适当的 hooks 调度器
3. **执行组件函数**：调用组件函数，这将触发所有 hooks 的执行
4. **处理渲染阶段更新**：如果在渲染过程中调度了新的更新，循环重新渲染直到没有更多更新
5. **验证 hooks 规则**：确保 hooks 的数量和调用顺序保持一致
6. 清理全局变量：重置所有在渲染过程中使用的全局变量

这个函数是 React hooks 系统的核心，确保 hooks 在每次渲染中都能正确执行，并处理各种边界情况，如渲染阶段更新和 hooks 规则验证。


```javascript
export function renderWithHooks<Props, SecondArg>(
  current: Fiber | null,        // 当前的 fiber 节点（work-in-progress 的 alternate）
  workInProgress: Fiber,        // 正在工作的 fiber 节点
  Component: (p: Props, arg: SecondArg) => any,  // 要渲染的组件函数
  props: Props,                 // 组件的 props
  secondArg: SecondArg,         // 第二个参数（通常是组件的 context 或其他）
  nextRenderLanes: Lanes,       // 下次渲染的优先级
): any {
  // 设置当前渲染优先级和当前渲染的 fiber
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;

  // 开发环境下的调试逻辑
  if (__DEV__) {
    // 记录当前组件使用的 hooks 类型
    hookTypesDev =
      current !== null
        ? ((current._debugHookTypes: any): Array<HookType>)  // 从当前 fiber 获取之前记录的 hooks 类型
        : null;  // 初始渲染时没有 hooks 类型
    hookTypesUpdateIndexDev = -1;  // 重置 hooks 索引
    // 用于热重载：当组件类型发生变化时忽略先前的依赖项
    ignorePreviousDependencies =
      current !== null && current.type !== workInProgress.type;
  }

  // 重置 fiber 的 memoizedState 和 updateQueue
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes;

  // 注释说明了下面的变量应该已经在函数开始前被重置
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // localIdCounter = 0;

  // TODO 在挂载时如果没有使用任何 hooks，而在更新时使用了 hooks，则发出警告
  // 目前我们会将更新渲染识别为挂载，因为 memoizedState === null
  // 这很棘手，因为这对某些类型的组件是有效的（例如 React.lazy）

  // 使用 memoizedState 来区分挂载/更新仅在使用至少一个有状态 hooks 时才有效
  // 无状态 hooks（如 context）不会被添加到 memoizedState，
  // 所以在更新和挂载期间 memoizedState 可能为 null

  // 根据当前 fiber 的状态设置适当的 dispatcher
  if (__DEV__) {
    // 如果存在 current fiber 且其 memoizedState 不为 null，则使用更新时的 dispatcher
    if (current !== null && current.memoizedState !== null) {
      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      // 这个 dispatcher 处理一个边缘情况：组件正在更新，
      // 但没有使用任何有状态的 hooks
      // 我们希望匹配生产代码的行为（将使用 HooksDispatcherOnMount），
      // 但使用额外的 DEV 验证来确保 hooks 顺序没有更改
      // 这个 dispatcher 就是做这个的
      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      // 初始挂载时使用挂载时的 dispatcher
      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;
    }
  } else {
    // 生产环境下的 dispatcher 选择逻辑
    ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount  // 挂载时的 dispatcher
        : HooksDispatcherOnUpdate; // 更新时的 dispatcher
  }

  // ！！！调用组件函数，这将执行所有的 hooks
  let children = Component(props, secondArg);

  // 检查是否发生了渲染阶段更新（render phase update）
  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    // 只要渲染阶段更新继续被调度，就继续循环渲染
    // 使用计数器防止无限循环
    let numberOfReRenders: number = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;  // 重置更新标志
      localIdCounter = 0;  // 重置 ID 计数器

      if (numberOfReRenders >= RE_RENDER_LIMIT) {
        // 防止无限循环，最多重渲染 RE_RENDER_LIMIT 次
        throw new Error(
          'Too many re-renders. React limits the number of renders to prevent ' +
            'an infinite loop.',
        );
      }

      numberOfReRenders += 1;
      if (__DEV__) {
        // 即使在热重载时，也要允许依赖项在第一次渲染后稳定下来
        // 以防止无限的渲染阶段更新
        ignorePreviousDependencies = false;
      }

      // 从头开始重新渲染
      currentHook = null;  // 重置当前 hook
      workInProgressHook = null;  // 重置工作中的 hook

      workInProgress.updateQueue = null;  // 重置更新队列

      if (__DEV__) {
        // 验证级联更新的 hook 顺序
        hookTypesUpdateIndexDev = -1;
      }

      // 设置重新渲染的 dispatcher
      ReactCurrentDispatcher.current = __DEV__
        ? HooksDispatcherOnRerenderInDEV  // 开发环境下的重新渲染 dispatcher
        : HooksDispatcherOnRerender;      // 生产环境下的重新渲染 dispatcher

      // 再次调用组件函数
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);  // 如果仍有渲染阶段更新，则继续循环
  }

  // 我们可以假设前一个 dispatcher 总是这个，因为我们
  // 在渲染阶段开始时设置了它，并且没有重新进入
  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  if (__DEV__) {
    // 保存当前 hooks 类型到 fiber，用于调试
    workInProgress._debugHookTypes = hookTypesDev;
  }

  // 这个检查使用 currentHook，因此在 DEV 和 prod 包中工作相同
  // hookTypesDev 可以捕获更多情况（例如 context），但仅在 DEV 包中
  const didRenderTooFewHooks =
    currentHook !== null && currentHook.next !== null;

  // 重置全局变量
  renderLanes = NoLanes;
  currentlyRenderingFiber = (null: any);

  currentHook = null;
  workInProgressHook = null;

  if (__DEV__) {
    // 开发环境下重置调试相关的变量
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;

    // 确认自上次渲染以来没有添加或删除静态标志
    // 如果触发此错误，表明我们在代码库的其他部分错误地重置了静态标志
    if (
      current !== null &&
      (current.flags & StaticMaskEffect) !==
        (workInProgress.flags & StaticMaskEffect) &&
      // 在 legacy 模式下禁用此警告，因为 legacy Suspense 很奇怪
      // 并会产生误报
      (current.mode & ConcurrentMode) !== NoMode
    ) {
      console.error(
        'Internal React error: Expected static flag was missing. Please ' +
          'notify the React team.',
      );
    }
  }

  didScheduleRenderPhaseUpdate = false;
  // 这个由 checkDidRenderIdHook 重置
  // localIdCounter = 0;

  // 如果渲染的 hooks 少于预期数量，则抛出错误
  if (didRenderTooFewHooks) {
    throw new Error(
      'Rendered fewer hooks than expected. This may be caused by an accidental ' +
        'early return statement.',
    );
  }

  // 启用懒惰上下文传播
  if (enableLazyContextPropagation) {
    if (current !== null) {
      if (!checkIfWorkInProgressReceivedUpdate()) {
        // 如果 props 或 state 没有变化，我们需要检查
        // 是否有上下文更改
        // 我们之前没有这样做，因为依赖项和 hooks 之间没有一对一的对应关系
        // 尽管在常见情况下几乎总是有（readContext 是内部 API），我们可以在那里比较
        // 但是，我们只在所有其他方案都跳出时才会遇到这种情况
        // 所以总的来说，将比较保留在常见路径之外可能是更好的选择
        const currentDependencies = current.dependencies;
        if (
          currentDependencies !== null &&
          checkIfContextChanged(currentDependencies)
        ) {
          markWorkInProgressReceivedUpdate();  // 标记接收到更新
        }
      }
    }
  }
  return children;  // 返回渲染的结果
}
```

# mountState（初始化组件useState调用）


这段代码是 React 源码中的 [mountState](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1521-L1542) 函数，*它是 `useState` Hook 在组件挂载阶段的实现*。

这个函数的*主要功能*包括：

1. **创建 Hook**：调用 [mountWorkInProgressHook](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L1450-L1476) *创建一个新的 hook 对象并将其添加到当前正在渲染的 fiber 的 hooks 链表中*。

2. **处理初始状态**：如果传入的初始状态是一个函数，则执行该函数获取实际的初始状态值。这允许我们使用惰性初始化，例如 `useState(() => expensiveCalculation())`，这样计算只会在初始渲染时执行一次。

3. **设置状态**：将初始状态设置为 hook 的 [memoizedState](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.begin.js#L297-L297) 和 [baseState](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L357-L357)。

4. **创建更新队列**：创建一个更新队列对象，用于管理后续的状态更新。队列包含等待处理的更新、优先级信息、分发函数等。

5. **创建 dispatch 函数**：创建一个绑定到当前 fiber 和队列的 dispatch 函数，这样当调用 setState 时，React 知道更新哪个 fiber 和队列。

6. **返回状态和更新函数**：返回包含当前状态和更新函数的数组，这就是 `useState` 返回的元组。

这个函数只在组件首次渲染（挂载）时调用，后续更新会使用不同的函数。React 通过这种方式维护 hooks 的状态和更新机制，确保每次渲染都能访问到正确的状态值和更新函数。

```javascript
function mountState<S>(
  initialState: (() => S) | S,  // 初始状态，可以是值或返回值的函数
): [S, Dispatch<BasicStateAction<S>>] {  // 返回状态值和更新函数的元组
  // 创建一个新的 hook 对象并添加到当前正在渲染的 fiber 的 hooks 链表中
  const hook = mountWorkInProgressHook();
  
  // 如果初始状态是一个函数，则执行该函数获取实际的初始状态值
  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }
  
  // 将初始状态设置为 hook 的 memoizedState 和 baseState
  hook.memoizedState = hook.baseState = initialState;
  
  // 创建一个更新队列来管理状态的更新
  const queue: UpdateQueue<S, BasicStateAction<S>> = {
    pending: null,                    // 等待处理的更新
    interleaved: null,                // 交错更新
    lanes: NoLanes,                   // 优先级通道
    dispatch: null,                   // 分发函数，稍后设置
    lastRenderedReducer: basicStateReducer,  // 最后一次渲染时使用的 reducer
    lastRenderedState: (initialState: any),  // 最后一次渲染时的状态
  };
  
  // 将队列赋值给 hook
  hook.queue = queue;
  
  // 创建 dispatch 函数，绑定当前 fiber 和队列
  const dispatch: Dispatch<BasicStateAction<S>> = (queue.dispatch =
    (dispatchSetState.bind(null, currentlyRenderingFiber, queue): any));
  
  // 返回状态值和更新函数
  return [hook.memoizedState, dispatch];
}
```

# mountWorkInProgressHook

这段代码是 React 源码中的 [mountWorkInProgressHook](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L646-L666) 函数，它是 React hooks 系统中的一个核心辅助函数，用于在组件挂载阶段创建和链接 hooks。

这个函数的*主要作用*是：

1. **创建 Hook 对象**：创建一个包含必要属性的 Hook 对象，用于*存储状态值、更新队列*等信息。

2. **构建链表结构**：*React 通过链表的形式存储组件中的所有 hooks*，这个函数负责*将新的 hook 添加到链表中*。

3. **维护顺序一致性**：*通过始终按照相同的顺序将 hooks 添加到链表中，React 确保了在后续渲染中能够正确匹配 hooks*。

*这个函数在每次调用 hook 时都会被调用*（如 useState、useEffect 等），*确保每个 hook 都能在组件的 memoizedState 中占据一个固定的位置*，这对于 React 的 hooks 机制至关重要。React 依赖于 hooks 的调用顺序保持一致，这样才能*在重新渲染时正确地将状态与相应的 hook 关联起来*。

如果 [workInProgressHook](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L355-L355) 为 null，表示这是组件中第一个被调用的 hook，所以将它设置为 fiber 的 [memoizedState](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiber.begin.js#L297-L297)。否则，将新 hook 添加到已有链表的末尾。

```javascript
function mountWorkInProgressHook(): Hook {
  // 创建一个新的 hook 对象，初始化其各个属性
  const hook: Hook = {
    memoizedState: null,    // 存储 hook 的当前状态值
    
    baseState: null,        // 基础状态，用于计算更新后的新状态
    baseQueue: null,        // 基础队列，存储待处理的更新
    queue: null,            // 存储更新队列，包含待处理的更新和分发函数
    
    next: null,             // 指向下一个 hook 的指针，用于构建 hooks 链表
  };

  // 判断当前是否是第一个 hook
  if (workInProgressHook === null) {
    // 如果是第一个 hook，则设置为 fiber 的 memoizedState，并同时更新 workInProgressHook（hook链表的指针）
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // 如果不是第一个 hook，则将其添加到现有 hooks 链表的末尾
    workInProgressHook = workInProgressHook.next = hook;
  }
  // 返回当前创建的 hook
  return workInProgressHook;
}
```

