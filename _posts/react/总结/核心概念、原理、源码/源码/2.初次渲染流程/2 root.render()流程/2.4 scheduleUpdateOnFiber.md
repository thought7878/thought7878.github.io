

这段代码定义了 [scheduleUpdateOnFiber](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L532-L657) 函数，*它是 React 更新调度系统的核心部分*。

这个函数的**主要功能包括：**

1. 检查和验证：检查嵌套更新、验证更新来源、警告不当使用
2. **标记更新**：*标记根节点有待处理的更新*，markRootUpdated
3. **区分更新类型**：区分*渲染阶段更新*和*正常更新*
4. 开发环境增强：添加开发者工具支持、警告和分析功能
5. **处理特殊情况**：处理交错更新、暂停状态等
6. **调度更新**：*确保根节点被正确调度*
7. **同步更新处理**：对于同步更新，在特定条件下立即执行

*这是 React 调度系统的中枢，负责确保更新被正确、高效地处理*。

参考：[[2.4.1 markRootUpdated]]、[[2.4.2 ensureRootIsScheduled]]

```javascript
// 在 Fiber 上调度更新的函数
// root: Fiber 根节点，FiberRoot
// fiber: 要更新的 Fiber 节点
// lane: 更新的优先级车道
// eventTime: 事件发生的时间
export function scheduleUpdateOnFiber(
  root: FiberRoot,
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // 检查嵌套更新（防止无限循环更新）
  checkForNestedUpdates();

  if (__DEV__) {
    // 在开发环境中，检查是否在 useInsertionEffect 中调度更新
    if (isRunningInsertionEffect) {
      console.error('useInsertionEffect must not schedule updates.');
    }
  }

  if (__DEV__) {
    // 在开发环境中，检查是否在被动效果期间调度更新
    if (isFlushingPassiveEffects) {
      didScheduleUpdateDuringPassiveEffects = true;
    }
  }

  // 标记FiberRoot根节点有待处理的更新
  markRootUpdated(root, lane, eventTime);

  // 检查更新是否在渲染阶段调度
  if (
    (executionContext & RenderContext) !== NoLanes &&  // 当前在渲染上下文中
    root === workInProgressRoot                    // 更新发生在正在进行的工作根节点上
  ) {
    // 此更新在渲染阶段被调度。如果更新来自用户空间（局部钩子更新除外，
    // 它们以不同方式处理且不会到达此函数），则是错误的，
    // 但有一些内部 React 特性使用此作为实现细节，如选择性水合。
    
    // 这个更新是在渲染阶段期间发送的。
	// 如果更新源自用户空间(除了本地hook update之外,hook update会被单独处理,不会到达这个函数),那么这是一个错误
	// 但是,有一些内部的React功能将这个作为实现细节,比如选择性hydration
    warnAboutRenderPhaseUpdatesInDEV(fiber);

    // 跟踪在渲染阶段更新的车道
    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(
      workInProgressRootRenderPhaseUpdatedLanes,
      lane,
    );
  } else {
    // 这是正常更新，从渲染阶段之外调度。例如，在输入事件期间。
    if (enableUpdaterTracking) {
      if (isDevToolsPresent) {
        // 如果开发工具存在，将 Fiber 添加到车道映射中
        addFiberToLanesMap(root, fiber, lane);
      }
    }

    // 在开发环境中警告未被 act 包装的更新
    warnIfUpdatesNotWrappedWithActDEV(fiber);

    // 如果启用分析器定时器和嵌套更新调度钩子
    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {
      // 如果在提交上下文中且根节点正在提交突变或布局效果
      if (
        (executionContext & CommitContext) !== NoContext &&
        root === rootCommittingMutationOrLayoutEffects
      ) {
        // 如果 Fiber 是分析模式
        if (fiber.mode & ProfileMode) {
          let current = fiber;
          // 遍历父级直到找到 Profiler 组件
          while (current !== null) {
            if (current.tag === Profiler) {
              // 获取 Profiler 的 ID 和嵌套更新调度回调
              const {id, onNestedUpdateScheduled} = current.memoizedProps;
              if (typeof onNestedUpdateScheduled === 'function') {
                // 调用嵌套更新调度回调
                onNestedUpdateScheduled(id);
              }
            }
            current = current.return;
          }
        }
      }
    }

    // 如果启用过渡跟踪
    if (enableTransitionTracing) {
      // 获取当前过渡
      const transition = ReactCurrentBatchConfig.transition;
      if (transition !== null) {
        // 如果过渡开始时间未设置，设置为当前时间
        if (transition.startTime === -1) {
          transition.startTime = now();
        }

        // 将过渡添加到车道映射
        addTransitionToLanesMap(root, transition, lane);
      }
    }

    // 如果根节点是正在进行的工作根节点
    // 页面初次渲染时候,此时workinProgressRoot还是null
    if (root === workInProgressRoot) {
      // 接收到正在渲染树的更新。标记此根节点上有交错更新。
      // 除非 `deferRenderPhaseUpdateToNextBatch` 标志关闭且这是渲染阶段更新。
      // 在这种情况下，出于向后兼容原因，我们不将渲染阶段更新视为交错更新。
      if (
        deferRenderPhaseUpdateToNextBatch ||
        (executionContext & RenderContext) === NoContext
      ) {
        // 合并交错更新的车道
        workInProgressRootInterleavedUpdatedLanes = mergeLanes(
          workInProgressRootInterleavedUpdatedLanes,
          lane,
        );
      }
      // 如果工作进程根节点退出状态是延迟暂停
      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
        // 根节点已延迟暂停，这意味着此渲染肯定不会完成。
        // 由于我们有新更新，让我们立即标记它为暂停，就在标记传入更新之前。
        // 这会产生中断当前渲染并切换到更新的效果。
        // TODO: 确保这不会覆盖我们已经开始渲染时发生的 ping。
        markRootSuspended(root, workInProgressRootRenderLanes);
      }
    }

    // 确保根节点被调度
    ensureRootIsScheduled(root, eventTime);
    
    // 如果是同步车道、没有执行上下文、不是并发模式且不是在 act 批处理中
    if (
      lane === SyncLane &&                           // 同步更新
      executionContext === NoContext &&              // 不在任何执行上下文中
      (fiber.mode & ConcurrentMode) === NoMode &&   // 不在并发模式下
      // 将 `act` 视为在 [batchedUpdates](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-dom/src/events/ReactDOMUpdateBatching.js#L46-L59) 内部，即使在传统模式下也是如此。
      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)
    ) {
      // 立即刷新同步工作，除非我们已经在工作或在批处理中。
      // 这有意在 scheduleUpdateOnFiber 中而不是在 scheduleCallbackForFiber 中，
      // 以保留调度回调而不立即刷新它的能力。
      // 我们只为用户发起的更新执行此操作，以保留传统模式的历史行为。
      resetRenderTimer();
      flushSyncCallbacksOnlyInLegacyMode();  // 仅在传统模式下刷新同步回调
    }
  }
}
```


