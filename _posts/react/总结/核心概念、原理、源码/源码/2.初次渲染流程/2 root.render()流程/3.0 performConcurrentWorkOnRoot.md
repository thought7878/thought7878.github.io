被调用：`ensureRootIsScheduled`
定义：`packages/react-reconciler/src/ReactFiberWorkLoop.new.js


这是React协调器中一个非常重要的函数，负责并发工作循环的执行。

让我为您详细解释 [performConcurrentWorkOnRoot](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L850-L989) 函数，这是React并发渲染系统的核心入口函数之一。
这个函数是**所有并发任务的入口点，任何通过Scheduler调度的任务都会经过这里**。

该函数的**主要职责包括：**
1. **清理状态**：重置事件时间和过渡通道
2. **验证执行上下文**：确保没有其他渲染或提交正在进行
3. **处理副作用**：在开始工作前先处理任何待处理的被动effect
4. **确定工作优先级**：获取下一个需要处理的lane(s)
5. **选择渲染策略**：根据情况决定使用时间切片(concurrent)还是同步渲染
6. **错误处理**：如果渲染出错，尝试恢复
7. **一致性检查**：验证渲染结果与外部store的一致性
8. **完成渲染**：将完成的工作赋值给root并执行提交
9. **安排后续工作**：确保后续任务被正确调度

这个函数是React并发渲染模型的关键组成部分，它允许React中断渲染过程以响应更高优先级的任务（如用户输入），然后在稍后恢复渲染，从而提高应用程序的响应性。


```javascript
// This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.
function performConcurrentWorkOnRoot(root, didTimeout) {
  // 重置调试相关标记（如果启用了相关功能）
  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {
    resetNestedUpdateFlag();
  }

  // 由于我们知道现在在React事件中，可以清空当前事件时间
  // 下次更新将计算一个新的事件时间
  currentEventTime = NoTimestamp;
  currentEventTransitionLane = NoLanes;

  // 确保当前不在渲染或提交上下文中
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error('Should not already be working.');
  }

  // 存储当前调度的任务引用
  const originalCallbackNode = root.callbackNode;
  // 在决定处理哪些lane之前，先刷新任何待处理的被动effect，
  // 因为它们可能会调度额外的工作
  const didFlushPassiveEffects = flushPassiveEffects();
  if (didFlushPassiveEffects) {
    // 被动effect阶段的某些内容可能取消了当前任务
    // 检查此root的任务节点是否已更改
    if (root.callbackNode !== originalCallbackNode) {
      // 当前任务已被取消。退出。
      // 我们不需要调用ensureRootIsScheduled，因为上面的检查意味着
      // 要么有新任务，要么在此root上没有剩余工作
      return null;
    } else {
      // 当前任务未被取消。继续。
    }
  }

  // 确定接下来要处理（本轮更新）的lanes，使用存储在root上的字段
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  if (lanes === NoLanes) {
    // 防御性编码。这种情况永远不应该发生
    return null;
  }

  // 在某些情况下我们禁用时间切片：
  // 如果工作CPU绑定时间过长（"过期"工作，为防止饥饿）
  // 或我们在同步更新默认模式下
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);
    
  // ！！！根据是否需要时间切片选择不同的渲染方式
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)  // 并发渲染
    : renderRootSync(root, lanes);       // 同步渲染，初次渲染走这里

  // 如果渲染未完成，处理各种情况
  if (exitStatus !== RootInProgress) {
    if (exitStatus === RootErrored) {
      // 如果出现错误，尝试再次渲染一次
      // 我们将同步渲染以阻止并发数据突变
      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
      if (errorRetryLanes !== NoLanes) {
        lanes = errorRetryLanes;
        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
      }
    }
    if (exitStatus === RootFatalErrored) {
      // 发生致命错误，抛出异常
      const fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    }

    if (exitStatus === RootDidNotComplete) {
      // 渲染被解卷但未完成树。这在特殊情况下发生，
      // 需要在不生成一致树或提交的情况下退出当前渲染
      markRootSuspended(root, lanes);
    } else {
      // ！！！渲染完成
      
      // 检查此渲染是否可能屈服于并发事件，如果是，
      // 确认任何新渲染的store是否与外部store一致
      const renderWasConcurrent = !includesBlockingLane(root, lanes);
      const finishedWork: Fiber = (root.current.alternate: any);
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(finishedWork)
      ) {
        // 在交错事件中改变了store。再次渲染，
        // 同步，以阻止进一步的突变
        exitStatus = renderRootSync(root, lanes);

        // 我们需要再次检查是否出现错误
        if (exitStatus === RootErrored) {
          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
          }
        }
        if (exitStatus === RootFatalErrored) {
          const fatalError = workInProgressRootFatalError;
          prepareFreshStack(root, NoLanes);
          markRootSuspended(root, lanes);
          ensureRootIsScheduled(root, now());
          throw fatalError;
        }
      }

      // ！！！现在我们有一棵一致的树。下一步是提交它，
      // 或者，如果某些内容被挂起，则等待超时后提交
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      finishConcurrentRender(root, exitStatus, lanes);
    }
  }

  // 确保根节点被安排下次更新
  ensureRootIsScheduled(root, now());
  
  // 如果为这个root安排的任务节点与当前执行的相同，
  // 需要返回一个continuation
  if (root.callbackNode === originalCallbackNode) {
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
```


---

这段代码是 React 并发工作循环的核心函数 [performConcurrentWorkOnRoot](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L850-L967)，它是所有并发任务的入口点。让我详细解释：

```javascript
// This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.
function performConcurrentWorkOnRoot(root, didTimeout) {
  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {
    resetNestedUpdateFlag();
  }

  // Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime = NoTimestamp;
  currentEventTransitionLane = NoLanes;

  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error('Should not already be working.');
  }
```

首先，重置嵌套更新标志，清除当前事件时间（因为已知我们在 React 事件中），并检查执行上下文以确保没有正在进行的渲染或提交工作。

```javascript
  // Flush any pending passive effects before deciding which lanes to work on,
  // in case they schedule additional work.
  const originalCallbackNode = root.callbackNode;
  const didFlushPassiveEffects = flushPassiveEffects();
  if (didFlushPassiveEffects) {
    // Something in the passive effect phase may have canceled the current task.
    // Check if the task node for this root was changed.
    if (root.callbackNode !== originalCallbackNode) {
      // The current task was canceled. Exit. We don't need to call
      // `ensureRootIsScheduled` because the check above implies either that
      // there's a new task, or that there's no remaining work on this root.
      return null;
    } else {
      // Current task was not canceled. Continue.
    }
  }
```

在决定处理哪些 lanes 之前，先清空任何待处理的被动效果（passive effects），因为它们可能会调度额外的工作。如果被动效果阶段取消了当前任务（改变了回调节点），则直接退出。

```javascript
  // Determine the next lanes to work on, using the fields stored
  // on the root.
  let lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  if (lanes === NoLanes) {
    // Defensive coding. This is never expected to happen.
    return null;
  }
```

确定接下来要处理的 lanes。如果没有任何 lanes 需要处理，则防御性地返回 null。

```javascript
  // We disable time-slicing in some cases: if the work has been CPU-bound
  // for too long ("expired" work, to prevent starvation), or we're in
  // sync-updates-by-default mode.
  // TODO: We only check `didTimeout` defensively, to account for a Scheduler
  // bug we're still investigating. Once the bug in Scheduler is fixed,
  // we can remove this, since we track expiration ourselves.
  const shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    (disableSchedulerTimeoutInWorkLoop || !didTimeout);
  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);
```

决定是否应该进行时间切片（time-slicing）。在某些情况下会禁用时间切片：如果工作已经 CPU 密集太长时间（过期的工作，防止饥饿），或者我们处于默认同步更新模式。根据是否需要时间切片，选择并发渲染或同步渲染。

```javascript
  if (exitStatus !== RootInProgress) {
    if (exitStatus === RootErrored) {
      // If something threw an error, try rendering one more time. We'll
      // render synchronously to block concurrent data mutations, and we'll
      // includes all pending updates are included. If it still fails after
      // the second attempt, we'll give up and commit the resulting tree.
      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
      if (errorRetryLanes !== NoLanes) {
        lanes = errorRetryLanes;
        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
      }
    }
    if (exitStatus === RootFatalErrored) {
      const fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    }

    if (exitStatus === RootDidNotComplete) {
      // The render unwound without completing the tree. This happens in special
      // cases where need to exit the current render without producing a
      // consistent tree or committing.
      //
      // This should only happen during a concurrent render, not a discrete or
      // synchronous update. We should have already checked for this when we
      // unwound the stack.
      markRootSuspended(root, lanes);
    } else {
      // The render completed.

      // Check if this render may have yielded to a concurrent event, and if so,
      // confirm that any newly rendered stores are consistent.
      // TODO: It's possible that even a concurrent render may never have yielded
      // to the main thread, if it was fast enough, or if it expired. We could
      // skip the consistency check in that case, too.
      const renderWasConcurrent = !includesBlockingLane(root, lanes);
      const finishedWork: Fiber = (root.current.alternate: any);
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(finishedWork)
      ) {
        // A store was mutated in an interleaved event. Render again,
        // synchronously, to block further mutations.
        exitStatus = renderRootSync(root, lanes);

        // We need to check again if something threw
        if (exitStatus === RootErrored) {
          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root, errorRetryLanes);
            // We assume the tree is now consistent because we didn't yield to any
            // concurrent events.
          }
        }
        if (exitStatus === RootFatalErrored) {
          const fatalError = workInProgressRootFatalError;
          prepareFreshStack(root, NoLanes);
          markRootSuspended(root, lanes);
          ensureRootIsScheduled(root, now());
          throw fatalError;
        }
      }

      // We now have a consistent tree. The next step is either to commit it,
      // or, if something suspended, wait to commit it after a timeout.
      root.finishedWork = finishedWork;
      root.finishedLanes = lanes;
      finishConcurrentRender(root, exitStatus, lanes);
    }
  }
```

根据渲染的退出状态进行相应处理：
- 如果出现错误（[RootErrored](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L66-L72)），尝试再次同步渲染以恢复
- 如果出现致命错误（[RootFatalErrored](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L67-L67)），抛出错误
- 如果渲染未完成（[RootDidNotComplete](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L70-L70)），标记为暂停
- 否则，表示渲染完成，进行一致性检查，然后准备提交

```javascript
  ensureRootIsScheduled(root, now());
  if (root.callbackNode === originalCallbackNode) {
    // The task node scheduled for this root is the same one that's
    // currently executed. Need to return a continuation.
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  return null;
}
```

最后，调用 [ensureRootIsScheduled](file:///Users/ll/Desktop/%E8%B5%84%E6%96%99/%E7%BC%96%E7%A8%8B/%E4%BB%93%E5%BA%93/react/react-18.2.0/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L708-L795) 确保根节点被正确调度。如果回调节点没有改变，说明需要继续工作，返回一个绑定的函数作为延续；否则返回 null 表示任务完成。

这个函数是 React 并发渲染机制的核心，处理了渲染过程中的各种情况，包括错误恢复、外部状态一致性检查和任务调度等。