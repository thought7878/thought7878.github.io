# React 18创建根节点与初始化详细流程

在React 18中，创建根节点与初始化是整个渲染流程的起点。以下是对这一阶段的深度解析，包括关键函数调用流程和功能说明：

## 1. 应用入口：createRoot API

```javascript
import { createRoot } from 'react-dom/client';

// 创建根节点
const root = createRoot(container); 
// 触发渲染
root.render(<App />);
```

## 2. 函数调用流程详解

### (1) createRoot 函数
**源码位置**：`react-dom/src/client/ReactDOM.js`
```javascript
export function createRoot(
  container: Element | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  // 验证容器元素
  warnIfReactDOMContainerInDEV(container);
  // 创建根节点的内部实现
  return createRootImpl(container, options);
}
```
**功能**：
- 验证容器元素是否合法
- 调用内部实现函数`createRootImpl`
- 支持Strict Mode等选项配置
- 返回包含render、unmount方法的根对象

### (2) createRootImpl 函数
**源码位置**：`react-dom/src/client/ReactDOMRoot.js`
```javascript
function createRootImpl(
  container: Container,
  options: void | RootOptions,
) {
  // 1. 创建新Fiber根节点
  const root = createContainer(container, ConcurrentRoot, null, false, null);
  
  // 2. 标记容器为React根节点
  markContainerAsRoot(root.current, container);
  
  // 3. 处理hydrate特殊情况
  if (options != null && options.hydrate) {
    // 服务端渲染相关处理
  }
  
  return root;
}
```
**功能**：
- 创建Fiber树的根节点
- 标记DOM容器
- 处理水合(hydration)特殊情况
- 返回FiberRoot对象

### (3) createContainer 函数
**源码位置**：`react-reconciler/src/ReactFiberReconciler.js`
```javascript
export function createContainer(
  containerInfo: Container,
  tag: RootTag, // ConcurrentRoot
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
): OpaqueRoot {
  return createFiberRoot(
    containerInfo,
    tag,
    hydrationCallbacks,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
  );
}
```
**功能**：
- 封装`createFiberRoot`的调用
- 传递根标签(ConcurrentRoot)标识并发模式
- 处理严格模式配置

### (4) createFiberRoot 函数
**源码位置**：`react-reconciler/src/ReactFiberRoot.js`
```javascript
export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
  isStrictMode: boolean,
  concurrentUpdatesByDefaultOverride: null | boolean,
): FiberRoot {
  // 1. 创建FiberRootNode实例
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate));
  
  // 2. 创建根Fiber节点
  const uninitializedFiber = createHostRootFiber(
    tag,
    isStrictMode,
  );
  
  // 3. 建立双向引用
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  
  // 4. 初始化根节点的更新队列
  initializeUpdateQueue(uninitializedFiber);
  
  return root;
}
```
**功能**：
- 创建FiberRootNode对象，存储整个应用的元数据
- 创建根Fiber节点(host root fiber)
- 建立FiberRootNode与根Fiber的双向引用
- 初始化更新队列
- 配置并发模式相关参数

### (5) FiberRootNode 构造函数
**源码位置**：`react-reconciler/src/ReactFiberRoot.js`
```javascript
function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag; // 标识是ConcurrentRoot
  this.containerInfo = containerInfo; // DOM容器
  this.pendingChildren = null;
  this.current = null; // 指向当前Fiber树
  this.pingCache = null;
  this.finishedWork = null; // 已完成的workInProgress树
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.callbackNode = null; // 用于调度的回调节点
  this.callbackPriority = NoLane; // 优先级
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);
  
  // 调度相关
  this.pendingLanes = NoLanes; // 待处理的更新车道
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;
  
  // 调度器回调
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);
  
  // 水合相关信息
  this.identifierPrefix = '';
  this.onRecoverableError = defaultOnRecoverableError;
  this.formState = null;
}
```
**功能**：
- 初始化Fiber树的根节点数据结构
- 配置调度系统所需的车道(lane)模型
- 建立更新优先级管理机制
- 存储渲染状态和上下文信息
- 设置错误处理回调

### (6) createHostRootFiber 函数
**源码位置**：`react-reconciler/src/ReactFiber.js`
```javascript
export function createHostRootFiber(
  tag: RootTag, // ConcurrentRoot
  isStrictMode: boolean,
): Fiber {
  // 1. 创建Fiber对象
  const fiber = createFiber(HostRoot, null, null, DefaultMode);
  
  // 2. 应用并发模式特性
  fiber.mode = ConcurrentMode | StrictLegacyMode | (enableStrictEffects ? StrictEffectsMode : NoMode);
  
  return fiber;
}
```
**功能**：
- 创建类型为HostRoot的根Fiber节点
- 设置模式标志(mode flags)启用并发特性
- 配置严格模式相关行为
- 初始化Fiber节点的基本结构

### (7) Fiber对象结构
根Fiber节点初始状态：
```javascript
{
  tag: HostRoot, // 根节点类型
  key: null,
  elementType: null,
  type: null,
  stateNode: FiberRootNode, // 指向FiberRoot
  
  return: null, // 父节点
  child: null, // 第一个子节点
  sibling: null, // 下一个兄弟节点
  
  pendingProps: null, // 新props
  memoizedProps: null, // 旧props
  memoizedState: null, // 状态
  
  alternate: null, // 指向workInProgress或current树
  
  // 优先级相关
  lanes: NoLanes,
  childLanes: NoLanes,
  
  // 副作用相关
  flags: 0,
  subtreeFlags: 0,
  deletions: null,
  
  // 更新队列
  updateQueue: {
    baseState: null,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
    },
    effects: null,
  },
} 
```

## 3. root.render()流程

### (1) render 方法
**源码位置**：`react-dom/src/client/ReactDOMRoot.js`
```javascript
render(children: ReactNodeList): void {
  const root = this._internalRoot;
  if (root === null) {
    throw new Error('Cannot update an unmounted root.');
  }

  updateContainer(children, root, null, () => {
    // 回调
  });
}
```
**功能**：
- 获取内部FiberRoot引用
- 调用updateContainer函数启动渲染
- 处理unmounted状态异常

### (2) updateContainer 函数
**源码位置**：`react-reconciler/src/ReactFiberReconciler.js`
```javascript
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): Lane {
  const current = container.current;
  
  // 1. 获取事件时间戳
  const eventTime = requestEventTime();
  
  // 2. 获取更新车道(优先级)
  const lane = requestUpdateLane(current);
  
  // 3. 创建Update对象
  const update = createUpdate(eventTime, lane);
  update.payload = { element };
  
  // 4. 回调处理
  if (callback !== undefined && callback !== null) {
    update.callback = callback;
  }
  
  // 5. 将更新放入队列
  enqueueUpdate(current, update, lane);
  
  // 6. 调度更新
  const root = scheduleUpdateOnFiber(current, lane, eventTime);
  
  // 7. 返回使用的优先级
  return lane;
}
```
**功能**：
- 创建更新对象并设置渲染内容(payload)
- 确定更新优先级
- 将更新放入Fiber节点的更新队列
- 启动调度流程
- 处理渲染完成回调

### (3) scheduleUpdateOnFiber 函数
**源码位置**：`react-reconciler/src/ReactFiberWorkLoop.js`
```javascript
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
  // 1. 检查嵌套更新深度
  checkForNestedUpdates();
  
  // 2. 将更新标记到根节点
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  
  // 3. 确保根节点被调度
  ensureRootIsScheduled(root, eventTime);
  
  // 4. 并发模式下自动批处理
  if (
    lane === SyncLane ||
    lane === InputContinuousHydrationLane ||
    lane === SelectHydrationLane
  ) {
    // 立即执行同步更新
    if (root === rootWithPendingPassiveEffects) {
      performSyncWorkOnRoot(root);
    }
  }
  
  return root;
}
```
**功能**：
- 将更新从当前Fiber向上标记至根节点
- 确保根节点进入调度队列
- 处理同步更新的特殊情况
- 启用自动批处理机制

## 4. 关键数据结构关系

```
FiberRootNode (root._internalRoot)
      │
      └─── current (指向Fiber树)
              │
              └─── stateNode (指回FiberRootNode)
              │
              └─── updateQueue (存储更新)
              │
              └─── child (App组件Fiber)
```

这个初始化过程建立了React 18并发渲染的基础架构，通过FiberRootNode与根Fiber节点的双向引用，以及车道(lane)模型的优先级系统，为后续的协调(reconciliation)和提交(commit)阶段做好了充分准备。React 18特别优化了这一阶段，以支持自动批处理、并发渲染、Suspense等新特性。