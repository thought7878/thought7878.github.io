调用：`packages/react-reconciler/src/ReactFiberReconciler.new.js`的updateContainer()
实现：`packages/react-reconciler/src/ReactFiberClassUpdateQueue.new.js`



这段代码定义了 [enqueueUpdate](file:///Users/ll/Desktop/资料/编程/仓库/react/react-18.2.0/packages/react-reconciler/src/ReactFiberConcurrentUpdates.new.js#L88-L111) 函数，用于**将更新添加到 Fiber 节点的更新队列中**。让我详细解释：

```javascript
// 将更新对象添加到 Fiber 节点的更新队列中的函数
// fiber: 要更新的 Fiber 节点
// update: 要添加的更新对象
// lane: 更新的优先级车道
export function enqueueUpdate<State>(
  fiber: Fiber,
  update: Update<State>,
  lane: Lane,
): FiberRoot | null {
  // 获取 Fiber 节点的更新队列
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    // 如果更新队列不存在，说明该 fiber 已经被卸载
    return null;
  }

  // 获取共享队列部分，这是可以跨 Fiber 实例共享的部分
  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;

  if (__DEV__) {
    // 在开发环境中，检测是否在更新函数内部调度了更新
    if (
      currentlyProcessingQueue === sharedQueue &&  // 检查是否在处理相同的队列
      !didWarnUpdateInsideUpdate  // 检查是否已经警告过
    ) {
      // 发出警告：从更新函数内部调度了更新，更新函数应该是纯函数，不应该有副作用
      console.error(
        'An update (setState, replaceState, or forceUpdate) was scheduled ' +
          'from inside an update function. Update functions should be pure, ' +
          'with zero side-effects. Consider using componentDidUpdate or a ' +
          'callback.',
      );
      // 标记已警告，避免重复警告
      didWarnUpdateInsideUpdate = true;
    }
  }

  // 类组件的旧的生命周期相关的update，这里不再展开详解
  // 检查是否是不安全的渲染阶段更新（在类组件中）
  if (isUnsafeClassRenderPhaseUpdate(fiber)) {
    // 这是一个不安全的渲染阶段更新。直接添加到更新队列，
    // 以便我们可以在当前渲染期间立即处理它
    
    // 获取当前等待处理的更新
    const pending = sharedQueue.pending;
    if (pending === null) {
      // 如果没有等待处理的更新，这是第一个更新，创建一个循环链表
      update.next = update;  // 将更新的 next 指向自己，形成循环
    } else {
      // 如果已有等待处理的更新，将新更新插入到链表中
      update.next = pending.next;  // 新更新的 next 指向原来第一个更新
      pending.next = update;       // 原来的最后一个更新指向新更新
    }
    // 将新更新设为等待处理的更新（最新的更新）
    sharedQueue.pending = update;

    // 即使我们很可能已经在渲染这个 fiber，也要更新 childLanes
    // 这是为了向后兼容，以防你在渲染阶段更新了与当前渲染组件
    // 不同的组件（这种模式会伴随一个警告）
    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
  } else {
    // 对于非渲染阶段的更新，使用并发更新队列
    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
  }
}
```

这个函数*处理了两种不同类型的更新：*
1. **渲染阶段更新**：如果在渲染阶段发生更新，需要立即处理，因为它可能影响当前渲染的结果。这种更新会直接添加到共享队列的循环链表中。
2. **常规更新**：对于不在渲染阶段的更新，会使用并发更新机制（`enqueueConcurrentClassUpdate`），*这样可以支持优先级调度和并发处理*。

函数还包含了一些重要的功能：
- 检测并警告不安全的更新模式（在更新函数内部再次发起更新）
- 处理循环链表结构以维护更新的顺序
- 返回根节点以进行进一步的调度处理
