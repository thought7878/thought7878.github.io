# Why
- **性能优化**
    - **避免重复计算**：在函数组件中，如果一个计算过程比较复杂或者计算量较大，每次组件重新渲染都进行这个计算会导致性能下降。例如，在一个数据可视化组件中，需要对大量的数据进行复杂的转换和计算来生成图表数据。如果没有`useMemo`，每次组件因为任何状态的变化而重新渲染时，这个复杂的计算都会重新执行。使用`useMemo`可以缓存这个计算结果，只有当依赖的数据发生变化时，才会重新计算，从而避免了不必要的重复计算，提高了组件的性能。
    - **减少渲染开销**：当计算结果用于决定组件是否需要重新渲染（如作为`React.memo`的依赖项或者用于判断组件的某些属性是否改变）时，`useMemo`可以确保只有在计算结果真正改变时才触发重新渲染。例如，在一个列表组件中，需要根据数据的某个属性来计算一个用于样式控制的值，这个计算可能涉及到一些复杂的逻辑。通过`useMemo`缓存这个样式控制值，只有当计算所依赖的数据改变时，样式控制值才会改变，从而避免了因为样式控制值的不必要变化而导致组件重新渲染。
- **保持引用稳定**
    - **用于依赖比较和副作用控制**：在 React 中，某些功能（如`useEffect`的依赖项检查、`React.memo`的属性比较）依赖于值的引用是否相等。如果一个复杂的对象或者函数在每次组件渲染时都重新创建，其引用会发生变化，这可能会导致一些副作用函数（如`useEffect`中的函数）被不必要地重新执行，或者`React.memo`无法正确地避免组件重新渲染。`useMemo`可以用于缓存这些对象或函数，保持它们的引用稳定，使得相关的依赖检查和渲染控制机制能够正确地工作。例如，在一个自定义 Hook 中，返回一个包含复杂计算结果和一个用于更新状态的函数的对象，通过`useMemo`缓存这个对象，可以确保在计算结果未改变时，对象的引用不变，从而避免了使用这个 Hook 的组件因为对象引用变化而重新渲染。

# What

`useMemo`是 React 提供的一个 Hook，用于缓存计算结果。它会返回一个记忆化（memorized）的值，只有当它的依赖项发生变化时，*才会重新计算这个值*。

# How

**基本语法**：
```jsx
const memoizedValue = useMemo(() => { 
// 计算逻辑 
}, [dependency1, dependency2,...]);
```

- 第一个参数是一个函数，*这个函数包含了要进行的计算逻辑*，**它会返回需要缓存的计算结果**。
- 第二个参数是一个依赖项数组，只有当依赖项数组中的任何一个元素发生变化时，`useMemo`才会重新执行第一个参数中的计算函数，重新计算并返回新的结果。

**示例**：

```jsx
import React, { useState, useMemo } from'react';
function ExpensiveCalculationComponent() {
  const [count, setCount] = useState(0);
  // 
  const expensiveValue = useMemo(() => {
    console.log('执行昂贵的计算');
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += i;
    }
    // 被缓存的结果
    return result;
  }, [count]);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>昂贵计算结果: {expensiveValue}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**示例说明**：

在这个`ExpensiveCalculationComponent`中，`useMemo`用于缓存一个昂贵的计算结果。*计算逻辑*是一个循环求和的过程，在实际应用中可能代表更复杂的计算，如*数据转换、算法执行*等。*依赖项*是`count`，这意味着*只有当`count`状态发生变化时，才会重新执行这个昂贵的计算*。当组件首次渲染时，会执行计算并打印日志`执行昂贵的计算`，之后如果`count`没有改变，即使组件因为其他原因重新渲染，也不会重新执行这个计算，*而是直接使用缓存的结果，从而提高了性能*。