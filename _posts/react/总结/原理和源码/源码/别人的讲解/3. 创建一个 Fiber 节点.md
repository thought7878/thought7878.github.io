## 创建 Fiber 节点：根据已有 ReactElement

```js
/**
 * 根据 React 元素创建对应的 Fiber 节点。
 *
 * @param {Object} element - 一个 React 元素对象，包含 type、props 和 key 等属性。
 * @returns {FiberNode} - 返回一个新创建的 Fiber 节点，该节点与传入的 React 元素相对应。
 */
export function createFiberFromElement(element) {
  // 初始化 Fiber 节点的标签，用于标识节点的类型
  let tag = null;
  // 从 React 元素中解构出 type、props 和 key 属性
  const { type, props, key } = element;

  // 根据元素类型设置 Fiber 节点的 tag
  if (typeof type === "string") {
    // 如果元素类型是字符串，说明是一个宿主组件（如 <div>、<span> 等 HTML 标签）
    tag = HostComponent;
  } else if (typeof type === "function") {
    // 如果元素类型是函数，需要进一步判断是类组件还是函数组件
    if (type.isReactComponent) {
      // 如果函数有 isReactComponent 属性，说明是类组件
      tag = ClassComponent;
    } else {
      // 否则，认为是函数组件
      tag = FunctionComponent;
    }
  }

  // 使用 createFiber 函数创建一个新的 Fiber 节点
  const fiberNode = createFiber(tag, props, key);
  // 将 React 元素的类型赋值给 Fiber 节点的 type 属性
  fiberNode.type = element.type;
  // 返回创建好的 Fiber 节点
  return fiberNode;
}
```

## 创建 Fiber 节点：根据已有 Fiber 节点

[03:30]

`stateNode`属性：当前 Fiber 节点对应的真实 DOM 节点。

**_React 每次更新时_，都会调用这个 createWorkInProgress 函数，根据老的 Fiber 节点，创建工作节点（新的节点）、复用老节点**

**根据已有 Fiber 节点，创建新的 Fiber 节点，应用场景**：_首次渲染后的第一次更新_，此时内存中只有一棵 Fiber 树。current Fiber 节点还没有 alternate 属性，就根据 current Fiber 节点创建一个新的副本 Fiber 节点。
_第二次及以后更新_，渲染时，*复用*已有的 workInProgress Fiber 节点，更新其 pendingProps

```js
/**
 * React每次更新时，都会调用这个函数，根据老的Fiber节点，创建工作节点
 *
 * 创建一个用于工作的 Fiber 节点（workInProgress Fiber）。
 * workInProgress Fiber 是当前正在构建的新 Fiber 树中的节点，与当前渲染的 Fiber 树（current Fiber 树）相对应。
 * @param {FiberNode} current - 当前渲染的 Fiber 树中的对应节点（老节点）。
 * @param {Object} pendingProps - 新的待处理属性。
 * @returns {FiberNode} - 返回用于工作的新的 Fiber 节点。
 */
export function createWorkInProgress(current, pendingProps) {
  // 尝试从 current Fiber 节点的 alternate 属性获取 workInProgress Fiber 节点
  let workInProgress = current.alternate;

  // 如果 alternate 不存在，说明还没有创建 workInProgress Fiber 节点
  // 首次渲染
  if (workInProgress === null) {
    // 使用 createFiber 函数创建一个新的 Fiber 节点，继承 current 节点的 tag、key 和新的 pendingProps
    workInProgress = createFiber(current.tag, pendingProps, current.key);
    // 将 current 节点的 stateNode 赋值给 workInProgress 节点，stateNode 通常存储 DOM 节点或组件实例
    workInProgress.stateNode = current.stateNode;
    // 建立 workInProgress 节点和 current 节点的双向关联
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 如果 alternate 存在，说明已经有 workInProgress Fiber 节点，复用它，更新其 pendingProps
    // 场景：第二次及以后更新，渲染时，复用已有的 workInProgress Fiber 节点，更新其 pendingProps
    workInProgress.pendingProps = pendingProps;
  }

  // 同步 current 节点的 type 到 workInProgress 节点，type 表示节点对应的组件类型或 DOM 标签名
  workInProgress.type = current.type;
  // 同步 current 节点的 child 到 workInProgress 节点，child 指向第一个子 Fiber 节点
  workInProgress.child = current.child;
  // 同步 current 节点的更新队列到 workInProgress 节点
  workInProgress.updateQueue = current.updateQueue;

  // 同步 current 节点的 lanes 和 childLanes 到 workInProgress 节点
  // lanes 用于表示任务的优先级
  workInProgress.lanes = current.lanes;
  workInProgress.childLanes = current.childLanes;

  // 返回创建好的 workInProgress Fiber 节点
  return workInProgress;
}
```

## 相关资料

- [创建一个 Fiber 节点](https://www.bilibili.com/video/BV1C9gDeNEzF/?share_source=copy_web&vd_source=9c1e19a73fa7bd23bb37aa8d7467d862)
