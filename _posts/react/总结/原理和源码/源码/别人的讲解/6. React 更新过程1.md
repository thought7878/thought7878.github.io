setState 背后的原理

## 
[00:00]

setState 的两大特性：
- 批量更新：调用setState后不是立即更新，而是选择一个比较恰当的时机，批量处理变更
- 局部更新：只更新改变了的相应的组件，而不是整个页面

## 批量更新
[01:07]

两个阶段
### 收集阶段
收集阶段：收集所有的变更。每次调用setState，都会将变更存储起来，而不是立即执行渲染。通过调度器，合并同一批次中的相同优先级的变更，最终执行一次渲染。

### 触发阶段
触发阶段：触发更新。

什么时候触发？
- 手动触发。forceUpdate()，使用少。
- setState 触发。setState的使用场景是在回调函数中（事件函数、生命周期函数）。React内部，在回调完这些函数后，检测是否需要更新，从而触发一次更新


## 局部更新
[02:23]
只更新改变了的相应的组件，而不是整个页面。

React 15的实现：每次调用setState的时候，react可以知道具体调用了哪个组件的setState，因此重新render这个组件（调用对象的render方法）。

React 16的实现：实现了 fiber 架构、双缓存树。每次更新，会在内存中生成新的fiber树。
React 是怎么知道fiber树上的哪个节点需要更新？标记一下。调用setState的时候，在当前的节点上标记一下，并且把这个标记一层一层传递到顶部的根节点。生成新的fiber树的时候，就可以根据根节点的标记，找到需要重新生成的fiber节点；其他的节点可以复用

## 代码实现
[03:47] 









