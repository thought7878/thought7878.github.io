---
title: "How to Learn Software Design and Architecture | The  Full-stack Software Design & Architecture Map | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/"
author:
  - "[[Khalil Stemmler]]"
published: 2019-09-28
created: 2025-10-10
description: "Software Design and Architecture is pretty much its own field of study within the realm of computing, like DevOps or UX Design. Here's a map describing the breadth of software design and architecture, from clean code to microkernels."
tags:
  - "clippings"
---
# notebooklmæ€»ç»“
è¯¥æ–‡ç« æä¾›äº†ä¸€ä»½å…³äº**å­¦ä¹ è½¯ä»¶è®¾è®¡ä¸æ¶æ„çš„è·¯çº¿å›¾**ï¼ˆâ€œThe Full-stack Software Design & Architecture Mapâ€ï¼‰ï¼Œè¯¥é¢†åŸŸè¢«è§†ä¸ºè®¡ç®—æœºé¢†åŸŸå†…ä¸€ä¸ªç‹¬ç«‹çš„å­¦ä¹ åˆ†æ”¯ï¼Œç±»ä¼¼äºDevOpsæˆ–UXè®¾è®¡ã€‚æ–‡ç« æ—¨åœ¨*å¸®åŠ©å¼€å‘è€…ï¼Œå°¤å…¶æ˜¯åˆçº§æˆ–è‡ªå­¦å¼€å‘è€…ï¼Œå…‹æœå­¦ä¹ å¦‚ä½•è®¾è®¡å¹²å‡€ä¸”å¯æ‰©å±•çš„ç³»ç»Ÿ*æ‰€é¢ä¸´çš„å·¨å¤§æŒ‘æˆ˜ã€‚

### è½¯ä»¶è®¾è®¡ä¸æ¶æ„çš„æ ¹æœ¬ç›®æ ‡

æ–‡ç« é¦–å…ˆåº”ç”¨**ç¬¬ä¸€æ€§åŸç†**æ¥è§£æ„é—®é¢˜ï¼Œç¡®å®š*è½¯ä»¶çš„é¦–è¦ç›®æ ‡ï¼š*

- `æ ¸å¿ƒç›®æ ‡`ï¼š è½¯ä»¶çš„ç›®æ ‡æ˜¯**æŒç»­åœ°ç”Ÿäº§å‡ºæ»¡è¶³ç”¨æˆ·éœ€æ±‚çš„äº§å“**ï¼Œ*åŒæ—¶å°†å®ç°è¿™ä¸€ç›®æ ‡æ‰€éœ€çš„åŠªåŠ›é™è‡³æœ€ä½*ã€‚
- `è®¾è®¡çš„é‡è¦æ€§`ï¼š ç”±äºç”¨æˆ·*éœ€æ±‚ç»å¸¸å˜åŒ–*ï¼Œè½¯ä»¶å¿…é¡»è¢«**è®¾è®¡æˆæ˜“äºæ›´æ”¹ï¼ˆå¯æ‰©å±•æ€§ï¼‰**ã€‚*å¦‚æœè½¯ä»¶éš¾ä»¥æ›´æ”¹*ï¼Œå®ƒå°±è¢«è®¤ä¸ºæ˜¯ç³Ÿç³•çš„è½¯ä»¶ï¼Œ*å› ä¸ºå®ƒé˜»ç¢äº†æˆ‘ä»¬æ»¡è¶³ç”¨æˆ·çš„å½“å‰éœ€æ±‚*ã€‚


### è½¯ä»¶è®¾è®¡ä¸æ¶æ„çš„ä¹ä¸ªé˜¶æ®µ
æ–‡ç« å°†è½¯ä»¶è®¾è®¡å’Œæ¶æ„çš„å­¦ä¹ è¿‡ç¨‹**åˆ†è§£ä¸ºä¹ä¸ªé˜¶æ®µ**ï¼ˆæˆ–ç§°ä¹‹ä¸º **â€œå †æ ˆâ€**ï¼‰ï¼Œ*æ¯ä¸ªé˜¶æ®µéƒ½å»ºç«‹åœ¨å‰ä¸€ä¸ªé˜¶æ®µçš„åŸºç¡€ä¹‹ä¸Š*ã€‚

#### Stage 1: Clean Code (å¹²å‡€ä»£ç )

è¿™æ˜¯åˆ›å»ºæŒä¹…è½¯ä»¶çš„ç¬¬ä¸€æ­¥ã€‚`å¹²å‡€ä»£ç `é€šå¸¸è¢«å®šä¹‰ä¸º**æ˜“äºç†è§£å’Œæ›´æ”¹çš„ä»£ç **ã€‚

- **ä½çº§è¡¨ç°ï¼š** åŒ…æ‹¬*ä¿æŒä¸€è‡´æ€§*ã€åå¥½*ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡/æ–¹æ³•/ç±»å*è€Œéæ³¨é‡Šã€*æ­£ç¡®çš„ç¼©è¿›å’Œé—´è·ã€ç¡®ä¿æ‰€æœ‰æµ‹è¯•éƒ½èƒ½è¿è¡Œã€ç¼–å†™æ²¡æœ‰å‰¯ä½œç”¨çš„çº¯å‡½æ•°ã€ä¸ä¼ é€’null*ã€‚è¿™äº›`è§„èŒƒ`è¢«ç§°ä¸º`ç¼–ç çº¦å®š`ã€‚
- **æ ¸å¿ƒè¦ç´ ï¼š** *å¹²å‡€ä»£ç åŒ…æ‹¬ä¸‰ä¸ªæ–¹é¢*ï¼š`å¼€å‘è€…å¿ƒæ€`ï¼ˆä¾‹å¦‚åŒç†å¿ƒã€åŒ äººç²¾ç¥ã€è®¾è®¡æ€ç»´ï¼‰ã€`ç¼–ç çº¦å®š`ï¼ˆä¾‹å¦‚å‘½åã€é‡æ„ã€æµ‹è¯•ï¼‰ã€`æŠ€èƒ½ä¸çŸ¥è¯†`ï¼ˆä¾‹å¦‚æ¨¡å¼ã€åŸåˆ™ã€é¿å…ä»£ç å¼‚å‘³å’Œåæ¨¡å¼ï¼‰ã€‚
- **åŒç†å¿ƒï¼š** å¼€å‘è€…ä¸ä»…ä¸ºæœ€ç»ˆç”¨æˆ·å†™ä»£ç ï¼Œ*ä¹Ÿä¸ºè‡ªå·±ã€é˜Ÿå‹ã€é¡¹ç›®æœªæ¥çš„ç»´æŠ¤è€…ï¼Œå†™ä»£ç *ã€‚åŒç†å¿ƒæ˜¯æè¿°è¿™ä¸€é˜¶æ®µçš„æœ€ä½³è¯æ±‡ã€‚
- **å­¦ä¹ èµ„æºï¼š** Robert C. Martinçš„ã€ŠClean Codeã€‹è¢«è®¤ä¸ºæ˜¯å­¦ä¹ ç¼–å†™å¹²å‡€ä»£ç çš„æœ€ä½³èµ„æºã€‚

#### Stage 2: Programming Paradigms (ç¼–ç¨‹èŒƒå¼)

åœ¨ç¼–å†™å¯è¯»ä¸”æ˜“äºç»´æŠ¤çš„ä»£ç åï¼Œç†è§£*ä¸‰å¤§ä¸»è¦ç¼–ç¨‹èŒƒå¼*ï¼ˆç»“æ„åŒ–ã€é¢å‘å¯¹è±¡ã€å‡½æ•°å¼ï¼‰åŠ*å…¶å¯¹ä»£ç ç¼–å†™æ–¹å¼çš„å½±å“*éå¸¸é‡è¦ã€‚

- **èŒƒå¼åˆ†å·¥ï¼š** æ ¹æ®Robert C. Martinçš„è§‚ç‚¹ï¼Œæœ‰æ•ˆçš„è½¯ä»¶*ä¼šæ··åˆä½¿ç”¨è¿™ä¸‰ç§èŒƒå¼ï¼š*
    - **é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰ï¼š** æœ€é€‚åˆç”¨äºå®šä¹‰*å¦‚ä½•é€šè¿‡å¤šæ€æ€§å’Œæ’ä»¶è·¨è¶Šæ¶æ„è¾¹ç•Œ*ã€‚
    - **å‡½æ•°å¼ç¼–ç¨‹ï¼š** ç”¨äº*å°†æ•°æ®æ¨é€åˆ°åº”ç”¨ç¨‹åºçš„è¾¹ç•Œ*ã€‚
    - **ç»“æ„åŒ–ç¼–ç¨‹ï¼š** ç”¨äº*ç¼–å†™ç®—æ³•*ã€‚

#### Stage 3: Object-Oriented Programming (é¢å‘å¯¹è±¡ç¼–ç¨‹)

å¯¹äºæ¶æ„è€Œè¨€ï¼ŒOOPæ˜¯æ˜ç¡®çš„â€œå·¥å…·â€ã€‚

- **ä»·å€¼ï¼š** OOPä¸ä»…èƒ½å®ç°**æ’ä»¶æ¶æ„**å’Œæ„å»ºçµæ´»æ€§ï¼Œå…¶å››å¤§åŸåˆ™ï¼ˆå°è£…ã€ç»§æ‰¿ã€å¤šæ€æ€§ã€æŠ½è±¡ï¼‰è¿˜æœ‰åŠ©äºåˆ›å»º**ä¸°å¯Œçš„é¢†åŸŸæ¨¡å‹**ã€‚
- **ç›®æ ‡ï¼š** å­¦ä¹ å¦‚ä½•åˆ›å»ºé—®é¢˜é¢†åŸŸçš„è½¯ä»¶å®ç°ï¼Œå¹¶å°†å…¶ç½®äº**åˆ†å±‚**Webåº”ç”¨ç¨‹åºçš„ä¸­å¿ƒï¼Œè¿™é€šå¸¸éœ€è¦ç†Ÿæ‚‰æ¨¡å‹é©±åŠ¨è®¾è®¡å’Œ**é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰**ã€‚

#### Stage 4: Design Principles (è®¾è®¡åŸåˆ™)

`è®¾è®¡åŸåˆ™`æ˜¯*ç»è¿‡å®è·µæ£€éªŒã€å®Œå–„çš„é¢å‘å¯¹è±¡æœ€ä½³å®è·µ*ï¼Œå®ƒä»¬å……å½“äº†**æŒ‡å¯¼æ¡†æ¶**ï¼Œ*å¸®åŠ©è§£å†³OOPå¯èƒ½å¼•å…¥çš„è®¾è®¡æŒ‘æˆ˜*ï¼ˆä¾‹å¦‚ä½•æ—¶ä½¿ç”¨ç»„åˆæˆ–ç»§æ‰¿ï¼‰ã€‚

- **ç¤ºä¾‹ï¼š** **ç»„åˆä¼˜äºç»§æ‰¿**ã€å°è£…å˜åŒ–ç‚¹ã€é’ˆå¯¹æŠ½è±¡ç¼–ç¨‹è€Œéå…·ä½“å®ç°ã€`SOLIDåŸåˆ™`ï¼ˆå°¤å…¶æ˜¯`å•ä¸€èŒè´£`åŸåˆ™ï¼‰ã€`DRY`ï¼ˆä¸é‡å¤è‡ªå·±ï¼‰å’Œ`YAGNI`ï¼ˆä½ ä¸ä¼šéœ€è¦å®ƒï¼‰ã€‚
- **æç¤ºï¼š** å¼€å‘è€…åº”å¾—å‡ºè‡ªå·±çš„ç»“è®ºï¼Œè€Œä¸æ˜¯ç›²ç›®éµå¾ªä»–äººçš„è¯´æ³•ã€‚

#### Stage 5: Design Patterns (è®¾è®¡æ¨¡å¼)

**è½¯ä»¶ä¸­çš„å‡ ä¹æ‰€æœ‰é—®é¢˜éƒ½å·²è¢«åˆ†ç±»å’Œè§£å†³**ï¼Œ***è¿™äº›è§£å†³æ–¹æ¡ˆ***è¢«ç§°ä¸º`è®¾è®¡æ¨¡å¼`ã€‚è®¾è®¡æ¨¡å¼*åˆ†ä¸ºä¸‰ç±»*ï¼š**åˆ›å»ºå‹**ã€**ç»“æ„å‹**ã€**è¡Œä¸ºå‹**ã€‚

- `åˆ›å»ºå‹`ï¼š *æ§åˆ¶å¯¹è±¡çš„åˆ›å»ºæ–¹å¼*ï¼ˆä¾‹å¦‚ï¼š*å•ä¾‹æ¨¡å¼*ã€æŠ½è±¡å·¥å‚æ¨¡å¼ã€åŸå‹æ¨¡å¼ï¼‰ã€‚
- `ç»“æ„å‹`ï¼š *ç®€åŒ–ç»„ä»¶ä¹‹é—´å…³ç³»*çš„å®šä¹‰ï¼ˆä¾‹å¦‚ï¼š*é€‚é…å™¨æ¨¡å¼*ã€æ¡¥æ¥æ¨¡å¼ã€è£…é¥°å™¨æ¨¡å¼ï¼‰ã€‚
- `è¡Œä¸ºå‹`ï¼š *ä¿ƒè¿›å¯¹è±¡ä¹‹é—´ä¼˜é›…çš„é€šä¿¡*ï¼ˆä¾‹å¦‚ï¼š*æ¨¡æ¿æ¨¡å¼*ã€ä¸­ä»‹è€…æ¨¡å¼ã€*è§‚å¯Ÿè€…æ¨¡å¼*ï¼‰ã€‚

**è®¾è®¡æ¨¡å¼ä¸æ¶æ„æ¨¡å¼çš„å…³ç³»ï¼š** ***æ¶æ„æ¨¡å¼æœ¬è´¨ä¸Šæ˜¯è®¾è®¡æ¨¡å¼åœ¨é«˜å±‚æ¬¡ä¸Šçš„è§„æ¨¡åŒ–æ‰©å±•ï¼Œè€Œè®¾è®¡æ¨¡å¼æ˜¯ä½å±‚æ¬¡çš„å®ç°ï¼ˆæ›´æ¥è¿‘ç±»å’Œå‡½æ•°ï¼‰***ã€‚

#### Stage 6: Architectural Principles (æ¶æ„åŸåˆ™)

**è¯¥é˜¶æ®µè¿›å…¥äº†è¶…è¶Šç±»çº§åˆ«çš„é«˜å±‚æ¬¡æ€è€ƒ**ã€‚å­¦ä¹ è¿™äº›æŒ‡å¯¼åŸåˆ™**æœ‰åŠ©äº*ä»£ç åº“æ„å»º*æ‰€éœ€çš„çµæ´»æ€§ï¼ˆå¯æ‰©å±•æ€§ï¼‰ï¼Œä»¥ä¾¿ç”¨æœ€å°‘çš„åŠªåŠ›åº”å¯¹æ–°åŠŸèƒ½å’Œéœ€æ±‚**ã€‚

- **æ¨èå­¦ä¹ ï¼š** *ç»„ä»¶è®¾è®¡åŸåˆ™*ï¼ˆç¨³å®šæŠ½è±¡åŸåˆ™ã€ç¨³å®šä¾èµ–åŸåˆ™ã€éå¾ªç¯ä¾èµ–åŸåˆ™ï¼‰ã€*ç­–ç•¥ä¸ç»†èŠ‚åˆ†ç¦»*ï¼ˆPolicy vs. Detailï¼‰ã€*è¾¹ç•Œ*ï¼ˆè¯†åˆ«åº”ç”¨åŠŸèƒ½æ‰€å±çš„å­é¢†åŸŸï¼‰ã€‚
- **å­¦ä¹ èµ„æºï¼š** Robert C. Martinçš„ã€ŠClean Architectureã€‹ã€‚

#### Stage 7: Architectural Styles (æ¶æ„é£æ ¼)

æ¶æ„å…³æ³¨çš„æ˜¯å¯¹ç³»ç»ŸæˆåŠŸè‡³å…³é‡è¦çš„äº‹æƒ…ï¼Œ***é€šè¿‡é€‰æ‹©æœ€ç¬¦åˆéœ€æ±‚çš„æ¶æ„*æ¥å¢åŠ æˆåŠŸçš„å‡ ç‡**ã€‚***æ¶æ„é£æ ¼æ˜¯é«˜å±‚æ¬¡çš„è®¾è®¡æ¨¡å¼***ã€‚

- **ç»“æ„åŒ–é£æ ¼ï¼š** *é€‚ç”¨äºå…·æœ‰ä¸åŒç»„ä»¶å’Œå¹¿æ³›åŠŸèƒ½çš„é¡¹ç›®*ã€‚ç¤ºä¾‹ï¼š`åˆ†å±‚æ¶æ„`ï¼ˆ*å°†å…³æ³¨ç‚¹å‚ç›´åˆ‡åˆ†*ä¸º*åŸºç¡€è®¾æ–½ã€åº”ç”¨ã€é¢†åŸŸå±‚*ï¼‰ã€`ç»„ä»¶å¼æ¶æ„`ï¼ˆ*æ°´å¹³åˆ†ç¦»å…³æ³¨ç‚¹*ï¼‰ã€`å•ä½“å¼æ¶æ„`ã€‚
- **æ¶ˆæ¯ä¼ é€’é£æ ¼ï¼š** *å»ºç«‹åœ¨å‡½æ•°å¼ç¼–ç¨‹åŸåˆ™å’Œè¡Œä¸ºè®¾è®¡æ¨¡å¼ä¹‹ä¸Š*ã€‚ç¤ºä¾‹ï¼š`äº‹ä»¶é©±åŠ¨æ¶æ„`ï¼ˆå°†æ‰€æœ‰æ˜¾è‘—çš„çŠ¶æ€å˜åŒ–è§†ä¸ºäº‹ä»¶ï¼‰ã€`å‘å¸ƒ-è®¢é˜…æ¶æ„`ã€‚
- **åˆ†å¸ƒå¼é£æ ¼ï¼š** *ç³»ç»Ÿçš„ç»„ä»¶è¢«åˆ†å¼€éƒ¨ç½²ï¼Œé€šè¿‡ç½‘ç»œåè®®è¿›è¡Œé€šä¿¡*ã€‚ç¤ºä¾‹ï¼š`å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„`ã€`å¯¹ç­‰ç½‘ç»œï¼ˆPeer-to-peerï¼‰æ¶æ„`ã€‚

#### Stage 8: Architectural Patterns (æ¶æ„æ¨¡å¼)

`æ¶æ„æ¨¡å¼`ä»¥æ›´å…·æˆ˜æœ¯æ€§çš„ç»†èŠ‚**è§£é‡Šäº†å¦‚ä½•å®é™…å®ç°ä¸€ç§æ¶æ„é£æ ¼**ã€‚

- **ç¤ºä¾‹ï¼š**
    - `é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰`ï¼š ä¸€ç§*é’ˆå¯¹å¤æ‚é—®é¢˜åŸŸ*çš„å¼€å‘æ–¹æ³•ï¼Œé€šå¸¸éœ€è¦å®ç°**åˆ†å±‚æ¶æ„**æ¥éš”ç¦»é¢†åŸŸæ¨¡å‹å’ŒåŸºç¡€è®¾æ–½ç»†èŠ‚ã€‚
    - `æ¨¡å‹-è§†å›¾-æ§åˆ¶å™¨ï¼ˆMVCï¼‰`ï¼š ä¸€ç§*æµè¡Œçš„UIåº”ç”¨æ¶æ„æ¨¡å¼*ï¼Œå°†åº”ç”¨åˆ†ä¸ºæ¨¡å‹ã€è§†å›¾å’Œæ§åˆ¶å™¨ã€‚å½“ä¸šåŠ¡é€»è¾‘å¤æ‚æ—¶ï¼ŒMVCå¯èƒ½ä¸è¶³ã€‚
    - `äº‹ä»¶æº¯æºï¼ˆEvent Sourcingï¼‰`ï¼š ä¸€ç§*å‡½æ•°å¼æ–¹æ³•*ï¼Œåªå­˜å‚¨äº‹åŠ¡ï¼Œé€šè¿‡åº”ç”¨æ‰€æœ‰äº‹åŠ¡æ¥é‡å»ºçŠ¶æ€ã€‚

#### Stage 9: Enterprise Patterns (ä¼ä¸šçº§æ¨¡å¼)

ä»»ä½•æ¶æ„æ¨¡å¼éƒ½ä¼šå¼•å…¥ä¸€ç³»åˆ—éœ€è¦ç†Ÿæ‚‰çš„æ„é€ å’ŒæŠ€æœ¯æœ¯è¯­ã€‚`ä¼ä¸šçº§æ¨¡å¼`æ—¨åœ¨**è§£å†³ç‰¹å®šæ¶æ„æ¨¡å¼æœªèƒ½å……åˆ†è§£å†³çš„ç»†èŠ‚é—®é¢˜**ã€‚

- **MVCé—ç•™é—®é¢˜ï¼š** MVCæœªèƒ½æ˜ç¡®åœ¨æ¨¡å‹ï¼ˆMï¼‰ä¸­å¤„ç†*éªŒè¯é€»è¾‘ã€ä¸šåŠ¡è§„åˆ™ã€é¢†åŸŸäº‹ä»¶ã€ç”¨ä¾‹ã€å¤æ‚æŸ¥è¯¢*çš„ä½ç½®ã€‚
- **DDDä¸­çš„ä¼ä¸šæ¨¡å¼ç¤ºä¾‹ï¼š**
    - **å®ä½“ï¼ˆEntitiesï¼‰ï¼š** æè¿°å…·æœ‰èº«ä»½çš„æ¨¡å‹ã€‚
    - **å€¼å¯¹è±¡ï¼ˆValue Objectsï¼‰ï¼š** æ²¡æœ‰èº«ä»½çš„æ¨¡å‹ï¼Œå¯ç”¨äºå°è£…éªŒè¯é€»è¾‘ã€‚
    - **é¢†åŸŸäº‹ä»¶ï¼ˆDomain Eventsï¼‰ï¼š** è¡¨ç¤ºå‘ç”Ÿçš„ã€ç›¸å…³çš„ä¸šåŠ¡äº‹ä»¶ï¼Œå¯ä¾›å…¶ä»–ç»„ä»¶è®¢é˜…ã€‚
- **å­¦ä¹ èµ„æºï¼š** Martin Fowlerçš„ã€ŠPatterns of Enterprise Application Architectureã€‹å’ŒEric Evansçš„ã€ŠDomain Driven Designã€‹ã€‚

æ€»ç»“æ¥è¯´ï¼Œè¿™ä¸ªå­¦ä¹ è·¯çº¿å›¾ï¼ˆMapï¼‰æ—¨åœ¨ä¸ºå¼€å‘è€…æä¾›ä¸€ä¸ª**ç»“æ„åŒ–çš„è·¯å¾„**ï¼Œä»ç¼–å†™ä½çº§**å¹²å‡€ä»£ç **çš„åŸºç¡€å¼€å§‹ï¼Œé€æ­¥æŒæ¡ç¼–ç¨‹èŒƒå¼ã€OOPã€è®¾è®¡åŸåˆ™å’Œæ¨¡å¼ï¼Œæœ€ç»ˆè¾¾åˆ°é«˜å±‚æ¬¡çš„**æ¶æ„åŸåˆ™ã€é£æ ¼å’Œä¼ä¸šçº§æ¨¡å¼**ï¼Œä»è€Œèƒ½å¤Ÿç”Ÿäº§å‡ºé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„è½¯ä»¶ã€‚


# è±†åŒ…æ€»ç»“
## ä¸€ã€æ–‡æ¡£æ¦‚è¿°
- **åŸºç¡€ä¿¡æ¯**ï¼šç½‘é¡µæ ‡é¢˜ä¸ºâ€œå¦‚ä½•å­¦ä¹ è½¯ä»¶è®¾è®¡ä¸æ¶æ„ | å…¨æ ˆè½¯ä»¶è®¾è®¡ä¸æ¶æ„å›¾è°±â€ï¼Œæœ€åæ›´æ–°äº2024å¹´3æœˆ18æ—¥ï¼Œè¯»è€…å·²å°†å…¶ç¿»è¯‘ä¸ºæ—¥è¯­ç‰ˆæœ¬ã€‚
- **æ ¸å¿ƒå®šä½**ï¼šè½¯ä»¶è®¾è®¡ä¸æ¶æ„æ˜¯è®¡ç®—é¢†åŸŸå†…ç‹¬ç«‹çš„ç ”ç©¶é¢†åŸŸï¼ˆç±»ä¼¼DevOpsã€UXè®¾è®¡ï¼‰ï¼Œæ—¨åœ¨ä¸ºåˆçº§/è‡ªå­¦/ä¸­çº§å¼€å‘è€…æä¾›æ¸…æ™°è·¯å¾„ï¼Œè§£å†³â€œé¡¹ç›®è¿­ä»£1-2æ¬¡åä»£ç å˜éš¾ç»´æŠ¤â€çš„ç—›ç‚¹ï¼Œå¸®åŠ©å…¶æŒæ¡â€œè®¾è®¡ç®€æ´ä¸”å¯æ‰©å±•ç³»ç»Ÿâ€çš„èƒ½åŠ›ã€‚
- **æ ¸å¿ƒæ¡†æ¶**ï¼šé€šè¿‡â€œæ¶æ„æ ˆâ€ï¼ˆç±»ä¼¼OSIæ¨¡å‹ï¼Œåˆ†å±‚æ„å»ºï¼Œä»é«˜å±‚æ¦‚å¿µåˆ°ä½å±‚ç»†èŠ‚ï¼‰å’Œâ€œæ¶æ„å›¾è°±â€ï¼ˆæ›´è¯¦ç»†ï¼Œé«˜æ¸…PNGå¯åœ¨ä½œè€…GitHubè·å–ï¼‰å‘ˆç°å­¦ä¹ èŒƒå›´ã€‚


## äºŒã€æ ¸å¿ƒç†å¿µ
### 1. ç¬¬ä¸€æ€§åŸç†ï¼ˆé—®é¢˜æ‹†è§£æ–¹æ³•ï¼‰
- `å®šä¹‰`ï¼š**å°†é—®é¢˜æ‹†è§£è‡³æ— æ³•å†åˆ†çš„â€œåŸå­å±‚é¢â€ï¼Œä»ç¡®å®šä¸ºçœŸçš„éƒ¨åˆ†é‡æ„è§£å†³æ–¹æ¡ˆ**ï¼Œæ˜¯åº”å¯¹è½¯ä»¶è®¾è®¡å¤æ‚æ€§çš„æ ¸å¿ƒæ€è·¯ã€‚
- è½¯ä»¶ç›®æ ‡æ¨å¯¼ï¼šåŸºäºç¬¬ä¸€æ€§åŸç†ï¼Œè½¯ä»¶çš„æ ¸å¿ƒç›®æ ‡æ˜¯â€œæŒç»­åˆ›é€ æ»¡è¶³ç”¨æˆ·éœ€æ±‚çš„äº§ç‰©ï¼ŒåŒæ—¶æœ€å°åŒ–å®ç°æˆæœ¬â€â€”â€”æ— æ³•æ»¡è¶³ç”¨æˆ·éœ€æ±‚çš„ä¸æ˜¯å¥½è½¯ä»¶ï¼Œéš¾ä»¥ä¿®æ”¹ï¼ˆæ— æ³•é€‚é…ç”¨æˆ·éœ€æ±‚å˜åŒ–ï¼‰çš„ä¹Ÿä¸æ˜¯å¥½è½¯ä»¶ã€‚


## ä¸‰ã€è½¯ä»¶è®¾è®¡ä¸æ¶æ„å­¦ä¹ è·¯å¾„ï¼ˆ9ä¸ªé˜¶æ®µï¼‰
### é˜¶æ®µ1ï¼šæ•´æ´ä»£ç ï¼ˆClean Codeï¼‰
- **æ ¸å¿ƒå®šä¹‰**ï¼šæ•´æ´ä»£ç éœ€æ»¡è¶³ä¸‰è¦ç´ ï¼š
  1. å¼€å‘è€…æ€ç»´ï¼ˆåŒç†å¿ƒã€å·¥åŒ ç²¾ç¥ã€æˆé•¿å‹æ€ç»´ã€è®¾è®¡æ€ç»´ï¼‰ï¼›
  2. ç¼–ç è§„èŒƒï¼ˆæœ‰æ„ä¹‰çš„å‘½åã€é‡æ„ã€æµ‹è¯•ã€ç¼©è¿›/é—´è·ä¸€è‡´ç­‰ï¼‰ï¼›
  3. æŠ€èƒ½çŸ¥è¯†ï¼ˆè¯†åˆ«è®¾è®¡æ¨¡å¼ã€åŸåˆ™ï¼Œè§„é¿ä»£ç å¼‚å‘³ä¸åæ¨¡å¼ï¼‰ã€‚
- **å…³é”®æé†’**ï¼šä»£ç ä¸ä»…æœåŠ¡ç»ˆç«¯ç”¨æˆ·ï¼Œè¿˜éœ€è€ƒè™‘é˜Ÿå‹ã€æœªæ¥ç»´æŠ¤è€…ï¼Œâ€œåŒç†å¿ƒâ€æ˜¯æ ¸å¿ƒå¿ƒæ€ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šä»£ç æ•´æ´ä¹‹é“ã€‹ï¼ˆRobert C. Martinï¼‰ã€ã€Šé‡æ„ã€‹ï¼ˆMartin Fowlerï¼Œç¬¬2ç‰ˆï¼‰ã€ã€Šç¨‹åºå‘˜ä¿®ç‚¼ä¹‹é“ã€‹ã€ã€Šæ—¥å¸¸ç‰©å“è®¾è®¡ã€‹ã€‚

### é˜¶æ®µ2ï¼šç¼–ç¨‹èŒƒå¼ï¼ˆProgramming Paradigmsï¼‰
- **ä¸‰å¤§æ ¸å¿ƒèŒƒå¼åŠä½œç”¨**ï¼š
  - é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰ï¼šé€šè¿‡å¤šæ€ã€æ’ä»¶å®šä¹‰æ¶æ„è¾¹ç•Œï¼Œæ„å»ºçµæ´»ç³»ç»Ÿï¼›
  - å‡½æ•°å¼ç¼–ç¨‹ï¼šå°†æ•°æ®æ¨é€åˆ°åº”ç”¨ç¨‹åºè¾¹ç•Œï¼›
  - ç»“æ„åŒ–ç¼–ç¨‹ï¼šç”¨äºç¼–å†™ç®—æ³•ã€‚
- **å…³é”®è§‚ç‚¹**ï¼šæœ‰æ•ˆè½¯ä»¶éœ€â€œæ··åˆä½¿ç”¨ä¸‰å¤§èŒƒå¼â€ï¼Œè€Œéå•ä¸€ä¾èµ–ï¼ˆé¿å…â€œæ‰‹æŒé”¤å­çœ‹ä»€ä¹ˆéƒ½åƒé’‰å­â€ï¼‰ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šæ•´æ´æ¶æ„ã€‹ï¼ˆRobert C. Martinï¼‰ã€ã€Šé¢†åŸŸå»ºæ¨¡ï¼šå‡½æ•°å¼å®ç°ã€‹ã€ã€Šç¼–ç¨‹è¯­è¨€æ¦‚å¿µã€‹ï¼ˆç¬¬10ç‰ˆï¼‰ã€‚

### é˜¶æ®µ3ï¼šé¢å‘å¯¹è±¡ç¼–ç¨‹ï¼ˆOOPï¼‰
- **æ ¸å¿ƒä»·å€¼**ï¼šä¸ä»…æ”¯æŒâ€œæ’ä»¶æ¶æ„â€ï¼Œè¿˜é€šè¿‡å°è£…ã€ç»§æ‰¿ã€å¤šæ€ã€æŠ½è±¡å››å¤§åŸåˆ™æ„å»ºâ€œä¸°å¯Œé¢†åŸŸæ¨¡å‹â€ï¼Œå°†ä¸šåŠ¡é€»è¾‘å°è£…äºé›¶ä¾èµ–çš„é¢†åŸŸæ¨¡å‹ä¸­ã€‚
- **å¸¸è§è¯¯åŒº**ï¼šå¤šæ•°å¼€å‘è€…ä»…å­¦OOPè¯­æ³•ï¼ŒæœªæŒæ¡â€œå°†é—®é¢˜é¢†åŸŸçš„è½¯ä»¶å®ç°ç½®äºåˆ†å±‚Webåº”ç”¨æ ¸å¿ƒâ€çš„èƒ½åŠ›ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šå¯¹è±¡è®¾è®¡é£æ ¼æŒ‡å—ã€‹ã€ã€Šæ•´æ´æ¶æ„ã€‹ã€ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ï¼ˆEric Evansï¼‰ã€‚

### é˜¶æ®µ4ï¼šè®¾è®¡åŸåˆ™ï¼ˆDesign Principlesï¼‰
- **æ ¸å¿ƒä½œç”¨**ï¼šä½œä¸ºOOPçš„â€œæŠ¤æ â€ï¼Œè§£å†³è®¾è®¡å†³ç­–éš¾é¢˜ï¼ˆå¦‚â€œä½•æ—¶ç”¨ç»„åˆ/ç»§æ‰¿/æŠ½è±¡ç±»â€ï¼‰ã€‚
- **å…³é”®åŸåˆ™**ï¼šç»„åˆä¼˜äºç»§æ‰¿ã€å°è£…å˜åŒ–éƒ¨åˆ†ã€é’ˆå¯¹æŠ½è±¡ç¼–ç¨‹ï¼ˆè€Œéå…·ä½“å®ç°ï¼‰ã€å¥½è±ååŸåˆ™ã€SOLIDåŸåˆ™ï¼ˆå°¤å…¶å•ä¸€èŒè´£ï¼‰ã€DRYï¼ˆä¸é‡å¤ä»£ç ï¼‰ã€YAGNIï¼ˆæ— éœ€æå‰å®ç°æœªå¿…éœ€åŠŸèƒ½ï¼‰ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€ŠHead Firstè®¾è®¡æ¨¡å¼ã€‹ã€ã€ŠGoFè®¾è®¡æ¨¡å¼ã€‹ã€‚

### é˜¶æ®µ5ï¼šè®¾è®¡æ¨¡å¼ï¼ˆDesign Patternsï¼‰
- **åˆ†ç±»ä¸ç¤ºä¾‹**ï¼š
  1. åˆ›å»ºå‹ï¼šæ§åˆ¶å¯¹è±¡åˆ›å»ºï¼ˆå•ä¾‹ã€æŠ½è±¡å·¥å‚ã€åŸå‹æ¨¡å¼ï¼‰ï¼›
  2. ç»“æ„å‹ï¼šç®€åŒ–ç»„ä»¶å…³ç³»ï¼ˆé€‚é…å™¨ã€æ¡¥æ¥ã€è£…é¥°å™¨æ¨¡å¼ï¼‰ï¼›
  3. è¡Œä¸ºå‹ï¼šä¼˜åŒ–å¯¹è±¡é€šä¿¡ï¼ˆæ¨¡æ¿ã€ä¸­ä»‹è€…ã€è§‚å¯Ÿè€…æ¨¡å¼ï¼‰ã€‚
- **å…³é”®æé†’**ï¼šè®¾è®¡æ¨¡å¼å¯èƒ½å¢åŠ å¤æ‚åº¦ï¼Œéœ€éµå¾ªYAGNIï¼Œä»…åœ¨ç¡®æœ‰å¿…è¦æ—¶ä½¿ç”¨ï¼›æ¶æ„æ¨¡å¼æœ¬è´¨æ˜¯â€œæ”¾å¤§åˆ°é«˜å±‚çº§çš„è®¾è®¡æ¨¡å¼â€ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€ŠHead Firstè®¾è®¡æ¨¡å¼ã€‹ã€‚

### é˜¶æ®µ6ï¼šæ¶æ„åŸåˆ™ï¼ˆArchitectural Principlesï¼‰
- **æ ¸å¿ƒç›®æ ‡**ï¼šåœ¨â€œç±»çº§åˆ«ä¹‹ä¸Šâ€çš„å±‚é¢ï¼Œç¡®ä¿ç³»ç»Ÿå¯ç»´æŠ¤æ€§ã€çµæ´»æ€§ã€å¯æµ‹è¯•æ€§ï¼Œé€‚é…æ–°éœ€æ±‚ã€‚
- **å…³é”®åŸåˆ™**ï¼š
  1. ç»„ä»¶è®¾è®¡åŸåˆ™ï¼šç¨³å®šæŠ½è±¡åŸåˆ™ã€ç¨³å®šä¾èµ–åŸåˆ™ã€æ— ç¯ä¾èµ–åŸåˆ™ï¼ˆè§£å†³ç»„ä»¶ç»„ç»‡ã€ä¾èµ–è€¦åˆé—®é¢˜ï¼‰ï¼›
  2. ç­–ç•¥ä¸ç»†èŠ‚åˆ†ç¦»ï¼ˆåŒºåˆ†åº”ç”¨è§„åˆ™ä¸å®ç°ç»†èŠ‚ï¼‰ï¼›
  3. è¯†åˆ«å­åŸŸï¼ˆæ˜ç¡®åº”ç”¨åŠŸèƒ½æ‰€å±è¾¹ç•Œï¼‰ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šæ•´æ´æ¶æ„ã€‹ï¼ˆRobert C. Martinï¼‰ã€‚

### é˜¶æ®µ7ï¼šæ¶æ„é£æ ¼ï¼ˆArchitectural Stylesï¼‰
- **åˆ†ç±»ä¸ç¤ºä¾‹**ï¼ˆæœ¬è´¨æ˜¯â€œé«˜å±‚çº§è®¾è®¡æ¨¡å¼â€ï¼‰ï¼š
  1. ç»“æ„å‹ï¼šæŒ‰ç»„ä»¶/åŠŸèƒ½åˆ’åˆ†ï¼ˆåŸºäºç»„ä»¶æ¶æ„ã€å•ä½“æ¶æ„ã€åˆ†å±‚æ¶æ„ï¼‰ï¼›
  2. æ¶ˆæ¯ä¼ é€’å‹ï¼šåŸºäºäº‹ä»¶/è®¢é˜…ï¼ˆäº‹ä»¶é©±åŠ¨æ¶æ„ã€å‘å¸ƒ-è®¢é˜…æ¶æ„ï¼‰ï¼›
  3. åˆ†å¸ƒå¼ï¼šç»„ä»¶ç‹¬ç«‹éƒ¨ç½²+ç½‘ç»œé€šä¿¡ï¼ˆå®¢æˆ·æœº-æœåŠ¡å™¨ã€ç‚¹å¯¹ç‚¹æ¶æ„ï¼‰ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šæ•´æ´æ¶æ„ã€‹ã€ã€Šè½¯ä»¶æ¶æ„å¸ˆæ‰‹å†Œã€‹ï¼ˆJoseph Ingenoï¼‰ã€‚

### é˜¶æ®µ8ï¼šæ¶æ„æ¨¡å¼ï¼ˆArchitectural Patternsï¼‰
- **å®šä¹‰**ï¼šæ›´è¯¦ç»†çš„â€œæˆ˜æœ¯å±‚é¢æŒ‡å—â€ï¼ŒæŒ‡å¯¼å¦‚ä½•å®ç°æ¶æ„é£æ ¼ã€‚
- **å…³é”®æ¨¡å¼**ï¼š
  1. é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰ï¼šé’ˆå¯¹å¤æ‚é¢†åŸŸï¼Œéœ€ç»“åˆåˆ†å±‚æ¶æ„åˆ†ç¦»é¢†åŸŸæ¨¡å‹ä¸åŸºç¡€è®¾æ–½ï¼ˆæ•°æ®åº“ã€ç¼“å­˜ç­‰ï¼‰ï¼›
  2. MVCï¼šé€‚ç”¨äºUIåº”ç”¨ï¼Œåˆ†æ¨¡å‹ã€è§†å›¾ã€æ§åˆ¶å™¨ï¼Œä½†æ— æ³•åº”å¯¹å¤§é‡ä¸šåŠ¡é€»è¾‘ï¼›
  3. äº‹ä»¶æº¯æºï¼šå‡½æ•°å¼æ–¹æ³•ï¼Œä»…å­˜å‚¨äº‹åŠ¡ã€ä¸å­˜å‚¨çŠ¶æ€ï¼Œéœ€çŠ¶æ€æ—¶å›æº¯æ‰€æœ‰äº‹åŠ¡ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ã€ã€Šå®ç°é¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ï¼ˆVaughn Vernonï¼‰ã€‚

### é˜¶æ®µ9ï¼šä¼ä¸šæ¨¡å¼ï¼ˆEnterprise Patternsï¼‰
- **æ ¸å¿ƒä½œç”¨**ï¼šè§£å†³MVCæœªè¦†ç›–çš„é—®é¢˜ï¼ˆå¦‚éªŒè¯é€»è¾‘ã€ä¸å˜è§„åˆ™ã€é¢†åŸŸäº‹ä»¶ã€å¤æ‚æŸ¥è¯¢çš„å½’å±ï¼‰ã€‚
- **å…³é”®æ¨¡å¼**ï¼ˆä»¥DDDä¸ºä¾‹ï¼‰ï¼šå®ä½“ï¼ˆæœ‰æ ‡è¯†çš„æ¨¡å‹ï¼‰ã€å€¼å¯¹è±¡ï¼ˆæ— æ ‡è¯†ï¼Œå°è£…éªŒè¯é€»è¾‘ï¼‰ã€é¢†åŸŸäº‹ä»¶ï¼ˆè§¦å‘ä¸šåŠ¡ç›¸å…³é€šçŸ¥ï¼‰ã€‚
- **å­¦ä¹ èµ„æº**ï¼šã€Šä¼ä¸šåº”ç”¨æ¶æ„æ¨¡å¼ã€‹ï¼ˆMartin Fowlerï¼‰ã€ã€Šä¼ä¸šé›†æˆæ¨¡å¼ã€‹ã€ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ã€ã€Šå®ç°é¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ã€‚


## å››ã€æ ¸å¿ƒèµ„æºæ±‡æ€»
1. **ä¹¦ç±**ï¼šè¦†ç›–å„é˜¶æ®µçš„ç»å…¸è‘—ä½œï¼ˆå¦‚ã€Šä»£ç æ•´æ´ä¹‹é“ã€‹ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ã€Šä¼ä¸šåº”ç”¨æ¶æ„æ¨¡å¼ã€‹ç­‰ï¼Œè¯¦è§å„é˜¶æ®µèµ„æºï¼‰ï¼›
2. **æ‰‹å†Œ**ï¼šä½œè€…é¢„å‘å¸ƒçš„ä¸€ç«™å¼èµ„æºã€Šsolidbook.io - è½¯ä»¶è®¾è®¡ä¸æ¶æ„æ‰‹å†Œã€‹ï¼ˆå®Œæ•´ç‰ˆå®Œæˆå‰æ‰“æŠ˜ï¼Œè¦†ç›–å›¾è°±å„é˜¶æ®µæ ¸å¿ƒçŸ¥è¯†ï¼‰ï¼›
3. **å›¾è°±**ï¼šé«˜æ¸…æ¶æ„å›¾è°±å¯åœ¨ä½œè€…GitHubè·å–ï¼›
4. **é€šè®¯**ï¼šè®¢é˜…åæ¯å‘¨è·å–â€œé«˜çº§å¼€å‘é€šè®¯â€ï¼ŒåŠ å…¥20000+å¼€å‘è€…ç¤¾åŒºã€‚


## äº”ã€ä½œè€…ä¿¡æ¯
- **ä½œè€…**ï¼šKhalil Stemmlerï¼Œå®šä½â€œSoftware Essentialistâ€ï¼ˆè½¯ä»¶æœ¬è´¨ä¸»ä¹‰è€…ï¼‰ï¼›
- **ç†å¿µ**ï¼šé€šè¿‡â€œè½¯ä»¶æœ¬è´¨ä¸»ä¹‰â€ï¼ˆSoftware Essentialismï¼‰ï¼Œå¸®åŠ©â€œä»£ç ä¼˜å…ˆâ€çš„å¼€å‘è€…çªç ´ç“¶é¢ˆï¼ˆå…‹æœæ— èŠã€ impostorç»¼åˆå¾ã€æ–¹å‘ç¼ºå¤±ï¼‰ï¼ŒæŒæ¡è½¯ä»¶è®¾è®¡ã€æ¶æ„ã€æµ‹è¯•çš„â€œ80/20å…³é”®çŸ¥è¯†â€ï¼›
- **æœåŠ¡**ï¼šæä¾›è¯¾ç¨‹ï¼ˆTesting Masteryã€The Software Essentialistï¼‰ã€æ•™ç»ƒæœåŠ¡ï¼ŒåŠæ¯å‘¨å®ç”¨å»ºè®®é€šè®¯ã€‚

---

# åŸæ–‡
Last updated Mar 18th, 2024 
æœ€åæ›´æ–°äº2024å¹´3æœˆ18æ—¥

Software Design and Architecture is pretty much its own field of study within the realm of computing, like DevOps or UX Design. Here's a map describing the breadth of software design and architecture, from clean code to microkernels.
è½¯ä»¶è®¾è®¡ä¸æ¶æ„åœ¨è®¡ç®—é¢†åŸŸä¸­å‡ ä¹æ˜¯ä¸€ä¸ª*ç‹¬ç«‹çš„ç ”ç©¶é¢†åŸŸ*ï¼Œå°±åƒå¼€å‘è¿ç»´ï¼ˆDevOpsï¼‰æˆ–ç”¨æˆ·ä½“éªŒï¼ˆUXï¼‰è®¾è®¡ä¸€æ ·ã€‚è¿™é‡Œæœ‰ä¸€å¼ å›¾è¡¨ï¼Œæè¿°äº†ä»æ•´æ´ä»£ç åˆ°å¾®å†…æ ¸çš„è½¯ä»¶è®¾è®¡ä¸æ¶æ„çš„å¹¿åº¦ã€‚

  
![[_posts/architect/ç½‘ç«™æ¶æ„/media/d69587d334fb8b4bdd53f11291318e04_MD5.png]]

You ever think about what it took for some of the world's most skilled developers to learn how to build systems within companies like Uber, YouTube, Facebook, or Github?
*ä½ æœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œä¸–ç•Œä¸Šä¸€äº›æœ€é¡¶å°–çš„å¼€å‘è€…æ˜¯ä»˜å‡ºäº†æ€æ ·çš„åŠªåŠ›ï¼Œæ‰å­¦ä¼šåœ¨ä¼˜æ­¥ã€YouTubeã€è„¸ä¹¦æˆ–Githubè¿™ç±»å…¬å¸é‡Œæ­å»ºç³»ç»Ÿçš„ï¼Ÿ*

It's crazy to me to consider the fact that Facebook was once an empty text file on someone's computer, and now it's this gargantuan company that has dipped it's toes into just about everything, and has personally impacted over [1.59 billion people](https://zephoria.com/top-15-valuable-facebook-statistics/) worldwide.
æƒ³åˆ°è„¸ä¹¦æ›¾ç»åªæ˜¯æŸäººç”µè„‘ä¸Šä¸€ä¸ªç©ºç™½çš„æ–‡æœ¬æ–‡ä»¶ï¼Œè€Œç°åœ¨å´æˆäº†ä¸€å®¶æ¶‰è¶³å‡ ä¹æ‰€æœ‰é¢†åŸŸçš„å·¨å¤´å…¬å¸ï¼Œè¿˜äº²èº«å½±å“äº†å…¨çƒè¶…è¿‡15.9äº¿äººï¼Œæˆ‘å°±è§‰å¾—ä¸å¯æ€è®®ã€‚

As a junior, self-taught developer or even intermediate developer, the roadmap to continued growth towards actually learning how to design *clean* and *scalable* systems seems kind of daunting. 
ä½œä¸ºä¸€ååˆçº§ã€è‡ªå­¦æˆæ‰çš„å¼€å‘è€…ï¼Œç”šè‡³æ˜¯ä¸­çº§å¼€å‘è€…ï¼Œæƒ³è¦ä¸æ–­æˆé•¿ï¼ŒçœŸæ­£å­¦ä¼šå¦‚ä½•è®¾è®¡ *ç®€æ´* ä¸” *å¯æ‰©å±•* çš„ç³»ç»Ÿï¼Œè¿™æ¡é“è·¯ä¼¼ä¹æœ‰äº›ä»¤äººæœ›è€Œç”Ÿç•ã€‚

For a lot of us, our projects die after one or two iterations because the code turns into an unmaintainable mess.
å¯¹æˆ‘ä»¬å¾ˆå¤šäººæ¥è¯´ï¼Œæˆ‘ä»¬çš„*é¡¹ç›®åœ¨ä¸€ä¸¤æ¬¡è¿­ä»£åå°±å¤­æŠ˜äº†ï¼Œå› ä¸ºä»£ç å˜æˆäº†éš¾ä»¥ç»´æŠ¤çš„ä¸€å›¢ä¹±éº»*ã€‚

So where do we even *start* in order to learn how to improve our designs?
é‚£ä¹ˆï¼Œä¸ºäº†å­¦ä¹ å¦‚ä½•æ”¹è¿›æˆ‘ä»¬çš„è®¾è®¡ï¼Œæˆ‘ä»¬ç©¶ç«Ÿè¯¥ä»å“ªé‡Œ *å¼€å§‹* å‘¢ï¼Ÿ

The truth is: 
äº‹å®æ˜¯ï¼š

> Software design and architecture is a *huge* topic 
> è½¯ä»¶è®¾è®¡å’Œæ¶æ„æ˜¯ä¸€ä¸ª *åºå¤§* çš„è¯é¢˜

Understanding how to:
äº†è§£å¦‚ä½•ï¼š

- Architect a system to serve the needs of its users 
	- **è®¾è®¡ä¸€ä¸ªç³»ç»Ÿä»¥æ»¡è¶³å…¶ç”¨æˆ·çš„éœ€æ±‚**
- Write code that's easy to change 
	- **ç¼–å†™æ˜“äºä¿®æ”¹çš„ä»£ç **
- Write code that's easy to maintain 
	- **ç¼–å†™æ˜“äºç»´æŠ¤çš„ä»£ç **
- Write code that's easy to test 
	- **ç¼–å†™æ˜“äºæµ‹è¯•çš„ä»£ç **

... is *very* hard. The breadth of learning required is just so large.â€¦â€¦
éå¸¸å›°éš¾ã€‚**æ‰€éœ€å­¦ä¹ çš„å¹¿åº¦å®åœ¨å¤ªå¤§äº†**ã€‚

And even though you know how to write code to make things work at least *once*, the bigger challenge is to figure out how to write code that makes it easy to change in order to *keep up with the current requirements*.
å°½ç®¡ä½ çŸ¥é“å¦‚ä½•ç¼–å†™ä»£ç è‡³å°‘èƒ½è®©ç¨‹åºè¿è¡Œ *ä¸€æ¬¡* ï¼Œä½†æ›´å¤§çš„æŒ‘æˆ˜æ˜¯*å¼„æ¸…æ¥šå¦‚ä½•ç¼–å†™ä¾¿äºä¿®æ”¹çš„ä»£ç *ï¼Œä»¥ä¾¿ *è·Ÿä¸Šå½“å‰çš„éœ€æ±‚* ã€‚

But again, where to start?...
ä½†é—®é¢˜åˆæ¥äº†ï¼Œä»å“ªé‡Œå¼€å§‹å‘¢ï¼Ÿâ€¦â€¦

---

Anytime I'm faced with a complex problem, I go back to [first principles](https://jamesclear.com/first-principles).
**æ¯å½“æˆ‘é‡åˆ°å¤æ‚é—®é¢˜æ—¶ï¼Œæˆ‘éƒ½ä¼šå›å½’åˆ° [ç¬¬ä¸€æ€§åŸç†](https://jamesclear.com/first-principles)** ã€‚

## First Principles

First principles is the most effective way to break down problems. 
`ç¬¬ä¸€æ€§åŸç†`æ˜¯**åˆ†è§£é—®é¢˜æœ€æœ‰æ•ˆçš„æ–¹æ³•**ã€‚

It works by deconstructing a problem all the way down to the **atomic level** where we can't deconstruct it anymore, and then reconstructing a solution from the parts that we're absolutely sure are true.
å®ƒçš„`å·¥ä½œåŸç†`æ˜¯**å°†ä¸€ä¸ªé—®é¢˜ä¸€ç›´æ‹†è§£åˆ°æ— æ³•å†æ‹†è§£çš„*åŸå­å±‚é¢* ï¼Œç„¶åä»æˆ‘ä»¬ç»å¯¹ç¡®å®šä¸ºçœŸå®çš„éƒ¨åˆ†é‡æ–°æ„å»ºå‡ºè§£å†³æ–¹æ¡ˆ**ã€‚

So let's apply it to software by first stating the goal.
*é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬å…ˆæ˜ç¡®ç›®æ ‡ï¼Œå†å°†å…¶åº”ç”¨åˆ°è½¯ä»¶ä¸­ã€‚*

What is the primary goal of software?
**è½¯ä»¶çš„ä¸»è¦ç›®æ ‡æ˜¯ä»€ä¹ˆï¼Ÿ**

> The goal of software is to *continually* **produce something that satisfies the needs of its users**, while minimizing the effort it takes to do so.
> `è½¯ä»¶çš„ç›®æ ‡`æ˜¯*ä¸æ–­åœ°åˆ›é€ å‡ºæ»¡è¶³ç”¨æˆ·éœ€æ±‚çš„ä¸œè¥¿ï¼ŒåŒæ—¶å°†å®ç°è¿™ä¸€ç›®æ ‡æ‰€éœ€çš„åŠªåŠ›é™è‡³æœ€ä½*ã€‚

I fought with coming up with the best definition for a long time, and I'm prepared to argue with you about why I think that's accurate.
å¾ˆé•¿ä¸€æ®µæ—¶é—´é‡Œï¼Œæˆ‘éƒ½åœ¨åŠªåŠ›æƒ³å‡ºæœ€æ°å½“çš„å®šä¹‰ï¼Œè€Œä¸”æˆ‘å·²ç»å‡†å¤‡å¥½å’Œä½ äº‰è®ºä¸ºä»€ä¹ˆæˆ‘è®¤ä¸ºè¿™ä¸ªå®šä¹‰æ˜¯å‡†ç¡®çš„ã€‚

Software that doesn't serve the needs of its users, simply isn't good software.
æ— æ³•æ»¡è¶³ç”¨æˆ·éœ€æ±‚çš„è½¯ä»¶ï¼Œæ ¹æœ¬ç®—ä¸ä¸Šå¥½è½¯ä»¶ã€‚

And since the needs of our users changes often, it's important to make sure that software **was designed in order to be changed**.
è€Œä¸”**ç”±äºæˆ‘ä»¬ç”¨æˆ·çš„éœ€æ±‚ç»å¸¸å˜åŒ–ï¼Œç¡®ä¿è½¯ä»¶çš„è®¾è®¡ä¾¿äºä¿®æ”¹å°±æ˜¾å¾—å¾ˆé‡è¦**ã€‚

If software cannot be changed (easily), that makes it bad software, because it prevents us from satisfying the *current* needs of our users.
*å¦‚æœè½¯ä»¶ï¼ˆéš¾ä»¥ï¼‰æ›´æ”¹ï¼Œé‚£å®ƒå°±æ˜¯ç³Ÿç³•çš„è½¯ä»¶ï¼Œå› ä¸ºè¿™ä¼šé˜»ç¢æˆ‘ä»¬æ»¡è¶³ç”¨æˆ·å½“å‰çš„éœ€æ±‚*ã€‚

---

We've established that design matters, and it's important to learn how to produce well-designed software, but it can be a long road.
æˆ‘ä»¬å·²ç»æ˜ç¡®è®¾è®¡å¾ˆé‡è¦ï¼Œè€Œä¸”å­¦ä¼šå¦‚ä½•è®¾è®¡è‰¯å¥½çš„è½¯ä»¶ä¹Ÿå¾ˆå…³é”®ï¼Œä½†è¿™å¯èƒ½æ˜¯ä¸€æ¡æ¼«é•¿çš„é“è·¯ã€‚

In this article, I'd like to present to you what I believe are the concrete pillars of software design and architecture. 
åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘æƒ³å‘å¤§å®¶ä»‹ç»*æˆ‘æ‰€è®¤ä¸ºçš„è½¯ä»¶è®¾è®¡ä¸æ¶æ„çš„å…·ä½“æ”¯æŸ±*ã€‚

## The stack

Before I show you the map, let me show you the *stack*.
åœ¨ç»™ä½ å±•ç¤ºè¿™ä¸ªå›¾è°±ä¹‹å‰ï¼Œè®©æˆ‘å…ˆä¸ºä½ ä»‹ç»ä¸€ä¸‹è¿™ä¸ª*æ¶æ„æ ˆ*ã€‚

Similar to something like the [OSI Model](https://en.wikipedia.org/wiki/OSI_model), each layer builds on top of the foundation of the previous one.
ç±»ä¼¼äºå¼€æ”¾ç³»ç»Ÿäº’è¿æ¨¡å‹ï¼ˆOSI Modelï¼‰ä¹‹ç±»çš„ä¸œè¥¿ï¼Œ**æ¯ä¸€å±‚éƒ½å»ºç«‹åœ¨å‰ä¸€å±‚çš„åŸºç¡€ä¹‹ä¸Š**ã€‚

![[_posts/architect/ç½‘ç«™æ¶æ„/media/504b84e2a4e3b3a9d1cc9be6cbcae614_MD5.png]]

The software design and architecture stack shows all of the layers of software design, from the most high-level concepts to the most low-level details.
`è½¯ä»¶è®¾è®¡`å’Œ`æ¶æ„æ ˆ`**å±•ç¤ºäº†è½¯ä»¶è®¾è®¡çš„æ‰€æœ‰å±‚çº§ï¼Œä»æœ€é«˜çº§åˆ«çš„æ¦‚å¿µåˆ°æœ€ä½çº§åˆ«çš„ç»†èŠ‚**ã€‚

In the stack, I've included examples to *some* of the most important concepts at that layer, but not all (because there are way too many).
åœ¨è¿™ä¸ªå †å ç»“æ„ä¸­ï¼Œæˆ‘å·²ç»*åŒ…å«äº†è¯¥å±‚çº§ä¸€äº›æœ€é‡è¦æ¦‚å¿µ*çš„ç¤ºä¾‹ï¼Œä½†å¹¶éå…¨éƒ¨ï¼ˆå› ä¸ºå®åœ¨å¤ªå¤šäº†ï¼‰ã€‚

Now, check out the map. While I think the stack is good to see the bigger picture, the map is a little bit more detailed, and as a result, I think it's more useful.
ç°åœ¨ï¼Œçœ‹çœ‹è¿™å¼ åœ°å›¾ã€‚è™½ç„¶æˆ‘è®¤ä¸ºè¿™ä¸ªå †å å›¾*æœ‰åŠ©äºäº†è§£æ•´ä½“æƒ…å†µ*ï¼Œä½†è¿™å¼ åœ°å›¾ï¼ˆä¸‹é¢ï¼‰æ›´è¯¦ç»†ä¸€äº›ï¼Œå› æ­¤æˆ‘è§‰å¾—å®ƒæ›´æœ‰ç”¨ã€‚

## The map

To avoid running up my bandwidth, I reduced the quality of the map shown on site. If you'd like to get a high-quality png, you can find that up on my [GitHub](https://github.com/stemmlerjs/software-design-and-architecture-roadmap).
ä¸ºäº†é¿å…å ç”¨è¿‡å¤šå¸¦å®½ï¼Œæˆ‘é™ä½äº†ç½‘ç«™ä¸Šæ˜¾ç¤ºçš„åœ°å›¾è´¨é‡ã€‚å¦‚æœä½ æƒ³è¦é«˜æ¸…PNGæ ¼å¼çš„åœ°å›¾ï¼Œå¯ä»¥å»æˆ‘çš„ [GitHub](https://github.com/stemmlerjs/software-design-and-architecture-roadmap) ä¸Šè·å–ã€‚

Below is the map for software design and architecture.
ä»¥ä¸‹æ˜¯**è½¯ä»¶è®¾è®¡å’Œæ¶æ„çš„å›¾è°±**ï¼š

![[_posts/architect/ç½‘ç«™æ¶æ„/media/260e84a6cce3e50d74469e4b388262c2_MD5.png]]

## Stage 1: Clean code
å‚è€ƒï¼š[[å¦‚ä½•ç¼–å†™ æ•´æ´ä»£ç ï¼Ÿ]]

The very first step towards creating long-lasting software is figuring out how to write **clean code**. 
åˆ›å»º**ç»ä¹…è€ç”¨çš„**è½¯ä»¶ï¼Œç¬¬ä¸€æ­¥å°±æ˜¯å¼„æ¸…æ¥šå¦‚ä½•ç¼–å†™ **æ•´æ´çš„ä»£ç ** ã€‚

If you ask anyone what they think constitutes *clean code*, you'll probably get a different answer every time. A lot of times, you'll hear that *clean code* is code that is easy to understand and change. At the low-level, this manifests in a few design choices like:
å¦‚æœä½ é—®ä»»ä½•äººä»–ä»¬è®¤ä¸ºä»€ä¹ˆæ„æˆäº† *æ•´æ´çš„ä»£ç * ï¼Œä½ å¾ˆå¯èƒ½æ¯æ¬¡éƒ½ä¼šå¾—åˆ°ä¸åŒçš„ç­”æ¡ˆã€‚å¾ˆå¤šæ—¶å€™ï¼Œä½ ä¼šå¬åˆ°äººä»¬è¯´ï¼Œ *æ•´æ´çš„ä»£ç * æ˜¯**æ˜“äºç†è§£å’Œä¿®æ”¹**çš„ä»£ç ã€‚åœ¨åº•å±‚ï¼Œè¿™ä½“ç°åœ¨ä¸€äº›è®¾è®¡é€‰æ‹©ä¸Šï¼Œæ¯”å¦‚ï¼š

- being consistent 
	- *ä¿æŒä¸€è‡´æ€§*
- preferring meaningful variable, method and class names over writing comments 
	- å€¾å‘äº*ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡åã€æ–¹æ³•åå’Œç±»å*ï¼Œè€Œéç¼–å†™æ³¨é‡Š
- ensuring code is indented and spaced properly 
	- ç¡®ä¿*ä»£ç ç¼©è¿›å’Œé—´è·*é€‚å½“
- ensuring all of the tests can run 
	- ç¡®ä¿æ‰€æœ‰*æµ‹è¯•*éƒ½èƒ½è¿è¡Œ
- writing pure functions with no side effects 
	- ç¼–å†™*æ— å‰¯ä½œç”¨çš„çº¯å‡½æ•°*
- not passing null 
	- ä¸ä¼ é€’ç©ºå€¼

These may seem like small things, but think of it like a game of Jenga. In order to keep the structure of our project stable over time, things like indentation, small classes and methods, and meaningful names, pay off a lot in the long run. è¿™äº›çœ‹èµ·æ¥å¯èƒ½éƒ½æ˜¯å°äº‹ï¼Œä½†å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆå å ä¹æ¸¸æˆã€‚ä¸ºäº†è®©æˆ‘ä»¬é¡¹ç›®çš„ç»“æ„é•¿æœŸä¿æŒç¨³å®šï¼Œåƒç¼©è¿›ã€å°å‹ç±»å’Œæ–¹æ³•ä»¥åŠæœ‰æ„ä¹‰çš„å‘½åä¹‹ç±»çš„ç»†èŠ‚ï¼Œä»é•¿è¿œæ¥çœ‹ä¼šå¸¦æ¥å¾ˆå¤§çš„å›æŠ¥ã€‚

If you ask me, this aspect of *clean code* is about having good **coding conventions** and following them. åœ¨æˆ‘çœ‹æ¥ï¼Œ *æ•´æ´ä»£ç * çš„è¿™ä¸€æ–¹é¢åœ¨äºæ‹¥æœ‰è‰¯å¥½çš„ **ç¼–ç è§„èŒƒ** å¹¶éµå¾ªå®ƒä»¬ã€‚

I belive that's only *one* aspect of writing *clean code*.æˆ‘è®¤ä¸ºè¿™åªæ˜¯ç¼–å†™ *æ•´æ´ä»£ç * çš„ *ä¸€ä¸ª* æ–¹é¢ã€‚

My definitive explanation of clean code consists of:æˆ‘å¯¹æ•´æ´ä»£ç çš„ç¡®åˆ‡è§£é‡ŠåŒ…æ‹¬ï¼š

- ğŸ§  Your developer mindset (empathy, craftsmanship, growth mindset, design thinking) ğŸ§  ä½ çš„å¼€å‘è€…æ€ç»´æ¨¡å¼ï¼ˆåŒç†å¿ƒã€å·¥åŒ ç²¾ç¥ã€æˆé•¿å‹æ€ç»´ã€è®¾è®¡æ€ç»´ï¼‰
- âš™ï¸ Your coding conventions (naming things, refactoring, testing, etc) âš™ï¸ ä½ çš„ç¼–ç è§„èŒƒï¼ˆå‘½åã€é‡æ„ã€æµ‹è¯•ç­‰ï¼‰
- ğŸ¤¹ğŸ¼ Your skills & knowledge (of patterns, principles, and how to avoid code smells and anti-patterns) ğŸ¤¹ğŸ¼ ä½ çš„æŠ€èƒ½å’ŒçŸ¥è¯†ï¼ˆå…³äºæ¨¡å¼ã€åŸåˆ™ï¼Œä»¥åŠå¦‚ä½•é¿å…ä»£ç å¼‚å‘³å’Œåæ¨¡å¼ï¼‰

Getting into the right mindset is incredibly important if you want to write clean code. One requirement is that you should care enough to learn about the business you're writing code within. If we don't care about the domain enough to understand it, then how can we be sure we're using **good names** to represent domain concepts? How can we be sure that we've accurately captured the functional requirements? å¦‚æœä½ æƒ³å†™å‡ºæ•´æ´çš„ä»£ç ï¼Œæ‹¥æœ‰æ­£ç¡®çš„å¿ƒæ€è‡³å…³é‡è¦ã€‚å…¶ä¸­ä¸€ä¸ªè¦æ±‚æ˜¯ï¼Œä½ åº”è¯¥è¶³å¤Ÿç”¨å¿ƒå»äº†è§£è‡ªå·±ç¼–å†™ä»£ç æ‰€æ¶‰åŠçš„ä¸šåŠ¡ã€‚å¦‚æœæˆ‘ä»¬å¯¹ç›¸å…³é¢†åŸŸä¸å¤Ÿå…³æ³¨ï¼Œæœªèƒ½ç†è§£å®ƒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•ç¡®ä¿è‡ªå·±ä½¿ç”¨äº†æ°å½“çš„åç§°æ¥ä»£è¡¨é¢†åŸŸæ¦‚å¿µå‘¢ï¼Ÿæˆ‘ä»¬åˆå¦‚ä½•ç¡®ä¿è‡ªå·±å‡†ç¡®æ•æ‰åˆ°äº†åŠŸèƒ½éœ€æ±‚å‘¢ï¼Ÿ

If we don't care about the code that we're writing, it's a lot less likely that we're going to implement essential coding conventions, have meaningful discussions, and ask for feedback on our solutions.å¦‚æœæˆ‘ä»¬ä¸åœ¨æ„è‡ªå·±æ­£åœ¨ç¼–å†™çš„ä»£ç ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸å¤ªå¯èƒ½å»éµå¾ªåŸºæœ¬çš„ç¼–ç è§„èŒƒã€è¿›è¡Œæœ‰æ„ä¹‰çš„è®¨è®ºï¼Œä¹Ÿä¸ä¼šå°±è‡ªå·±çš„è§£å†³æ–¹æ¡ˆå¯»æ±‚åé¦ˆã€‚

We often think that code is solely written to serve the needs of the *end user*, but we forget the **other people we write code for**: us, our teammates, and the project's future maintainers. Having an understanding of the principles of *design* and how human psychology decides what is *good* and *bad* design, will help us write better code.æˆ‘ä»¬å¸¸å¸¸è®¤ä¸ºä»£ç ä»…ä»…æ˜¯ä¸ºäº†æ»¡è¶³ *ç»ˆç«¯ç”¨æˆ·* çš„éœ€æ±‚è€Œç¼–å†™çš„ï¼Œä½†æˆ‘ä»¬å¿˜è®°äº† **æˆ‘ä»¬ä¸ºå…¶ç¼–å†™ä»£ç çš„å…¶ä»–äºº** ï¼šæˆ‘ä»¬è‡ªå·±ã€æˆ‘ä»¬çš„é˜Ÿå‹ä»¥åŠé¡¹ç›®æœªæ¥çš„ç»´æŠ¤è€…ã€‚ç†è§£ *è®¾è®¡* åŸåˆ™ï¼Œä»¥åŠäººç±»å¿ƒç†å­¦å¦‚ä½•åˆ¤å®šä»€ä¹ˆæ˜¯ *å¥½çš„* è®¾è®¡å’Œ *å·®çš„* è®¾è®¡ï¼Œå°†æœ‰åŠ©äºæˆ‘ä»¬ç¼–å†™æ›´å¥½çš„ä»£ç ã€‚

So essentially, the best word that describes this step of your journey? **Empathy**.æ‰€ä»¥æœ¬è´¨ä¸Šï¼Œæœ€èƒ½æè¿°ä½ è¿™æ®µæ—…ç¨‹ä¸­è¿™ä¸€æ­¥çš„è¯æ˜¯ä»€ä¹ˆï¼Ÿ **åŒç†å¿ƒ** ã€‚

Once we've got that down, learn the *tricks of the trade* and continue to improve them them over time by improving your knowledge of the essential software development patterns and principles.ä¸€æ—¦æˆ‘ä»¬æŒæ¡äº†è¿™ä¸€ç‚¹ï¼Œå°±è¦å­¦ä¹ è¡Œä¸šè¯€çªï¼Œå¹¶é€šè¿‡ä¸æ–­åŠ æ·±å¯¹åŸºæœ¬è½¯ä»¶å¼€å‘æ¨¡å¼å’ŒåŸåˆ™çš„ç†è§£ï¼Œæ¥æŒç»­æ”¹è¿›è¿™äº›è¯€çªã€‚

### Learning resources

- Clean Code, by Robert C. Martin ã€Šä»£ç æ•´æ´ä¹‹é“ã€‹ï¼Œä½œè€…ï¼šç½—ä¼¯ç‰¹Â·CÂ·é©¬ä¸
- Refactoring, by Martin Fowler (2nd edition) ã€Šé‡æ„ã€‹ï¼Œé©¬ä¸Â·ç¦å‹’ï¼ˆç¬¬2ç‰ˆï¼‰
- The Pragmatic Programmer, by Andy Hunt and Dave Thomas ã€Šç¨‹åºå‘˜ä¿®ç‚¼ä¹‹é“ã€‹ï¼Œä½œè€…ï¼šå®‰è¿ªÂ·äº¨ç‰¹ä¸æˆ´å¤«Â·æ‰˜é©¬æ–¯
- The Design of Everyday Things, by Don Norman ã€Šæ—¥å¸¸ç‰©å“è®¾è®¡ã€‹ï¼Œä½œè€…ï¼šå”Â·è¯ºæ›¼

The best resource to learn how to write clean code is Uncle Bob's book, " [Clean Code](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) ".
å­¦ä¹ å¦‚ä½•ç¼–å†™æ•´æ´ä»£ç çš„æœ€ä½³èµ„æºæ˜¯é²å‹ƒå¤§å”çš„ã€Š [Clean Code](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) ã€‹ä¸€ä¹¦ã€‚

## Stage 2: Programming Paradigms

Now that we're writing readable code that's easy to maintain, it would be a good idea to really understand the 3 major programming paradigms and the way they influence how we write code.æ—¢ç„¶æˆ‘ä»¬ç°åœ¨ç¼–å†™çš„ä»£ç å¯è¯»æ€§å¼ºä¸”æ˜“äºç»´æŠ¤ï¼Œé‚£ä¹ˆçœŸæ­£ç†è§£ä¸‰å¤§ä¸»è¦ç¼–ç¨‹èŒƒå¼ä»¥åŠå®ƒä»¬å¯¹æˆ‘ä»¬ç¼–å†™ä»£ç æ–¹å¼çš„å½±å“ä¼šæ˜¯ä¸ªä¸é”™çš„ä¸»æ„ã€‚

In Uncle Bob's book, " [Clean Architecture](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ", he brings attention to the fact that:åœ¨é²å‹ƒå¤§å”çš„ã€Š [æ•´æ´æ¶æ„](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ã€‹ä¸€ä¹¦ä¸­ï¼Œä»–æé†’äººä»¬ï¼š

- Object-Oriented Programming is the tool best suited for defining how we cross architectural boundaries with polymorphism and plugins é¢å‘å¯¹è±¡ç¼–ç¨‹æ˜¯æœ€é€‚åˆé€šè¿‡å¤šæ€æ€§å’Œæ’ä»¶æ¥å®šä¹‰æˆ‘ä»¬å¦‚ä½•è·¨è¶Šæ¶æ„è¾¹ç•Œçš„å·¥å…·ã€‚
- Functional programming is the tool we use to push data to the boundaries of our applications å‡½æ•°å¼ç¼–ç¨‹æ˜¯æˆ‘ä»¬ç”¨æ¥å°†æ•°æ®æ¨é€åˆ°åº”ç”¨ç¨‹åºè¾¹ç•Œçš„å·¥å…·
- and Structured programming is the tool we use to write algorithms è€Œç»“æ„åŒ–ç¼–ç¨‹æ˜¯æˆ‘ä»¬ç”¨æ¥ç¼–å†™ç®—æ³•çš„å·¥å…·

This implies that effective software uses a hybrid all 3 programming paradigms styles at different times.è¿™æ„å‘³ç€æœ‰æ•ˆçš„è½¯ä»¶ä¼šåœ¨ä¸åŒæ—¶æœŸé‡‡ç”¨è¿™ä¸‰ç§ç¼–ç¨‹èŒƒå¼çš„æ··åˆé£æ ¼ã€‚

While you *could* take a strictly functional or strictly object-oriented approach to writing code, understanding where each excels will improve the quality of your designs.è™½ç„¶ä½ å¯ä»¥é‡‡ç”¨çº¯å‡½æ•°å¼æˆ–çº¯é¢å‘å¯¹è±¡çš„æ–¹æ³•æ¥ç¼–å†™ä»£ç ï¼Œä½†äº†è§£æ¯ç§æ–¹æ³•çš„ä¼˜åŠ¿æ‰€åœ¨ï¼Œå°†ä¼šæé«˜ä½ çš„è®¾è®¡è´¨é‡ã€‚

> If all you have is a hammer, everything seems like a nail.å¦‚æœä½ æ‰‹é‡Œåªæœ‰ä¸€æŠŠé”¤å­ï¼Œé‚£ä¹ˆä¸€åˆ‡çœ‹èµ·æ¥éƒ½åƒé’‰å­ã€‚

### Learning resources

- Clean Architecture, by Robert C. Martin ã€Šæ•´æ´æ¶æ„ã€‹ï¼Œä½œè€…ï¼šç½—ä¼¯ç‰¹Â·CÂ·é©¬ä¸
- Domain Modeling Made Functional, by Scott Wlaschin ã€Šé¢†åŸŸå»ºæ¨¡ï¼šå‡½æ•°å¼å®ç°ã€‹ï¼Œä½œè€…ï¼šæ–¯ç§‘ç‰¹Â·æ²ƒæ‹‰æ–¯é’¦
- Concepts of Programming Languages, Robert W. Sebesta (10th edition) ã€Šç¼–ç¨‹è¯­è¨€æ¦‚å¿µã€‹ï¼Œç½—ä¼¯ç‰¹Â·WÂ·å¡è´æ–¯å¡”ï¼ˆç¬¬10ç‰ˆï¼‰

## Stage 3: Object-Oriented Programming

It's important to know how each of the paradigms work and how they urge you to structure the code within them, but with respect to architecture, Object-Oriented Programming is the clear *tool for the job*.äº†è§£æ¯ç§èŒƒå¼çš„å·¥ä½œåŸç†ä»¥åŠå®ƒä»¬å¦‚ä½•ä¿ƒä½¿ä½ åœ¨å…¶ä¸­æ„å»ºä»£ç å¾ˆé‡è¦ï¼Œä½†å°±æ¶æ„è€Œè¨€ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹æ˜¾ç„¶æ˜¯å®Œæˆè¿™é¡¹å·¥ä½œçš„å·¥å…·ã€‚

Not only does Object-Oriented programming enable us to create a **plugin architecture** and build flexibility into our projects; OOP comes with the 4 principles of OOP (encapsulation, inheritance, polymorhism, and abstraction) that help us create **rich domain models**.é¢å‘å¯¹è±¡ç¼–ç¨‹ä¸ä»…èƒ½è®©æˆ‘ä»¬åˆ›å»ºæ’ä»¶æ¶æ„ï¼Œä¸ºé¡¹ç›®æ³¨å…¥çµæ´»æ€§ï¼›å®ƒè¿˜å…·å¤‡é¢å‘å¯¹è±¡ç¼–ç¨‹çš„å››å¤§åŸåˆ™ï¼ˆå°è£…ã€ç»§æ‰¿ã€å¤šæ€å’ŒæŠ½è±¡ï¼‰ï¼Œå¸®åŠ©æˆ‘ä»¬æ„å»ºä¸°å¯Œçš„é¢†åŸŸæ¨¡å‹ã€‚

Most developers learning Object-Oriented Programming never get to this part: learning how to create a software implementation of the problem domain, and locating it in the center of a **layered** web app. å¤§å¤šæ•°å­¦ä¹ é¢å‘å¯¹è±¡ç¼–ç¨‹çš„å¼€å‘è€…ä»æœªæ¥è§¦åˆ°è¿™éƒ¨åˆ†å†…å®¹ï¼šå­¦ä¹ å¦‚ä½•åˆ›å»ºé—®é¢˜é¢†åŸŸçš„è½¯ä»¶å®ç°ï¼Œå¹¶å°†å…¶ç½®äºåˆ†å±‚Webåº”ç”¨çš„æ ¸å¿ƒä½ç½®ã€‚

Functional programming can seem like the means to all ends in this scenario, but I'd recommend getting acquainted with model-driven design and [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) to understand the bigger picture on how object-modelers are able to encapsulate an entire business in a zero-dependency domain model.åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå‡½æ•°å¼ç¼–ç¨‹ä¼¼ä¹æ˜¯è§£å†³æ‰€æœ‰é—®é¢˜çš„æ–¹æ³•ï¼Œä½†æˆ‘å»ºè®®ä½ äº†è§£æ¨¡å‹é©±åŠ¨è®¾è®¡å’Œé¢†åŸŸé©±åŠ¨è®¾è®¡</b0ï¼Œä»¥ä¾¿æ›´å…¨é¢åœ°ç†è§£å¯¹è±¡å»ºæ¨¡è€…å¦‚ä½•åœ¨é›¶ä¾èµ–çš„é¢†åŸŸæ¨¡å‹ä¸­å°è£…æ•´ä¸ªä¸šåŠ¡ã€‚

> Why is that a huge deal?ä¸ºä»€ä¹ˆè¿™æ˜¯ä¸€ä»¶å¤§äº‹ï¼Ÿ

It's huge because if you can create a mental-model of a business, you can create a software implementation of that business.è¿™æ„ä¹‰é‡å¤§ï¼Œå› ä¸ºå¦‚æœä½ èƒ½æ„å»ºä¸€ä¸ªä¸šåŠ¡çš„å¿ƒæ™ºæ¨¡å‹ï¼Œä½ å°±èƒ½æ®æ­¤å¼€å‘å‡ºè¯¥ä¸šåŠ¡çš„è½¯ä»¶å®ç°ã€‚

### Learning resources

- Object-Design Style Guide, by Matthias Noback ã€Šå¯¹è±¡è®¾è®¡é£æ ¼æŒ‡å—ã€‹ï¼Œä½œè€…ï¼šé©¬è’‚äºšæ–¯Â·è¯ºå·´å…‹
- Clean Architecture, by Robert C. Martin ã€Šæ•´æ´æ¶æ„ã€‹ï¼Œä½œè€…ï¼šç½—ä¼¯ç‰¹Â·CÂ·é©¬ä¸
- Domain-Driven Design, by Eric Evans åŸƒé‡Œå…‹Â·åŸƒæ–‡æ–¯æ‰€è‘—çš„ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹

## Stage 4: Design Principles

At this point, you're understanding that Object-Oriented Programming is very useful for encapsulating rich domain models and solving the [3rd type of "Hard Software Problems"- Complex Domains](https://khalilstemmler.com/wiki/3-categories-of-hard-software-problems/).åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä½ åº”è¯¥å·²ç»ç†è§£ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹åœ¨å°è£…ä¸°å¯Œçš„é¢†åŸŸæ¨¡å‹ä»¥åŠè§£å†³ [ç¬¬ä¸‰ç§â€œè½¯ä»¶éš¾é¢˜â€â€”â€”å¤æ‚é¢†åŸŸ](https://khalilstemmler.com/wiki/3-categories-of-hard-software-problems/) æ–¹é¢éå¸¸æœ‰ç”¨ã€‚

But OOP can introduce some design challenges. ä½†é¢å‘å¯¹è±¡ç¼–ç¨‹å¯èƒ½ä¼šå¸¦æ¥ä¸€äº›è®¾è®¡æŒ‘æˆ˜ã€‚

When should I use composition?æˆ‘åº”è¯¥ä½•æ—¶ä½¿ç”¨ç»„åˆï¼Ÿ

When should I use inheritance?æˆ‘åº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ç»§æ‰¿ï¼Ÿ

When should I use an abstract class?æˆ‘åº”è¯¥ä»€ä¹ˆæ—¶å€™ä½¿ç”¨æŠ½è±¡ç±»ï¼Ÿ

Design principles are really well-established and battle-tested object-oriented best practices that you use as railguards.è®¾è®¡åŸåˆ™æ˜¯éå¸¸æˆç†Ÿä¸”ç»è¿‡å®è·µæ£€éªŒçš„é¢å‘å¯¹è±¡æœ€ä½³å®è·µï¼Œå¯ä½œä¸ºä½ çš„æŒ‡å¯¼å‡†åˆ™ã€‚

Some examples of common design principles you should familiarize yourself with are:ä½ åº”è¯¥ç†Ÿæ‚‰çš„ä¸€äº›å¸¸è§è®¾è®¡åŸåˆ™ç¤ºä¾‹å¦‚ä¸‹ï¼š

- Composition over inheritance ç»„åˆä¼˜äºç»§æ‰¿
- Encapsulate what varies å°è£…å˜åŒ–çš„éƒ¨åˆ†
- Program against abstractions, not concretions é’ˆå¯¹æŠ½è±¡ç¼–ç¨‹ï¼Œè€Œéå…·ä½“å®ç°ç¼–ç¨‹
- The hollywood principle: "Don't call us, we'll call you" å¥½è±ååŸåˆ™ï¼šâ€œä¸è¦è°ƒç”¨æˆ‘ä»¬ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨ä½ â€
- The [SOLID principles](https://khalilstemmler.com/articles/solid-principles/solid-typescript/), especially the [Single responsibility principle](https://khalilstemmler.com/articles/solid-principles/single-responsibility/) [SOLIDåŸåˆ™](https://khalilstemmler.com/articles/solid-principles/solid-typescript/) ï¼Œç‰¹åˆ«æ˜¯ [å•ä¸€èŒè´£åŸåˆ™](https://khalilstemmler.com/articles/solid-principles/single-responsibility/)
- DRY (Do Not Repeat Yourself) DRYï¼ˆä¸è¦é‡å¤è‡ªå·±ï¼‰
- [YAGNI (You Aren't Gonna Need It) YAGNIï¼ˆä½ ä¸ä¼šéœ€è¦å®ƒï¼‰](https://khalilstemmler.com/wiki/yagni/)

Make sure to come to your *own* conclusions, though. Don't just follow what someone else says you should do. Make sure that it makes sense to you.ä¸è¿‡ï¼Œä¸€å®šè¦å¾—å‡ºè‡ªå·±çš„ç»“è®ºã€‚ä¸è¦åªæ˜¯ç›²ä»åˆ«äººå‘Šè¯‰ä½ åº”è¯¥åšçš„äº‹ã€‚è¦ç¡®ä¿å®ƒå¯¹ä½ æ¥è¯´æ˜¯æœ‰æ„ä¹‰çš„ã€‚

### Learning resources

- Head First Design Patterns, by various authors ã€ŠHead First è®¾è®¡æ¨¡å¼ã€‹ï¼Œå¤šä½ä½œè€…è‘—
- GoF Design Patterns, by various authors ã€ŠGoFè®¾è®¡æ¨¡å¼ã€‹ï¼Œå¤šä½ä½œè€…è‘—

## Stage 5: Design Patterns

Just about every problem in software has been categorized and solved already. We call these patterns: design patterns, actually.è½¯ä»¶é¢†åŸŸå‡ ä¹æ‰€æœ‰çš„é—®é¢˜éƒ½å·²ç»è¢«å½’ç±»å¹¶è§£å†³äº†ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å°†è¿™äº›ç§°ä¸ºæ¨¡å¼ï¼šè®¾è®¡æ¨¡å¼ã€‚

There are 3 categories of design patterns: **creational**, **structural**, and **behaviour**.è®¾è®¡æ¨¡å¼åˆ†ä¸º3ç±»ï¼š **åˆ›å»ºå‹** ã€ **ç»“æ„å‹** å’Œ **è¡Œä¸ºå‹** ã€‚

### Creational

Creational patterns are patterns that control how objects are created.åˆ›å»ºå‹æ¨¡å¼æ˜¯æ§åˆ¶å¯¹è±¡åˆ›å»ºæ–¹å¼çš„æ¨¡å¼ã€‚

Examples of creational patterns include:åˆ›å»ºå‹æ¨¡å¼çš„ç¤ºä¾‹åŒ…æ‹¬ï¼š

- The **Singleton pattern**, for ensuring only a single instance of a class can exist å•ä¾‹æ¨¡å¼ï¼ˆ **Singleton pattern** ï¼‰ï¼Œç”¨äºç¡®ä¿ä¸€ä¸ªç±»åªèƒ½å­˜åœ¨ä¸€ä¸ªå®ä¾‹
- The **Abstract Factory pattern**, for creating an instance of several families of classes æŠ½è±¡å·¥å‚æ¨¡å¼</b0ï¼Œç”¨äºåˆ›å»ºå¤šä¸ªç±»æ—çš„å®ä¾‹
- The **Prototype pattern**, for starting out with an instance that is cloned from an existing one **åŸå‹æ¨¡å¼** ï¼Œç”¨äºä»ç°æœ‰å®ä¾‹å…‹éš†å‡ºä¸€ä¸ªå®ä¾‹ä½œä¸ºèµ·ç‚¹

### Structural

Structural patterns are patterns that simplify how we define relationships between components.ç»“æ„æ¨¡å¼æ˜¯ç®€åŒ–æˆ‘ä»¬å®šä¹‰ç»„ä»¶ä¹‹é—´å…³ç³»çš„æ¨¡å¼ã€‚

Examples of structural design patterns include:ç»“æ„å‹è®¾è®¡æ¨¡å¼çš„ç¤ºä¾‹åŒ…æ‹¬ï¼š

- The **Adapter pattern**, for creating an interface to enable classes that normally can't work together, to work together. **é€‚é…å™¨æ¨¡å¼** ç”¨äºåˆ›å»ºä¸€ä¸ªæ¥å£ï¼Œä½¿é€šå¸¸æ— æ³•ååŒå·¥ä½œçš„ç±»èƒ½å¤ŸååŒå·¥ä½œã€‚
- The **Bridge pattern**, for splitting a class that should actually be one or more, into a set of classes that belong to a hierarchy, enabling the implementations to be developed independently of each other.**æ¡¥æ¥æ¨¡å¼** ç”¨äºå°†ä¸€ä¸ªå®é™…ä¸Šåº”è¯¥æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªçš„ç±»æ‹†åˆ†ä¸ºä¸€ç»„å±äºæŸä¸ªå±‚æ¬¡ç»“æ„çš„ç±»ï¼Œä½¿å„ä¸ªå®ç°èƒ½å¤Ÿç›¸äº’ç‹¬ç«‹åœ°å¼€å‘ã€‚
- The **Decorator pattern**, for adding responsibilities to objects dynamically.**è£…é¥°å™¨æ¨¡å¼** ï¼Œç”¨äºåŠ¨æ€åœ°ä¸ºå¯¹è±¡æ·»åŠ èŒè´£ã€‚

### Behavioural

Behavioural patterns are common patterns for facilitating elegant communication between objects.è¡Œä¸ºæ¨¡å¼æ˜¯ä¿ƒè¿›å¯¹è±¡ä¹‹é—´ä¼˜é›…é€šä¿¡çš„å¸¸è§æ¨¡å¼ã€‚

Examples of behavioural patterns are:è¡Œä¸ºæ¨¡å¼çš„ç¤ºä¾‹åŒ…æ‹¬ï¼š

- The **Template pattern**, for deferring the exact steps of an algorithm to a subclass.**æ¨¡æ¿æ¨¡å¼** ï¼Œç”¨äºå°†ç®—æ³•çš„ç¡®åˆ‡æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­å®ç°ã€‚
- The **Mediator pattern**, for defining the exact communication channels allowed between classes. **ä¸­ä»‹è€…æ¨¡å¼** ï¼Œç”¨äºå®šä¹‰ç±»ä¹‹é—´å…è®¸çš„ç²¾ç¡®é€šä¿¡æ¸ é“ã€‚
- The **Observer pattern**, for enabling classes to subscribe to something of interest, and to be notified when a change occurred.**è§‚å¯Ÿè€…æ¨¡å¼** ï¼Œç”¨äºä½¿ç±»èƒ½å¤Ÿè®¢é˜…æ„Ÿå…´è¶£çš„å†…å®¹ï¼Œå¹¶åœ¨å‘ç”Ÿå˜åŒ–æ—¶æ”¶åˆ°é€šçŸ¥ã€‚

---

### Design pattern criticisms è®¾è®¡æ¨¡å¼çš„æ‰¹è¯„

Design patterns are great and all, but sometimes they can an additional complexity to our designs. It's important to remember YAGNI and attempt to keep our designs as simple as possible. Only use design patterns when you're really sure you need them. You'll know when you will.è®¾è®¡æ¨¡å¼å›ºç„¶å¾ˆæ£’ï¼Œä½†æœ‰æ—¶å®ƒä»¬ä¼šç»™æˆ‘ä»¬çš„è®¾è®¡å¢åŠ é¢å¤–çš„å¤æ‚æ€§ã€‚é‡è¦çš„æ˜¯è¦è®°ä½â€œä½ ä¸ä¼šéœ€è¦å®ƒâ€ï¼ˆYAGNIï¼‰åŸåˆ™ï¼Œå¹¶åŠªåŠ›è®©æˆ‘ä»¬çš„è®¾è®¡å°½å¯èƒ½ç®€æ´ã€‚åªæœ‰åœ¨ä½ ç¡®å®ç¡®å®šéœ€è¦è®¾è®¡æ¨¡å¼æ—¶å†ä½¿ç”¨å®ƒä»¬ï¼Œåˆ°æ—¶å€™ä½ è‡ªç„¶ä¼šæ˜ç™½çš„ã€‚

---

If we know what each of these patterns are, when to use them, and when to *not even bother* using them, we're in good shape to begin to understand how to architect larger systems.å¦‚æœæˆ‘ä»¬çŸ¥é“è¿™äº›æ¨¡å¼åˆ†åˆ«æ˜¯ä»€ä¹ˆã€ä½•æ—¶ä½¿ç”¨å®ƒä»¬ä»¥åŠä½•æ—¶ *æ ¹æœ¬ä¸å¿…è´¹å¿ƒ* ä½¿ç”¨å®ƒä»¬ï¼Œæˆ‘ä»¬å°±å·²ç»ä¸ºå¼€å§‹ç†è§£å¦‚ä½•æ„å»ºæ›´å¤§çš„ç³»ç»Ÿåšå¥½äº†å‡†å¤‡ã€‚

The reason behind that is because **architectural patterns are just design patterns blown-up in scale to the high-level**, where design patterns are low-level implementations (closer to classes and functions).å…¶èƒŒåçš„åŸå› æ˜¯ï¼Œ **æ¶æ„æ¨¡å¼åªæ˜¯è®¾è®¡æ¨¡å¼åœ¨è§„æ¨¡ä¸Šæ‰©å±•åˆ°äº†é«˜å±‚çº§** ï¼Œè€Œè®¾è®¡æ¨¡å¼æ˜¯ä½å±‚çº§çš„å®ç°ï¼ˆæ›´æ¥è¿‘ç±»å’Œå‡½æ•°ï¼‰ã€‚

### Learning resources

- Head First Design Patterns, by various authors ã€Šæ·±å…¥æµ…å‡ºè®¾è®¡æ¨¡å¼ã€‹ï¼Œå¤šä½ä½œè€…è‘—

## Stage 6: Architectural Principles

Now we're at a higher level of thinking beyond the class level.ç°åœ¨æˆ‘ä»¬å¤„äºè¶…è¶Šç±»çº§åˆ«ä¹‹ä¸Šçš„æ›´é«˜å±‚æ¬¡çš„æ€è€ƒå±‚é¢ã€‚

We now understand that the decisions we make towards organzing and building relationships between components at the high-level and the low-level, will have a significant impact on the maintainability, flexibility, and testability of our project.æˆ‘ä»¬ç°åœ¨æ˜ç™½ï¼Œæˆ‘ä»¬åœ¨ç»„ç»‡å’Œæ„å»ºé«˜å±‚ä¸ä½å±‚ç»„ä»¶ä¹‹é—´çš„å…³ç³»æ—¶æ‰€åšçš„å†³ç­–ï¼Œå°†å¯¹æˆ‘ä»¬é¡¹ç›®çš„å¯ç»´æŠ¤æ€§ã€çµæ´»æ€§å’Œå¯æµ‹è¯•æ€§äº§ç”Ÿé‡å¤§å½±å“ã€‚

Learn the guiding principles that helps you build in the flexibility that your codebase needs in order to be able to react to new features and requirements, with as little effort as possible.äº†è§£è¿™äº›æŒ‡å¯¼åŸåˆ™ï¼Œå®ƒä»¬èƒ½å¸®åŠ©ä½ ä¸ºä»£ç åº“æ„å»ºæ‰€éœ€çš„çµæ´»æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿä»¥æœ€å°çš„å·¥ä½œé‡åº”å¯¹æ–°åŠŸèƒ½å’Œæ–°éœ€æ±‚ã€‚

Here's what I'd recommend learning right off the bat:ä»¥ä¸‹æ˜¯æˆ‘å»ºè®®ä½ ç«‹å³å­¦ä¹ çš„å†…å®¹ï¼š

- Component design principles: [The Stable Abstraction Principle](https://khalilstemmler.com/wiki/stable-abstraction-principle/), [The Stable Dependency Principle](https://khalilstemmler.com/wiki/stable-dependency-principle/), and The Acyclic Dependency Principle, for how to organize components, their dependencies, when to couple them, and the implications of accidentally creating dependency cycles and relying on unstable components.ç»„ä»¶è®¾è®¡åŸåˆ™ï¼š [ç¨³å®šæŠ½è±¡åŸåˆ™](https://khalilstemmler.com/wiki/stable-abstraction-principle/) ã€ [ç¨³å®šä¾èµ–åŸåˆ™](https://khalilstemmler.com/wiki/stable-dependency-principle/) å’Œæ— ç¯ä¾èµ–åŸåˆ™ï¼Œè¿™äº›åŸåˆ™æ¶‰åŠå¦‚ä½•ç»„ç»‡ç»„ä»¶ã€å®ƒä»¬çš„ä¾èµ–å…³ç³»ã€ä½•æ—¶è€¦åˆå®ƒä»¬ï¼Œä»¥åŠæ„å¤–åˆ›å»ºä¾èµ–å¾ªç¯å’Œä¾èµ–ä¸ç¨³å®šç»„ä»¶çš„å½±å“ã€‚
- [Policy vs. Detail](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/), for understanding how to separate the rules of your application from the implementation details.[ç­–ç•¥ä¸ç»†èŠ‚](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/) ï¼Œç”¨äºç†è§£å¦‚ä½•å°†åº”ç”¨ç¨‹åºçš„è§„åˆ™ä¸å®ç°ç»†èŠ‚åŒºåˆ†å¼€æ¥ã€‚
- Boundaries, and how to identify the [subdomains](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) that the features of your application belongs within.è¾¹ç•Œï¼Œä»¥åŠå¦‚ä½•ç¡®å®šåº”ç”¨ç¨‹åºåŠŸèƒ½æ‰€å±çš„ [å­åŸŸ](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) ã€‚

Uncle Bob discovered and originally documented many of these principles, so the best resource to learn about this is again, " [Clean Architecture](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ".é²å‹ƒå¤§å”å‘ç°å¹¶æœ€æ—©è®°å½•äº†å…¶ä¸­è®¸å¤šåŸåˆ™ï¼Œå› æ­¤äº†è§£è¿™ä¸€ç‚¹çš„æœ€ä½³èµ„æºä»ç„¶æ˜¯ã€Š [æ•´æ´æ¶æ„](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ã€‹ã€‚

### Learning resources å­¦ä¹ èµ„æº

- Clean Architecture, by Robert C. Martin ã€Šæ•´æ´æ¶æ„ã€‹ï¼Œä½œè€…ï¼šç½—ä¼¯ç‰¹Â·CÂ·é©¬ä¸

## Stage 7: Architectural Styles

Architecture is about the stuff that matters.æ¶æ„å…³ä¹é‡è¦çš„äº‹ç‰©ã€‚

It's about identifying what a system needs in order for it to be successful, and then stacking the odds of success by choosing the architecture that best fits the requirements.è¿™å…³ä¹äºç¡®å®šä¸€ä¸ªç³»ç»Ÿè¦å–å¾—æˆåŠŸæ‰€éœ€è¦çš„æ¡ä»¶ï¼Œç„¶åé€šè¿‡é€‰æ‹©æœ€ç¬¦åˆéœ€æ±‚çš„æ¶æ„æ¥å¢åŠ æˆåŠŸçš„å‡ ç‡ã€‚

For example, a system that has a lot of **business logic complexity** would benefit from using a **layered architecture** to encapsulate that complexity.ä¾‹å¦‚ï¼Œä¸€ä¸ªå…·æœ‰å¤§é‡ **ä¸šåŠ¡é€»è¾‘å¤æ‚æ€§** çš„ç³»ç»Ÿï¼Œå°†å—ç›Šäºä½¿ç”¨ **åˆ†å±‚æ¶æ„** æ¥å°è£…è¿™ç§å¤æ‚æ€§ã€‚

A system like Uber needs to be able to handle a lot of **real time-events** at once and update drivers' locations, so **publish-subscribe** style architecture might be most effective.åƒä¼˜æ­¥è¿™æ ·çš„ç³»ç»Ÿéœ€è¦èƒ½å¤ŸåŒæ—¶å¤„ç†å¤§é‡çš„å®æ—¶äº‹ä»¶</b0ï¼Œå¹¶æ›´æ–°å¸æœºçš„ä½ç½®ï¼Œå› æ­¤ **å‘å¸ƒ-è®¢é˜…** å¼æ¶æ„å¯èƒ½æ˜¯æœ€æœ‰æ•ˆçš„ã€‚

I'll repeat myself here because it's important to note that the 3 categories of architectural styles are similar to the 3 categories of design patterns, because **architectural styles are design patterns at the high-level**.æˆ‘åœ¨è¿™é‡Œå†é‡å¤ä¸€éï¼Œå› ä¸ºæœ‰å¿…è¦æŒ‡å‡ºï¼Œæ¶æ„é£æ ¼çš„3ä¸ªç±»åˆ«ä¸è®¾è®¡æ¨¡å¼çš„3ä¸ªç±»åˆ«ç›¸ä¼¼ï¼Œè¿™æ˜¯å› ä¸º **æ¶æ„é£æ ¼æ˜¯é«˜å±‚çº§çš„è®¾è®¡æ¨¡å¼** ã€‚

### Structrual

Projects with *varying levels* of components and wide-ranging functionality will either benefit or suffer from adopting a structural architecture.ç»„ä»¶çº§åˆ«å„å¼‚ä¸”åŠŸèƒ½èŒƒå›´å¹¿æ³›çš„é¡¹ç›®ï¼Œé‡‡ç”¨ç»“æ„åŒ–æ¶æ„è¦ä¹ˆä¼šä»ä¸­å—ç›Šï¼Œè¦ä¹ˆä¼šå› æ­¤å—æŸã€‚

Here are a few examples:ä»¥ä¸‹æ˜¯å‡ ä¸ªä¾‹å­ï¼š

- **Component-based** architectures emphasize separation of concerns between the *individual components* within a system. Think **Google** for a sec. Consider how many applications they have within their enterprise (Google Docs, Google Drive, Google Maps, etc). For platforms with lots of functionality, component-based architectures divide the concerns into loosely coupled independent components. This is a *horizontal* separation. **åŸºäºç»„ä»¶çš„** æ¶æ„å¼ºè°ƒç³»ç»Ÿå†… *å„ä¸ªç»„ä»¶* ä¹‹é—´çš„å…³æ³¨ç‚¹åˆ†ç¦»ã€‚ç¨æƒ³ä¸€ä¸‹ **è°·æ­Œ** ã€‚æƒ³æƒ³ä»–ä»¬ä¼ä¸šå†…éƒ¨æœ‰å¤šå°‘åº”ç”¨ç¨‹åºï¼ˆè°·æ­Œæ–‡æ¡£ã€è°·æ­Œäº‘ç«¯ç¡¬ç›˜ã€è°·æ­Œåœ°å›¾ç­‰ï¼‰ã€‚å¯¹äºå…·æœ‰å¤§é‡åŠŸèƒ½çš„å¹³å°ï¼ŒåŸºäºç»„ä»¶çš„æ¶æ„å°†å…³æ³¨ç‚¹åˆ’åˆ†ä¸ºæ¾è€¦åˆçš„ç‹¬ç«‹ç»„ä»¶ã€‚è¿™æ˜¯ä¸€ç§ *æ¨ªå‘* åˆ†ç¦»ã€‚
- **Monolithic** means that the application is combined into a single platform or program, deployed altogether. *Note: You can have a component-based AND monolithic architecture if you separate your applications properly, yet deploy it all as one piece*.**å•ä½“å¼** æŒ‡çš„æ˜¯åº”ç”¨ç¨‹åºè¢«æ•´åˆåˆ°ä¸€ä¸ªå•ä¸€å¹³å°æˆ–ç¨‹åºä¸­ï¼Œæ•´ä½“éƒ¨ç½²ã€‚ *æ³¨æ„ï¼šå¦‚æœå¯¹åº”ç”¨ç¨‹åºè¿›è¡Œäº†é€‚å½“æ‹†åˆ†ï¼ŒåŒæ—¶åˆä½œä¸ºä¸€ä¸ªæ•´ä½“éƒ¨ç½²ï¼Œé‚£ä¹ˆä½ å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªåŸºäºç»„ä»¶ä¸”é‡‡ç”¨å•ä½“å¼çš„æ¶æ„* ã€‚
- **Layered** architectures separate the concerns *vertically* by cutting software into infrastructure, application, and domain layers.**åˆ†å±‚** æ¶æ„é€šè¿‡å°†è½¯ä»¶åˆ’åˆ†ä¸ºåŸºç¡€è®¾æ–½å±‚ã€åº”ç”¨å±‚å’Œé¢†åŸŸå±‚ï¼Œåœ¨ *å‚ç›´æ–¹å‘* ä¸Šåˆ†ç¦»å…³æ³¨ç‚¹ã€‚

![[_posts/architect/ç½‘ç«™æ¶æ„/media/622d496c5a8c838f618da0ac62695585_MD5.svg]]

> An example of cutting the concerns of an application *vertically* by using a layered architecture. Read [here](https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/) for more information on how to do this.é€šè¿‡ä½¿ç”¨åˆ†å±‚æ¶æ„å‚ç›´åˆ’åˆ†åº”ç”¨ç¨‹åºå…³æ³¨ç‚¹çš„ç¤ºä¾‹ã€‚ç‚¹å‡»æ­¤å¤„äº†è§£æ›´å¤šç›¸å…³æ“ä½œä¿¡æ¯ã€‚

### Messaging

Depending on your project, messaging might be a really important component to the success of the system. For projects like this, message-based architectures build on top of functional programming principles and behavioural design patterns like the observer pattern.æ ¹æ®ä½ çš„é¡¹ç›®æƒ…å†µï¼Œæ¶ˆæ¯ä¼ é€’å¯èƒ½æ˜¯ç³»ç»ŸæˆåŠŸçš„ä¸€ä¸ªéå¸¸é‡è¦çš„ç»„æˆéƒ¨åˆ†ã€‚å¯¹äºè¿™ç±»é¡¹ç›®ï¼ŒåŸºäºæ¶ˆæ¯çš„æ¶æ„å»ºç«‹åœ¨å‡½æ•°å¼ç¼–ç¨‹åŸåˆ™å’Œè¡Œä¸ºè®¾è®¡æ¨¡å¼ï¼ˆå¦‚è§‚å¯Ÿè€…æ¨¡å¼ï¼‰ä¹‹ä¸Šã€‚

Here are a few examples of message-based architectural styles:ä»¥ä¸‹æ˜¯å‡ ç§åŸºäºæ¶ˆæ¯çš„æ¶æ„é£æ ¼ç¤ºä¾‹ï¼š

- **Event-Driven** architectures view all signficant changes to state as events. For example, within a [vinyl-trading app](https://github.com/stemmlerjs/white-label), a offer's state might change from "pending" to "accepted" when both parties agreee on the trade. **äº‹ä»¶é©±åŠ¨** æ¶æ„å°†æ‰€æœ‰é‡è¦çš„çŠ¶æ€å˜åŒ–è§†ä¸ºäº‹ä»¶ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ª [é»‘èƒ¶å”±ç‰‡äº¤æ˜“åº”ç”¨](https://github.com/stemmlerjs/white-label) ä¸­ï¼Œå½“åŒæ–¹å°±äº¤æ˜“è¾¾æˆä¸€è‡´æ—¶ï¼Œä¸€ä¸ªæŠ¥ä»·çš„çŠ¶æ€å¯èƒ½ä¼šä»â€œå¾…å¤„ç†â€å˜ä¸ºâ€œå·²æ¥å—â€ã€‚
- **Publish-subscribe** architectures build on top of the Observer design pattern by making it the primary communication method between the system itself, end-users / clients, and others systems and components.**å‘å¸ƒ-è®¢é˜…** æ¶æ„å»ºç«‹åœ¨è§‚å¯Ÿè€…è®¾è®¡æ¨¡å¼ä¹‹ä¸Šï¼Œå°†å…¶ä½œä¸ºç³»ç»Ÿæœ¬èº«ã€æœ€ç»ˆç”¨æˆ·/å®¢æˆ·ç«¯ä»¥åŠå…¶ä»–ç³»ç»Ÿå’Œç»„ä»¶ä¹‹é—´çš„ä¸»è¦é€šä¿¡æ–¹æ³•ã€‚

### Distributed åˆ†å¸ƒå¼

A distributed architecture simply means that the components of the system are deployed separately and operate by communicating over a network protocol. Distributed systems can be very effective for scaling throughput, scaling teams, and delegating (potentially expensive tasks or) responsibility to other components.åˆ†å¸ƒå¼æ¶æ„ç®€å•æ¥è¯´å°±æ˜¯ç³»ç»Ÿçš„å„ä¸ªç»„ä»¶åˆ†å¼€éƒ¨ç½²ï¼Œå¹¶é€šè¿‡ç½‘ç»œåè®®è¿›è¡Œé€šä¿¡æ¥è¿è¡Œã€‚åˆ†å¸ƒå¼ç³»ç»Ÿåœ¨æé«˜ååé‡ã€æ‰©å±•å›¢é˜Ÿè§„æ¨¡ä»¥åŠå°†ï¼ˆå¯èƒ½æˆæœ¬é«˜æ˜‚çš„ä»»åŠ¡æˆ–ï¼‰è´£ä»»åˆ†é…ç»™å…¶ä»–ç»„ä»¶æ–¹é¢éå¸¸æœ‰æ•ˆã€‚

A few examples of distributed architectural styles are:åˆ†å¸ƒå¼æ¶æ„é£æ ¼çš„ä¸€äº›ç¤ºä¾‹å¦‚ä¸‹ï¼š

- **Client-server** architecture. One of the most common architectures, where we divide the work to be done between the client (presentation) and the server (business logic). **å®¢æˆ·æœº-æœåŠ¡å™¨** æ¶æ„ã€‚è¿™æ˜¯æœ€å¸¸è§çš„æ¶æ„ä¹‹ä¸€ï¼Œæˆ‘ä»¬å°†éœ€è¦å®Œæˆçš„å·¥ä½œåœ¨å®¢æˆ·æœºï¼ˆè¡¨ç¤ºå±‚ï¼‰å’ŒæœåŠ¡å™¨ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰ä¹‹é—´è¿›è¡Œåˆ†é…ã€‚
- **Peer-to-peer** architectures distribute application-layer tasks between equally-privileged participants, forming a peer-to-peer network. **ç‚¹å¯¹ç‚¹** æ¶æ„åœ¨æƒé™å¹³ç­‰çš„å‚ä¸è€…ä¹‹é—´åˆ†é…åº”ç”¨å±‚ä»»åŠ¡ï¼Œå½¢æˆä¸€ä¸ªç‚¹å¯¹ç‚¹ç½‘ç»œã€‚

### Learning resources

- Clean Architecture, by Robert C. Martin ç½—ä¼¯ç‰¹Â·CÂ·é©¬ä¸æ‰€è‘—çš„ã€Šæ•´æ´æ¶æ„ã€‹
- Software Architect's Handbook, by Joseph Ingeno ã€Šè½¯ä»¶æ¶æ„å¸ˆæ‰‹å†Œã€‹ï¼Œä½œè€…ï¼šçº¦ç‘Ÿå¤«Â·è‹±æ ¼è¯º

## Stage 8: Architectural Patterns

Architectural *patterns* explain in greater tactical detail how to actually implement one of those architectural *styles*.æ¶æ„æ¨¡å¼æ›´è¯¦ç»†åœ°ä»æˆ˜æœ¯å±‚é¢è§£é‡Šäº†å¦‚ä½•å®é™…å®æ–½è¿™äº›æ¶æ„é£æ ¼ä¸­çš„ä¸€ç§ã€‚

Here are a couple of examples of architectural patterns and the styles that they inherit from:ä»¥ä¸‹æ˜¯å‡ ä¸ªæ¶æ„æ¨¡å¼åŠå…¶æ‰€ç»§æ‰¿çš„æ¶æ„é£æ ¼çš„ä¾‹å­ï¼š

- **[Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/)** is an approach to software development against really complex problem domains. For DDD to be most successful, we need to implement a **layered architecture** in order to separate the concerns of a domain model from the infrastrural details that makes the application actually run, like databases, webservers, caches, etc.**[é¢†åŸŸé©±åŠ¨è®¾è®¡](https://khalilstemmler.com/articles/domain-driven-design-intro/)** æ˜¯ä¸€ç§é’ˆå¯¹éå¸¸å¤æ‚çš„é—®é¢˜é¢†åŸŸçš„è½¯ä»¶å¼€å‘æ–¹æ³•ã€‚ä¸ºäº†ä½¿é¢†åŸŸé©±åŠ¨è®¾è®¡å–å¾—æœ€å¤§æˆåŠŸï¼Œæˆ‘ä»¬éœ€è¦å®æ–½ **åˆ†å±‚æ¶æ„** ï¼Œä»¥å°†é¢†åŸŸæ¨¡å‹çš„å…³æ³¨ç‚¹ä¸ä½¿åº”ç”¨ç¨‹åºå®é™…è¿è¡Œçš„åŸºç¡€è®¾æ–½ç»†èŠ‚ï¼ˆå¦‚æ•°æ®åº“ã€WebæœåŠ¡å™¨ã€ç¼“å­˜ç­‰ï¼‰åˆ†ç¦»å¼€æ¥ã€‚
- **Model-View Controller** is probably the most well-known architectural pattern for developing user interface-based applications. It works by dividing the app into 3 components: model, view, and controller. MVC is incredibly useful when you're first starting out, and it helps you piggyback towards other architectures, but there hit's a point when we realize [MVC isn't enough](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/) for problems with lots of business logic.**æ¨¡å‹-è§†å›¾-æ§åˆ¶å™¨** å¯èƒ½æ˜¯å¼€å‘åŸºäºç”¨æˆ·ç•Œé¢çš„åº”ç”¨ç¨‹åºæ—¶æœ€è‘—åçš„æ¶æ„æ¨¡å¼ã€‚å®ƒé€šè¿‡å°†åº”ç”¨ç¨‹åºåˆ†ä¸ºä¸‰ä¸ªç»„ä»¶æ¥å·¥ä½œï¼šæ¨¡å‹ã€è§†å›¾å’Œæ§åˆ¶å™¨ã€‚MVCåœ¨ä½ åˆšå¼€å§‹å¼€å‘æ—¶éå¸¸æœ‰ç”¨ï¼Œå®ƒèƒ½å¸®åŠ©ä½ è½»æ¾è¿‡æ¸¡åˆ°å…¶ä»–æ¶æ„ï¼Œä½†å½“æˆ‘ä»¬æ„è¯†åˆ°å¯¹äºåŒ…å«å¤§é‡ä¸šåŠ¡é€»è¾‘çš„é—®é¢˜è€Œè¨€ï¼Œ [MVCæ˜¯ä¸å¤Ÿçš„](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/) æ—¶ï¼Œæƒ…å†µå°±ä¸åŒäº†ã€‚
- **Event sourcing** is a functional approach where we store only the transactions, and never the state. If we ever need the state, we can apply all the transactions from the beginning of time.**äº‹ä»¶æº¯æº** æ˜¯ä¸€ç§å‡½æ•°å¼æ–¹æ³•ï¼Œæˆ‘ä»¬åªå­˜å‚¨äº‹åŠ¡ï¼Œä»ä¸å­˜å‚¨çŠ¶æ€ã€‚å¦‚æœæˆ‘ä»¬éœ€è¦çŠ¶æ€ï¼Œå¯ä»¥ä»ä¸€å¼€å§‹å°±åº”ç”¨æ‰€æœ‰äº‹åŠ¡ã€‚

### Learning resource

- Domain-Driven Design, by Eric Evans åŸƒé‡Œå…‹Â·åŸƒæ–‡æ–¯æ‰€è‘—çš„ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹
- Implementing Domain-Driven Design, by Vaughn Vernon ã€Šå®ç°é¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ï¼Œä½œè€…ï¼šæ²ƒæ©Â·å¼—å†œ

## Stage 9: Enterprise patterns

Any architectural pattern you choose will introduce a number of constructs and technical jargon to familiarize yourself with and decide on whether it's worth the effort to use or not.ä½ é€‰æ‹©çš„ä»»ä½•æ¶æ„æ¨¡å¼éƒ½ä¼šå¼•å…¥ä¸€äº›æ¦‚å¿µå’ŒæŠ€æœ¯æœ¯è¯­ï¼Œä½ éœ€è¦ç†Ÿæ‚‰è¿™äº›å†…å®¹ï¼Œå¹¶åˆ¤æ–­æ˜¯å¦å€¼å¾—èŠ±ç²¾åŠ›å»ä½¿ç”¨å®ƒã€‚

Taking an example that many of us know, in **MVC**, the *view* holds all the presentation layer code, the *controller* is translates commands and queries from the *view* into requests that are handled by the *model* and returned by the *controller*.ä¸¾ä¸€ä¸ªæˆ‘ä»¬å¾ˆå¤šäººéƒ½çŸ¥é“çš„ä¾‹å­ï¼Œåœ¨ **MVC** ä¸­ï¼Œ *è§†å›¾* åŒ…å«æ‰€æœ‰è¡¨ç¤ºå±‚ä»£ç ï¼Œ *æ§åˆ¶å™¨* å°†æ¥è‡ª *è§†å›¾* çš„å‘½ä»¤å’ŒæŸ¥è¯¢è½¬æ¢ä¸ºç”± *æ¨¡å‹* å¤„ç†å¹¶ç”± *æ§åˆ¶å™¨* è¿”å›çš„è¯·æ±‚ã€‚

Where in the Model (M) do we handle these things?:åœ¨æ¨¡å‹ï¼ˆMï¼‰ä¸­çš„å“ªä¸ªéƒ¨åˆ†å¤„ç†è¿™äº›äº‹æƒ…ï¼Ÿ

- validation logic éªŒè¯é€»è¾‘
- invariant rules ä¸å˜è§„åˆ™
- domain events é¢†åŸŸäº‹ä»¶
- use cases ç”¨ä¾‹
- complex queries å¤æ‚æŸ¥è¯¢
- and business logic ä»¥åŠä¸šåŠ¡é€»è¾‘

If we simply use an ORM (object-relational mapper) like Sequelize or TypeORM as the *model*, all that important stuff to gets left to interpretation on where it should go, and it finds itself in some unspecified layer between (what should be a rich) *model* and the *controller*.å¦‚æœæˆ‘ä»¬ç®€å•åœ°ä½¿ç”¨åƒ Sequelize æˆ– TypeORM è¿™æ ·çš„ORMï¼ˆå¯¹è±¡å…³ç³»æ˜ å°„å™¨ï¼‰ä½œä¸ºæ¨¡å‹</b2ï¼Œé‚£ä¹ˆæ‰€æœ‰é‡è¦çš„å†…å®¹éƒ½éœ€è¦å»åˆ¤æ–­åº”è¯¥æ”¾åœ¨å“ªé‡Œï¼Œç»“æœè¿™äº›å†…å®¹ä¼šå‡ºç°åœ¨ï¼ˆæœ¬åº”å†…å®¹ä¸°å¯Œçš„ï¼‰ *æ¨¡å‹* å’Œ *æ§åˆ¶å™¨* ä¹‹é—´æŸä¸ªä¸æ˜ç¡®çš„å±‚çº§ä¸­ã€‚

![[_posts/architect/ç½‘ç«™æ¶æ„/media/b66e66c0509e8ed0fbec3c1c085fbb96_MD5.svg]]

> Taken from "3.1 - Slim (Logic-less) models" in [solidbook.io](https://solidbook.io/).èŠ‚é€‰è‡ªsolidbook.ioçš„â€œ3.1 - ç²¾ç®€ï¼ˆæ— é€»è¾‘ï¼‰æ¨¡å‹â€ã€‚

If there's something I've learned so far in my journey going beyond MVC, it's that **there is a construct for everything**.åœ¨æˆ‘è¶…è¶ŠMVCçš„æ¢ç´¢ä¹‹æ—…ä¸­ï¼Œåˆ°ç›®å‰ä¸ºæ­¢æˆ‘å­¦åˆ°çš„ä¸€ç‚¹æ˜¯ï¼Œ **ä¸‡ç‰©çš†æœ‰å…¶æ„é€ ** ã€‚

For each of those things that MVC fails to address, in [Domain-Driven Design specifically](https://khalilstemmler.com/articles/domain-driven-design-intro/), there exist several **enterprise patterns** to solve them. For example:å¯¹äºMVCæœªèƒ½è§£å†³çš„æ¯ä¸€ä¸ªé—®é¢˜ï¼Œåœ¨ [ç‰¹åˆ«æ˜¯é¢†åŸŸé©±åŠ¨è®¾è®¡ä¸­](https://khalilstemmler.com/articles/domain-driven-design-intro/) ï¼Œéƒ½å­˜åœ¨å‡ ç§ **ä¼ä¸šçº§æ¨¡å¼** æ¥è§£å†³å®ƒä»¬ã€‚ä¾‹å¦‚ï¼š

- **[Entities](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/)** describe models that have an identity.**[å®ä½“](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/)** æè¿°å…·æœ‰æ ‡è¯†çš„æ¨¡å‹ã€‚
- **[Value Objects](https://khalilstemmler.com/articles/typescript-value-object/)** are models that have no identity, and can be used in order to encapsulate validation logic.**[å€¼å¯¹è±¡](https://khalilstemmler.com/articles/typescript-value-object/)** æ˜¯æ²¡æœ‰æ ‡è¯†çš„æ¨¡å‹ï¼Œå¯ç”¨äºå°è£…éªŒè¯é€»è¾‘ã€‚
- **[Domain Events](https://khalilstemmler.com/articles/typescript-domain-driven-design/chain-business-logic-domain-events/)** are events that signify some relevant business event occurring, and can be subscribed to from other components.**[é¢†åŸŸäº‹ä»¶](https://khalilstemmler.com/articles/typescript-domain-driven-design/chain-business-logic-domain-events/)** æ˜¯è¡¨ç¤ºå‘ç”Ÿäº†æŸäº›ç›¸å…³ä¸šåŠ¡äº‹ä»¶çš„äº‹ä»¶ï¼Œå…¶ä»–ç»„ä»¶å¯ä»¥è®¢é˜…è¿™äº›äº‹ä»¶ã€‚

Depending on the architectural style you've chosen, there are going to be *a ton* of other enterprise patterns for you to learn in order to implement that pattern to it's fullest potential. æ ¹æ®ä½ é€‰æ‹©çš„æ¶æ„é£æ ¼ï¼Œä½ è¿˜éœ€è¦å­¦ä¹ å¤§é‡å…¶ä»–ä¼ä¸šæ¨¡å¼ï¼Œæ‰èƒ½å……åˆ†å‘æŒ¥è¯¥æ¨¡å¼çš„æ½œåŠ›ã€‚

### Learning resources

These are just a few different learning resources mostly focused on Domain-Driven Design and Enteprise Application Architecture. But this is where there is the *most* to learn, and where you can *dive the deepest* in your learning, because it builds ontop of everything we've learned thus far.è¿™äº›åªæ˜¯ä¸€äº›ä¸åŒçš„å­¦ä¹ èµ„æºï¼Œä¸»è¦é›†ä¸­åœ¨é¢†åŸŸé©±åŠ¨è®¾è®¡å’Œä¼ä¸šåº”ç”¨æ¶æ„æ–¹é¢ã€‚ä½†è¿™æ­£æ˜¯æœ‰æœ€å¤šçŸ¥è¯†å¯ä»¥å­¦ä¹ çš„åœ°æ–¹ï¼Œä¹Ÿæ˜¯ä½ èƒ½åœ¨å­¦ä¹ ä¸­é’»ç ”å¾—æœ€æ·±å…¥çš„åœ°æ–¹ï¼Œå› ä¸ºå®ƒå»ºç«‹åœ¨æˆ‘ä»¬è¿„ä»Šä¸ºæ­¢æ‰€å­¦çš„ä¸€åˆ‡åŸºç¡€ä¹‹ä¸Šã€‚

- Patterns of Enterprise Application Architecture, by Martin Fowler ã€Šä¼ä¸šåº”ç”¨æ¶æ„æ¨¡å¼ã€‹ï¼Œé©¬ä¸Â·ç¦å‹’è‘—
- Enterprise Integration Patterns, by Gregor Hohpe ã€Šä¼ä¸šé›†æˆæ¨¡å¼ã€‹ï¼Œä½œè€…ï¼šæ ¼é›·æˆˆå°”Â·éœæ™®
- Domain Driven Design, by Eric Evans ã€Šé¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ï¼ŒåŸƒé‡Œå…‹Â·åŸƒæ–‡æ–¯ è‘—
- Implementing Domain-Driven Design, by Vaughn Vernon ã€Šå®ç°é¢†åŸŸé©±åŠ¨è®¾è®¡ã€‹ï¼Œä½œè€…ï¼šæ²ƒæ©Â·å¼—å†œ

## Resources & Conclusion

We talk a lot about [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) on this blog, but there's a lot readers would benefit from knowing first (like layered architectures, oop, model-driven design, design principles and patterns) before we dive deep on building rich domain models with TypeScript.æˆ‘ä»¬åœ¨è¿™ä¸ªåšå®¢ä¸­ç»å¸¸è°ˆè®ºé¢†åŸŸé©±åŠ¨è®¾è®¡</b0ï¼Œä½†åœ¨æ·±å…¥æ¢è®¨å¦‚ä½•ä½¿ç”¨TypeScriptæ„å»ºä¸°å¯Œçš„é¢†åŸŸæ¨¡å‹ä¹‹å‰ï¼Œè¯»è€…ä»¬æœ€å¥½å…ˆäº†è§£å¾ˆå¤šçŸ¥è¯†ï¼ˆæ¯”å¦‚åˆ†å±‚æ¶æ„ã€é¢å‘å¯¹è±¡ç¼–ç¨‹ã€æ¨¡å‹é©±åŠ¨è®¾è®¡ã€è®¾è®¡åŸåˆ™å’Œæ¨¡å¼ï¼‰ã€‚

## References

- [Wikipedia: List of architectural styles and patterns ç»´åŸºç™¾ç§‘ï¼šå»ºç­‘é£æ ¼ä¸æ¨¡å¼åˆ—è¡¨](https://en.wikipedia.org/wiki/List_of_software_architecture_styles_and_patterns)
- [Architectural styles vs. architectural patterns vs. design patterns æ¶æ„é£æ ¼ä¸æ¶æ„æ¨¡å¼ä¸è®¾è®¡æ¨¡å¼](https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/)
- [The Clean Architecture æ•´æ´æ¶æ„](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)


---