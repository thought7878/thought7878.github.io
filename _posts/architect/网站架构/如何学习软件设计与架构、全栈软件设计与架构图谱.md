---
title: "How to Learn Software Design and Architecture | The  Full-stack Software Design & Architecture Map | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/software-design-architecture/full-stack-software-design/"
author:
  - "[[Khalil Stemmler]]"
published: 2019-09-28
created: 2025-10-10
description: "Software Design and Architecture is pretty much its own field of study within the realm of computing, like DevOps or UX Design. Here's a map describing the breadth of software design and architecture, from clean code to microkernels."
tags:
  - "clippings"
---
# notebooklm总结
该文章提供了一份关于**学习软件设计与架构的路线图**（“The Full-stack Software Design & Architecture Map”），该领域被视为计算机领域内一个独立的学习分支，类似于DevOps或UX设计。文章旨在*帮助开发者，尤其是初级或自学开发者，克服学习如何设计干净且可扩展的系统*所面临的巨大挑战。

### 软件设计与架构的根本目标

文章首先应用**第一性原理**来解构问题，确定*软件的首要目标：*

- `核心目标`： 软件的目标是**持续地生产出满足用户需求的产品**，*同时将实现这一目标所需的努力降至最低*。
- `设计的重要性`： 由于用户*需求经常变化*，软件必须被**设计成易于更改（可扩展性）**。*如果软件难以更改*，它就被认为是糟糕的软件，*因为它阻碍了我们满足用户的当前需求*。


### 软件设计与架构的九个阶段
文章将软件设计和架构的学习过程**分解为九个阶段**（或称之为 **“堆栈”**），*每个阶段都建立在前一个阶段的基础之上*。

#### Stage 1: Clean Code (干净代码)

这是创建持久软件的第一步。`干净代码`通常被定义为**易于理解和更改的代码**。

- **低级表现：** 包括*保持一致性*、偏好*使用有意义的变量/方法/类名*而非注释、*正确的缩进和间距、确保所有测试都能运行、编写没有副作用的纯函数、不传递null*。这些`规范`被称为`编码约定`。
- **核心要素：** *干净代码包括三个方面*：`开发者心态`（例如同理心、匠人精神、设计思维）、`编码约定`（例如命名、重构、测试）、`技能与知识`（例如模式、原则、避免代码异味和反模式）。
- **同理心：** 开发者不仅为最终用户写代码，*也为自己、队友、项目未来的维护者，写代码*。同理心是描述这一阶段的最佳词汇。
- **学习资源：** Robert C. Martin的《Clean Code》被认为是学习编写干净代码的最佳资源。

#### Stage 2: Programming Paradigms (编程范式)

在编写可读且易于维护的代码后，理解*三大主要编程范式*（结构化、面向对象、函数式）及*其对代码编写方式的影响*非常重要。

- **范式分工：** 根据Robert C. Martin的观点，有效的软件*会混合使用这三种范式：*
    - **面向对象编程（OOP）：** 最适合用于定义*如何通过多态性和插件跨越架构边界*。
    - **函数式编程：** 用于*将数据推送到应用程序的边界*。
    - **结构化编程：** 用于*编写算法*。

#### Stage 3: Object-Oriented Programming (面向对象编程)

对于架构而言，OOP是明确的“工具”。

- **价值：** OOP不仅能实现**插件架构**和构建灵活性，其四大原则（封装、继承、多态性、抽象）还有助于创建**丰富的领域模型**。
- **目标：** 学习如何创建问题领域的软件实现，并将其置于**分层**Web应用程序的中心，这通常需要熟悉模型驱动设计和**领域驱动设计（DDD）**。

#### Stage 4: Design Principles (设计原则)

`设计原则`是*经过实践检验、完善的面向对象最佳实践*，它们充当了**指导框架**，*帮助解决OOP可能引入的设计挑战*（例如何时使用组合或继承）。

- **示例：** **组合优于继承**、封装变化点、针对抽象编程而非具体实现、`SOLID原则`（尤其是`单一职责`原则）、`DRY`（不重复自己）和`YAGNI`（你不会需要它）。
- **提示：** 开发者应得出自己的结论，而不是盲目遵循他人的说法。

#### Stage 5: Design Patterns (设计模式)

**软件中的几乎所有问题都已被分类和解决**，***这些解决方案***被称为`设计模式`。设计模式*分为三类*：**创建型**、**结构型**、**行为型**。

- `创建型`： *控制对象的创建方式*（例如：*单例模式*、抽象工厂模式、原型模式）。
- `结构型`： *简化组件之间关系*的定义（例如：*适配器模式*、桥接模式、装饰器模式）。
- `行为型`： *促进对象之间优雅的通信*（例如：*模板模式*、中介者模式、*观察者模式*）。

**设计模式与架构模式的关系：** ***架构模式本质上是设计模式在高层次上的规模化扩展，而设计模式是低层次的实现（更接近类和函数）***。

#### Stage 6: Architectural Principles (架构原则)

**该阶段进入了超越类级别的高层次思考**。学习这些指导原则**有助于*代码库构建*所需的灵活性（可扩展性），以便用最少的努力应对新功能和需求**。

- **推荐学习：** *组件设计原则*（稳定抽象原则、稳定依赖原则、非循环依赖原则）、*策略与细节分离*（Policy vs. Detail）、*边界*（识别应用功能所属的子领域）。
- **学习资源：** Robert C. Martin的《Clean Architecture》。

#### Stage 7: Architectural Styles (架构风格)

架构关注的是对系统成功至关重要的事情，***通过选择最符合需求的架构*来增加成功的几率**。***架构风格是高层次的设计模式***。

- **结构化风格：** *适用于具有不同组件和广泛功能的项目*。示例：`分层架构`（*将关注点垂直切分*为*基础设施、应用、领域层*）、`组件式架构`（*水平分离关注点*）、`单体式架构`。
- **消息传递风格：** *建立在函数式编程原则和行为设计模式之上*。示例：`事件驱动架构`（将所有显著的状态变化视为事件）、`发布-订阅架构`。
- **分布式风格：** *系统的组件被分开部署，通过网络协议进行通信*。示例：`客户端-服务器架构`、`对等网络（Peer-to-peer）架构`。

#### Stage 8: Architectural Patterns (架构模式)

`架构模式`以更具战术性的细节**解释了如何实际实现一种架构风格**。

- **示例：**
    - `领域驱动设计（DDD）`： 一种*针对复杂问题域*的开发方法，通常需要实现**分层架构**来隔离领域模型和基础设施细节。
    - `模型-视图-控制器（MVC）`： 一种*流行的UI应用架构模式*，将应用分为模型、视图和控制器。当业务逻辑复杂时，MVC可能不足。
    - `事件溯源（Event Sourcing）`： 一种*函数式方法*，只存储事务，通过应用所有事务来重建状态。

#### Stage 9: Enterprise Patterns (企业级模式)

任何架构模式都会引入一系列需要熟悉的构造和技术术语。`企业级模式`旨在**解决特定架构模式未能充分解决的细节问题**。

- **MVC遗留问题：** MVC未能明确在模型（M）中处理*验证逻辑、业务规则、领域事件、用例、复杂查询*的位置。
- **DDD中的企业模式示例：**
    - **实体（Entities）：** 描述具有身份的模型。
    - **值对象（Value Objects）：** 没有身份的模型，可用于封装验证逻辑。
    - **领域事件（Domain Events）：** 表示发生的、相关的业务事件，可供其他组件订阅。
- **学习资源：** Martin Fowler的《Patterns of Enterprise Application Architecture》和Eric Evans的《Domain Driven Design》。

总结来说，这个学习路线图（Map）旨在为开发者提供一个**结构化的路径**，从编写低级**干净代码**的基础开始，逐步掌握编程范式、OOP、设计原则和模式，最终达到高层次的**架构原则、风格和企业级模式**，从而能够生产出高质量、可维护的软件。


# 豆包总结
## 一、文档概述
- **基础信息**：网页标题为“如何学习软件设计与架构 | 全栈软件设计与架构图谱”，最后更新于2024年3月18日，读者已将其翻译为日语版本。
- **核心定位**：软件设计与架构是计算领域内独立的研究领域（类似DevOps、UX设计），旨在为初级/自学/中级开发者提供清晰路径，解决“项目迭代1-2次后代码变难维护”的痛点，帮助其掌握“设计简洁且可扩展系统”的能力。
- **核心框架**：通过“架构栈”（类似OSI模型，分层构建，从高层概念到低层细节）和“架构图谱”（更详细，高清PNG可在作者GitHub获取）呈现学习范围。


## 二、核心理念
### 1. 第一性原理（问题拆解方法）
- `定义`：**将问题拆解至无法再分的“原子层面”，从确定为真的部分重构解决方案**，是应对软件设计复杂性的核心思路。
- 软件目标推导：基于第一性原理，软件的核心目标是“持续创造满足用户需求的产物，同时最小化实现成本”——无法满足用户需求的不是好软件，难以修改（无法适配用户需求变化）的也不是好软件。


## 三、软件设计与架构学习路径（9个阶段）
### 阶段1：整洁代码（Clean Code）
- **核心定义**：整洁代码需满足三要素：
  1. 开发者思维（同理心、工匠精神、成长型思维、设计思维）；
  2. 编码规范（有意义的命名、重构、测试、缩进/间距一致等）；
  3. 技能知识（识别设计模式、原则，规避代码异味与反模式）。
- **关键提醒**：代码不仅服务终端用户，还需考虑队友、未来维护者，“同理心”是核心心态。
- **学习资源**：《代码整洁之道》（Robert C. Martin）、《重构》（Martin Fowler，第2版）、《程序员修炼之道》、《日常物品设计》。

### 阶段2：编程范式（Programming Paradigms）
- **三大核心范式及作用**：
  - 面向对象编程（OOP）：通过多态、插件定义架构边界，构建灵活系统；
  - 函数式编程：将数据推送到应用程序边界；
  - 结构化编程：用于编写算法。
- **关键观点**：有效软件需“混合使用三大范式”，而非单一依赖（避免“手持锤子看什么都像钉子”）。
- **学习资源**：《整洁架构》（Robert C. Martin）、《领域建模：函数式实现》、《编程语言概念》（第10版）。

### 阶段3：面向对象编程（OOP）
- **核心价值**：不仅支持“插件架构”，还通过封装、继承、多态、抽象四大原则构建“丰富领域模型”，将业务逻辑封装于零依赖的领域模型中。
- **常见误区**：多数开发者仅学OOP语法，未掌握“将问题领域的软件实现置于分层Web应用核心”的能力。
- **学习资源**：《对象设计风格指南》、《整洁架构》、《领域驱动设计》（Eric Evans）。

### 阶段4：设计原则（Design Principles）
- **核心作用**：作为OOP的“护栏”，解决设计决策难题（如“何时用组合/继承/抽象类”）。
- **关键原则**：组合优于继承、封装变化部分、针对抽象编程（而非具体实现）、好莱坞原则、SOLID原则（尤其单一职责）、DRY（不重复代码）、YAGNI（无需提前实现未必需功能）。
- **学习资源**：《Head First设计模式》、《GoF设计模式》。

### 阶段5：设计模式（Design Patterns）
- **分类与示例**：
  1. 创建型：控制对象创建（单例、抽象工厂、原型模式）；
  2. 结构型：简化组件关系（适配器、桥接、装饰器模式）；
  3. 行为型：优化对象通信（模板、中介者、观察者模式）。
- **关键提醒**：设计模式可能增加复杂度，需遵循YAGNI，仅在确有必要时使用；架构模式本质是“放大到高层级的设计模式”。
- **学习资源**：《Head First设计模式》。

### 阶段6：架构原则（Architectural Principles）
- **核心目标**：在“类级别之上”的层面，确保系统可维护性、灵活性、可测试性，适配新需求。
- **关键原则**：
  1. 组件设计原则：稳定抽象原则、稳定依赖原则、无环依赖原则（解决组件组织、依赖耦合问题）；
  2. 策略与细节分离（区分应用规则与实现细节）；
  3. 识别子域（明确应用功能所属边界）。
- **学习资源**：《整洁架构》（Robert C. Martin）。

### 阶段7：架构风格（Architectural Styles）
- **分类与示例**（本质是“高层级设计模式”）：
  1. 结构型：按组件/功能划分（基于组件架构、单体架构、分层架构）；
  2. 消息传递型：基于事件/订阅（事件驱动架构、发布-订阅架构）；
  3. 分布式：组件独立部署+网络通信（客户机-服务器、点对点架构）。
- **学习资源**：《整洁架构》、《软件架构师手册》（Joseph Ingeno）。

### 阶段8：架构模式（Architectural Patterns）
- **定义**：更详细的“战术层面指南”，指导如何实现架构风格。
- **关键模式**：
  1. 领域驱动设计（DDD）：针对复杂领域，需结合分层架构分离领域模型与基础设施（数据库、缓存等）；
  2. MVC：适用于UI应用，分模型、视图、控制器，但无法应对大量业务逻辑；
  3. 事件溯源：函数式方法，仅存储事务、不存储状态，需状态时回溯所有事务。
- **学习资源**：《领域驱动设计》、《实现领域驱动设计》（Vaughn Vernon）。

### 阶段9：企业模式（Enterprise Patterns）
- **核心作用**：解决MVC未覆盖的问题（如验证逻辑、不变规则、领域事件、复杂查询的归属）。
- **关键模式**（以DDD为例）：实体（有标识的模型）、值对象（无标识，封装验证逻辑）、领域事件（触发业务相关通知）。
- **学习资源**：《企业应用架构模式》（Martin Fowler）、《企业集成模式》、《领域驱动设计》、《实现领域驱动设计》。


## 四、核心资源汇总
1. **书籍**：覆盖各阶段的经典著作（如《代码整洁之道》《领域驱动设计》《企业应用架构模式》等，详见各阶段资源）；
2. **手册**：作者预发布的一站式资源《solidbook.io - 软件设计与架构手册》（完整版完成前打折，覆盖图谱各阶段核心知识）；
3. **图谱**：高清架构图谱可在作者GitHub获取；
4. **通讯**：订阅后每周获取“高级开发通讯”，加入20000+开发者社区。


## 五、作者信息
- **作者**：Khalil Stemmler，定位“Software Essentialist”（软件本质主义者）；
- **理念**：通过“软件本质主义”（Software Essentialism），帮助“代码优先”的开发者突破瓶颈（克服无聊、 impostor综合征、方向缺失），掌握软件设计、架构、测试的“80/20关键知识”；
- **服务**：提供课程（Testing Mastery、The Software Essentialist）、教练服务，及每周实用建议通讯。

---

# 原文
Last updated Mar 18th, 2024 
最后更新于2024年3月18日

Software Design and Architecture is pretty much its own field of study within the realm of computing, like DevOps or UX Design. Here's a map describing the breadth of software design and architecture, from clean code to microkernels.
软件设计与架构在计算领域中几乎是一个*独立的研究领域*，就像开发运维（DevOps）或用户体验（UX）设计一样。这里有一张图表，描述了从整洁代码到微内核的软件设计与架构的广度。

  
![[_posts/architect/网站架构/media/d69587d334fb8b4bdd53f11291318e04_MD5.png]]

You ever think about what it took for some of the world's most skilled developers to learn how to build systems within companies like Uber, YouTube, Facebook, or Github?
*你有没有想过，世界上一些最顶尖的开发者是付出了怎样的努力，才学会在优步、YouTube、脸书或Github这类公司里搭建系统的？*

It's crazy to me to consider the fact that Facebook was once an empty text file on someone's computer, and now it's this gargantuan company that has dipped it's toes into just about everything, and has personally impacted over [1.59 billion people](https://zephoria.com/top-15-valuable-facebook-statistics/) worldwide.
想到脸书曾经只是某人电脑上一个空白的文本文件，而现在却成了一家涉足几乎所有领域的巨头公司，还亲身影响了全球超过15.9亿人，我就觉得不可思议。

As a junior, self-taught developer or even intermediate developer, the roadmap to continued growth towards actually learning how to design *clean* and *scalable* systems seems kind of daunting. 
作为一名初级、自学成才的开发者，甚至是中级开发者，想要不断成长，真正学会如何设计 *简洁* 且 *可扩展* 的系统，这条道路似乎有些令人望而生畏。

For a lot of us, our projects die after one or two iterations because the code turns into an unmaintainable mess.
对我们很多人来说，我们的*项目在一两次迭代后就夭折了，因为代码变成了难以维护的一团乱麻*。

So where do we even *start* in order to learn how to improve our designs?
那么，为了学习如何改进我们的设计，我们究竟该从哪里 *开始* 呢？

The truth is: 
事实是：

> Software design and architecture is a *huge* topic 
> 软件设计和架构是一个 *庞大* 的话题

Understanding how to:
了解如何：

- Architect a system to serve the needs of its users 
	- **设计一个系统以满足其用户的需求**
- Write code that's easy to change 
	- **编写易于修改的代码**
- Write code that's easy to maintain 
	- **编写易于维护的代码**
- Write code that's easy to test 
	- **编写易于测试的代码**

... is *very* hard. The breadth of learning required is just so large.……
非常困难。**所需学习的广度实在太大了**。

And even though you know how to write code to make things work at least *once*, the bigger challenge is to figure out how to write code that makes it easy to change in order to *keep up with the current requirements*.
尽管你知道如何编写代码至少能让程序运行 *一次* ，但更大的挑战是*弄清楚如何编写便于修改的代码*，以便 *跟上当前的需求* 。

But again, where to start?...
但问题又来了，从哪里开始呢？……

---

Anytime I'm faced with a complex problem, I go back to [first principles](https://jamesclear.com/first-principles).
**每当我遇到复杂问题时，我都会回归到 [第一性原理](https://jamesclear.com/first-principles)** 。

## First Principles

First principles is the most effective way to break down problems. 
`第一性原理`是**分解问题最有效的方法**。

It works by deconstructing a problem all the way down to the **atomic level** where we can't deconstruct it anymore, and then reconstructing a solution from the parts that we're absolutely sure are true.
它的`工作原理`是**将一个问题一直拆解到无法再拆解的*原子层面* ，然后从我们绝对确定为真实的部分重新构建出解决方案**。

So let's apply it to software by first stating the goal.
*那么，让我们先明确目标，再将其应用到软件中。*

What is the primary goal of software?
**软件的主要目标是什么？**

> The goal of software is to *continually* **produce something that satisfies the needs of its users**, while minimizing the effort it takes to do so.
> `软件的目标`是*不断地创造出满足用户需求的东西，同时将实现这一目标所需的努力降至最低*。

I fought with coming up with the best definition for a long time, and I'm prepared to argue with you about why I think that's accurate.
很长一段时间里，我都在努力想出最恰当的定义，而且我已经准备好和你争论为什么我认为这个定义是准确的。

Software that doesn't serve the needs of its users, simply isn't good software.
无法满足用户需求的软件，根本算不上好软件。

And since the needs of our users changes often, it's important to make sure that software **was designed in order to be changed**.
而且**由于我们用户的需求经常变化，确保软件的设计便于修改就显得很重要**。

If software cannot be changed (easily), that makes it bad software, because it prevents us from satisfying the *current* needs of our users.
*如果软件（难以）更改，那它就是糟糕的软件，因为这会阻碍我们满足用户当前的需求*。

---

We've established that design matters, and it's important to learn how to produce well-designed software, but it can be a long road.
我们已经明确设计很重要，而且学会如何设计良好的软件也很关键，但这可能是一条漫长的道路。

In this article, I'd like to present to you what I believe are the concrete pillars of software design and architecture. 
在本文中，我想向大家介绍*我所认为的软件设计与架构的具体支柱*。

## The stack

Before I show you the map, let me show you the *stack*.
在给你展示这个图谱之前，让我先为你介绍一下这个*架构栈*。

Similar to something like the [OSI Model](https://en.wikipedia.org/wiki/OSI_model), each layer builds on top of the foundation of the previous one.
类似于开放系统互连模型（OSI Model）之类的东西，**每一层都建立在前一层的基础之上**。

![[_posts/architect/网站架构/media/504b84e2a4e3b3a9d1cc9be6cbcae614_MD5.png]]

The software design and architecture stack shows all of the layers of software design, from the most high-level concepts to the most low-level details.
`软件设计`和`架构栈`**展示了软件设计的所有层级，从最高级别的概念到最低级别的细节**。

In the stack, I've included examples to *some* of the most important concepts at that layer, but not all (because there are way too many).
在这个堆叠结构中，我已经*包含了该层级一些最重要概念*的示例，但并非全部（因为实在太多了）。

Now, check out the map. While I think the stack is good to see the bigger picture, the map is a little bit more detailed, and as a result, I think it's more useful.
现在，看看这张地图。虽然我认为这个堆叠图*有助于了解整体情况*，但这张地图（下面）更详细一些，因此我觉得它更有用。

## The map

To avoid running up my bandwidth, I reduced the quality of the map shown on site. If you'd like to get a high-quality png, you can find that up on my [GitHub](https://github.com/stemmlerjs/software-design-and-architecture-roadmap).
为了避免占用过多带宽，我降低了网站上显示的地图质量。如果你想要高清PNG格式的地图，可以去我的 [GitHub](https://github.com/stemmlerjs/software-design-and-architecture-roadmap) 上获取。

Below is the map for software design and architecture.
以下是**软件设计和架构的图谱**：

![[_posts/architect/网站架构/media/260e84a6cce3e50d74469e4b388262c2_MD5.png]]

## Stage 1: Clean code
参考：[[如何编写 整洁代码？]]

The very first step towards creating long-lasting software is figuring out how to write **clean code**. 
创建**经久耐用的**软件，第一步就是弄清楚如何编写 **整洁的代码** 。

If you ask anyone what they think constitutes *clean code*, you'll probably get a different answer every time. A lot of times, you'll hear that *clean code* is code that is easy to understand and change. At the low-level, this manifests in a few design choices like:
如果你问任何人他们认为什么构成了 *整洁的代码* ，你很可能每次都会得到不同的答案。很多时候，你会听到人们说， *整洁的代码* 是**易于理解和修改**的代码。在底层，这体现在一些设计选择上，比如：

- being consistent 
	- *保持一致性*
- preferring meaningful variable, method and class names over writing comments 
	- 倾向于*使用有意义的变量名、方法名和类名*，而非编写注释
- ensuring code is indented and spaced properly 
	- 确保*代码缩进和间距*适当
- ensuring all of the tests can run 
	- 确保所有*测试*都能运行
- writing pure functions with no side effects 
	- 编写*无副作用的纯函数*
- not passing null 
	- 不传递空值

These may seem like small things, but think of it like a game of Jenga. In order to keep the structure of our project stable over time, things like indentation, small classes and methods, and meaningful names, pay off a lot in the long run. 这些看起来可能都是小事，但可以把它想象成叠叠乐游戏。为了让我们项目的结构长期保持稳定，像缩进、小型类和方法以及有意义的命名之类的细节，从长远来看会带来很大的回报。

If you ask me, this aspect of *clean code* is about having good **coding conventions** and following them. 在我看来， *整洁代码* 的这一方面在于拥有良好的 **编码规范** 并遵循它们。

I belive that's only *one* aspect of writing *clean code*.我认为这只是编写 *整洁代码* 的 *一个* 方面。

My definitive explanation of clean code consists of:我对整洁代码的确切解释包括：

- 🧠 Your developer mindset (empathy, craftsmanship, growth mindset, design thinking) 🧠 你的开发者思维模式（同理心、工匠精神、成长型思维、设计思维）
- ⚙️ Your coding conventions (naming things, refactoring, testing, etc) ⚙️ 你的编码规范（命名、重构、测试等）
- 🤹🏼 Your skills & knowledge (of patterns, principles, and how to avoid code smells and anti-patterns) 🤹🏼 你的技能和知识（关于模式、原则，以及如何避免代码异味和反模式）

Getting into the right mindset is incredibly important if you want to write clean code. One requirement is that you should care enough to learn about the business you're writing code within. If we don't care about the domain enough to understand it, then how can we be sure we're using **good names** to represent domain concepts? How can we be sure that we've accurately captured the functional requirements? 如果你想写出整洁的代码，拥有正确的心态至关重要。其中一个要求是，你应该足够用心去了解自己编写代码所涉及的业务。如果我们对相关领域不够关注，未能理解它，那么我们如何确保自己使用了恰当的名称来代表领域概念呢？我们又如何确保自己准确捕捉到了功能需求呢？

If we don't care about the code that we're writing, it's a lot less likely that we're going to implement essential coding conventions, have meaningful discussions, and ask for feedback on our solutions.如果我们不在意自己正在编写的代码，那么我们就不太可能去遵循基本的编码规范、进行有意义的讨论，也不会就自己的解决方案寻求反馈。

We often think that code is solely written to serve the needs of the *end user*, but we forget the **other people we write code for**: us, our teammates, and the project's future maintainers. Having an understanding of the principles of *design* and how human psychology decides what is *good* and *bad* design, will help us write better code.我们常常认为代码仅仅是为了满足 *终端用户* 的需求而编写的，但我们忘记了 **我们为其编写代码的其他人** ：我们自己、我们的队友以及项目未来的维护者。理解 *设计* 原则，以及人类心理学如何判定什么是 *好的* 设计和 *差的* 设计，将有助于我们编写更好的代码。

So essentially, the best word that describes this step of your journey? **Empathy**.所以本质上，最能描述你这段旅程中这一步的词是什么？ **同理心** 。

Once we've got that down, learn the *tricks of the trade* and continue to improve them them over time by improving your knowledge of the essential software development patterns and principles.一旦我们掌握了这一点，就要学习行业诀窍，并通过不断加深对基本软件开发模式和原则的理解，来持续改进这些诀窍。

### Learning resources

- Clean Code, by Robert C. Martin 《代码整洁之道》，作者：罗伯特·C·马丁
- Refactoring, by Martin Fowler (2nd edition) 《重构》，马丁·福勒（第2版）
- The Pragmatic Programmer, by Andy Hunt and Dave Thomas 《程序员修炼之道》，作者：安迪·亨特与戴夫·托马斯
- The Design of Everyday Things, by Don Norman 《日常物品设计》，作者：唐·诺曼

The best resource to learn how to write clean code is Uncle Bob's book, " [Clean Code](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) ".
学习如何编写整洁代码的最佳资源是鲍勃大叔的《 [Clean Code](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) 》一书。

## Stage 2: Programming Paradigms

Now that we're writing readable code that's easy to maintain, it would be a good idea to really understand the 3 major programming paradigms and the way they influence how we write code.既然我们现在编写的代码可读性强且易于维护，那么真正理解三大主要编程范式以及它们对我们编写代码方式的影响会是个不错的主意。

In Uncle Bob's book, " [Clean Architecture](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ", he brings attention to the fact that:在鲍勃大叔的《 [整洁架构](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) 》一书中，他提醒人们：

- Object-Oriented Programming is the tool best suited for defining how we cross architectural boundaries with polymorphism and plugins 面向对象编程是最适合通过多态性和插件来定义我们如何跨越架构边界的工具。
- Functional programming is the tool we use to push data to the boundaries of our applications 函数式编程是我们用来将数据推送到应用程序边界的工具
- and Structured programming is the tool we use to write algorithms 而结构化编程是我们用来编写算法的工具

This implies that effective software uses a hybrid all 3 programming paradigms styles at different times.这意味着有效的软件会在不同时期采用这三种编程范式的混合风格。

While you *could* take a strictly functional or strictly object-oriented approach to writing code, understanding where each excels will improve the quality of your designs.虽然你可以采用纯函数式或纯面向对象的方法来编写代码，但了解每种方法的优势所在，将会提高你的设计质量。

> If all you have is a hammer, everything seems like a nail.如果你手里只有一把锤子，那么一切看起来都像钉子。

### Learning resources

- Clean Architecture, by Robert C. Martin 《整洁架构》，作者：罗伯特·C·马丁
- Domain Modeling Made Functional, by Scott Wlaschin 《领域建模：函数式实现》，作者：斯科特·沃拉斯钦
- Concepts of Programming Languages, Robert W. Sebesta (10th edition) 《编程语言概念》，罗伯特·W·塞贝斯塔（第10版）

## Stage 3: Object-Oriented Programming

It's important to know how each of the paradigms work and how they urge you to structure the code within them, but with respect to architecture, Object-Oriented Programming is the clear *tool for the job*.了解每种范式的工作原理以及它们如何促使你在其中构建代码很重要，但就架构而言，面向对象编程显然是完成这项工作的工具。

Not only does Object-Oriented programming enable us to create a **plugin architecture** and build flexibility into our projects; OOP comes with the 4 principles of OOP (encapsulation, inheritance, polymorhism, and abstraction) that help us create **rich domain models**.面向对象编程不仅能让我们创建插件架构，为项目注入灵活性；它还具备面向对象编程的四大原则（封装、继承、多态和抽象），帮助我们构建丰富的领域模型。

Most developers learning Object-Oriented Programming never get to this part: learning how to create a software implementation of the problem domain, and locating it in the center of a **layered** web app. 大多数学习面向对象编程的开发者从未接触到这部分内容：学习如何创建问题领域的软件实现，并将其置于分层Web应用的核心位置。

Functional programming can seem like the means to all ends in this scenario, but I'd recommend getting acquainted with model-driven design and [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) to understand the bigger picture on how object-modelers are able to encapsulate an entire business in a zero-dependency domain model.在这种情况下，函数式编程似乎是解决所有问题的方法，但我建议你了解模型驱动设计和领域驱动设计</b0，以便更全面地理解对象建模者如何在零依赖的领域模型中封装整个业务。

> Why is that a huge deal?为什么这是一件大事？

It's huge because if you can create a mental-model of a business, you can create a software implementation of that business.这意义重大，因为如果你能构建一个业务的心智模型，你就能据此开发出该业务的软件实现。

### Learning resources

- Object-Design Style Guide, by Matthias Noback 《对象设计风格指南》，作者：马蒂亚斯·诺巴克
- Clean Architecture, by Robert C. Martin 《整洁架构》，作者：罗伯特·C·马丁
- Domain-Driven Design, by Eric Evans 埃里克·埃文斯所著的《领域驱动设计》

## Stage 4: Design Principles

At this point, you're understanding that Object-Oriented Programming is very useful for encapsulating rich domain models and solving the [3rd type of "Hard Software Problems"- Complex Domains](https://khalilstemmler.com/wiki/3-categories-of-hard-software-problems/).到目前为止，你应该已经理解，面向对象编程在封装丰富的领域模型以及解决 [第三种“软件难题”——复杂领域](https://khalilstemmler.com/wiki/3-categories-of-hard-software-problems/) 方面非常有用。

But OOP can introduce some design challenges. 但面向对象编程可能会带来一些设计挑战。

When should I use composition?我应该何时使用组合？

When should I use inheritance?我应该在什么时候使用继承？

When should I use an abstract class?我应该什么时候使用抽象类？

Design principles are really well-established and battle-tested object-oriented best practices that you use as railguards.设计原则是非常成熟且经过实践检验的面向对象最佳实践，可作为你的指导准则。

Some examples of common design principles you should familiarize yourself with are:你应该熟悉的一些常见设计原则示例如下：

- Composition over inheritance 组合优于继承
- Encapsulate what varies 封装变化的部分
- Program against abstractions, not concretions 针对抽象编程，而非具体实现编程
- The hollywood principle: "Don't call us, we'll call you" 好莱坞原则：“不要调用我们，我们会调用你”
- The [SOLID principles](https://khalilstemmler.com/articles/solid-principles/solid-typescript/), especially the [Single responsibility principle](https://khalilstemmler.com/articles/solid-principles/single-responsibility/) [SOLID原则](https://khalilstemmler.com/articles/solid-principles/solid-typescript/) ，特别是 [单一职责原则](https://khalilstemmler.com/articles/solid-principles/single-responsibility/)
- DRY (Do Not Repeat Yourself) DRY（不要重复自己）
- [YAGNI (You Aren't Gonna Need It) YAGNI（你不会需要它）](https://khalilstemmler.com/wiki/yagni/)

Make sure to come to your *own* conclusions, though. Don't just follow what someone else says you should do. Make sure that it makes sense to you.不过，一定要得出自己的结论。不要只是盲从别人告诉你应该做的事。要确保它对你来说是有意义的。

### Learning resources

- Head First Design Patterns, by various authors 《Head First 设计模式》，多位作者著
- GoF Design Patterns, by various authors 《GoF设计模式》，多位作者著

## Stage 5: Design Patterns

Just about every problem in software has been categorized and solved already. We call these patterns: design patterns, actually.软件领域几乎所有的问题都已经被归类并解决了。实际上，我们将这些称为模式：设计模式。

There are 3 categories of design patterns: **creational**, **structural**, and **behaviour**.设计模式分为3类： **创建型** 、 **结构型** 和 **行为型** 。

### Creational

Creational patterns are patterns that control how objects are created.创建型模式是控制对象创建方式的模式。

Examples of creational patterns include:创建型模式的示例包括：

- The **Singleton pattern**, for ensuring only a single instance of a class can exist 单例模式（ **Singleton pattern** ），用于确保一个类只能存在一个实例
- The **Abstract Factory pattern**, for creating an instance of several families of classes 抽象工厂模式</b0，用于创建多个类族的实例
- The **Prototype pattern**, for starting out with an instance that is cloned from an existing one **原型模式** ，用于从现有实例克隆出一个实例作为起点

### Structural

Structural patterns are patterns that simplify how we define relationships between components.结构模式是简化我们定义组件之间关系的模式。

Examples of structural design patterns include:结构型设计模式的示例包括：

- The **Adapter pattern**, for creating an interface to enable classes that normally can't work together, to work together. **适配器模式** 用于创建一个接口，使通常无法协同工作的类能够协同工作。
- The **Bridge pattern**, for splitting a class that should actually be one or more, into a set of classes that belong to a hierarchy, enabling the implementations to be developed independently of each other.**桥接模式** 用于将一个实际上应该是一个或多个的类拆分为一组属于某个层次结构的类，使各个实现能够相互独立地开发。
- The **Decorator pattern**, for adding responsibilities to objects dynamically.**装饰器模式** ，用于动态地为对象添加职责。

### Behavioural

Behavioural patterns are common patterns for facilitating elegant communication between objects.行为模式是促进对象之间优雅通信的常见模式。

Examples of behavioural patterns are:行为模式的示例包括：

- The **Template pattern**, for deferring the exact steps of an algorithm to a subclass.**模板模式** ，用于将算法的确切步骤延迟到子类中实现。
- The **Mediator pattern**, for defining the exact communication channels allowed between classes. **中介者模式** ，用于定义类之间允许的精确通信渠道。
- The **Observer pattern**, for enabling classes to subscribe to something of interest, and to be notified when a change occurred.**观察者模式** ，用于使类能够订阅感兴趣的内容，并在发生变化时收到通知。

---

### Design pattern criticisms 设计模式的批评

Design patterns are great and all, but sometimes they can an additional complexity to our designs. It's important to remember YAGNI and attempt to keep our designs as simple as possible. Only use design patterns when you're really sure you need them. You'll know when you will.设计模式固然很棒，但有时它们会给我们的设计增加额外的复杂性。重要的是要记住“你不会需要它”（YAGNI）原则，并努力让我们的设计尽可能简洁。只有在你确实确定需要设计模式时再使用它们，到时候你自然会明白的。

---

If we know what each of these patterns are, when to use them, and when to *not even bother* using them, we're in good shape to begin to understand how to architect larger systems.如果我们知道这些模式分别是什么、何时使用它们以及何时 *根本不必费心* 使用它们，我们就已经为开始理解如何构建更大的系统做好了准备。

The reason behind that is because **architectural patterns are just design patterns blown-up in scale to the high-level**, where design patterns are low-level implementations (closer to classes and functions).其背后的原因是， **架构模式只是设计模式在规模上扩展到了高层级** ，而设计模式是低层级的实现（更接近类和函数）。

### Learning resources

- Head First Design Patterns, by various authors 《深入浅出设计模式》，多位作者著

## Stage 6: Architectural Principles

Now we're at a higher level of thinking beyond the class level.现在我们处于超越类级别之上的更高层次的思考层面。

We now understand that the decisions we make towards organzing and building relationships between components at the high-level and the low-level, will have a significant impact on the maintainability, flexibility, and testability of our project.我们现在明白，我们在组织和构建高层与低层组件之间的关系时所做的决策，将对我们项目的可维护性、灵活性和可测试性产生重大影响。

Learn the guiding principles that helps you build in the flexibility that your codebase needs in order to be able to react to new features and requirements, with as little effort as possible.了解这些指导原则，它们能帮助你为代码库构建所需的灵活性，使其能够以最小的工作量应对新功能和新需求。

Here's what I'd recommend learning right off the bat:以下是我建议你立即学习的内容：

- Component design principles: [The Stable Abstraction Principle](https://khalilstemmler.com/wiki/stable-abstraction-principle/), [The Stable Dependency Principle](https://khalilstemmler.com/wiki/stable-dependency-principle/), and The Acyclic Dependency Principle, for how to organize components, their dependencies, when to couple them, and the implications of accidentally creating dependency cycles and relying on unstable components.组件设计原则： [稳定抽象原则](https://khalilstemmler.com/wiki/stable-abstraction-principle/) 、 [稳定依赖原则](https://khalilstemmler.com/wiki/stable-dependency-principle/) 和无环依赖原则，这些原则涉及如何组织组件、它们的依赖关系、何时耦合它们，以及意外创建依赖循环和依赖不稳定组件的影响。
- [Policy vs. Detail](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/), for understanding how to separate the rules of your application from the implementation details.[策略与细节](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/) ，用于理解如何将应用程序的规则与实现细节区分开来。
- Boundaries, and how to identify the [subdomains](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) that the features of your application belongs within.边界，以及如何确定应用程序功能所属的 [子域](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) 。

Uncle Bob discovered and originally documented many of these principles, so the best resource to learn about this is again, " [Clean Architecture](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) ".鲍勃大叔发现并最早记录了其中许多原则，因此了解这一点的最佳资源仍然是《 [整洁架构](https://www.amazon.ca/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=asc_df_0132350882/?tag=googleshopc0c-20&linkCode=df0&hvadid=292982483438&hvpos=1o2&hvnetw=g&hvrand=13521899336201370454&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9000834&hvtargid=pla-435472505264&psc=1) 》。

### Learning resources 学习资源

- Clean Architecture, by Robert C. Martin 《整洁架构》，作者：罗伯特·C·马丁

## Stage 7: Architectural Styles

Architecture is about the stuff that matters.架构关乎重要的事物。

It's about identifying what a system needs in order for it to be successful, and then stacking the odds of success by choosing the architecture that best fits the requirements.这关乎于确定一个系统要取得成功所需要的条件，然后通过选择最符合需求的架构来增加成功的几率。

For example, a system that has a lot of **business logic complexity** would benefit from using a **layered architecture** to encapsulate that complexity.例如，一个具有大量 **业务逻辑复杂性** 的系统，将受益于使用 **分层架构** 来封装这种复杂性。

A system like Uber needs to be able to handle a lot of **real time-events** at once and update drivers' locations, so **publish-subscribe** style architecture might be most effective.像优步这样的系统需要能够同时处理大量的实时事件</b0，并更新司机的位置，因此 **发布-订阅** 式架构可能是最有效的。

I'll repeat myself here because it's important to note that the 3 categories of architectural styles are similar to the 3 categories of design patterns, because **architectural styles are design patterns at the high-level**.我在这里再重复一遍，因为有必要指出，架构风格的3个类别与设计模式的3个类别相似，这是因为 **架构风格是高层级的设计模式** 。

### Structrual

Projects with *varying levels* of components and wide-ranging functionality will either benefit or suffer from adopting a structural architecture.组件级别各异且功能范围广泛的项目，采用结构化架构要么会从中受益，要么会因此受损。

Here are a few examples:以下是几个例子：

- **Component-based** architectures emphasize separation of concerns between the *individual components* within a system. Think **Google** for a sec. Consider how many applications they have within their enterprise (Google Docs, Google Drive, Google Maps, etc). For platforms with lots of functionality, component-based architectures divide the concerns into loosely coupled independent components. This is a *horizontal* separation. **基于组件的** 架构强调系统内 *各个组件* 之间的关注点分离。稍想一下 **谷歌** 。想想他们企业内部有多少应用程序（谷歌文档、谷歌云端硬盘、谷歌地图等）。对于具有大量功能的平台，基于组件的架构将关注点划分为松耦合的独立组件。这是一种 *横向* 分离。
- **Monolithic** means that the application is combined into a single platform or program, deployed altogether. *Note: You can have a component-based AND monolithic architecture if you separate your applications properly, yet deploy it all as one piece*.**单体式** 指的是应用程序被整合到一个单一平台或程序中，整体部署。 *注意：如果对应用程序进行了适当拆分，同时又作为一个整体部署，那么你可以拥有一个基于组件且采用单体式的架构* 。
- **Layered** architectures separate the concerns *vertically* by cutting software into infrastructure, application, and domain layers.**分层** 架构通过将软件划分为基础设施层、应用层和领域层，在 *垂直方向* 上分离关注点。

![[_posts/architect/网站架构/media/622d496c5a8c838f618da0ac62695585_MD5.svg]]

> An example of cutting the concerns of an application *vertically* by using a layered architecture. Read [here](https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/) for more information on how to do this.通过使用分层架构垂直划分应用程序关注点的示例。点击此处了解更多相关操作信息。

### Messaging

Depending on your project, messaging might be a really important component to the success of the system. For projects like this, message-based architectures build on top of functional programming principles and behavioural design patterns like the observer pattern.根据你的项目情况，消息传递可能是系统成功的一个非常重要的组成部分。对于这类项目，基于消息的架构建立在函数式编程原则和行为设计模式（如观察者模式）之上。

Here are a few examples of message-based architectural styles:以下是几种基于消息的架构风格示例：

- **Event-Driven** architectures view all signficant changes to state as events. For example, within a [vinyl-trading app](https://github.com/stemmlerjs/white-label), a offer's state might change from "pending" to "accepted" when both parties agreee on the trade. **事件驱动** 架构将所有重要的状态变化视为事件。例如，在一个 [黑胶唱片交易应用](https://github.com/stemmlerjs/white-label) 中，当双方就交易达成一致时，一个报价的状态可能会从“待处理”变为“已接受”。
- **Publish-subscribe** architectures build on top of the Observer design pattern by making it the primary communication method between the system itself, end-users / clients, and others systems and components.**发布-订阅** 架构建立在观察者设计模式之上，将其作为系统本身、最终用户/客户端以及其他系统和组件之间的主要通信方法。

### Distributed 分布式

A distributed architecture simply means that the components of the system are deployed separately and operate by communicating over a network protocol. Distributed systems can be very effective for scaling throughput, scaling teams, and delegating (potentially expensive tasks or) responsibility to other components.分布式架构简单来说就是系统的各个组件分开部署，并通过网络协议进行通信来运行。分布式系统在提高吞吐量、扩展团队规模以及将（可能成本高昂的任务或）责任分配给其他组件方面非常有效。

A few examples of distributed architectural styles are:分布式架构风格的一些示例如下：

- **Client-server** architecture. One of the most common architectures, where we divide the work to be done between the client (presentation) and the server (business logic). **客户机-服务器** 架构。这是最常见的架构之一，我们将需要完成的工作在客户机（表示层）和服务器（业务逻辑）之间进行分配。
- **Peer-to-peer** architectures distribute application-layer tasks between equally-privileged participants, forming a peer-to-peer network. **点对点** 架构在权限平等的参与者之间分配应用层任务，形成一个点对点网络。

### Learning resources

- Clean Architecture, by Robert C. Martin 罗伯特·C·马丁所著的《整洁架构》
- Software Architect's Handbook, by Joseph Ingeno 《软件架构师手册》，作者：约瑟夫·英格诺

## Stage 8: Architectural Patterns

Architectural *patterns* explain in greater tactical detail how to actually implement one of those architectural *styles*.架构模式更详细地从战术层面解释了如何实际实施这些架构风格中的一种。

Here are a couple of examples of architectural patterns and the styles that they inherit from:以下是几个架构模式及其所继承的架构风格的例子：

- **[Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/)** is an approach to software development against really complex problem domains. For DDD to be most successful, we need to implement a **layered architecture** in order to separate the concerns of a domain model from the infrastrural details that makes the application actually run, like databases, webservers, caches, etc.**[领域驱动设计](https://khalilstemmler.com/articles/domain-driven-design-intro/)** 是一种针对非常复杂的问题领域的软件开发方法。为了使领域驱动设计取得最大成功，我们需要实施 **分层架构** ，以将领域模型的关注点与使应用程序实际运行的基础设施细节（如数据库、Web服务器、缓存等）分离开来。
- **Model-View Controller** is probably the most well-known architectural pattern for developing user interface-based applications. It works by dividing the app into 3 components: model, view, and controller. MVC is incredibly useful when you're first starting out, and it helps you piggyback towards other architectures, but there hit's a point when we realize [MVC isn't enough](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/) for problems with lots of business logic.**模型-视图-控制器** 可能是开发基于用户界面的应用程序时最著名的架构模式。它通过将应用程序分为三个组件来工作：模型、视图和控制器。MVC在你刚开始开发时非常有用，它能帮助你轻松过渡到其他架构，但当我们意识到对于包含大量业务逻辑的问题而言， [MVC是不够的](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/) 时，情况就不同了。
- **Event sourcing** is a functional approach where we store only the transactions, and never the state. If we ever need the state, we can apply all the transactions from the beginning of time.**事件溯源** 是一种函数式方法，我们只存储事务，从不存储状态。如果我们需要状态，可以从一开始就应用所有事务。

### Learning resource

- Domain-Driven Design, by Eric Evans 埃里克·埃文斯所著的《领域驱动设计》
- Implementing Domain-Driven Design, by Vaughn Vernon 《实现领域驱动设计》，作者：沃恩·弗农

## Stage 9: Enterprise patterns

Any architectural pattern you choose will introduce a number of constructs and technical jargon to familiarize yourself with and decide on whether it's worth the effort to use or not.你选择的任何架构模式都会引入一些概念和技术术语，你需要熟悉这些内容，并判断是否值得花精力去使用它。

Taking an example that many of us know, in **MVC**, the *view* holds all the presentation layer code, the *controller* is translates commands and queries from the *view* into requests that are handled by the *model* and returned by the *controller*.举一个我们很多人都知道的例子，在 **MVC** 中， *视图* 包含所有表示层代码， *控制器* 将来自 *视图* 的命令和查询转换为由 *模型* 处理并由 *控制器* 返回的请求。

Where in the Model (M) do we handle these things?:在模型（M）中的哪个部分处理这些事情？

- validation logic 验证逻辑
- invariant rules 不变规则
- domain events 领域事件
- use cases 用例
- complex queries 复杂查询
- and business logic 以及业务逻辑

If we simply use an ORM (object-relational mapper) like Sequelize or TypeORM as the *model*, all that important stuff to gets left to interpretation on where it should go, and it finds itself in some unspecified layer between (what should be a rich) *model* and the *controller*.如果我们简单地使用像 Sequelize 或 TypeORM 这样的ORM（对象关系映射器）作为模型</b2，那么所有重要的内容都需要去判断应该放在哪里，结果这些内容会出现在（本应内容丰富的） *模型* 和 *控制器* 之间某个不明确的层级中。

![[_posts/architect/网站架构/media/b66e66c0509e8ed0fbec3c1c085fbb96_MD5.svg]]

> Taken from "3.1 - Slim (Logic-less) models" in [solidbook.io](https://solidbook.io/).节选自solidbook.io的“3.1 - 精简（无逻辑）模型”。

If there's something I've learned so far in my journey going beyond MVC, it's that **there is a construct for everything**.在我超越MVC的探索之旅中，到目前为止我学到的一点是， **万物皆有其构造** 。

For each of those things that MVC fails to address, in [Domain-Driven Design specifically](https://khalilstemmler.com/articles/domain-driven-design-intro/), there exist several **enterprise patterns** to solve them. For example:对于MVC未能解决的每一个问题，在 [特别是领域驱动设计中](https://khalilstemmler.com/articles/domain-driven-design-intro/) ，都存在几种 **企业级模式** 来解决它们。例如：

- **[Entities](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/)** describe models that have an identity.**[实体](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/)** 描述具有标识的模型。
- **[Value Objects](https://khalilstemmler.com/articles/typescript-value-object/)** are models that have no identity, and can be used in order to encapsulate validation logic.**[值对象](https://khalilstemmler.com/articles/typescript-value-object/)** 是没有标识的模型，可用于封装验证逻辑。
- **[Domain Events](https://khalilstemmler.com/articles/typescript-domain-driven-design/chain-business-logic-domain-events/)** are events that signify some relevant business event occurring, and can be subscribed to from other components.**[领域事件](https://khalilstemmler.com/articles/typescript-domain-driven-design/chain-business-logic-domain-events/)** 是表示发生了某些相关业务事件的事件，其他组件可以订阅这些事件。

Depending on the architectural style you've chosen, there are going to be *a ton* of other enterprise patterns for you to learn in order to implement that pattern to it's fullest potential. 根据你选择的架构风格，你还需要学习大量其他企业模式，才能充分发挥该模式的潜力。

### Learning resources

These are just a few different learning resources mostly focused on Domain-Driven Design and Enteprise Application Architecture. But this is where there is the *most* to learn, and where you can *dive the deepest* in your learning, because it builds ontop of everything we've learned thus far.这些只是一些不同的学习资源，主要集中在领域驱动设计和企业应用架构方面。但这正是有最多知识可以学习的地方，也是你能在学习中钻研得最深入的地方，因为它建立在我们迄今为止所学的一切基础之上。

- Patterns of Enterprise Application Architecture, by Martin Fowler 《企业应用架构模式》，马丁·福勒著
- Enterprise Integration Patterns, by Gregor Hohpe 《企业集成模式》，作者：格雷戈尔·霍普
- Domain Driven Design, by Eric Evans 《领域驱动设计》，埃里克·埃文斯 著
- Implementing Domain-Driven Design, by Vaughn Vernon 《实现领域驱动设计》，作者：沃恩·弗农

## Resources & Conclusion

We talk a lot about [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) on this blog, but there's a lot readers would benefit from knowing first (like layered architectures, oop, model-driven design, design principles and patterns) before we dive deep on building rich domain models with TypeScript.我们在这个博客中经常谈论领域驱动设计</b0，但在深入探讨如何使用TypeScript构建丰富的领域模型之前，读者们最好先了解很多知识（比如分层架构、面向对象编程、模型驱动设计、设计原则和模式）。

## References

- [Wikipedia: List of architectural styles and patterns 维基百科：建筑风格与模式列表](https://en.wikipedia.org/wiki/List_of_software_architecture_styles_and_patterns)
- [Architectural styles vs. architectural patterns vs. design patterns 架构风格与架构模式与设计模式](https://herbertograca.com/2017/07/28/architectural-styles-vs-architectural-patterns-vs-design-patterns/)
- [The Clean Architecture 整洁架构](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)


---