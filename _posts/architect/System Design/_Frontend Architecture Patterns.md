[Frontend Architecture Patterns You Need to Know in 2025 ](https://www.youtube.com/watch?v=ixee55xm_d8)
[[前端架构模式]]

摘要：
前端应用复杂到足以需要我们认真对待其架构。在这篇深入探讨中，我们研究了 9 种以上的架构模式（MVC、MVP、MVVM、Clean Architecture、Hexagonal、VIPER 等），并提供了每种模式的使用时机实用指南。非常适合希望构建**可扩展、可维护**应用并掌握技术面试的开发者。

Timecodes
0:00 Introduction & Why Architecture Matters
3:06 MVC (Model-View-Controller)
13:54 MVP (Model-View-Presenter)
16:58 MVVM (Model-View-ViewModel)
21:14 Hierarchical MVC (HMVC)
24:09 MVVM-C (with Coordinator)
25:29 VIPER Architecture
28:00 Clean Architecture
32:04 Hexagonal Architecture
36:03 Screaming Architecture
40:18 Vertical Slices
43:38 Final Thoughts & Conclusions

---
# notebooklm总结

这是一个关于**前端架构模式**的深入视频，由高级 Web 开发人员 Dimma 制作，旨在帮助开发者理解和应用现代前端应用程序所需的*关键架构模式*。视频强调，由于现代前端应用（如本地优先应用、高交互性 UI）的*复杂性日益增加，前端架构已成为开发过程中的关键部分*。

该视频详细介绍了多种流行的架构模式、它们的优势、局限性以及适用场景。

### 一、 前端架构的重要性与基础概念

- `架构的定义`: 架构***不仅仅是文件的结构，而是应用程序不同层之间如何交互***。
- ***必要性***: 良好的架构提供了**灵活性**（修改或替换部分功能时不影响其他部分）、**可测试性**和**可扩展性**。
- ***影响因素***: 架构的重要性取决于*项目规模、团队规模和项目生命周期*。**对于长期项目**，扎实的架构是必须的，尽管它可能会减慢初期的开发速度。
- ***总体原则***: *模式不应被严格遵循，而必须根据每个应用的独特挑战进行调整*。模式的存在为开发者提供了**共同的语言**。

### 二、 核心架构模式及其权衡

视频介绍了多种架构模式，并从传统的 MVC 开始，逐步深入到更现代、更具模块化的模式。

#### 1. **MVC** (Model-View-Controller)

- **结构**: `Model`（数据/业务逻辑），`View`（UI），`Controller`（模型与视图之间的*桥梁*，*处理输入（输入逻辑）*）。
- **前端应用**: 在现代前端中，*Model 通常是状态管理系统（如 Redux），View 是组件，Controller 可能是 Hooks 或中间件*。
- ***缺点***: 易出现` “臃肿的控制器” (Fat Controller) 问题`，控制器*承担过多职责*（如 API 响应、缓存、同步）。边界模糊，且**不适合具有复杂客户端逻辑的现代 Web 应用**。

#### 2. 客户端类型：Thin Client vs. Thick Client

- `Thin Client（瘦客户端）`: 大部分处理在服务器端完成，客户端只处理 UI；依赖服务器（响应慢）。
- `Thick Client（厚客户端/胖客户端）`: *在客户端处理大量逻辑，管理状态*，有时可离线工作；*常见于 SPA 和本地优先应用*。

#### 3. MVP (Model-View-Presenter)

- **演进**: *解决了 MVC 中 View 直接观察 Model 的问题*。
- **关键层**: *Presenter 充当 View 和 Model 之间的中介*，接收数据更新，使 View 成为纯粹的 UI 层（**被动视图**）。
- **优点**: 职责分离更好，可测试性更高。
- **缺点**: 仍可能出现 `“臃肿的 Presenter” (Fat Presenter) 问题`。

#### 4. MVVM (Model-View-ViewModel)

- **关键分离**: *区分**业务逻辑**（修改核心数据）和**视图逻辑**（纯 UI 相关的变化，如打开模态窗口）*。
- **View Model**: 专门处理所有 UI 相关逻辑，并确保 UI 与数据同步。
- **新概念**: 引入`双向数据绑定 (Two-Way Binding)`，自动同步 View 和 View Model 的变化。
- **适用性**: 最适合具有复杂、可测试 UI 逻辑的应用（例如，带有实时验证的表单）。

#### 5. HMVC (Hierarchical Model-View-Controller)

- **目标**: *解决 MVC 的可扩展性问题*。
- **结构**: 将应用分解为多个**独立**的 MVC 块，每个块处理一个特定的功能（如用户功能、仪表板）。
- **适用性**: 适用于大型应用和多团队协作的项目。

#### 6. MVVMC (MVVM Coordinator)

- **结构**: 在 MVVM 中新增 **Coordinator** 层。
- **Coordinator 职责**: 专门管理导航和屏幕转换，防止 View Model 被导航逻辑过度填充。
- **适用性**: 适用于具有复杂导航场景的应用，如多步工作流（如电子商务结账流程）。

#### 7. VIPER (View Interactor Presenter Entity Router)

- **结构**: 分层更多，以达到更高的模块化和可测试性。各层职责明确（View 纯 UI、Presenter 准备数据、Interactor 处理业务逻辑、Router 管理导航）。
- **优点**: 更好的职责分离，易于单元测试，适用于大型应用。
- **缺点**: 需要编写更多样板代码和接口。

#### 8. Clean Architecture (整洁架构)

- **结构**: 由四层组成，依赖关系指向内部：Entities（核心业务逻辑）-> Use Cases（应用逻辑）-> Interface Adapters（适配器/转换器）-> Frameworks and Drivers（UI、数据库）。
- **核心原则**: **依赖规则**——内部层（如 Entities）不能依赖外部层（如 UI 框架或数据库）。
- **优点**: 高度可测试，独立于数据库和 UI 框架。
- **缺点**: 实施复杂性高，对团队经验要求高。

#### 9. Hexagonal Architecture (六边形架构/端口与适配器)

- **聚焦**: 侧重于系统与外部接口之间的交互，使分布式开发更容易。
- **结构**: 业务逻辑在中心，通过 **Input Ports**（驱动侧，如用户事件）和 **Output Ports**（被驱动侧，如 UI 渲染）进行通信。
- **实践**: 通过使用 **Contracts**（类型、Schema）来稳定 Ports 和 Adapters 之间的交互，确保前端和后端保持同步。

#### 10. Screaming Architecture (尖叫架构)

- **理念**: 架构的顶层结构应立即体现应用程序的**业务意图和目的**，而不是技术细节（如 React、MongoDB）。
- **组织方式**: 围绕**核心业务概念**组织代码库，并按功能而非技术层级组织。

#### 11. Vertical Slices (垂直切片)

- **理念**: 最现代的架构风格之一。它通过将应用**垂直**切分成独立的、自包含的**业务功能**（Slice）来解决分层架构（如 Clean Architecture）中缺乏内部结构的问题。
- **结构**: 每个切片包含该功能所需的所有层级（Entity, Use Case, Controller, Interface）。
- **优点**: 更好的代码组织，多团队可以独立工作，适用于大型应用。
- **缺点**: 对于简单应用可能导致过度工程化。

### 三、 架构决策与实践总结

视频作者强调，架构决策是一个“艰难的决定” (tough decision)，一旦项目规模扩大，几乎不可能重写整个架构。因此，在项目开始时选择一个**足够好的**架构至关重要。相比之下，文件结构和命名约定是容易改变的。

尽管该视频主要讨论了前端架构，但很多概念和模式（如 VIPER、Clean Architecture）最初来源于移动或后端开发，这体现了软件开发中跨领域借鉴的常态。


# 豆包总结

视频讲述了2025年需了解的前端架构模式，包括各类模式的原理、优缺点、适用场景，以及前端架构的重要性和选择原则等内容，具体如下：
- **前端架构的重要性及关键影响因素**：[00:28]前端架构*易被忽视*，但现代前端应用*复杂度高*，其是开发关键部分。`架构`不仅是文件结构，更关乎应用各层交互。`作用`包括*提升灵活性*（便于修改替换部分功能、明确组件边界）、*可测试性*（单个层易测试）、*可扩展性*（清晰关注点分离应对应用增长）。`关键影响因素`有*项目规模*（大型项目需更多结构）、*团队规模*（团队越大越关键，10-15人团队必备）、*项目生命周期*（短期MVP可优先速度，长期项目需稳固架构避免技术债务），且架构虽可能减缓初始开发，但长期利于扩展和功能开发。
- **MVC（Model-View-Controller）模式**：[03:06]有36年以上历史，虽在现代前端应用不常用，但含基础概念。将应用分三层，Model（应用数据和业务逻辑，常对应后端、数据库及有时的API）、View（展示数据的UI，含打开模态窗口等UI逻辑）、Controller（连接Model和View，处理用户输入、更新Model、指示View展示内容）。工作流程为用户输入→View捕获并传递给Controller→Controller处理输入并与Model交互→Model更新数据→Controller和Model更新View（通过观察者模式或显式请求更新）→用户看到更新UI。可分纯前端MVC（Model为Redux等状态管理系统，View为React等组件，Controller层不明确，可能由hooks等承担）和全栈MVC（View为前端UI框架构建，Controller为API层，Model为后端业务逻辑和数据库），大型应用可拆分为多个独立MVC单元形成分层MVC。其优点是易理解、易开发维护，缺点有胖控制器问题（控制器功能过多）、Model与Controller边界模糊、View不仅是纯UI层（含事件处理和状态观察，增加测试维护难度），且更适用于经典Web应用，不适用于现代复杂应用。适用于中小型Web应用，不适用于复杂状态管理、重客户端逻辑及本地优先的SPA。
- **瘦客户端与胖客户端差异及对MVC的影响**：[08:44]瘦客户端大部分处理在服务器，客户端仅处理UI和用户交互，常见于传统多页面应用和静态网站，依赖服务器，每次交互需服务器处理并返回更新页面，对应经典MVC，前端简单轻量但响应慢。胖客户端客户端处理大量逻辑，减少服务器负载，多数交互无需整页刷新，可离线工作，常见于现代Web应用，前端除展示数据外还管理状态、处理逻辑及离线存储数据，对应现代MVC，响应快、可离线但客户端负载重，SPA等依赖胖客户端。
- **MVP（Model-View-Presenter）模式**：[13:54]由MVC演变而来，View不直接与Model通信，所有交互经Presenter，Presenter承担View中观察者逻辑，使View为纯UI层，提升系统可预测性、可测试性和结构性。分监督控制器型MVP（View处理简单更新，复杂逻辑经Presenter，优点是减少模板代码、开发快，缺点是View难测试维护，适用于简单UI）和被动视图型MVP（View完全被动，所有逻辑由Presenter处理，优点是层边界清晰、各部分易测试，缺点是需更多代码，适用于复杂UI逻辑或注重可测试性和扩展性的应用）。优点是关注点分离更好、可测试性更高，缺点有胖Presenter问题（若组织不当功能过多）、表达性差（未明确后端同步等处理位置）。适用于与MVC类似场景，也适用于客户端逻辑更复杂的应用。
- **MVVM（Model-View-ViewModel）模式**：[16:58]核心是分离视图逻辑（UI相关，不修改核心数据，如弹窗开关等）与业务逻辑（修改数据，如修改用户名等）。分为View（UI）、ViewModel（处理UI相关逻辑，更新View、与Model交互，确保UI与数据同步）、Model（处理业务逻辑和实际数据）三层，关键特性是双向绑定（View与ViewModel相互影响，一方变化另一方自动更新）。与之前模式相比，ViewModel存储UI数据，区分业务与UI数据，View与Model隔离，多个View可共享一个ViewModel，一个View不能有多个ViewModel。优点是层分离清晰、可扩展性好、易测试维护，缺点是学习曲线陡、表达性差（未明确API请求等处理位置）。适用于复杂UI逻辑、需测试、多用户交互及动态UI更新的应用，不适用于简单静态网站。
- **分层MVC（HMVC）模式**：[21:14]为解决传统MVC可扩展性问题，将应用拆分为多个独立MVC模块，每个模块处理特定功能，模块间仅通过控制器交互。优点是模块化（应用可拆分为小模块，利于独立开发、维护、测试和错误隔离）、代码可复用，缺点是学习曲线陡、模块间可能不一致（不同开发者或团队采用不同标准）。适用于大型应用、多团队负责不同部分及从多个API和服务获取数据的前端应用，不适用于中小型应用。
- **MVVM-C（Model-View-ViewModel-Coordinator）模式**：[24:09]在MVVM基础上增加Coordinator层，负责管理导航和屏幕过渡。解决MVVM中导航逻辑无明确处理位置的问题，避免ViewModel因包含导航逻辑而臃肿。优点是关注点分离（导航逻辑与UI、业务逻辑分离）、可测试性高（导航逻辑可独立单元测试），缺点是增加架构复杂度（多一层）。适用于有复杂导航场景（如电商结账流程）的应用。
- **VIPER架构**：[25:29]包含View（被动视图，仅展示UI和转发用户操作）、Presenter（为View准备数据，确保数据格式正确）、Interactor（处理业务逻辑，负责数据获取和修改）、Entity（原始数据，无逻辑仅结构化信息）、Router（管理屏幕过渡和导航）五层，各层依赖关系为View依赖Presenter，Presenter依赖Interactor和Router，Interactor依赖Entity。优点是基于用例设计应用、明确API处理位置（Interactor）、明确导航处理位置（Router）、关注点分离好、可扩展性好、适用于大型应用和多团队协作，缺点是需编写大量模板代码（如大量接口）。适用于复杂长期应用，不适用于小型应用。
- **Clean Architecture（整洁架构）**：[28:00]有四层，Entities（核心业务逻辑，不关注UI、数据库和框架，如银行应用中的交易规则）、Use Cases（应用逻辑，处理数据但不存储，如获取最近100条银行交易记录）、Interface Adapters（适配Use Cases与框架间数据，确保数据格式正确）、Frameworks and Drivers（外部工具，如UI框架、数据库、外部API等），依赖规则为依赖指向内部，内层不了解外层。即使无后端或仅客户端视图逻辑，结构仍适用。优点是可测试性高（各层可独立测试）、数据库无关（应用与数据库解耦）、UI无关（UI框架隔离），缺点是入门门槛高（依赖经验丰富且自律的团队）、复杂度高（尤其小型项目）。
- **Hexagonal Architecture（六边形架构）**：[32:04]又称端口适配器架构，核心是业务逻辑，周围是输入端口（驱动端，如用户事件、WebSocket等）和输出端口（被驱动端，如UI、客户端存储等），驱动端控制应用，被驱动端受应用逻辑控制。利于分布式开发，不同团队可独立开发不同部分，通过集成测试和模拟进行独立测试。可添加契约（如使用响应验证器和集成测试）确保端口与适配器交互稳定，定义清晰交互边界，防止API意外变更，确保前后端同步。适用于有前端业务逻辑、本地优先或与多个接口交互的应用，不适用于简单应用和小型团队项目。与Clean Architecture相比，Clean Architecture较新，源于Hexagonal Architecture，注重单应用内部分层；Hexagonal Architecture较旧但有效，适用于系统涉及多个分布式部分的场景，注重服务与外部接口交互。
- **Screaming Architecture（呐喊架构）**：[36:03]由Robert Martin提出，核心是软件系统架构仅通过顶层结构（如包名、模型名、目录）即可识别，体现应用意图和目的，无需深入细节。强调代码中的实体，与领域驱动设计有相似之处，注重以业务模型描述架构，而非围绕技术细节（如框架、数据库）组织应用，应按业务领域命名（如待办应用的“tasks”或“to-dos”），按功能而非层组织，每个功能包含所需全部内容，隐藏技术细节。在系统设计面试中应关注架构而非组织方式，架构是难逆转的重要决策，文件结构和命名规则易变更。
- **Vertical Slices（垂直切片）**：[40:18]是较现代且广泛使用的架构风格，针对Clean Architecture等分层架构未明确层内功能组织的问题，采用基于功能的方法，将应用垂直拆分为独立功能切片，每个切片包含自身的Entity、Use Case、Controller和外部接口，每个功能自包含。可与其他架构模式结合（如MVP中为每个功能创建切片，各切片内部遵循MVP）。优点是代码组织好（功能自包含，代码库模块化易管理）、利于多团队协作（各切片独立，多团队可同时开发不同切片），缺点是可能过度工程化（简单功能也严格遵循导致复杂和冗余代码）、团队间可能不一致（独立开发导致代码库不一致，可通过通用设计指南、代码检查和开发者轮换解决）。适用于大型应用和跨职能团队（团队可全权负责特定功能），不适用于简单应用和小型团队项目。
- **前端架构选择的最终思考**：[43:38]视频未涵盖所有前端架构模式，重点介绍了常用模式，也提及了如VIPER等非前端原生但可借鉴的模式，前端开发者常从后端借鉴概念。现代前端应用复杂度高（如本地优先、高交互UI、状态密集型应用），前端架构应得到更多关注。架构模式不应被严格遵循，需根据具体需求调整（如增减层），无适用于所有情况的完美模式，需量身定制。架构模式提供了开发者间的通用语言，便于沟通。