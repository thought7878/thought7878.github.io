[原文](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet)


A structured approach is very important when appearing for a frontend system design interview since most of the frontend system design can be overwhelming for an hour-long interview.
在参加前端系统设计面试时，采用结构化的方法非常重要，因为大多数前端系统设计在一小时的面试中可能会让人感到压力很大。

  

This comprehensive **Frontend System Design Cheat Sheet** will provide a guided framework-driven approach to handle any **Frontend System Design Interview**. This will help you to ace the System Design Interview by completing the important part of the system design within time limits. Let's start这份全面的**前端系统设计速查表**将提供一种以框架为导向的引导方法，帮助你应对任何**前端系统设计面试**。它能助你在规定时间内完成系统设计的重要部分，从而顺利通过系统设计面试。让我们开始吧。

## 涵盖的主题
Topic Covered 

1. [Know About Interview 了解面试](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#know-about-interview "Know About Interview")
2. [RADIO Framework for Frontend System Design前端系统设计的RADIO框架](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#radio-framework "RADIO Framework for Frontend System Design")
3. [Requirement Gathering 需求收集](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#requirement-gathering "Requirement Gathering")
    - [Functional Requirements 功能需求](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#functional-requirements "Functional Requirements")
    - [Non-Functional Requirements 非功能性需求](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#non-functional-requirements "Non-Functional Requirements")
    - [Scoping 范围界定](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#scoping "Scoping")
4. [Architecture Approaches 架构方法](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#architecture-approaches "Architecture Approaches")
    - [Frontend Architecture 前端架构](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#frontend-architecture "Frontend Architecture")
    - [Data fetching protocols 数据获取协议](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-fetching-protocols "Data fetching protocols")
    - [Data fetching techniques 数据获取技术](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-fetching-techniques "Data fetching techniques")
    - [UI & Data Rending Approaches & MechanismUI与数据渲染方法及机制](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#ui-and-data-rendering-approaches-and-mechanisms "UI & Data Rending Approaches & Mechanism")
    - [Enable support for Accessibility, i18n & Offline Support启用对无障碍、国际化和离线支持的支持](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#enable-support-for-accessibility-i18n-offline-support "Enable support for Accessibility, i18n & Offline Support")
5. [Data Handling 数据处理](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-handling "Data Handling")
    - [Data Entities 数据实体](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-entities "Data Entities")
    - [Data Store (like Redux) 数据存储（如Redux）](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-store "Data Store (like Redux)")
6. [Interface (API) 接口（API）](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#interface-api "Interface (API)")
7. [Optimizations 优化](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#optimizations "Optimizations")
    - [Performance Optimizations 性能优化](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#performance-optimizations "Performance Optimizations")
    - [Network Optimizations 网络优化](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#network-optimizations "Network Optimizations")
    - [Rendering Optimizations 渲染优化](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#rendering-optimizations "Rendering Optimizations")
8. [Extended Topics 扩展主题](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#extended-topics "Extended Topics")
    - [Security Considerations 安全注意事项](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#security-considerations "Security Considerations")
    - [Observability 可观测性](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#observability "Observability")
    - [Testing & Automation Considerations 测试与自动化考量](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#testing-and-automation "Testing & Automation Considerations")

## 1. 了解系统设计面试
1. Know About System Design Interview

This interview mostly focuses on how well you can capture the requirements and translate those requirements into designing a frontend system.
这次面试主要考察你**能否准确捕捉需求**，并将这些需求转化为前端系统设计。

### 你可能会遇到的问题类型
1.1 Type of question you can expect1.1 

Primarily there are 2 types of questions you can expect
主要来说，你可能会遇到*两种类型的问题*

1. **Complex component frontend system design 复杂组件前端系统设计**  
    Examples - [Data table/Grid component](https://www.frontendgeek.com/frontend-interview/system-design-interview#data-table/grid "Data table/Grid component"), Notification, [Nested Tree view](https://www.frontendgeek.com/frontend-interview/system-design-interview#tree-view "Nested Tree view"),  [Auto Complete/Typeahead search](https://www.frontendgeek.com/frontend-interview/system-design-interview#autocomplete-and-typeahead-widget "Auto Complete/Typeahead search")示例 - [数据表/网格组件](https://www.frontendgeek.com/frontend-interview/system-design-interview#data-table/grid "Data table/Grid component")、通知、[嵌套树形视图](https://www.frontendgeek.com/frontend-interview/system-design-interview#tree-view "Nested Tree view")、[自动完成/预输入搜索](https://www.frontendgeek.com/frontend-interview/system-design-interview#autocomplete-and-typeahead-widget "Auto Complete/Typeahead search")
2. **Application frontend system design 应用前端系统设计**  
    Examples - [Facebook News feed](https://www.frontendgeek.com/frontend-interview/system-design-interview#news-feed-design "Facebook News feed"), [YouTube player](https://www.frontendgeek.com/frontend-interview/system-design-interview#audio/video-streaming "YouTube player"), [Sprint Board](https://www.frontendgeek.com/frontend-interview/system-design-interview#kanban-boards "Sprint Board") etc.示例 - [Facebook 新闻推送](https://www.frontendgeek.com/frontend-interview/system-design-interview#news-feed-design "Facebook News feed")、[YouTube 播放器](https://www.frontendgeek.com/frontend-interview/system-design-interview#audio/video-streaming "YouTube player")、[冲刺看板](https://www.frontendgeek.com/frontend-interview/system-design-interview#kanban-boards "Sprint Board")等。

### 1.2 面试官的期望是什么？
1.2 What is the interviewer's expectation?

There are 3 major expectations in the frontend system design interviews
在前端系统设计面试中，面试官*主要有3个期望*。

1. Able to drive & design the whole frontend system from open-ended requirements.
	1. **能够根据开放式需求推动并设计整个前端系统**。
2. Knowledge about the frontend system best practices Examples - when to use [Debounce or throttling](https://www.frontendgeek.com/frontend-interview/javascript-interview#throttling-&-debouncing "Debounce or throttling"), [Virtualization](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "Virtualization"), Intersection Observers etc.
	1. 关于前端系统**最佳实践的知识示例**——何时使用[防抖或节流](https://www.frontendgeek.com/frontend-interview/javascript-interview#throttling-&-debouncing "Debounce or throttling")、[虚拟化](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "Virtualization")、交叉观察器等。
3. Able to explain tradeoffs between various approaches while building frontend system design Ex - REST vs GraphQL, where to store data [local, session or IndexedDB](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#local-&-session-storage "local, session or IndexedDB")
	1. 能够在构建前端系统设计时**解释各种方法之间的权衡**，例如*REST与GraphQL*，以及*数据应存储在何处*（本地、会话或IndexedDB）

## 2. 前端系统设计的RADIO框架
RADIO Framework for Frontend System Design

Best Framework to follow for frontend system design - “RADIO
”前端系统设计的最佳遵循框架——“RADIO”

### R - Requirements

Clarify functional & Non Functional requirements. Define the scope of the front-end system design.
**明确功能性和非功能性需求。定义前端系统设计的范围。**

### A - Architecture

Which architecture to follow - Monolith or Micro-frontend or Mono-repo
**应采用哪种架构**——`单体架构`、`微前端`还是`单体仓库`

### D - Data Entities

How the application data look like and the entity's relationship
应用程序**数据的样子**以及**实体之间的关系**

### I - Interface APIs

API Interface to interact with various functions of the system this can be REST API, GraphQL interface or functional interfaces.
用于**与系统各种功能交互的API接口**，这可以是`REST API`、`GraphQL接口`或`函数接口`。

### O - Optimizations

Various optimizations to make frontend applications more performant & scalable, primarily [Network Optimizations techniques](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#network-optimizations "Network Optimizations techniques"), [Asset Optimizations techniques](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#javascript-optimizations "Asset Optimizations techniques") & [Rendering Optimizations techniques](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "Rendering Optimizations techniques").
**为提高前端应用的性能和可扩展性而进行的各种优化**，主要包括[网络优化技术](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#network-optimizations "Network Optimizations techniques")、[资源优化技术](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#javascript-optimizations "Asset Optimizations techniques")和[渲染优化技术](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "Rendering Optimizations techniques")。

In the rest of the notes we will deep dive into each of the RADIO framework steps one by one, let's start 👇👇👇
在接下来的笔记中，我们将逐一深入探讨RADIO框架的每个步骤，让我们开始吧👇👇👇

## 3. Requirement Gathering
需求收集

![[_posts/architect/System Design/media/9dc688883fda7388a5fccaa5ee96cf61_MD5.jpg]]

Any frontend system design round starts with requirements gathering, and generally, 2 types of requirements should be gathered as part of this stage.
任何前端系统设计环节都**始于需求收集**，通常在这一阶段**需要收集两类需求**。

> 💡 It is important to rather focus on remembering requirements, we should focus on the right questions to generate the functional and non-functional requirements.
> 💡 重要的是，与其专注于记住需求，我们不如**专注于提出正确的问题，以生成功能性和非功能性需求**。

### 3.1 Functional Requirements 
3.1 功能需求

The functionality the system will provide to the end users to fulfil their use-case. for example - for an e-commerce website, displaying catalogue items, and searching through the catalogue is the functional requirement.
**系统将向最终用户提供的、用于满足其用例的功能**。例如，对于电子商务网站，展示商品目录以及在目录中进行搜索就是`功能需求`。  
  
***Question***: What user will the user use the system for? or what capabilities the system will provide to the users?
***问题***：用户将使用该系统做什么？或者该系统将为用户提供哪些功能？

We can derive functional requirements via 2 approaches
我们可以*通过两种方法推导出*功能需求

1. **Page-wise functional capabilities *页面级功能能力***  
    Example: [E-commerce system design](https://www.frontendgeek.com/frontend-interview/system-design-interview#e-com-application "E-commerce system design"): Home page, login page, user page, catalogue page, search page, details page, checkout page, payment page
    示例：[电子商务系统设计](https://www.frontendgeek.com/frontend-interview/system-design-interview#e-com-application "E-commerce system design")：首页、登录页、用户页、目录页、搜索页、详情页、结账页、支付页
2. **Module-wise capabilities *模块级功能***  
    Example: E-commerce system design: user module, catalogue module, checkout module, product module.
    示例：电子商务系统设计：用户模块、目录模块、结账模块、产品模块。

### 3.2 Non-Functional requirements 
3.2 非功能性需求

All the requirements which are essential to make a frontend application more robust, performant, scalable, and secure are considered non-functional requirements.
所有对于**使前端应用程序更健壮、性能更好、可扩展性更强和更安全至关重要的要求**都被视为`非功能性需求`。

_**Question**: Who are the users? **问题**：用户是谁？_

1. Multiple roles - RBAC support 
	1. `多角色` - 基于角色的访问控制支持
2. All age group support requires “Accessibility support” - Keyboard navigation, screen reader support
	1. 所有年龄段人群的支持都需要“`无障碍支持`”——*键盘导航、屏幕阅读器支持*
3. Across the globe, support requires “Internationalization” - language, currency, date format
	1. 在全球范围内，支持需要“`国际化`”——*语言、货币、日期格式*

_**Question**: How will they going to use the system?**问题**：他们将如何使用这个系统？_

1. Device support - Desktop, tablet, mobile phones, screen readers, slow network
	1. `设备支持` - 台式电脑、平板电脑、手机、屏幕阅读器、低速网络
2. Offline support required - using service workers
	1. 需要`离线支持`——使用服务工作线程
3. PWA (Native support) - direct launch, push notifications, offline access
	1. `PWA`（原生支持）- 直接启动、推送通知、离线访问
4. Personalization - The system should be configurable for personalization **个性化** - 系统应可配置以实现个性化
    - Dark Mode preferences 深色模式偏好设置
    - Notification preferences 通知偏好设置

_**Question**: What kind of experience do we want to support in the system?**问题**：我们希望在系统中支持什么样的体验？_

1. Performance - The system should be performant
	1. `性能` - 系统应具备高性能
2. Security - The system should be secure from unauthorized or unauthenticated use
	1. `安全性` - 系统应能防止未授权或未认证的使用
3. Scalability - Use scalable UI design patterns, like virtualization, pagination, lazy loading etc.
	1. `可扩展性` - 采用可扩展的用户界面设计模式，例如虚拟化、分页、懒加载等。
4. Graceful Error & Exception handling `优雅的错误与异常处理`
    - Server errors/exceptions `服务器错误/异常`
    - Network error/exceptions `网络错误/异常`
    - User error/exceptions `用户错误/异常`
5. Extensibility - How easy is it to extend the system and add new functionalities
	1. `可扩展性` - 扩展系统和添加新功能的难易程度如何

### 3.3 Scoping 
3.3 确定范围

It is a very important step after requirement gathering since we know most of the frontend system design interviews last for around 45 min to 1 hour. In this limited time, we can not dig deep into all the functional and non-functional requirements.
这是需求收集后的一个非常重要的步骤，因为我们知道大多数前端系统设计*面试时长约为45分钟到1小时*。在这*有限的时间里*，我们*无法深入挖掘所有的功能性和非功能性需求*。

This step helps you to discuss all the functional and non-functional requirements, and come up with a scoped list of requirements on which you will going to focus in the rest of the interview
**这一步有助于你讨论所有功能性和非功能性需求，并制定一份有明确范围的需求清单，在面试的剩余部分你将重点关注这些需求**。

#### Example 
示例

Let's say we need to build an e-commerce application like Amazon, and we have mentioned user management, authorization & authentication, and role-based access as a functional requirement. These kinds of requirements are common in most applications, so In the scoping step, you can discuss and remove these kinds of trivial common requirements and focus on more specific requirements related to the application design.
假设我们需要构建一个像*亚马逊*这样的电子商务应用程序，并且我们已经提到*用户管理、授权与认证以及基于角色的访问*是`功能需求`。**这类需求在大多数应用程序中都很常见，因此在确定范围的步骤中，你可以讨论并*剔除这些琐碎的常见需求，专注于与应用程序设计相关的更具体的需求***。

## 4. Architecture Approaches 
架构方法

### 4.1 Frontend Architecture 
4.1 前端架构

![[_posts/architect/System Design/media/ecc8643a9ca430413b247e3ecba271c2_MD5.jpg]]

There are 3 major approaches for architecting frontends
**构建前端有3种主要方法**

#### Micro-Frontends 
微前端

1. Popular ways to implement using IFrame, Web Components, Module Federation
	1. 使用`IFrame`、`Web组件`、`模块联邦`的常见实现方式
2. Vertical slicing of the application development as part of micro-frontends.
	1. 作为微前端一部分的应用开发垂直切片。
3. 2 primary ways of implementation - Build Time integrations & Run Time Integrations.
	1. 实现的两种主要方式——`构建时集成`和`运行时集成`。
4. Provide better separation of concerns
	1. 提供**更好的关注点分离**
5. Can use different tech stacks for developing front-end applications.
	1. 可以**使用不同的技术栈**开发前端应用程序。
6. Different teams can work on different micro-frontends in different delivery cycles
	1. **不同的团队可以在不同的交付周期中开发不同的微前端**。
7. There is no need to build the whole code every time, only an updated micro-frontend needs to be built and released.
	1. **无需每次构建整个代码，只需构建并发布更新后的微前端即可**。

#### Monolithic frontend 
单体前端

1. All the teams need to work on the same code base so hard to scale
	1. 所有团队都需要**在同一个代码库上**工作，这很难扩展。
2. Adding new functionalities can be challenging along with the existing code
	1. 在现有代码基础上添加新功能可能具有挑战性
3. Required to build the whole code for any change in any part of the application
	1. 若应用程序的**任何部分发生更改，都需要构建完整的代码**。
4. Any kind of bug fixes or change in tooling will impact the whole code base and create regressions
	1. **任何类型的错误修复或工具变更都会影响整个代码库并导致回归问题**。
5. It is very easy to start, and suitable for minimum functionality and less frequent releases.
	1. 它*非常容易上手，适用于功能最少且发布频率较低的情况*。
6. Bound to use the same tech stack across the frontend side, like the framework.
	1. 前端*必须使用相同的技术栈*，例如框架。

#### Mono Repo 

1. Primarily suitable for projects where existing logic/framework/ feature needs to be shared with new projects so that they do need not to reinvent the wheel.
	1. 主要适用于需要**将现有逻辑/框架/功能共享给新项目**的情况，这样新项目就无需重复开发。
2. Build and release processes are generally slower than counterparts, but saving time from reusability of logic can justify this slowness.
	1. **构建和发布流程通常比同类流程慢，但逻辑的可复用性所节省的时间可以弥补这种缓慢**。

### 4.2 Data Fetching Protocols 
4.2 数据获取协议

![[_posts/architect/System Design/media/9f36c2ae2e5e225d48d1c6b36e263147_MD5.jpg]]

There are 4 Major Protocols for Communication between client-server or between services.
客户端-服务器之间或服务之间的通信**有4种主要协议**。

#### 1️⃣ REST APIs 
1️⃣ REST API

1. Simple to use, No additional client required like GraphQL  **使用简单，无需像GraphQL那样额外的客户端**  
    Out-of-box caching is available **提供开箱即用的缓存功能**
2. Multiplexing, header compression, and server push are available through HTTP2  **通过HTTP2可以实现多路复用、头部压缩、服务器推送**。  
    Statelessness between requests. **请求之间的无状态性**。
3. It is best suited for external APIs because of widespread community support.  **由于拥有广泛的社区支持，它最适合用于外部API**。  
    Typically returns JSON or XML. *通常返回JSON或XML*。
4. Cons - More bandwidth consumption, requires multiple calls **`缺点` - 带宽消耗更大，需要多次调用**
5. Cons - Under-fetching and Over-fetching issues **`缺点` - 数据获取不足和数据获取过量问题**

#### 2️⃣ GraphQL (From Facebook) 
2️⃣ GraphQL（来自Facebook）

1. Pros - Fetch what exactly needed, No under-fetching, or Over-fetching
	1. `优点` - **准确获取所需内容**，不会出现获取不足或获取过多的情况
2. Pros - Can use HTTP2 benefits, and is suitable for complex structures.
	1. `优点` - 可以利用HTTP2的优势，且适用于复杂结构。
3. Cons - Additional client is required like Apollo
	1. `缺点` - **需要额外的客户端，如Apollo**
4. Cons - Out-of-the-box caching is not available
	1. `缺点` - **不提供开箱即用的缓存功能**

#### 3️⃣ gRPC - Google Remote Procedure Call (From Google)
3️⃣ gRPC - 谷歌远程过程调用（来自谷歌）

1. Suitable for communication between internal services
	1. **适用于内部服务之间的通信**
2. HTTP/2 usage for transport 
	1. **传输使用HTTP/2**
3. Support fast bi-directional communication.
	1. **支持快速的双向通信**。
4. Use protocol buffer (aka ProtoBuff) for the communication than JSON
	1. 在通信中使用协议缓冲区（又名ProtoBuff）而非JSON
5. Suitable when strong typing is required across different languages (services developed in different languages like Java - Node).
	1. **适用于在不同语言间需要强类型的场景**（例如用Java、Node等不同语言开发的服务）。

#### 4️⃣ tRPC - TypeScript Remote Procedure Call
4️⃣ tRPC - TypeScript 远程过程调用

1. Focused on Client Server communication based on TypeScript
	1. **专注于基于TypeScript的客户端-服务器通信**
2. Utilize typescript for type safety across the communication
	1. 在整个通信过程中**利用TypeScript确保类型安全**
3. tRPC provides GraphQL-like dynamic schema but with more simple approach than GraphQL.tRPC 
	1. **提供了类似 GraphQL 的动态模式，但比 GraphQL 的方法更简单**。
4. It can work with typescript-based tooling like Node, React etc
	1. 它可以与基于TypeScript的工具（如Node、React等）配合使用

### 4.3 Data Fetching Techniques 
4.3 数据获取技术

![[_posts/architect/System Design/media/8f53ea8b2d65efc47b4a810254570f98_MD5.jpg]]

4 Common Approaches for Data Fetching
**数据获取的4种常见方法**

#### 1️⃣ Short Polling - Using REST protocol
1️⃣ 短轮询 - 使用REST协议

- Stateful communication, Easy to load balance
	- **有状态通信，易于负载均衡**
- Simple to use with REST 
	- **使用REST时简单易用**
- Cons - More bandwidth utilization, more load on the server
	- `缺点` - 带宽利用率更高，服务器负载更大
- Cons - This can result in a slow UI experience in case of polling a large chunk of data frequently.
	- `缺点` - 如果频繁轮询大量数据，可能会导致用户界面体验缓慢。

#### 2️⃣ Long polling 
2️⃣ 长轮询

- Client sends requests frequently but sever sends a response when there is a new/updated response available.
	- 客户端频繁发送请求，但服务器仅在有新的或更新的响应可用时才发送响应。
- Stateful communication, Easy-to-load balance.
	- 有状态通信，易于负载均衡。
- Better than short polling, and uses less bandwidth than short polling.
	- **比短轮询更好，并且比短轮询使用更少的带宽**。
- Server-side logic is required to enable long polling.
	- 启用长轮询需要服务器端逻辑。

#### 3️⃣ Web Sockets - using ws/wss protocol
3️⃣ WebSocket - 使用ws/wss协议

- Stateless persistent communication. 
	- 无状态持久通信。
- Enables Bidirectional event-driven communication支持双向事件驱动通信
- Pros - Real-time communication - Best suitable for apps that require live interactions like chat, collaboration board优点 - 实时通信 - 最适合需要实时互动的应用，如聊天、协作板
- Cons - HTTP2 support is not available缺点 - 不支持HTTP2
- Cons - Required more resources and Load balancing is hard缺点 - 需要更多资源，且负载均衡难度大
- Cons - Cause issues with firewalls & proxies缺点 - 会导致防火墙和代理出现问题

#### 4️⃣ Server-side events 
4️⃣ 服务器端事件

- Send data from server to client, best suitable for notifications, live charts etc.从服务器向客户端发送数据，最适合用于通知、实时图表等场景。
- Pros - Push data from server to client优点 - 从服务器向客户端推送数据
- Supports HTTP2 capabilities. 支持HTTP2功能。
- Cons - Only text data supported 缺点 - 仅支持文本数据
- Cons - Only one-way communication happens缺点 - 仅存在单向通信

📖 [Learn more about Data Fetching Techniques](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#polling "Learn more about Data Fetching Techniques")📖 [了解更多关于数据获取技术的信息](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#polling "Learn more about Data Fetching Techniques")

### 4.4 UI & Data Rendering Approaches & Mechanisms
4.4 用户界面与数据渲染方法及机制

![[_posts/architect/System Design/media/2ad9745e63ef6255be96c99918db745c_MD5.jpg]]

How data and overall webpage render on the client device.数据和整个网页在客户端设备上的呈现方式。

#### Data Rendering Approaches 
数据渲染方法

DOM-based Vs Canvas 
基于DOM与Canvas

##### 1️⃣ DOM Based 
1️⃣ 基于DOM

1. Pagination - Page size, page no, offset分页 - 页面大小、页码、偏移量
2. Virtualization - using libraries like react-window where rather than adding new DOM elements, it uses existing DOM elements with updated content.虚拟化——使用像react-window这样的库，它不会添加新的DOM元素，而是使用现有DOM元素并更新其内容。
3. Infinite Scroll or Infinite load - This can be done using intersection observers.无限滚动或无限加载——这可以通过交叉观察器来实现。

##### 2️⃣ Canvas Based 
2️⃣ 基于画布

1. Relatively harder to implement than the DOM-based approach与基于DOM的方法相比，实现起来相对更难
2. A large amount of data can be rendered as part of the single canvas DOM element.大量数据可以作为单个画布DOM元素的一部分进行渲染。
3. Accessibility & Event handling is challenging with Canvas and requires custom handling of these cases.在Canvas中，无障碍性和事件处理颇具挑战性，需要对这些情况进行自定义处理。

#### Rendering mechanism 
渲染机制

How is the overall webpage delivered to the user’s device? There are 3 popular techniques
整个网页是如何传输到用户设备上的？有三种常用技术

##### 1️⃣ CSR - client-side rendering 
1️⃣ CSR - 客户端渲染

1. Very little SEO support 
	1. SEO支持极少
2. Navigation between pages is smooth 
	1. 页面间的导航很流畅
3. Less utilization of bandwidth - Good for bandwidth-critical devices.
	1. 带宽利用率更低——适用于对带宽要求较高的设备。

A classic create-react app is an example of client-side rendering, without using any special package to make it server-side. This means only a single base “div” element is rendered and the whole application is rendered within div using JavaScript.一个经典的create-react应用程序是客户端渲染的例子，它不使用任何特殊包来实现服务器端渲染。这意味着只渲染一个基础的“div”元素，整个应用程序通过JavaScript在该div内进行渲染。

##### 2️⃣ SSR - server-side rendering 
2️⃣ SSR - 服务器端渲染

1. Very Good for SEO 对SEO非常有利
2. Fast initial load, The server sends the whole page初始加载速度快，服务器会发送整个页面
3. More server-side changes are required to support this.支持这一点需要更多的服务器端更改。
4. More bandwidth utilization 更多带宽使用
5. Navigation between pages is smoother than CSR页面间的导航比客户端渲染（CSR）更流畅
6. Next JS, or older JSP, ExtJS are the classic example of SSR applications.Next JS 或较旧的 JSP、ExtJS 都是服务器端渲染（SSR）应用程序的典型例子。

##### 3️⃣ SSR with hydration 
3️⃣ 带水合作用的服务器端渲染

1. This approach tries to mix both approaches to take advantage of both SSO and smooth internal navigation.
	1. 这种方法试图将两种方式结合起来，以利用单点登录（SSO）和流畅的内部导航这两方面的优势。
2. Fast static website initial load, and then JavaScript injected to add interaction to the webpage.
	1. 快速的静态网站初始加载，然后注入JavaScript以增加网页的交互性。

📖 [Resources to learn more about Rendering Approaches](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#client-side-rendering "Resources to learn more about Rendering Approaches")📖 [了解更多渲染方法的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#client-side-rendering "Resources to learn more about Rendering Approaches")

### 4.5 Enable support for Accessibility, i18n, Offline Support
4.5 支持无障碍访问、国际化和离线功能

![[_posts/architect/System Design/media/cfe945d158840d902e931ed1911060a4_MD5.jpg]]

#### Accessibility 
无障碍性

✅ You should cover this part only if you get a “YES” below questions from the interviewer✅ 只有当你从面试官那里得到以下问题的“是”时，才需要涵盖这部分内容  
Q1 - What is the user age group? Do we need special support for senior citizens?问题1：用户的年龄群体是什么？我们是否需要为老年人提供特殊支持？  
Q2 - Is this a general-purpose application? and expected to be utilized by specially-abled users?Q2 - 这是一款通用应用吗？是否预计会有残障用户使用？  
  
✅ Primary considerations (You should cover the important ones, due to the limited time, otherwise there are many others for vision, hearing, voice & disabilities)✅ 主要考虑因素（由于时间有限，你应该涵盖重要的方面，否则在视觉、听觉、语音和残疾方面还有很多其他因素）  
💠 Screen reader support - By utilizing semantic elements, aria-roles and aria-states💠 屏幕阅读器支持 - 通过使用语义元素、aria角色和aria状态  
💠 Keyboard support - Keyboard navigation support for the Application💠 键盘支持 - 应用程序的键盘导航支持  
💠 Contrast colour support - Support contrasting colours, light/dark theme support.💠 对比色支持 - 支持对比色、明暗主题。

📖 [Resources to learn more about Accessibility](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#accessibility-principals "Resources to learn more about Accessibility")📖 [了解更多关于无障碍性的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#accessibility-principals "Resources to learn more about Accessibility")

#### Internationalization (i18n) & Localization
国际化（i18n）与本地化

✅ You should cover this part only if you get a “YES” below questions from the interviewer✅ 只有当你从面试官那里得到以下问题的“是”时，才需要涵盖这部分内容  
Q1 - Does this application have a user base across the borders?问题1 - 这款应用是否拥有跨国界的用户群体？  
Q2 - Does this application require localization support for multiple local languagesQ2 - 此应用程序是否需要对多种本地语言的本地化支持  
For example - localization can still be applicable in India to support regional languages, along with English.例如，在印度，本地化仍然适用，可用于支持各地区语言以及英语。  
  
✅ Primary considerations ✅ 主要考虑因素  
💠 Support for the language switch or auto-detect the browser's default language💠 支持语言切换或自动检测浏览器的默认语言  
💠 Which currency to show 💠 显示哪种货币  
💠 Time-zone & date time format support etc.💠 时区和日期时间格式支持等。

📖 [Resources to learn more about Internationalization (i18n) & Localization](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#i18n-&-localization "Internationalization (i18n) & Localization Resources")📖 [更多关于国际化（i18n）和本地化的学习资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#i18n-&-localization "Internationalization (i18n) & Localization Resources")

#### PWA/Offline Access 
PWA/离线访问

✅ You should cover this part only if you get a “YES” below questions from the interviewer✅ 只有当你从面试官那里得到以下问题的“是”时，才需要涵盖这部分内容  
Q1 - Does this application work even if there is no internet connection, and will sync as soon as online?问题1——即使没有互联网连接，此应用程序是否仍然可以运行，并且一旦联网就会同步？  
Q2 - How much data support is required for offline access? With the answer to this question, you can decide which type of cashing you can utilize to support offline access第二季度——离线访问需要多少数据支持？有了这个问题的答案，你就可以决定使用哪种缓存类型来支持离线访问。  
  
✅ Primary considerations ✅ 主要考虑因素  
💠 Implementation of offline capabilities can be achieved through “Service workers”. You can consider making the app a PWA (Progressive web app) where the app will have more capabilities than just offline support.💠 离线功能的实现可以通过“服务工作线程”来完成。你可以考虑将应用程序打造成渐进式Web应用（PWA），这样应用程序将具备更多功能，而不仅仅是离线支持。

📖 [Resources to learn more about PWA/Offline Acess Resources](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#basics,-service-workers-&-offline-support "PWA/Offline Acess Resrouces")📖 [了解更多关于PWA/离线访问的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#basics,-service-workers-&-offline-support "PWA/Offline Acess Resrouces")

## 5. Data Handling 
5. 数据处理

Divided into 2 parts to cover them in depth within the length limit为在篇幅限制内深入涵盖这些内容，将其分为两部分  
1. Data Entities 1. 数据实体  
2. Data Store 2. 数据存储

### 5.1 Data Entities 
5.1 数据实体

![[_posts/architect/System Design/media/684db9bd6325ab1333b4cec41d64249e_MD5.jpg]]

What are data entities? how do you represent them?什么是数据实体？如何表示它们？  
  
💠 Data entities represent the building blocks of the data which is required to render the part of the frontend application.💠 数据实体是渲染前端应用程序部分所需数据的基本构建块。  
For example - In the News Feed frontend System, define data entities that are required to represent a single newsfeed例如——在新闻推送前端系统中，定义表示单个新闻推送所需的数据实体。  
💠 Data Entities are similar to Objects (Real-world Entities) in Object Oriented Programming.💠 数据实体类似于面向对象编程中的对象（现实世界实体）。  
💠 Generally it's advisable to use TypeScript to represent the type of the data entities, you can assume these are the kinds of TS Interfaces that you need to design the system.💠 通常建议使用TypeScript来表示数据实体的类型，你可以假设这些就是你需要设计系统的那种TS接口。

#### Example: 
示例：

Let’s take an example of a complex system like Google Sheets,让我们以谷歌表格这样的复杂系统为例，  
here is a glimpse of data entities, (It's not the whole, there can be many more)以下是部分数据实体的示例（这并非全部，可能还有更多）

```
cell: {
     calculatedValue: string
     type: TableCellType
     formula: formula
     formatting: [FormatOptions]
     width: number
     height: number
}

type CellType {
     type: enum [NUMBER, STRING, DATE, CUSTOM],
     defaultFormula: formula
     customFormula: String
}

type formula {
    name: string
    expression: string
}

type FormatOptions: enum {
    BOLD,
    STRIKETHROUGH,
    ITALIC,
    …
}
```

#### 重要说明
Important Notes 

👉 In general, trivial data entities can be skipped after getting confirmation from the interviewer, for example, User management, Authentication/Authorization (Role base access), Caching entities etc.👉 一般来说，在得到面试官确认后，可以跳过一些琐碎的数据实体，例如用户管理、身份验证/授权（基于角色的访问）、缓存实体等。  
👉 It's important to make sure that using the described entities, you will be able to represent the whole data/functionalities required in step 1 of requirement gathering.👉 重要的是要确保，使用所描述的实体，您能够表示需求收集步骤1中所需的全部数据/功能。  
👉 Keep it crisp so that it can be practical to cover in 1 hour Interview.内容要简洁明了，以便能在1小时的面试中切实覆盖到。

### 5.2 Data Store 
5.2 数据存储

Data Sore is important for easily storing and accessing application state-specific data and API responses. A few examples of data store libraries like Redux, Redux-toolkit, MobX数据存储对于轻松存储和访问特定于应用程序状态的数据以及API响应非常重要。一些数据存储库的例子包括Redux、Redux-toolkit、MobX。

Follow the below pointers to create a Data Store for an application or component in the frontend system design interview在前端系统设计面试中，按照以下要点为应用程序或组件创建数据存储

1. **Error Cases:** Include Error scenarios, to store as part of the Data Store. In most cases, the error comes from API.**错误案例：**包含错误场景，作为数据存储的一部分进行存储。在大多数情况下，错误来自应用程序接口（API）。
2. **Data Entities:** Make sure you plan to store all the data entities which have been identified in the previous step.**数据实体：**确保你计划存储所有在上一步中已识别的数据实体。
3. **Load when required:** In case of pagination or cursor-based data, plan to add the data incrementally as the user fetches the data.**按需加载：**对于分页数据或基于游标的数据，应计划在用户获取数据时逐步添加数据。
4. **Store Normalized Data:** Store data entities in Normalized format for quick access through keys rather than looping through the entire array.**存储标准化数据：**以标准化格式存储数据实体，以便通过键快速访问，而无需遍历整个数组。  
    Normalization Example 规范化示例  
    
    ```
    {
    posts: [
        {
            id: 12758,
            slug: "blogs/mypost1",
            tags: ["concept", "javascript"]
        },
        {
            id: 12698,
            slug: "blogs/mypost2",
            tags: ["concept", "css"]
        }
      ]
    }
    ```
    
    Normalized data for Data Store, Now posts can be accessed directly `posts[<id>]`数据存储的标准化数据，现在可以直接访问帖子 `posts[<id>]`   
    
    ```
    {
    posts: {
        12758: {
            slug: "blogs/mypost1",
            tags: ["concept", "javascript"]
        },
        12698: {
            slug: "blogs/mypost2",
            tags: ["concept", "css"]
        }
      ]
    }
    ```
    

## 6. Interface (API) 
6. 接口（API）

![[_posts/architect/System Design/media/a213179908f4b73888edbeefed5d8d29_MD5.jpg]]

This step involves designing an API which will fuel the whole application with data from the server这一步包括设计一个API，该API将用来自服务器的数据为整个应用程序提供支持。

Design the API using the protocol which has been selected as part of [**Data Fetching Protocols**](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-fetching-protocols "Data Fetching Protocols") and consider the below points while designing the APIs使用已被选为[**数据获取协议**](https://www.frontendgeek.com/blogs/best-frontend-system-design-interview-cheat-sheet#data-fetching-protocols "Data Fetching Protocols")一部分的协议来设计API，并在设计API时考虑以下几点。

### API Design 
API设计

There are 2 parts of the API design - the URL and the responseAPI设计分为两部分——URL和响应

1. URL - URL should follow the best practices defined as part of the protocol design (like REST or GraphQL best practices)URL - URL应遵循协议设计中定义的最佳实践（如REST或GraphQL最佳实践）
2. API Response - Design the API response based on the application data store or vice-versa, the response should be extensible and should be loosely coupled with the type of data.API响应——基于应用程序数据存储设计API响应，反之亦然，该响应应具有可扩展性，且应与数据类型松散耦合。

### API Versioning 
API版本控制

Use API versioning to enable backward compatibility in case of a change in APIs.在API发生变更时，使用API版本控制以实现向后兼容性。

Examples: `/api/v1/posts` & `/api/v2/posts`示例：`/api/v1/posts` 和 `/api/v2/posts`

### Long List Support 
长列表支持

Consider long list support for the API design在API设计中考虑对长列表的支持

1. Pagination Support - There are 2 popular ways.分页支持 - 有两种常用方式。
    - Cursor-based 基于游标
    - page number-based 基于页码的
2. Filtering - Consumers can filter data on the server side using filter query parameters筛选 - 消费者可以使用筛选查询参数在服务器端筛选数据
3. Searching - Consumers can search text/regex-based search on the server side using filter query parameters搜索 - 消费者可以使用筛选查询参数在服务器端进行基于文本/正则表达式的搜索
4. Sorting - Consumers can sort on the pre-defined keys on the server side using filter query parameters (asc/desc)排序 - 消费者可以使用筛选查询参数（升序/降序）在服务器端按预定义的键进行排序

### Security 
安全

Use required tokens to enable API security, popular ones are below使用必需的令牌来启用API安全，常见的令牌如下

1. API Key as a query param 作为查询参数的API密钥
2. CSRF token CSRF令牌
3. Authorization JWT token - `Authorization: bearer <JWT token>`授权JWT令牌 - `Authorization: bearer <JWT token>`
4. Content Policy 内容政策

### Error Handling 
错误处理

Use Failure & Exception handling by adding Error Codes & Error Messages as part of the API response.通过在API响应中添加错误代码和错误消息来进行故障和异常处理。

```
{
      error: {
          code: 2374,
          message: [{
               error_message: "Something went wrong",
               error_description: "This error happened due to failure of xyz service."
          }]
      }
      ... rest of the API details
}
```

## 7. Optimizations 
7. 优化

3 types of optimizations can be done to make frontend applications fast and optimized.可以通过三种优化方式来使前端应用程序快速且经过优化。

![[_posts/architect/System Design/media/c21f8e63c30844e690755b28316b8e5e_MD5.jpg]]

### 7.1 Performance Optimizations 
7.1 性能优化

1. **Don’t block main thread**: use web-workers for heavy computations, parallel tasks**不要阻塞主线程**：对于大量计算和并行任务，使用Web Workers
    - Only for non-DOM manipulation tasks 仅适用于非DOM操作任务
2. Asset Optimizations 资产优化
    - **JS optimization JS优化**
        - Async, defer for JS script JS脚本的async、defer属性
        - Minification of JS bundle - webpackJS 包的压缩 - webpack
    - **CSS optimization CSS优化**
        - Load above the fold - critical CSS first先加载首屏内容 - 关键CSS优先
        - Use rem units 使用rem单位
        - Use Naming convention - `BEM block__element--modifier`使用命名约定 - `BEM block__element--modifier`
    - **Image optimizations 图像优化**
        - Use progressive image - PNG, WebP image使用渐进式图像 - PNG、WebP 图像
        - Lazy load images using `_<img loading="lazy/eager" src="" />_`使用`<img loading="lazy/eager" src="" />`实现图像懒加载
        - Use height and width for images - To minimize CLS (Cummulative layout shift) web vital.为图片设置高度和宽度——以减少累积布局偏移（CLS）这一网页核心指标。
        - Adaptive images - using "srcset" 自适应图像 - 使用“srcset”

**📖** [More resources to learn Performance Optimizations](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#web-vitals "More resources to learn Performance Optimizations")**📖** [更多学习性能优化的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#web-vitals "More resources to learn Performance Optimizations")

### 7.2 Network Optimizations 
7.2 网络优化

1. Gzip, Compression for assets - HTML, CSS, JSGzip，资源压缩 - HTML、CSS、JS
2. Resource Hinting - Prefetch, preload, pre-connect资源提示 - 预取、预加载、预连接
3. Rate limit request to server - Debounce, throttling对服务器的请求进行速率限制 - 防抖、节流
4. Bundle splitting - load only what you want to consume代码分割 - 只加载你想要使用的内容
5. Optimizing content delivery 优化内容分发
    - Content Delivery through CDN 通过CDN进行内容分发
    - HTTP Cache (Using cache-control header)HTTP缓存（使用cache-control标头）
    - Service Workers - Can be used for caching for faster content load.服务工作线程 - 可用于缓存以加快内容加载速度。

📖 [More resources to learn Network Optimizations](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#network-optimizations "More resources to learn Network Optimizations")📖 [更多学习网络优化的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#network-optimizations "More resources to learn Network Optimizations")

### 7.3 Rendering Optimizations 
7.3 渲染优化

1. Loaders, placeholders and error state加载器、占位符和错误状态
2. Virtualization (Using Intersection Observer), lazy loading, pagination or infinite scroll虚拟化（使用交叉观察器）、懒加载、分页或无限滚动
3. Lazy loading and code splitting - Non-critical assets懒加载和代码分割 - 非关键资源
4. Select SSR or SSR with hydration for better initial load performance选择SSR或带水合的SSR以获得更好的初始加载性能

**📖** [More resources to learn Rendering Optimizations](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "More resources to learn Rendering Optimizations")**📖** [更多学习渲染优化的资源](https://www.frontendgeek.com/frontend-interview/ui-technologies-interview#rendering-optimizations "More resources to learn Rendering Optimizations")

## 8. Extended Topics 
8. 扩展主题

These are the additional topics, which can be covered if explicitly asked or time permits as part of the frontend Sytem Sesign Interview这些是额外的主题，若在前端系统设计面试中被明确问及或时间允许，将会涉及到这些内容。

### 8.1 Security Considerations
8.1 安全考量

Below are the important security considerations for most applications以下是大多数应用程序的重要安全注意事项

1. Authentication & Authorization using SSO, or OAuth2.0使用SSO或OAuth2.0进行身份验证和授权
2. Using HTTPS 使用HTTPS
3. XSS attack - cross-site scripting XSS攻击 - 跨站脚本攻击
    - Encoding input text, and decoding while showing on the page对输入文本进行编码，并在页面显示时进行解码
4. CSRF - Cross Server resource forgeryCSRF - 跨服务器资源伪造
5. CSP - content security policy CSP - 内容安全策略
6. CORS - cross-origin resource sharingCORS - 跨域资源共享
7. API Rate limits, to avoid Denial of service attacks.API 速率限制，以避免拒绝服务攻击。

### 8.2 Observability 
8.2 可观测性

Observability involves the systems and ways to measure the health of the overall system可观测性涉及用于衡量整个系统健康状况的系统和方法

1. Logging & traceability - Logging error information and other information to debug any issues日志记录与可追溯性 - 记录错误信息和其他信息以调试任何问题
    - Success and failure logging 成功与失败日志记录
    - Latency logging 延迟日志记录
2. Analytics 分析学
    - Tracking user interactions 跟踪用户交互
    - Page views, observe clicks etc 页面浏览量、观察点击等

### 8.3 Testing & Automation considerations
8.3 测试与自动化考量

How to ensure the quality of the application when several team members working on the same code base, and how to avoid regressions. There are a few primary testing & automation considerations like当多名团队成员在同一个代码库上工作时，如何确保应用程序的质量，以及如何避免回归问题。有几个主要的测试和自动化方面的考虑因素，比如

1. Smoke UI tests - including basic sanity check of the application if things are working as expected like login, page load etcSmoke UI测试——包括对应用程序的基本健全性检查，如登录、页面加载等功能是否按预期工作
2. UI automation using libraries like Cypress, Nightwatch, and Puppeteer. 使用Cypress、Nightwatch和Puppeteer等库进行UI自动化。

## 接下来：其他与系统设计相关的博客
What's Next: Other System Design Related Blogs

✳️ [21 Most Asked Frontend System Design Interview Questions & Patterns](https://www.frontendgeek.com/blogs/21-most-asked-frontend-system-design-interview-questions-and-patterns "21 Most Asked Frontend System Design Interview Questions & Patterns")✳️ [21个最常被问到的前端系统设计面试问题及模式](https://www.frontendgeek.com/blogs/21-most-asked-frontend-system-design-interview-questions-and-patterns "21 Most Asked Frontend System Design Interview Questions & Patterns")

✳️ [Best Cheat Sheet for Frontend Machine Coding Interview Round](https://www.frontendgeek.com/blogs/best-cheat-sheet-for-frontend-machine-coding-interview-round "Best Cheat Sheet for Frontend Machine Coding Interview Round")✳️ [前端机器编码面试环节最佳速查表](https://www.frontendgeek.com/blogs/best-cheat-sheet-for-frontend-machine-coding-interview-round "Best Cheat Sheet for Frontend Machine Coding Interview Round")

✳️ [Explained Web Authorization Techniques - Session & JWT](https://www.frontendgeek.com/blogs/notes-for-web-authorization-techniques-session-and-jwt "Explained Web Authorization Techniques - Session & JWT")✳️ [解析Web授权技术 - 会话与JWT](https://www.frontendgeek.com/blogs/notes-for-web-authorization-techniques-session-and-jwt "Explained Web Authorization Techniques - Session & JWT")

✳️ [What is CORS ? Cross-Origin Resource Sharing Explained](https://www.frontendgeek.com/blogs/what-is-cors-cross-origin-resource-sharing-explained-for-interviews "What is CORS ? Cross-Origin Resource Sharing Explained")✳️ [什么是CORS？跨域资源共享解释](https://www.frontendgeek.com/blogs/what-is-cors-cross-origin-resource-sharing-explained-for-interviews "What is CORS ? Cross-Origin Resource Sharing Explained")

✳️ [Critical Rendering path for web performance](https://www.frontendgeek.com/blogs/understanding-critical-rendering-path-crp-to-improve-web-performance "Critical Rendering path for web performance")✳️ [Web性能的关键渲染路径](https://www.frontendgeek.com/blogs/understanding-critical-rendering-path-crp-to-improve-web-performance "Critical Rendering path for web performance")

