
## The RADIO Framework 无线电框架

Approach your front end system design interviews in a structured fashion. A good structure is half the battle won.  
**以结构化的方式进行前端系统设计面试。良好的结构是成功的一半。**

---

A good beginning is half the battle won. By using the **RADIO framework** to answer front end system design questions, you will already be much closer to acing your interview.  
良好的开端是胜利的一半。**通过使用 *RADIO 框架* 来回答前端系统设计问题**，您已经离面试成功更近了。

In the context of front end system design interviews, the systems you are asked to design tend to be products, so we'll refer to the system as "product" from here on. Start by understanding the **R** equirements, defining the high level **A** rchitecture and the **D** ata Model. Then define the **I** nterfaces between the components in the product and talk about any **O** ptimizations or dive deep into specific areas which require special attention.  
在前端系统设计面试的背景下，*你被要求设计的系统往往是产品，所以我们从这里开始将系统称为“产品”*。从理解 **R** 需求开始，定义**高层架构** 和 **数据模型**。然后**定义产品中组件之间的接口**，并讨论任何 **优化** 或深入研究需要特别注意的特定区域。

## RADIO 是什么?
What is RADIO about? 

1. **Requirements exploration**: Understand the problem thoroughly and determine the scope by asking a number of clarifying questions  
	**需求探索** ：*彻底理解问题*，并通过*提出一些澄清性问题来确定范围*
2. **Architecture / High-level design**: Identify the key components of the product and how they are related to each other  
	**架构/高层设计** ：*确定产品的关键组件以及它们之间的关系*
3. **Data model / Core entities**: Describe the core entities and its data – the fields each entity contains and which component(s) they belong to  
	**数据模型/核心实体** ：*描述核心实体及其数据*-每个实体包含的*字段及其所属组件*
4. **Interface definition (API)**: Define the interface (API) between components in the product, functionality of each API, their parameters and responses  
	**接口定义（API）** ：*定义产品中组件之间的接口（API）、每个 API 的功能、它们的参数和响应*
5. **Optimizations and deep dive**: Discuss possible optimization opportunities and specific areas of interest when building the product  
	**优化和深入探讨** ：讨论构建产品时*可能的优化机会*和感兴趣的特定领域

## 需求探索
Requirements exploration 

**Objective**: Understand the problem thoroughly and determine the scope by asking a number of clarifying questions.  
**目标** ：*通过提出一些澄清性问题，彻底理解问题并确定范围*。

**Recommended duration**: Not more than 15% of the session.  
**建议持续时间** ：不超过会议的 15%。

System design interview questions are open-ended in nature and are usually vague and under-specified on purpose. **You are required to dig deeper and clarify ambiguities in the problem by asking useful questions.** Treat your interviewer as a product manager you are working with on a new project, ask enough questions so that you know what problems you are trying to solve and what you need to build. In reality, some problems can be solved without any engineering at all!  
系统设计面试问题本质上是*开放式的，通常是模糊的，**故意不明确***。 **你需要*通过提出有用的问题来深入挖掘并澄清问题中的模糊之处*。** *把你的面试官当作一个新项目的产品经理，**问足够多的问题，这样你就知道你要解决什么问题，你需要做什么***。事实上，有些问题根本不需要任何工程就可以解决！

No two system design interview experiences will be the same even if you have been asked the same question before. Interviewers have different backgrounds and might prioritize different aspects of the system. Take this chance to find out what they are most interested in and plan your answers accordingly.  
*没有两个系统设计面试经验是相同的*，即使你以前被问过同样的问题。面试官有不同的背景，可能会优先考虑系统的不同方面。*抓住这个机会找出他们最感兴趣的是什么，并相应地计划你的答案*。

Some general questions you should get answers to before moving on to the next part of the interview:  
*在进入面试的下一部分之前，你应该先回答一些一般性的问题：*

### 我们应该关注的主要用例、功能是什么？
What are the main use cases we should be focusing on? 

Imagine you were asked to "Design Facebook". Facebook is a huge platform, there's news feed, profiles, friends, groups, stories, and more. Which parts of Facebook should you focus on? The interviewer has the answer in mind but wants you to find out by asking questions. Typically you should focus on the most unique aspects of the product, the features which define it. For Facebook, it would be the news feed, pagination of the feed, and creating new posts. For YouTube, it would be the video-watching experience. The important areas for other type of products be found in the [types of questions](https://www.greatfrontend.com/system-design/types-of-questions#examples).  
*假设你被要求“设计 Facebook”*。Facebook 是一个巨大的平台，有新闻提要，个人资料，朋友，群组，故事等等。**你应该关注 Facebook 的哪些部分？面试官心里已经有了答案，但想让你通过提问找到答案**。通常，你应该关注产品最独特的方面，即定义它的功能。对于 Facebook，这将是新闻提要，提要的分页，以及创建新帖子。对于 YouTube 来说，这将是观看视频的体验。其他类型产品的重要领域可以在 [问题类型](https://www.greatfrontend.com/system-design/types-of-questions#examples) 中找到。

For the rest of this page, we'll be using "Design Facebook" as the problem and apply the framework to it.  
在本页的其余部分，我们将使用“设计 Facebook”作为问题，并将框架应用于它。

Let's assume you didn't clarify which parts of the product to focus on and you assumed you should talk about the befriending flow and started talking about it. In the best case, good interviewers will steer you back in the direction the question was meant to proceed, but they will make a mental note that you didn't clarify the question. In the worst case, inexperienced interviewers will let you keep talking and politely try to find an opportunity to correct you, but you would have already wasted some precious minutes discussing an unimportant topic.  
让我们假设你没有明确说明产品的哪些部分是重点，你认为你应该谈论交友流程，并开始谈论它。*在最好的情况下，好的面试官会引导你回到问题的方向，但他们会记住你没有澄清问题*。*在最坏的情况下*，没有经验的面试官会让你继续说下去，并礼貌地试图找机会纠正你，但你已经浪费了一些宝贵的时间来讨论一个不重要的话题。

### 什么是功能性需求和非功能性需求？
What are the functional requirements and non-functional requirements? 

Firstly, what are functional and non-functional requirements?  
首先，什么是功能性需求和非功能性需求？

- **Functional requirements**: Basic requirements of the product such that the product cannot function without them. This is usually whether a user can complete the core flows correctly.  
	**功能需求** ：*产品的基本要求，没有这些要求，产品就无法运行*。这通常是指*用户是否能够正确完成核心流程*。
- **Non-functional requirements**: Requirements that are viewed as improvements to the product, but not strictly required for the product to be usable, i.e. the product can still be used without these. These include performance (how fast the page loads, how fast an interaction takes), scalability (how many items can be present on the page before the page slows to a crawl), good user experience, etc.  
	**非功能性需求** ：被视为*对产品的改进*，但不是产品可用的严格要求，即*没有这些需求产品仍然可以使用*。这些包括*性能*（页面加载的速度，交互的速度），*可伸缩性*（在页面慢到爬行之前，页面上可以显示多少项目），*良好的用户体验*等。

There are two ways you can get the answer to this question:  
**有两种方法可以得到这个问题的答案：**
1. Take the initiative to list out what you think are the requirements and get feedback and alignment from the interviewer (Preferred).  
	*主动列出你认为的需求，并从面试官那里得到反馈和调整（首选）*。
2. Ask the interviewer directly. However, most of the time they'd want you to define them. Even if they give you an answer, it won't be too detailed.  
	*直接问面试官*。然而，大多数时候*他们希望你来定义它们*。即使他们给你一个答案，也不会太详细。

At the very minimum, your design has to meet the functional requirements. After meeting all the function requirements, move on to talk about how to fulfill the non-functional requirements.  
至少，您的设计必须满足功能需求。**在满足所有功能需求之后，继续讨论如何实现非功能需求**。

### 什么是重点关注的核心功能，哪些是好的？
What are the core features to focus on and which are good-to-have? 

Even after you know the functional requirements, there can still be a ton of small features that make up the large feature. For example, when creating new Facebook posts, what kind of post formats should be supported? Besides the usual text-based posts, should the user be able to upload photos, upload videos, create polls, check in to a location, etc.  
*即使在您知道功能需求之后，仍然可能有大量的小功能组成大功能*。*例如*，在创建新的 Facebook 帖子时，应该支持什么样的帖子格式？除了通常的基于文本的帖子，用户是否应该能够上传照片，上传视频，创建投票，检查到一个位置，等等。

You should clarify the core features beforehand and design for them before moving on to the extra features.  
**你应该事先澄清核心功能，并在开始额外的功能之前为它们进行设计**。

### 其他问题
Other questions: 

- What devices/platforms (desktop/tablet/mobile) need to be supported?  
	*需要支持哪些设备/平台*（台式机/平板电脑/移动的）？
- Is offline support necessary?  
	*是否需要离线支持？*
- Who are the main users of the product?  
	*产品的主要用户是谁？*
- What are the performance requirements, if any? Performance requirements typically fall under non-functional requirements  
	*性能要求是什么*（如果有）？*性能需求通常属于非功能需求*

The questions above should give you a good starting list but it is by no means an exhaustive list! Different problems will require you to ask domain-specific questions, which we will talk about in the case studies.  
*上面的问题应该给你一个很好的开始列表，但它绝不是一个详尽的列表！不同的问题会要求你提出特定领域的问题*，我们将在案例研究中讨论。

You are recommended to write down the agreed requirements somewhere so that you can refer to them throughout the interview and ensure that you've covered them.  
我们*建议您将商定的需求写在某处，以便您可以在整个面试过程中参考它们，并确保您已经涵盖了它们*。

---

## 架构/高层设计
Architecture / High-level design 

**Objective**: Identify the key components of the product and how they are related to each other.  
`目标` ：**确定产品的*关键组件*以及*它们之间的关系***。

**Recommended duration**: Roughly 20% of the session.  
建议持续时间 ：约为会议的 20%。

With the requirements in mind, we can move on to the architecture design proper. Your next task is to come up with a product/system architecture by identifying the key components of the product, how the components interact with each other, and how they are related. Remember to focus on the **client-side architecture**, not the back end.  
*有了需求之后，我们就可以继续进行架构设计了*。您的下一个任务是**通过识别产品的关键组件，组件如何相互作用以及它们如何相关，来*提出产品/系统架构***。*记住，要关注 **客户端架构** ，而不是后端*。

Diagrams are your friends here. Each component can be represented using a rectangle and your high-level design usually ends up looking like a few rectangular boxes with arrows between them to demonstrate the flow of data. It is also possible to have components within components, in that case, draw the parent using bigger rectangles since they need to fit multiple subcomponents.  
图表是你的朋友。**每个组件**都可以用一个`矩形`来表示，您的高级设计*通常最终看起来像几个矩形框，它们之间有`箭头`来演示**数据流***。也可以**在组件中包含组件**，在这种情况下，*使用更大的矩形绘制父组件，因为它们需要包含多个子组件*。

Examples of components/modules which are commonly found in a high-level front end design:  
**高级前端设计中*常见的组件/模块***示例：

- **Server**: In front end system design interviews, we can treat the server as a black box and assume it exposes some APIs you can call via HTTP/WebSockets.  
	**服务器** ：在前端系统设计面试中，我们*可以将服务器视为一个黑盒子*，并*假设它公开了一些您可以通过 HTTP/WebSockets 调用的 API*。
- **View**: This represents what the user sees, and it usually contains smaller subviews within it. Can contain client-side only state.  
	**视图** ：表示用户看到的内容，通常*包含较小的子视图*。可以只包含客户端状态。
- **Controller**: The module which responds to user interactions and processes the data from the store/model in a format the view expects. This module is not always needed if the application is small and there's not much passing of data between modules.  
	**控制器** ：*响应用户交互*并以视图期望的格式*处理来自存储/模型的数据*的模块。如果应用程序很小，并且模块之间没有太多数据传递，*则不总是需要此模块*。
- **Model/Client store**: Where the data lives. Stores contain data which will be presented to the user via views and stores tend to be app-wide in an interview context. In reality, you can have multiple stores within an application and stores can contain other stores.  
	**模型/客户端存储** ：*数据所在的位置*。`Store`*包含将通过视图呈现给用户的数据*，并且store在面试上下文中倾向于app范围。实际上，*您可以在一个应用程序中拥有多个store，并且store可以包含其他store*。

Other things to consider when defining the responsibilities of components:  
*定义组件职责时需要考虑的其他事项：*

- **Separation of concerns**: Components are meant to be modular and serve to encapsulate a set of functionality and data. Consider the purpose/functionality of each component, what data it should contain and how it can service the rest of the system (what it can do for the other components).  
	**关注点分离** ：*组件应该是模块化的，用于封装一组功能和数据*。*考虑每个组件的目的/功能，它应该包含什么数据以及它如何为系统的其余部分提供服务*（它可以为其他组件做什么）。
- **Where computation should occur**: If some amount of computation is needed (e.g. filtering of results given a search term, calculating the total amount for a cart), should the work be done on the server or the client? There are tradeoffs to each approach and the decision is both product-dependent and context-dependent.  
	**计算应该发生在哪里** ：如果需要一定量的计算（例如，过滤给定搜索项的结果，计算购物车的总金额），*应该在服务器上还是在客户端上完成工作？* 每种方法都有权衡，决策既取决于产品，也取决于上下文。

It is important to realize that not every common component mentioned above will be relevant and necessary for every product, it depends on the unique aspects of the product.  
重要的是要认识到，*并不是上面提到的每个通用组件都与每个产品相关和必要，这取决于产品的独特方面*。

After drawing out the architecture diagram, verbally describe the responsibilities of each component (box in the diagram).  
在画出架构图之后，口头描述每个组件的职责（图中的方框）。

### 架构示例
Architecture example 

Here's an example architecture diagram for the [News Feed](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) question drawn using Excalidraw.  
下面是使用 Excalidraw 绘制的 [News Feed](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) 问题的示例架构图。

![[_posts/architect/System Design/greatfrontend.com/media/723a835cb5c3d712820cb2b36ef3c016_MD5.png]]

#### 组成部分的职责
Component responsibilities 

- **Server**: Serves feed data and provides a HTTP API for new feed posts to be created.  
	**服务器** ：*提供提要数据*，并为要创建的新提要帖子*提供 HTTP API*。
- **Controller**: Controls the flow of data within the application and makes network requests to the server.  
	**控制器** ：*控制应用程序中的数据流*，并*向服务器发出网络请求*。
- **Client store**: Stores data needed across the whole application. In the context of a news feed, most of the data in the store will be server-originated data needed by the feed UI.  
	**客户端存储** ：*存储整个应用程序所需的数据*。在新闻提要的上下文中，*存储中的大部分数据都是提要 UI 所需的源自服务器的数据*。
- **Feed UI**: Contains a list of feed posts and the UI for composing new posts.  
	**Feed UI** ：包含 Feed 帖子列表和用于撰写新帖子的 UI。
	- **Feed post**: Presents the data for a feed post and contains buttons to interact with the post (like/react/share/comment).  
		**Feed post** ：显示 Feed post 的数据，并包含与 post 交互的按钮（like/react/share/comment）。
	- **Post composer**: UI for users to create new feed posts.  
		**Post composer** ：用户可以创建新的 Feed 帖子的 UI。

Common free drawing tools that you might be asked to use include [diagrams.net](https://app.diagrams.net/) and [Excalidraw](https://excalidraw.com/). It'd be a good idea to familiarize yourself with these tools beforehand.  
您可能会被要求使用的常见免费绘图工具包括 [diagrams.net](https://app.diagrams.net/) 和 [Excalidraw](https://excalidraw.com/) 。这将是一个好主意，*让自己熟悉这些工具事先*。

---

## 数据模型
Data model 

**Objective**: Describe the various data entities, the fields they contain and which component(s) they belong to.  
`目标` ：*描述各种数据实体，它们包含的字段以及它们属于哪些组件*。

**Recommended duration**: Roughly 10% of the session.  
**建议持续时间** ：大约 10%的会话。

We now have to think about what data fields are present in the client. There are two kinds of data on client applications:  
我们现在必须考虑客户端中存在哪些数据字段。**客户端应用程序上有两种数据：**

### 源自服务器的数据
Server-originated data 

Data that originates from the server, usually from a database and meant to be seen by multiple people or accessed from multiple different devices. Common examples include user data (name, profile picture) and user-generated data (feed posts, comments).  
`源自服务器的数据`，通常*来自数据库*，旨在被多个人看到或从多个不同的设备访问。常见的例子包括*用户数据*（姓名，个人资料图片）和*用户生成的数据*（提要帖子，评论）。

### 客户端的数据
Client-only data 

Client-only data, also commonly known as state, is data that only needs to live on the client and does not have to be sent to the server for writing into the database. Client data can be further broken down into two:  
*仅限客户端的数据*，通常也称为`状态`，是**只需要存在于客户端上的数据，不必发送到服务器写入数据库**。

*客户端数据可以进一步细分为两个：*
- **Data to be persisted**: Usually user input such as data entered into form fields. These data usually has to be sent to the server and saved into a database for it to be useful.  
	**要持久化的数据** ：通常是*用户输入*，比如*输入到表单字段中的数据*。这些数据通常*必须发送到服务器并保存到数据库中*才能使用。
- **Ephemeral data**: Temporary state that lasts for a short time. Common examples include form validation state, current navigation tab, whether a section is expanded, etc. It's usually acceptable to lose these data when the browser tab is closed.  
	**短暂数据** ：*持续时间很短的临时状态*。常见的例子包括*表单验证状态、当前导航选项卡、某个部分是否展开*等。当浏览器选项卡关闭时，丢失这些数据通常是可以接受的。

When listing the data fields, it'd be useful to identify what kind of data that field is, whether it's server-originated data or client-only data.  
在列出数据字段时，*识别该字段是什么类型的数据是很有用的*，无论它是源自服务器的数据还是仅客户端的数据。

### 数据模型示例
Data model example 

Here's a basic example of data model for the various entities using the [News Feed](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) question.  
下面是使用 [News Feed](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) 问题的*各种实体的数据模型*的基本示例。

| Source 源                      | Entity 实体 | Belongs to 属于          | Fields 领域                                                                  |
| ----------------------------- | --------- | ---------------------- | -------------------------------------------------------------------------- |
| Server                        | `Post`    | Feed Post              | `id`, `created_time`, `content`, `image`, `author` (a `User`), `reactions` |
| Server                        | `Feed`    | Feed UI                | `posts` (list of `Post` s), `pagination` (pagination metadata)             |
| Server                        | `User`    | Client Store <br>客户端存储 | `id`, `name`, `profile_photo_url`                                          |
| User input (client) 用户输入（客户端） | `NewPost` | Feed Composer UI       | `message`, `image`                                                         |

Depending on how far you progress along in the question and how the requirements have evolved and grown during the interview, you might need to add more fields. It's a dynamic and iterative process.  
根据你在问题上的沿着程度以及面试过程中需求的发展和增长，你可能需要添加更多的字段。这是一个动态和迭代的过程。

You might want to write these fields near the components which owns them in your architecture diagram.  
您可能希望*将这些字段写在架构图中拥有它们的组件附近*。

---

## 接口定义（API）
Interface definition (API) 

**Objective**: Define the interface between components in the product, functionality of the various APIs, their parameters and responses.  
`目标` ：*定义产品中组件之间的接口、各种 API 的功能、它们的参数和响应*。

**Recommended duration**: Roughly 15% of the session.  
**建议持续时间** ：约为会议的 15%。

With the components and data within each components, we can move on to discuss the interface (APIs) between the components. API is an overloaded term and generally refer to the protocol which software components communicate and request/send data between components. *Client and server communicate via network layer APIs (HTTP/WebSockets). **Client components generally communicate via functions** in the browser runtime*. All APIs have three things in common whether they are between the server and the client or between client components:  
*有了组件和每个组件中的数据*，我们可以继续讨论**组件之间的接口（API）**。`API` 是一个重载术语，通常是指**软件组件在组件之间通信和请求/发送数据的协议**。**客户端和服务器*通过网络层 API（HTTP/WebSockets）进行通信***。***客户端组件之间*通常通过浏览器运行时中的*函数进行通信***。

所有 API 都有**三个共同点**，无论它们是在*服务器和客户端之间*还是在*客户端组件之间*：

| Parts of an API <br>部分 API       | Server-client<br>服务器-客户端                                       | Client-client <br>客户端-客户端             |
| -------------------------------- | -------------------------------------------------------------- | ------------------------------------- |
| Name and functionality <br>名称和功能 | HTTP path(URL path)<br>HTTP 路径                                 | JavaScript function <br>JavaScript 函数 |
| Parameters <br>参数                | HTTP GET query and POST parameters   <br>HTTP GET 查询和 POST 参数  | Function parameters <br>函数参数          |
| Return Value <br>返回值             | HTTP response, typically JSON format   <br>HTTP 响应，通常为 JSON 格式 | Function return value <br>函数返回值       |

### 服务器-客户端 API 示例
Server-client API example 

#### 名称和功能
Name and functionality

Using the [News Feed system design](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) example yet again, we have a server API that allows the client to fetch the latest feed posts.  
再次使用 [NewsFeed 系统设计](https://www.greatfrontend.com/questions/system-design/news-feed-facebook) 示例，我们有一个服务器 API，它允许客户端获取最新的 Feed 帖子。

| Field 领域    | Value 值                                               |
| ----------- | ----------------------------------------------------- |
| HTTP Method | `GET`                                                 |
| Path        | `/feed`                                               |
| Description | Fetches the feed results for a user.   <br>获取用户的提要结果。 |

#### 参数
Parameters 

A feed response is a paginated list so the API expects pagination parameters.  
提要响应是一个分页列表，因此 API 需要分页参数。

```json
{
  "size": 10,
  "cursor": "=dXNlcjpXMDdRQ1JQQTQ"
}
```

#### 响应
Response 

```json
{
  "pagination": {
    "size": 10,
    "next_cursor": "=dXNlcjpVMEc5V0ZYTlo"
  },
  "results": [
    {
      "id": "123",
      "author": {
        "id": "456",
        "name": "John Doe"
      },
      "content": "Hello world",
      "image": "https://www.example.com/feed-images.jpg",
      "reactions": {
        "likes": 20,
        "haha": 15
      },
      "created_time": 1620639583
    }
    // ... More posts.
  ]
}
```

### 客户端-客户端 API 示例
Client-client API example


The client-client API can be written in a similar fashion as the server-client API, main difference being they are JavaScript functions, or events that are being listened to. The most important parts to describe are the functionality of the API, the parameters and the return/response value.  
客户端-客户端 API 可以以与服务器-客户端 API 类似的方式编写，**主要区别**在于*它们是 JavaScript 函数或正在侦听的事件*。要描述的最重要的部分是 *API 的功能、参数和返回/响应值*。

### 用于 UI 组件系统设计的 API
API for UI component system design 

If you're asked to design a UI component, for the "Interface" section, discuss the customization options for the component, similar to the props of a React component.  
如果你被要求*设计一个 UI 组件*，**在“接口”部分，讨论组件的自定义选项，类似于 React 组件的props**。

---

## 优化和深度挖掘
Optimizations and deep dive 

**Objective**: Discuss about possible optimization opportunities and specific areas of interest when building the product.  
**目标** ：讨论构建产品时*可能的优化机会和特定的关注领域*。

**Recommended duration**: Roughly 40% of the session.  
**建议持续时间** ：***约占会议的 40%***。

There's no fixed way to go about the optimization and deep dive section and you are free to focus on different areas of the product. There will not be sufficient time to cover every area, so select how you want to spend your time carefully according to these guidelines:  
没有固定的方法可以进行优化和深入研究，您可以自由地专注于产品的不同领域。没有足够的时间来涵盖每个领域，因此请*根据以下指南仔细选择*您想要如何度过时间：

- **Focus on the important areas of the product**: For e-commerce websites, performance is crucial and you'd want to spend the bulk of your time diving into the various performance optimizations that can be done. For collaborative editors, the complexity is in how to handle race conditions and concurrent modifications, so you'd want to focus on explaining that.  
	**专注于产品的重要领域** ：*对于电子商务网站来说，性能至关重要*，您希望*花费大量时间深入研究可以完成的各种性能优化*。*对于协作编辑器*，复杂性在于如何处理争用条件和并发修改，因此您需要重点解释这一点。
- **Focus on your strengths**: Showcase your domain knowledge. If you are well-versed in accessibility, talk about the various accessibility pitfalls that can occur in the product and how to address them. Impress the interviewer with your knowledge. If you are a performance guru, explain the various performance optimization opportunities that can provide a buttery smooth user experience.  
	**专注于您的优势** ：***展示您的领域知识***。*如果你精通可访问性*，谈谈产品中可能出现的各种可访问性陷阱以及如何解决它们。用你的知识给面试官留下深刻印象。*如果你是一个性能专家*，解释各种性能优化机会，可以提供一个黄油顺利的用户体验。

### 一般优化/深入研究的领域
General optimization / Deep dive areas 

Here's a list of topics you can talk about for this section. Bear in mind that the importance of a topic depends on the product and some topics are entirely irrelevant to certain products (possible but unlikely).  
这里有一个你可以*在这一节谈论的话题列表*。请记住，*主题的重要性取决于产品*，有些主题与某些产品完全无关（可能但不太可能）。

- Performance 性能
- User Experience 用户体验
- Network 网络
- Accessibility (a11y) 无障碍（a11y）
- Multilingual Support 多语言支持
- Multi-device Support 多设备支持
- Security 安全

Refer to our [Best Practices for Building User Interfaces Guide](https://www.greatfrontend.com/front-end-interview-guidebook/user-interface-questions-cheatsheet) for details on each topic.  
有关每个主题的详细信息，请参阅我们 [的构建用户界面最佳实践指南](https://www.greatfrontend.com/front-end-interview-guidebook/user-interface-questions-cheatsheet) 。

---

## Summary 总结

## [Summary](https://www.greatfrontend.com/front-end-system-design-playbook/framework#summary)

|Step|Objective|Recommended duration|
|---|---|---|
|Requirements exploration|Understand the problem thoroughly and determine the scope by asking a number of clarifying questions.|<15%|
|Architecture / High-level design|Identify the key components of the product and how they are related to each other.|~20%|
|Data model|Describe the various data entities, the fields they contain and which component(s) they belong to.|~10%|
|Interface definition (API)|Define the interface (API) between components in the product, functionality of each APIs, their parameters and responses.|~15%|
|Optimizations and deep dive|Discuss about possible optimization opportunities and specific areas of interest when building the product.|~40%|

The fastest way to learn Front End – by building actual projects  
学习前端的最快方法-通过构建实际项目

Want to grow in your front end skills? Learn them the right way — build apps step-by-step while referencing best practices from Senior engineers.

- [80+ real world projects](https://www.greatfrontend.com/a/click?a=projects-in-content&u=%2Fprojects%2Fchallenges)
- Professional specs and designs by top-tier product managers and designers
- Guides and reference solutions from Senior Big Tech engineers
- Use a [front end skill roadmap](https://www.greatfrontend.com/a/click?a=projects-in-content&u=%2Fprojects%2Fskills) to build from beginner to pro
