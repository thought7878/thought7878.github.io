

---

## “需求与原型（原型设计）”课程文字稿

Evgenii simulates an interview environment for designing a social media application news feed similar to Twitter. The application requirements and a mock-up of the virtualization are designed. The requirements include both functional and non-functional items.
叶夫根尼模拟了一个类似Twitter的社交媒体应用新闻推送设计的面试环境。他设计了该应用的需求以及虚拟化的模型。这些需求既包括功能性项目，也包括非功能性项目。

[00:00:00]  
>> Evgenii Ray: So, let's try now to simulate the interview environment and design some complex app from scratch. So, we are going to look at the Twitter-like news feed problem. So, a few things to know about the system design interview is usually that they usually have around 35-45 minutes. To design the app, and it's a very limited timeframe, you'll not be able to handle all the cases and explain every point.>> 叶夫根尼·雷：那么，我们现在来试着模拟一下面试环境，从零开始设计一个复杂的应用程序。我们要研究的是类似Twitter的新闻推送问题。关于系统设计面试，有几点需要了解，这类面试通常时长在35到45分钟左右。要在这么有限的时间内设计出一个应用程序，你不可能涵盖所有情况，也无法解释清楚每一个细节。

[00:00:31]  
So you need to make sure that you commit to requirements that you actually can complete on the board. So make sure that you're not over committing because if you're over committing in terms of things you want to design then it won't look good. So first you always start with the requirements, you need to understand what you're trying to build and design.所以你要确保自己承诺的任务是确实能在黑板上完成的。所以一定不要承诺过多，因为如果在你想设计的内容上承诺过多，结果会不太好。所以首先，你要从需求入手，你需要明白自己要构建和设计的是什么。

[00:00:59]  
So since we know the problem, it's the Twitter like news feed, so let's define this requirements here in the board.既然我们已经了解了这个问题，也就是类似Twitter的新闻推送，那我们就在这块板上明确一下这些需求吧。  
>> Evgenii Ray: So first of all, I think it will be useful for us to have some simple mock up of the app that we're trying to build. So let's have a mock up section, and so the newsfeed is basically the list where we render the stories, right, one after another.>> 叶夫根尼·雷：首先，我认为制作一个我们正尝试开发的应用的简单模拟界面会对我们有所帮助。所以我们来设置一个模拟界面部分，而新闻推送本质上就是一个列表，我们在其中逐条展示新闻，对吧。

[00:01:35]  
And the two key characteristics here that the stories are loaded dynamically and we have unlimited number of stories. So let's mock this up, so we have a few stories, story one, story two, story three, and story four. And all the stories are rendered from top to bottom, and that's also mark them as one, as two, as three, and as four.这里的两个关键特征是，这些故事是动态加载的，而且我们拥有无限数量的故事。所以让我们来模拟一下，我们有几个故事，故事一、故事二、故事三，还有故事四。所有的故事都是从上到下渲染的，并且也把它们标记为一、二、三、四。

[00:02:05]  
So this can serve us as a mockup, now, let's list all the requirements to our newsfeed. So first of all, we already said that the stories render from top to bottom and they might be an infinite number of stories.所以这可以作为我们的模型，现在，让我们列出我们新闻推送的所有要求。首先，我们已经说过，这些报道从上到下呈现，而且可能有无数条报道。  
>> Evgenii Ray: So the second one that is infinite number of stories.>> 叶夫根尼·雷：所以第二个是无限数量的帖子。

[00:02:38]  
>> Evgenii Ray: Also, our story can also contain some media content, so we can probably attach some images or the videos. So I would limit this design to image only to make sure that we cover everything. So let's say we want to support the media, and we'll list images as a supported media.>> 叶夫根尼·雷：另外，我们的故事也可以包含一些媒体内容，所以或许可以附上一些图片或视频。不过为了确保涵盖所有内容，我会把这个设计限制为仅支持图片。这么说吧，我们希望支持媒体，而我们会将图片列为受支持的媒体类型。

[00:03:02]  
>> Evgenii Ray: So this is the basic requirements for the app, you also have a non-functional requirements section where you describe how your application should find, like some additional technical details how your application should function. And let's call it non-functional and the first requirement will be that usually in the news feed, is used on the mobile devices because most of the social network content now is consumed from the mobiles.>> 叶夫根尼·雷：这是该应用程序的基本要求，你还需要一个非功能性需求部分，在这部分中描述你的应用程序应如何运行，比如一些关于应用程序应如何运作的额外技术细节。我们就称其为非功能性需求，第一个需求通常是，新闻推送功能通常用于移动设备，因为现在大多数社交网络内容都是通过移动设备来消费的。

[00:03:36]  
So we need to make sure that our news feed works properly on the mobile and desktop.所以我们需要确保我们的新闻推送在移动设备和桌面设备上都能正常运行。  
>> Evgenii Ray: And as a result, since we're expected to use our application on a mobile device, we are constrained on the network vendor. We can expect that our user may have a slow 3G connection, so we should be network efficient.>> 叶夫根尼·雷：因此，由于我们的应用预计要在移动设备上使用，我们在网络供应商方面会受到限制。我们可以预料到用户可能使用的是速度较慢的3G网络，所以我们的网络使用效率必须很高。

[00:04:14]  
>> Evgenii Ray: And last thing I'd like to mention is, since we also use our newsfeed on a mobile, we need to think about the performance of the app. So we need to make sure that our infinitely rendered list doesn't impact the CPU and the memory and we don't consume too much.>> 叶夫根尼·雷：我想提的最后一点是，既然我们也在移动端使用新闻推送功能，就需要考虑应用的性能问题。所以我们要确保无限渲染列表不会影响CPU和内存，也不会消耗过多资源。

[00:04:35]  
So this means that we should be CPU and memory efficient.这意味着我们应该提高CPU和内存的使用效率。  
>> Evgenii Ray: And the last thing that we may add to this design is, usually when you go on a plane or on a train, you may not have the network. But I still want to check my stories that are already loaded, so let's have the offline support>> 叶夫根尼·雷：我们可以为这个设计添加的最后一项功能是，通常当你乘坐飞机或火车时，可能没有网络。但我仍然想查看那些已经加载好的内容，所以我们来加入离线支持吧。  
>> Evgenii Ray: Okay, so now we're have all our basic requirements that we want to complete for this design.>> 叶夫根尼·雷：好的，现在我们已经掌握了这个设计需要完成的所有基本要求。

[00:05:24]  
Let's start with our mock up, and let's try to understand, first, how can we optimize the rendering of this mock up? So first of all, since we expect to have the infinite number of the stories, let me quickly clean this up because we will need some space around here.让我们从我们的模型开始，首先试着理解，我们如何优化这个模型的渲染？首先，由于我们预计会有无限数量的故事，我来快速清理一下，因为我们这里需要一些空间。

[00:05:49]  
>> Evgenii Ray: So we expect that we have unlimited number of stories to be rendered on the device. So the one way to achieve that is to implement the virtualization and how the virtualization is done. So we need to register two observers, one at the top and one at the bottom.>> 叶夫根尼·雷：所以我们希望能在设备上渲染无限数量的故事。实现这一点的一种方法是实施虚拟化，以及如何进行虚拟化。因此，我们需要注册两个观察器，一个在顶部，一个在底部。

[00:06:15]  
>> Evgenii Ray: So we're also gonna use the concept of the viewport, this green line will tell us where the view port is. So when we render our stories and the view port touches the bottom observer, this means that we need to load a new page. So, how are we going to implement the virtualization?>> 叶夫根尼·雷：所以我们还要用到视口的概念，这条绿线会告诉我们视口在哪里。因此，当我们渲染故事且视口触碰到底部观察器时，这意味着我们需要加载新页面。那么，我们要如何实现虚拟化呢？

[00:06:42]  
So the way how we could potentially implement the virtualization is to move this elements out of the normal flow using the absolute positioning. This way we can limit the number of mutations and reflows by moving the Selma to separate stacking context for the absolute positioning. So we've registered two observers now and we moved all our stories to separate stacking context, but now we need to detect the position and render them absolutely.因此，我们潜在的虚拟化实现方式是通过绝对定位将这些元素移出正常流。这样，通过将Selma移至绝对定位的独立堆叠上下文，我们可以减少变异和重排的次数。目前我们已经注册了两个观察器，并将所有内容移到了独立的堆叠上下文，但现在我们需要检测位置并以绝对定位的方式渲染它们。

[00:07:12]  
So for that, we're gonna use the CSS transformation because CSS transformation utilizes the optimized reflow pipeline. So, the way we calculate the stories, the story position, is we take the previous y position of the ESFRI then we plus the margin. Which is ESFRI, plus the height of the next story, which is 84.因此，我们将使用CSS变换，因为CSS变换利用了优化的回流管道。我们计算故事及其位置的方法是，取ESFRI之前的y坐标，然后加上边距。也就是ESFRI加上下一个故事的高度（84）。

[00:07:47]  
And we use a CSS transformation for that, since we use the CSS transformation, we use we utilize the optimize pipeline. And we make sure that our stories render via GPU, so we select these two stories and recycle them to the bottom. So basically this stories will appear here.为此我们使用了CSS变换，因为我们使用了CSS变换，所以我们利用了优化管道。并且我们确保我们的故事通过GPU渲染，所以我们选择了这两个故事并将它们循环到底部。所以基本上这些故事将会出现在这里。

[00:08:22]  
>> Evgenii Ray: And now, we need to move our observer, so we'll move our bottom observer to the bottom, and here we're gonna use the top observer, so here now we will have empty space.>> 叶夫根尼·雷：现在，我们需要移动我们的观测器，所以我们要把底部的观测器移到底部，而这里我们要用顶部的观测器，所以现在这里会有空白区域。  
>> Evgenii Ray: So, this is the empty area.>> 叶夫根尼·雷：所以，这是一片空白区域。  
>> Evgenii Ray: And the way we can maintain the scroll bar here is by simulating the height of the container.>> 叶夫根尼·雷：我们在这里能够保持滚动条的方法是通过模拟容器的高度。

[00:08:56]  
So we always know the Scroll height of the container, so we can use the property scroll height and apply the CSS style to that. CSS styles to the main container, so the main container always knows the styles, the height, yep.所以我们总是知道容器的滚动高度，因此我们可以使用滚动高度属性并将CSS样式应用于该属性。将CSS样式应用于主容器，这样主容器就总能知道这些样式和高度了，没错。  
>> Speaker 2: How would this work if you had varying height cards?>> 发言者2：如果卡片的高度各不相同，这会如何运作呢？

[00:09:20]  
>> Speaker 2: Is it presumed fixed height?>> 发言者2：它的高度被假定为固定的吗？  
>> Evgenii Ray: Yeah, no, it would work the same way because since you protest the card one by one, you always take in account the height of the previous card. Because you're in the formula, you use the height of the card, and the card can be different in the size, so it will work for the dynamic sizes too.>> 叶夫根尼·雷：是的，不，它的工作原理是一样的，因为既然你一张一张地处理卡片，你总会考虑到前一张卡片的高度。因为在公式中，你会用到卡片的高度，而卡片的尺寸可能不同，所以它也适用于动态尺寸。

[00:09:46]  
So the way we can handle the rendering, for instance, if we squeeze the content and now the card increased. In this case we'll have to trigger the rendering off the virtual list so everything is positioned correctly. Okay, now we have the mockup and also we explained how everything will work, so the bottom observer will take the position of the last element in the list.所以我们处理渲染的方式是，例如，如果我们压缩内容，现在卡片变大了。在这种情况下，我们必须触发虚拟列表的渲染，这样所有内容才能正确定位。好的，现在我们有了模型，也解释了所有东西的工作原理，底部观察器会获取列表中最后一个元素的位置。

[00:10:20]  
And the top observer will take the position of the first element in the list and they will also be moved using the CSS transformation. So if we look at the data, how the data would look like, so basically we have an array of our data, which is d1, d2, d3, d4, and then we also have a d5 and d6.排名靠前的观察者将占据列表中第一个元素的位置，并且它们也会通过CSS变换进行移动。所以如果我们查看数据，数据会是怎样的呢？基本上，我们有一个数据数组，包括d1、d2、d3、d4，此外还有d5和d6。

[00:10:50]  
When we do initial render, we render it the first page of the data and the second page of the data, so this is the page 1, this is the page 2. So when we trigger the bottom observer, so we move the start pointer. Before it was here, here was the start, so we moved it by plus 1, so now it starts in that page 2.当我们进行初始渲染时，会渲染数据的第一页和第二页，所以这是第1页，这是第2页。因此，当我们触发底部观察器时，就会移动起始指针。之前起始指针在这里，这里是起点，我们将它加1，所以现在它从第2页开始。

[00:11:18]  
And to load this chunk of data removed our end pointer to the page 3, this is how we maintain the sliding window in the memory. So in the memory we'll have our data array and we can basically move. So once we loaded the data, we don't really need to load it one more time.而加载这部分数据时，我们将尾指针移到了第3页，这就是我们在内存中维持滑动窗口的方式。所以在内存中，我们会有数据数组，并且基本上可以移动它。因此，一旦加载了数据，我们就真的不需要再加载一次了。

[00:11:40]  
We can utilize the cache data from the global state, do we just move around with the start and end pointers. So this is how we would optimize the virtual list.我们可以利用全局状态中的缓存数据，只需移动起始指针和结束指针即可。这就是我们优化虚拟列表的方法。



