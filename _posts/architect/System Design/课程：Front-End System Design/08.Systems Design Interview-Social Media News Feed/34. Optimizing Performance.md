

---

## “优化性能”课程文字稿

Evgenii completes the system design for the social media news feed by describing how to optimize the network, UI rendering, and JavaScript code execution performance.
叶夫根尼通过阐述如何优化网络、用户界面渲染和JavaScript代码执行性能，完成了社交媒体新闻推送的系统设计。


[00:00:00]  
>> Evgenii Ray: So next bit is the performance optimization. So since we already passed for the workshop and you probably know where we were going to start, so the performance optimization is split into the free section. The first one is the network.>> 叶夫根尼·雷：接下来是性能优化。既然我们已经完成了研讨会的内容，你们可能也知道我们接下来要从哪里开始，性能优化分为三个部分。第一部分是网络。  
>> Evgenii Ray: The second one is the rendering.>> 叶夫根尼·雷：第二个是渲染。  
>> Evgenii Ray: And the last one is the JavaScript, so let's start with the network.>> 叶夫根尼·雷：最后一个是JavaScript，那我们从网络开始讲起。

[00:00:34]  
The first thing that we can do to optimize the network is to migrate to HTTP2. Since it will allow us to fetch 200 SSE in parallel within one TCP connection it will also Utila better utilize the device battery. Because we don't need to create five sockets in parallel compared to a CP1.优化网络的第一件事是迁移到HTTP2。因为它允许我们在一个TCP连接中并行获取200个SSE，这也能更好地利用设备电池。因为与CP1相比，我们不需要并行创建五个套接字。

[00:01:02]  
>> Evgenii Ray: The next thing is, since we have HTTP2, it's a very good idea to split the bundle. So let's split it, so we call it bundle split.>> 叶夫根尼·雷：接下来，既然我们有了HTTP2，拆分捆绑包是个非常好的主意。那我们就来拆分吧，我们称之为捆绑包拆分。  
>> Evgenii Ray: And we can actually split our bundle even more and prepare the default, for platform targets so it can be ES5, and it can also be ES.>> 叶夫根尼·雷：实际上，我们可以进一步拆分我们的包，并为平台目标准备默认设置，这样它既可以是ES5，也可以是ES。

[00:01:29]  
Next, so we're reduce the size of the initial bundle that we're loading on the screen. So the next thing would be to define defer the scripts, so if we have any analytic scripts or any non-critical stuff, we can load this layer once the page is loaded. So it's also a good idea to compress things.接下来，我们要减小加载到屏幕上的初始捆绑包的大小。所以下一步是定义延迟加载脚本，这样如果我们有任何分析脚本或非关键内容，就可以在页面加载完成后再加载这一层。此外，对内容进行压缩也是个好主意。

[00:01:57]  
So we want to make sure that we're using Gzip or at least broadly, actually it should be in a different order. So we should at least use the Gzip, and then if we have the broadly support, then it's better to use the broadly, because Gzip will provide around 85% compression.所以我们要确保我们在使用Gzip，或者至少是更广泛地使用，实际上顺序应该有所不同。所以我们至少应该使用Gzip，如果我们能获得更广泛的支持，那么最好使用更广泛的方式，因为Gzip能提供大约85%的压缩率。

[00:02:22]  
They broadly provides around 91% of compression. Okay, so also one thing you want to make sure that all your assets are served not from the directly from the API server but from CDN. And this is also it's a very common means from the web infrastructure perspective.它们大致能提供约91%的压缩率。好的，另外有一点你要确保的是，所有资源都不是直接从API服务器提供，而是通过CDN来提供。从网络基础设施的角度来看，这也是一种非常常见的方式。  
>> Evgenii Ray: When it comes to your image to the images assets, so let's create a section, assets for the images you want to use the opt, optimized format.>> 叶夫根尼·雷：说到你的图像与图像资源，那我们来创建一个部分，用于存放你想要使用优化格式的图像资源。

[00:03:02]  
So make sure that you use WebP, or you can also provide a full back for JPEG if this doesn't work out. Also use the font loading, so if you have some custom fonts, to use font loading attribute to make sure that you don't wait three seconds until until the custom folder is loaded.所以请确保使用WebP格式，或者如果WebP不可用，也可以提供JPEG格式作为完整的替代方案。另外，要使用字体加载功能，如果你有一些自定义字体，通过使用字体加载属性，确保不会等待三秒钟才加载完自定义字体。

[00:03:35]  
So what else we can do with the our with the network? So one thing that's, if you have such budget in your, in your organization, you may consider implementing the optimization service. So usually there is some kind of the API that takes an image as an input, and then outputs the compressed version for the specific viewport.那么，我们还能通过这个网络做些什么呢？有一点是，如果你所在的组织有这样的预算，你可以考虑实施优化服务。通常会有某种应用程序接口（API），它接收图像作为输入，然后为特定的视口输出压缩版本。

[00:04:09]  
So it ensures that you don't load the image which is too large for the screen. So I think we're done with the networking for now, let's do the rendering. And when it comes to rendering, the first thing that you want to make sure that you implement is the DOM optimization.因此，它能确保你不会加载对于屏幕来说过大的图像。所以我认为我们目前的网络部分已经完成了，接下来我们来处理渲染。说到渲染，你首先要确保实现的就是DOM优化。

[00:04:36]  
So first thing, you need to maintain the constant number of nodes because if you maintain a constant number of NOS, then your device use the same the same amount of memory all the time. And it increases the responsiveness of the app and to do that, you can consider to use the virtualisation which we already used for the infinite list loading.首先，你需要保持节点数量不变，因为如果保持网络操作系统（NOS）的数量恒定，那么你的设备就会一直使用相同数量的内存。这会提高应用程序的响应速度，要做到这一点，你可以考虑使用我们已经在无限列表加载中使用过的虚拟化技术。

[00:05:06]  
Also make sure that your CSS lectures are flattened, if you have hundreds of CSS questions.另外，如果你有数百个CSS问题，请确保你的CSS选择器是扁平化的。  
>> Speaker 2: Yeah, there is a question. Some performance optimizations might add a lot of complexity or time to the project, how do you know when it's worth it when designing?>> 发言者2：是的，我有个问题。一些性能优化可能会给项目增加很多复杂性或时间成本，在设计时你怎么判断这么做是否值得呢？  
>> Evgenii Ray: So follow the guidelines for web vitals, if you see that your web vitals are not perfect, like in a yellow zone, and your first screen loading performance is around four seconds.>> 叶夫根尼·雷：所以要遵循网页核心指标的指导原则，如果你发现自己的网页核心指标并不理想，比如处于黄色区域，而且首屏加载性能在四秒左右。

[00:05:44]  
And I guess it's a pretty bad experience for the user, so you don't need to be 99% best at the web vitals, but as long as your website is loading pretty fast for the users, then you provide this optimization. So you do the optimization when you actually need them, if your website loads fast, you don't need to overcomplicate the design.我想这对用户来说会是相当糟糕的体验，所以你不必在网页核心指标上做到99%的极致，但只要你的网站对用户来说加载速度足够快，那就说明你进行了这种优化。所以，只有在真正需要的时候才去做优化，如果你的网站加载速度很快，就没必要把设计搞得过于复杂。

[00:06:11]  
Here we just list the possibilities of what we can do on the system design tree. Okay, so first, you want to flat in the selectors.下面我们仅列出在系统设计树中可以进行的操作可能性。好的，首先，你需要简化选择器。  
>> Evgenii Ray: And if you have hundreds of complex selects on the app, it can add around 50 or 100 milliseconds in total to the first screen rendering.>> 叶夫根尼·雷：如果你的应用程序上有数百个复杂的选择操作，这可能会给首屏渲染总共增加大约50到100毫秒的时间。

[00:06:36]  
So make sure that you use some naming methodology that helps to simplify such selectors. Also we want to make sure that we do not trigger the reflow and the way we do not trigger the reflow is we by utilizing the properties that trigger only limited pipeline which is GPU based.所以要确保使用一些命名方法来简化这类选择器。此外，我们还要确保不会触发回流，而避免触发回流的方法是利用那些只触发有限流水线（基于GPU）的属性。

[00:07:01]  
So as a follow up, we need to make sure that we use CSS transformation for the animations.因此，作为后续步骤，我们需要确保对动画使用CSS变换。  
>> Evgenii Ray: So it's also good practice to use some when we just load our application, we may want to consider to include some loading icons in the initial index HTML response. So we give the good feedback to the user, so we'll call it loading placeholders.>> 叶夫根尼·雷：所以，在加载应用程序时，使用一些加载图标也是个好做法，我们可能需要考虑在初始的index HTML响应中加入一些加载图标。这样我们就能给用户良好的反馈，我们称之为加载占位符。

[00:07:41]  
>> Evgenii Ray: Okay, and what else can be done on the rendering side?>> 叶夫根尼·雷：好的，在渲染方面还能做些什么呢？  
>> Evgenii Ray: Okay, I think we can now finish this section and jump to the CSS, so the rule of thumb for Creep is we shouldn't block the UI thread. So make sure that you do stuff as asynchronous as possible, so if you have the heavy job, go to the web worker or your API.>> 叶夫根尼·雷：好的，我认为我们现在可以结束这一部分，转而讲解CSS了。关于Creep的经验法则是，我们不应该阻塞UI线程。所以要确保尽可能以异步方式处理任务，如果你有繁重的工作，就交给Web Worker或者你的API去处理。

[00:08:20]  
And if you can't use both, one way we can do the asynchronous job is to schedule the Idle callback. So the Idle callback will instruct the browser to find the time frame to execute a piece of job into the free space of time while the browser is not doing any rendering.如果不能同时使用两者，我们可以通过一种方式来处理异步任务，那就是调度空闲回调。空闲回调会指示浏览器在其不进行任何渲染的空闲时间里，找到合适的时间段来执行某段任务。

[00:08:42]  
So we can provide the idle callback.所以我们可以提供空闲回调。  
>> Evgenii Ray: Okay, so we also want to make sure that we use asynchronous storages, such as IndexDB. And it's also a good thing to implement the service worker, the service worker is a very simple type of background workers that caches your assets.>> 叶夫根尼·雷：好的，所以我们还想确保使用异步存储，比如IndexDB。而且实现服务工作线程也是个好主意，服务工作线程是一种非常简单的后台工作线程，用于缓存你的资源。

[00:09:17]  
So between your server, and the client, the service worker interrupts the requests and it can put them into the Index DB. And next time you load your asset, it will be served from the Index DB so you don't do additional network trip.因此，在服务器和客户端之间，服务工作线程会拦截请求并将其存入索引数据库。下次加载资源时，就会从索引数据库中获取，这样就无需额外的网络请求了。  
>> Evgenii Ray: So one thing about the JavaScript is you need to make sure that you reduce the downloadable code, we already talked about this in network section.>> 叶夫根尼·雷：关于JavaScript，有一点需要注意，那就是要确保减少可下载的代码量，这一点我们在网络部分已经讨论过了。

[00:09:56]  
But the less the browser needs to parse the better for initial loading because when you initiate the script, the browser has to compile this and provide the optimized runtime for that. So make sure that you reduce the GS payload. I know it's pretty hard, especially with the libraries, but you can reduce that by optimizing the network section where we split the bundle and also prepare the ES5 and ES next bundles.但浏览器需要解析的内容越少，初始加载效果就越好，因为当你启动脚本时，浏览器必须对其进行编译，并为其提供优化的运行时环境。所以要确保减少GS的负载量。我知道这相当困难，尤其是对于库文件而言，但你可以通过优化网络部分来实现这一点，在这部分我们可以拆分捆绑包，同时准备好ES5和ES next的捆绑包。

[00:10:33]  
So for the JavaScript, I think we are done. So, this is the performance optimization section and basically this is the end of the our system design interview now, and this should provide the good overview of the points that we mentioned before. So we wanted to design first the efficient rendering of the list, so we provided an explanation with the virtualization then we also provide an explanation how we store the data efficiently.关于JavaScript部分，我认为我们已经完成了。这是性能优化部分，基本上到这里我们的系统设计面试就结束了，这应该能很好地概述我们之前提到的要点。我们首先想设计列表的高效渲染，所以我们给出了关于虚拟化的解释，然后也说明了如何高效地存储数据。

[00:11:09]  
And one thing that we may also mention is we can also utilize our Index DB to store the state data. So we can out source the data from runtime to the hard drive and we also provided the performance optimization points that we can apply to our application. So this is basically what you can do in 35 minutes time frame and yeah this is Is it for the system design?还有一点我们可能需要提到的是，我们也可以利用索引数据库（Index DB）来存储状态数据。这样我们就可以将数据从运行时转移到硬盘上存储，而且我们还提供了一些可以应用于我们应用程序的性能优化要点。所以，这基本上就是在35分钟的时间内你可以完成的事情，是的，这就是系统设计的内容吗？

[00:11:40]  
>> Speaker 2: So one of the non functional requirements you talked about was offline usage, could you just speak a little bit to like, which parts of this whole everything you discussed fits into that?>> 发言者2：你提到的一个非功能性需求是离线使用，你能稍微说说，你所讨论的这一切中，哪些部分符合这一点吗？  
>> Evgenii Ray: So when we register the service worker, so it basically registers on inside a browser, it says, very small.>> 叶夫根尼·雷：所以当我们注册服务工作线程时，它基本上是在浏览器内部注册的，情况就是这样，非常简单。

[00:11:58]  
Script that basically caches the resources in IndexDB, so you can instruct the service worker to put the HTML CSS images assets in the index DB. And when you load your application next time, so it will interrupt the request to the server and serve your asset from the image DB so you can open your application even offline.这个脚本主要用于在IndexDB中缓存资源，因此你可以指示服务工作线程将HTML、CSS、图像等资产存入索引数据库。这样，当你下次加载应用程序时，它会中断对服务器的请求，从图像数据库中提供资产，从而使你即使在离线状态下也能打开应用程序。

[00:12:22]  
>> Speaker 2: Is it worth getting into how to invalidate the cache data from index DB?>> 发言者2：有没有必要深入探讨如何使索引数据库中的缓存数据失效？  
>> Evgenii Ray: Yeah, it's a pretty good problem. If you have time you can discuss that but I would if you actually have the time left, one thing that is cover is the accessibility and accessibility with the virtualization is a pretty complex topic.>> 叶夫根尼·雷：是的，这是个相当不错的问题。如果你有时间的话，可以讨论一下，但如果你确实还有时间的话，有一件事需要涉及，那就是无障碍性，而虚拟化环境下的无障碍性是一个相当复杂的话题。

[00:12:43]  
If you have time to speak about accessibility that would be probably the better way to how to organize your time.如果你有时间谈论无障碍问题，这可能是安排时间的更好方式。  
>> Speaker 2: What's your TLDR on accessibility and virtualization? [LAUGH] Too much, okay.>> 发言者2：关于无障碍性和虚拟化，你的简明摘要是什么？[笑] 内容太多了，好吧。  
>> Evgenii Ray: It cannot be TLDR but the way how for instance, the three there manages the accessibility.>> 叶夫根尼·雷：不能长话短说，但比如，这三者处理无障碍性的方式就不是这样。

[00:13:05]  
So when you move elements around the browser the screen reader loses access loses understanding of ways in which order elements are rendered. Even if you apply the index property to tell the browser, okay, this is the second and the third element, when you move them through CSS transformation, browser will not reread this.所以，当你在浏览器中移动元素时，屏幕阅读器会无法获取、无法理解元素的渲染顺序。即便你使用索引属性告诉浏览器“好的，这是第二个元素，那是第三个元素”，但当你通过CSS变换来移动它们时，浏览器也不会重新读取这些信息。

[00:13:27]  
So your screen reader will not be able to understand that you move elements around. And one way how can you handle that is how the Twitter does that. So they basically, they render, fully re-rendered the list. So when you move elements around, so they do not have the full virtualization, they instead limit the number of rendered elements to some 10 or 20 elements and they re-render them fully.因此，你的屏幕阅读器无法理解你在移动元素。而解决这个问题的一种方法是Twitter所采用的方式。他们基本上会渲染、完全重新渲染列表。所以当你移动元素时，他们不会进行完全的虚拟化，而是将渲染的元素数量限制在10个或20个左右，并对它们进行完全重新渲染。

[00:13:55]  
>> Speaker 2: Okay, so you don't get peer reflow benefits, but you're still having less stuff.>> 发言者2：好的，所以你无法获得同级回流的好处，但你拥有的内容仍然更少了。  
>> Evgenii Ray: Yeah, and so if you want to manage this using the ECS when we just move elements around and reduce the reflow, then you would need to manually set up the event handlers that will track the.>> 叶夫根尼·雷：是的，所以如果你想在我们移动元素并减少回流时使用ECS来管理这一点，那么你就需要手动设置事件处理程序来跟踪……

[00:14:18]  
The keyboard events, and we'll go through the list manually. And they will also focus the element that you are currently selecting, and kind of try to force the browser to read this one.键盘事件，我们会手动浏览列表。它们还会聚焦你当前正在选择的元素，并尝试迫使浏览器读取该元素。