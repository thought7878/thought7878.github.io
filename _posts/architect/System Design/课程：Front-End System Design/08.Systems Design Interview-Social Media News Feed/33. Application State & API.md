


---

## “应用状态与API”课程文字稿

Evgenii continues the system design for the social media news feed. The state layer and the API are designed. Stories will be managed in a global state with their associated comments and media attachments. The API will use GET requests with server-side events.
叶夫根尼继续进行社交媒体新闻推送的系统设计。状态层和应用程序接口已设计完成。故事将在全局状态中进行管理，包含其相关的评论和媒体附件。该接口将使用带有服务器端事件的GET请求。

[00:00:00]  
>> Evgenii: Now let's talk about the API. So our application is expected actually probably the let's first talk about the state. So our application is expected to work on the mobile devices. And we need to make sure that we use optimize stay structure. So let's think about what are the properties we can store in the state.>> 叶夫根尼：现在我们来谈谈API。我们的应用程序实际上可能……让我们先谈谈状态。我们的应用程序预计会在移动设备上运行。我们需要确保使用优化的状态结构。所以让我们想想可以在状态中存储哪些属性。

[00:00:24]  
So first of all, I will store the stories.所以首先，我会存储这些故事。  
>> Evgenii: And I would apply the normalization, the first and the second normal form, to optimize the story. So my story can be accessed by id of the string. And each story will contain the text content, which is string. And it also will have an id which is also type id.>> 叶夫根尼：我会应用规范化，即第一范式和第二范式，来优化这个故事。这样我的故事就可以通过字符串的标识进行访问。每个故事都将包含文本内容，也就是字符串。而且它还会有一个标识，类型也是标识。

[00:01:01]  
As you can see, we don't have any content in this story entity related to the comments. So this means that we need to have one more field called comments. And here, we'll use the story id to give us an array of the comments, and also we'll store the attachments array.如你所见，这个故事实体中没有任何与评论相关的内容。这意味着我们需要再添加一个名为“评论”的字段。在这里，我们将使用故事ID来获取评论数组，同时也会存储附件数组。

[00:01:35]  
So we can access all the images attachment that we're planning to utilize by the store id. Okay, this is the attachment array. So the attachment is pretty simple since we're just using the images we can use the simple URL for that所以我们可以通过店铺ID访问所有计划使用的图片附件。好的，这是附件数组。由于我们只使用图片，所以附件很简单，我们可以为此使用简单的URL。  
>> Evgenii: And that should be it. So now we have this state, let's look what are the API methods that we can use for loading the story data.>> 叶夫根尼：应该就是这样了。现在我们有了这个状态，来看看我们可以使用哪些API方法来加载故事数据。

[00:02:07]  
So let's create a new section called API.那么我们来创建一个名为API的新部分。  
>> Evgenii: And if we think about the API, then we actually need just a single endpoint which will getstories. And now we need to decide, decide how we're going to load the stories. So first of all, we could potentially.>> 叶夫根尼：如果我们考虑API的话，实际上我们只需要一个能获取故事的端点。现在我们需要决定，决定如何加载这些故事。所以首先，我们有可能可以……  
>> Speaker 1: Sorry, there's a bunch of questions, but maybe you want to get through this section before we take questions or.>> 发言者1：抱歉，有很多问题，但或许你想先讲完这部分内容，之后我们再解答问题，或者……

[00:02:39]  
>> Evgenii: I think we can start with the questions now.>> 叶夫根尼：我觉得我们现在可以开始提问了。  
>> Speaker 1: Candidates said I would use react window for virtualization. What would you say to that?>> 发言者1：候选人说我会使用react window来实现虚拟化。对此你有什么看法？  
>> Evgenii: I think it depends on your company. Because some companies actually prefer candidates to use some modern frameworks how they will resolve that problem with using the modern frameworks.>> 叶夫根尼：我认为这取决于你的公司。因为有些公司实际上更希望应聘者使用一些现代框架，看他们如何用这些现代框架来解决那个问题。

[00:03:00]  
But on average, I think the idea of system design interview is actually, or evaluate the fundamentals knowledge. So if I would be evaluating the fundamentals knowledge, I would ask the candidate to be kind of framework agnostic. So we have just a Vanilla API, so what would you do with the Vanilla API?但总的来说，我认为系统设计面试的目的实际上是考察基础知识。所以如果我要考察基础知识，我会要求应聘者不局限于特定的框架。比如我们只有一个基础API，那你会用这个基础API做些什么呢？

[00:03:23]  
Maybe I'm the company and I want to develop my libraries, and what would you do? Yep.或许我就是那家公司，我想开发自己的库，那你会怎么做呢？是的。  
>> Speaker 1: And in this state, where do you keep the chronological order of the stories? Is it a list of story ids?>> 发言者1：在这种状态下，你把故事的时间顺序保存在哪里？是故事ID的列表吗？  
>> Evgenii: Because the story they come. So usually you expect that this list will be connected to some global state, and we define this global state here, so we can always provide the stories in a sorted order to the virtual list.>> 叶夫根尼：因为故事它们来了。所以通常你会期望这个列表会与某个全局状态相关联，而我们在这里定义了这个全局状态，这样我们就总能以排序后的顺序向虚拟列表提供故事。

[00:04:04]  
So virtual lists can manage actually the array of the data because it renders the array. Because we're rendering a very limited subset of the data, we can basically extract the ids that we are going to render from the global state and then sort it out by the timestamp.因此，虚拟列表实际上可以管理数据数组，因为它会渲染该数组。由于我们只渲染数据中非常有限的一部分，我们基本上可以从全局状态中提取将要渲染的ID，然后按时间戳对其进行排序。

[00:04:24]  
So the thing is that the story right now doesn't have a timestamp, so it's very, very good suggestions. So we also need to have the time when the story was posted.问题是，目前这个故事没有时间戳，所以这些建议非常、非常好。我们还需要显示故事发布的时间。  
>> Speaker 1: When describing data structures, how do you know when you've gotten too deep into the weeds? For instance, if you're in this case, you could be debating whether to use a JavaScript object or a map, or sets and that kind of things.>> 发言者1：在描述数据结构时，你怎么知道自己是否陷入了过于细致的讨论中？例如，在这种情况下，你可能会纠结于使用JavaScript对象还是映射，或者集合之类的东西。

[00:04:54]  
>> Evgenii: I think, the map is actually the same as JavaScript object. It's just the very fancy wrapper around the JavaScript object. I don't think that you will have a discussion about the differences, to be honest. So I don't think it's very important for this specific design to discuss the difference between the object and the map.>> 叶夫根尼：我认为，map实际上和JavaScript对象是一样的。它只是JavaScript对象外面一个非常华丽的包装。说实话，我觉得你们不会去讨论两者的区别。所以，我认为在这个特定的设计中，讨论对象和map之间的区别并不是很重要。

[00:05:16]  
Yeah, I would not focus on that too much.是啊，我不会太关注那个的。  
>> Evgenii: Okay, so let's continue. So we design our state, we have the stories, the comment, and the attachment. Now we need to understand how we want to load our stories. And there are, as we discussed in the workshop, there are three ways how can we do that.>> 叶夫根尼：好的，那我们继续。我们设计了状态，有了故事、评论和附件。现在我们需要弄清楚如何加载这些故事。正如我们在工作坊中讨论的，有三种方法可以做到这一点。

[00:05:37]  
So the first one is we can use sharp pulling.所以第一种是我们可以使用短轮询。  
>> Evgenii: Second thing, we could potentially use web sockets and the third thing is service and events. So if we try to compare all of this, yep.>> 叶夫根尼：第二点，我们或许可以使用网络套接字，第三点是服务和事件。所以如果我们试着把这些都比较一下，是的。  
>> Speaker 2: Sorry can I ask a question? So earlier during the workshop, one of the things he talked about was long polling.>> 发言者2：抱歉，我能问个问题吗？刚才在工作坊中，他谈到的内容之一是长轮询。

[00:06:05]  
How would you differentiate between what's considered short polling versus long polling?你会如何区分短轮询和长轮询？  
>> Evgenii: Okay, so the short polling is usually has the timeframe around 5 seconds is basically the short pulling you keep your TCP socket open because the time passed from the from previous request is not enough to close this by default.>> 叶夫根尼：好的，短轮询的时间框架通常在5秒左右，这基本上就是短轮询，你要保持TCP套接字处于打开状态，因为默认情况下，从上一个请求开始经过的时间不足以关闭它。

[00:06:29]  
You can also instruct the server to keep the connection alive but it's not very efficient from the client bearer perspective. So long polling, you always initiate a new full request, so you will set the full metadata. And usually the timeframe is around 20 or 30 seconds. So if we compare this method specifically for the fetching purposes, so the short polling will definitely work.你也可以指示服务器保持连接活跃，但从客户端承载的角度来看，这并不是很高效。对于长轮询，你总是会发起一个全新的完整请求，因此需要设置完整的元数据。通常，这个时间范围在20到30秒左右。所以，如果我们专门将这种方法用于数据获取，那么短轮询肯定是有效的。

[00:06:59]  
So it's very simple, it utilizes the HTTP protocol, it's very simple to implement. But the issue with the short polling, because it keeps your TCP connections, so TCP socket open, this means that we're having additional battery drain. So let's use the minus here, battery,所以这非常简单，它利用HTTP协议，实现起来非常容易。但短轮询存在一个问题，因为它会保持你的TCP连接，也就是让TCP套接字处于打开状态，这意味着会额外消耗电池电量。所以这里我们要考虑它的缺点，即对电池的影响。  
>> Evgenii: Drain. >> 叶夫根尼：排水。  
>> Evgenii: Then it's not very efficient.>> 叶夫根尼：那它的效率不是很高。

[00:07:30]  
>> Evgenii: The huge pro is that it's very simple. But the issue is that you may have the latency. And the latency comes from establishing the full connection again, when you do the reconnection then also you pay additional cost on implementing the infrastructure to how to handle the reconnections.>> 叶夫根尼：最大的优点是它非常简单。但问题在于可能会有延迟。这种延迟源于重新建立完整连接的过程，而且在进行重连时，你还需要在构建处理重连的基础设施方面付出额外成本。

[00:07:58]  
So you may expect that the latency will decrease, especially when, you're on the fast train or when you need to reconnect to a network towers. The problem also with the short polling is because we are focusing on the mobile devices a lot, and the short polling will utilize the duplex antenna of the mobile device so it will drain the energy again.因此，你可能会预期延迟会降低，尤其是当你在快速行驶的火车上，或者需要重新连接到信号塔时。短轮询的问题还在于，我们非常关注移动设备，而短轮询会使用移动设备的双工天线，这又会消耗能量。

[00:08:20]  
So here we can put two minuses. [LAUGH] Yeah, so let's go to the WebSockets. So the WebSockets provides us with a real time communication. So it's super fast. But do we need real time communication to fetch the stories? I don't think so. So it has the very huge infrastructure cost.所以这里我们可以放两个减号。（笑）没错，那我们来谈谈WebSocket吧。WebSocket为我们提供了实时通信功能，速度非常快。但我们获取新闻报道需要实时通信吗？我觉得不需要。而且它的基础设施成本非常高。

[00:08:42]  
It's very hard to implement in a good way. So I guess we can just remove the web sockets from the consideration completely. So let's consider the service side events. So if we speak about server side events, let's list the pros of the server side events. So first of all, they're very, very efficient.要以一种好的方式实现它非常困难。所以我想我们可以完全不考虑WebSocket了。那我们来考虑服务端事件吧。如果我们要讨论服务端事件，先列出它的优点。首先，它们非常、非常高效。

[00:09:00]  
And they also have a very comparable performance to the WebSockets. They are slower, but still they're pretty fast. Also, because they utilize the mono antenna of the device, we can expect that the energy drain will be much less. And also, the service side events are based on HTTP2 protocol.而且它们的性能与WebSocket也非常接近。虽然速度较慢，但仍然相当快。此外，由于它们利用了设备的单天线，我们可以预期能耗将会低得多。而且，服务端事件是基于HTTP2协议的。

[00:09:21]  
This means that HTTP2 will be able to establish us the much better performance because within one TCP connection we can establish hundreds of parallel requests being loaded. Basically our application will be able to utilize just a single TCP connection for every request. So I think the service events in this case, we can actually use the combination of the service side events plus the simple GET request because if you scroll down, you don't wanna wait for the server to give you the result from service end events.这意味着HTTP2将能为我们带来好得多的性能，因为在一个TCP连接内，我们可以建立数百个并行加载的请求。基本上，我们的应用程序能够为每个请求只使用一个TCP连接。所以我认为，在这种情况下的服务事件，我们实际上可以结合使用服务端事件和简单的GET请求，因为如果你向下滚动，你不会想等待服务器通过服务端事件给你返回结果。

[00:10:02]  
So we can just create a new, simple HTTP request via the GET and get the data. So the answer will be the combination of the GET request plus service end events. And if we think about the parameters that they get, stories can accept. So the first thing is the API token to access the server API.所以我们可以通过GET方法创建一个新的、简单的HTTP请求来获取数据。因此，答案将是GET请求与服务端事件的组合。如果我们考虑它们能获取到的参数，stories是可以接受的。首先是访问服务器API的API令牌。

[00:10:32]  
The second one is the limit. So we need to distinguish the, we need to know the limit, how many elements we want to load from the server. So because, for instance, for the for large screens, we'll be able to load more items on the screen. For smaller devices, such as mobile, we may limit this to just five or four elements.第二个是限制。所以我们需要区分，我们需要知道这个限制，即我们希望从服务器加载多少个元素。例如，对于大屏幕，我们能够在屏幕上加载更多项目。对于较小的设备，比如手机，我们可能会将其限制在仅四五个元素。

[00:10:59]  
So this third parameter will be the previous page. So the previous page pointer will tell the server to load the data from specific place. So if we're returning, so we floated some stories then we closed our application and then we open it again. So we want to load the stories exactly from the place where it stopped.所以第三个参数将是上一页。上一页指针会告诉服务器从特定位置加载数据。比如，如果我们返回，我们浏览了一些故事，然后关闭了应用程序，之后又重新打开它。我们希望从上次停止的位置继续加载这些故事。

[00:11:24]  
So we'll be able to utilize the previous page. If, for instance, this is our first time we're loading the stories, then we'll just load the stories that are relevant to us with the current time step.因此，我们将能够利用上一页。例如，如果这是我们第一次加载这些报道，那么我们只会加载与当前时间步相关的报道。



