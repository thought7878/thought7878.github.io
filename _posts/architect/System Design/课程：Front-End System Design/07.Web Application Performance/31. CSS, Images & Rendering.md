


---

## “CSS、图像与渲染”课程文字稿

Evgenii covers optimization techniques for assets such as CSS stylesheets and images. Similar JS optimizations like splitting, minifying, and compressing can be applied to CSS. Image optimization strategies depend on the type of image asset. The WEBP format is designed to replace PNG, JPG, and GIF usage on web pages. This lesson also includes performance optimizations for fonts and rendering performance.
叶夫根尼（Evgenii）涵盖了**CSS样式表和图像等资源的优化技术**。类似的JavaScript优化（如拆分、压缩和缩减）也可应用于CSS。图像优化策略取决于图像资源的类型。WEBP格式旨在替代网页上PNG、JPG和GIF的使用。本节课还包括字体的性能优化和渲染性能优化。

[00:00:00]  
>> Evgenii Ray: Okay, so what about CSS? For CSS, we can apply exactly the same technique. So if we expect that we have three types of devices to work with, mobile, standard, or super wide, we can split our CSS into the three bundles, and then serve it based on the user agent.>> 叶夫根尼·雷：好的，那CSS呢？对于CSS，我们可以应用完全相同的技术。所以，如果我们希望适配三种类型的设备——移动设备、标准设备或超宽屏设备，我们可以将CSS拆分成三个包，然后根据用户代理来提供相应的包。

[00:00:17]  
And instead of loading the whole CSS chunk, we can load a slightly reduced one. Same applies to the minification and compression. So if you take the minified Tailwind library, so uncompressed is 2.1 megabyte, minified, it's 1,900 kilobytes, gzipped it's 200 kilobytes. And the brotli provides the best compression, it's 46 kilobytes.而且我们不用加载整个CSS代码块，而是可以加载一个精简一点的版本。这一点同样适用于代码压缩和压缩处理。比如，如果你拿经过压缩的Tailwind库来说，未压缩时是2.1兆字节，压缩后是1900千字节，用gzip压缩后是200千字节。而brotli压缩的效果最好，只有46千字节。

[00:00:44]  
So the next important thing is critical style extraction. So when we fetch the index.html page, the way we load the assets, we see the asset link, and then we send the additional HTTP requests to fetch the data. So it results to doing two network trips. So we can optimize that by inlining the critical styles that are important for our application to function into the initial index.html request.因此，下一个重要的事情是关键样式提取。当我们获取index.html页面时，加载资源的方式是先看到资源链接，然后发送额外的HTTP请求来获取数据。这就导致了两次网络传输。因此，我们可以通过将对应用程序正常运行至关重要的关键样式内联到初始的index.html请求中，来优化这一过程。

[00:01:20]  
So when we load our first page, we already have all the styles inlined, and we can immediately show the content. And non-critical styles, such as some advanced graphic features or inactive pages, can be loaded under the low priority, and the way we can load additional styles. So first, let's see actually how this would look like.所以当我们加载第一个页面时，我们已经将所有样式内联了，这样就能立即显示内容。而那些非关键样式，比如一些高级图形功能或未激活页面的样式，可以以低优先级加载，这也是我们加载额外样式的方式。那么首先，让我们来看看实际情况会是怎样的。

[00:01:46]  
So the non-optimized way, we just link our CSS to some CDN, and this will be loaded in normal order as a separate HTTP request. And optimize, we just create a style tag on our initial index.html and inline the styles within this section.那么，在未优化的方式下，我们只是将CSS链接到某个CDN，它会作为一个单独的HTTP请求按正常顺序加载。而优化的做法是，在初始的index.html上创建一个style标签，并将样式内联到这个部分中。  
>> Evgenii Ray: And how do we fetch non-critical styles ideally?>> 叶夫根尼·雷：那么我们理想情况下应该如何获取非关键样式呢？

[00:02:11]  
So there are two ways how can we do that. The first one, we can tell the browser that these styles are used for printer, this is like a life hack. So when this the media type is print, then the browser will not load this immediately. But here we see there is a little hack.有两种方法可以做到这一点。第一种，我们可以告诉浏览器这些样式是用于打印机的，这就像一个小窍门。所以当媒体类型是打印时，浏览器不会立即加载它。但这里我们看到有一个小技巧。

[00:02:35]  
So we have onload event. So when the content is loaded, we change the media type to all. This will instruct the browser to load the following CSS when the whole page is loaded. So, alternatively, you can also use the preload parameter to load the non-critical CSS under the low priority.所以我们有onload事件。当内容加载完成后，我们会将媒体类型更改为“all”。这会指示浏览器在整个页面加载完成后加载后续的CSS。另外，你也可以使用preload参数以低优先级加载非关键CSS。

[00:03:00]  
So both solutions would work. Summary, so how do we optimize the network performance? First of all, split the bundle. So now when we have the HTTP/2, split as much as possible. Because usually, generally, it's better to load things in parallel. And minify and compress, this is basically included in every bundle now.所以这两种解决方案都是可行的。总结一下，我们该如何优化网络性能呢？首先，拆分资源包。在使用HTTP/2时，要尽可能多地进行拆分。因为通常来说，并行加载资源效果更好。此外，还要进行代码压缩和文件压缩，现在基本上每个资源包都会包含这一步骤。

[00:03:31]  
And also inline critical resources to optimize the first screen rendering. And load the non-critical resources on the background under low priority. So in the bright future, I hope that we will not have any bundler, because everything will be supported natively, and we will not need to actually prepare the assets anyhow.同时，将关键资源内联以优化首屏渲染。并在后台以低优先级加载非关键资源。因此，在美好的未来，我希望我们不再需要任何打包工具，因为一切都将得到原生支持，我们实际上也无需以任何方式准备资源。

[00:03:53]  
But for now, yeah, we will we have to introduce the boundary in our application. Okay, so what about other assets?但就目前而言，是的，我们必须在我们的应用程序中引入边界。好的，那其他资产呢？  
>> Speaker 2: Quick question on the CSS thing in the previous example. It seems like preload would be sort of the like, quote unquote, right way to do it, whereas the print one is a little hackier.>> 发言者2：关于上一个例子中的CSS问题，我快速问一下。似乎预加载（preload）算是所谓的正确做法，而打印那个方法则有点取巧。

[00:04:13]  
Is there a reason you would ever use the print one over?有没有什么理由会让你更倾向于使用打印版本呢？  
>> Evgenii Ray: So the thing about preload that, so, you mentioned that you are loading the page, and when the browser reads the preload, it still fires the request. But in case, in the media print, it will fire the request only when the whole page is rendered, so the ordering will be slightly different.>> 叶夫根尼·雷：关于预加载，你提到正在加载页面，当浏览器读取到预加载时，它仍然会发起请求。但在媒体打印的情况下，只有当整个页面渲染完成后才会发起请求，所以顺序会略有不同。

[00:04:39]  
And utilizing the preload too much may lead to having too many assets being queued, so you really need to consider case-by-case how you want to load the resources. So what about the images? So the images have multiple types, so it can be animated content, it can be icon or logos, it can be also a raster graphic or the photos.而且过度使用预加载可能会导致太多资源进入队列，所以你确实需要根据具体情况来考虑如何加载资源。那么图片呢？图片有多种类型，可能是动画内容，可能是图标或标志，也可能是光栅图形或照片。

[00:05:06]  
For animated content, usually we use the GIF, which is GIF. And the GIF is not the best way to represent animated content because the size of the GIF, even for three seconds, it can be 10 megabytes. So usually, we replace the GIF with a MP4, or we can also use the WebP.对于动画内容，我们通常使用GIF，也就是GIF格式。但GIF并不是呈现动画内容的最佳方式，因为即使是3秒钟的GIF，其大小也可能达到10兆字节。所以，我们通常会用MP4来替代GIF，也可以使用WebP格式。

[00:05:29]  
And for icons and logos, we use SVG, and we can optimize SVG by using compressed SVG. And for the raster graphic, there's a PNG. But there is a newer format called webp, which is basically built to replace the PNG and JPEG. And we can utilize it because it provides the better compression ratio without the quality loss.对于图标和徽标，我们使用SVG，并且可以通过压缩SVG来对其进行优化。对于光栅图形，有PNG格式。但还有一种更新的格式叫做webp，它本质上是为替代PNG和JPEG而设计的。我们可以使用这种格式，因为它能提供更好的压缩率，同时不会损失画质。

[00:05:56]  
And the next format, which is relatively new one, is the AVIF, which provides the best compression rate for the photo content. So if you're building the photo website and you need to provide high-quality images, then AVIF will provide you the best compression ratio to quality.下一种格式是相对较新的AVIF，它为照片内容提供了最佳的压缩率。所以，如果你正在构建照片网站，并且需要提供高质量的图像，那么AVIF将为你提供最佳的压缩比与质量的平衡。  
>> Evgenii Ray: And so let's go through these assets.>> 叶夫根尼·雷：那我们来仔细看看这些资源。

[00:06:21]  
So for instance, the following 60-kilobyte GIF can be the same 5-kilobyte webp. So it's very important to choose the right format. Also, if you look at the webp and/or AVIF, and we can see uncompressed image quality. So the original JPEG is 10 megabytes, the WebP is 7.5 megabytes, while the AVIF is 6.2 megabytes.例如，下面这个60千字节的GIF可以转换为同样的5千字节的webp。因此，选择正确的格式非常重要。此外，如果你查看webp和/或AVIF格式，会发现它们具有未压缩的图像质量。原始的JPEG格式为10兆字节，WebP格式为7.5兆字节，而AVIF格式为6.2兆字节。

[00:06:48]  
So uncompressed image is 38% less than the JPEG, which is pretty good, and also AVIF allows us to compress even image even farther without a big data loss comparing to JPEG. So anyway, when you're building your website, it's a good practice to compress images. Because when we browse the website, we don't really need to see the full size of the image.未压缩的图像比JPEG小38%，这相当不错，而且与JPEG相比，AVIF还能在没有大幅数据损失的情况下将图像压缩得更小。总之，在搭建网站时，压缩图像是个好习惯。因为我们浏览网站时，其实并不需要看到图像的完整尺寸。

[00:07:18]  
And so the question is, should we actually use these formats? And I think we should, because right now, the webp is supported by 97% of the clients, while the AVIF is supported by 93% of the clients. So we'll see, I think all these formats will become pretty standard.所以问题是，我们真的应该使用这些格式吗？我认为应该，因为目前97%的客户端支持webp格式，而93%的客户端支持AVIF格式。所以我觉得，这些格式都会成为相当标准的格式，让我们拭目以待。

[00:07:37]  
They already are the standard, to be honest. And if you're still supporting some legacy clients, you can always fall back, you provide a fallback to JPEG in case if the WebP image is not supported.说实话，它们已经是标准了。而且如果你还在支持一些遗留客户端，你总能找到退路，万一WebP图像不被支持，你可以提供JPEG作为替代方案。  
>> Evgenii Ray: Same applies to SVG. So when you have your SVG, you can actually compress that, so it's called SVG path compression.>> 叶夫根尼·雷：SVG也是如此。所以当你有SVG文件时，实际上可以对其进行压缩，这被称为SVG路径压缩。

[00:08:03]  
And we already have extension to our bundlers that do this automated job when you do the build of the bundle. So basically, we can express the same SVG using slightly different semantics. And by simply removing a few symbols, we compress the SVG by more than 50%. And if you have lots of sprites, SVG-based sprites, then you probably could have, if you have the large SVG library icon set, then you can optimize the SVG significantly.而且我们的打包工具已经有了扩展，能在你构建包的时候自动完成这项工作。所以基本上，我们可以用略有不同的语义来表达同一个SVG。只需移除几个符号，我们就能将SVG压缩50%以上。如果你有很多基于SVG的精灵图，而且有大型的SVG库图标集，那么你很可能可以显著优化这些SVG。

[00:08:42]  
And this is the number without the zip compression or brotli, so it can be even optimized even further. So the summary for the image section. So compress images for web and use optimized formats. So now the optimized formats become the standard for the web. And make sure that if you use SVG, use SVG path compression.这还是未经过zip压缩或brotli压缩的数值，所以它还能进一步优化。以上是关于图像部分的总结。要为网络压缩图像并使用优化格式。如今，优化格式已成为网络的标准。另外要注意，如果你使用SVG，要进行SVG路径压缩。

[00:09:08]  
>> Evgenii Ray: Okay, what about the fonts? A few interesting characteristics of the font is if you use any custom font on your application, then the browser behavior is it waits three seconds to load the font, and then it renders the content. If the font is not loaded within three seconds, it will render the content using unstyled text.>> 叶夫根尼·雷：好的，那字体呢？字体有几个有趣的特点，如果你在应用程序中使用任何自定义字体，浏览器的行为是会等待三秒加载字体，然后再渲染内容。如果字体在三秒内没有加载完成，它就会使用无样式文本渲染内容。

[00:09:32]  
So I think this, this part is not pretty good because, for instance, our CDN that stores the fonts fails, and we don't want to not show in the screen until the font is loaded. So we could potentially sacrifice some beautiness of the app and provide the font display fallback.所以我觉得这部分不太好，比如，我们存储字体的内容分发网络（CDN）出故障了，我们不希望在字体加载完成前不在屏幕上显示内容。所以我们可能会牺牲应用的一些美观性，提供字体显示的备选方案。

[00:09:53]  
This will instruct the browser to render the unstyled text immediately without waiting for three seconds. If the font is loaded, then we do the runtime switch of the font. And there is also the value called optional. So basically, we render unstyled text immediately. But when we load the font, we just store and cache it.这将指示浏览器立即渲染未设置样式的文本，无需等待三秒钟。如果字体已加载，我们就会在运行时切换字体。此外还有一个名为“optional”的值。所以基本上，我们会立即渲染未设置样式的文本。但当我们加载字体时，我们只会对其进行存储和缓存。

[00:10:18]  
And when we refresh the page, we just get the value from cache and render the font as it should be. You can choose whatever suits your application and the design requirements. So I think the fallback is pretty good alternative. Just make sure that you provide that because default value is auto.当我们刷新页面时，我们只需从缓存中获取值，并按应有的方式渲染字体。你可以选择任何适合你的应用程序和设计要求的选项。所以我认为这种备选方案是相当不错的选择。只需确保你进行了设置，因为默认值是自动。

[00:10:43]  
And here is the summary of what we discussed. You can just store this diagram and it will provide you the shortcut what we need to do with the app. So, and let's summarize the rendering performance. So we're not creating a new section in slides because we actually discussed this already, how to optimize the rendering performance.以下是我们讨论内容的总结。你只需保存这张图表，它就会为你提供我们需要对该应用程序执行的操作的快捷方式。那么，让我们总结一下渲染性能。我们不会在幻灯片中创建新的部分，因为我们实际上已经讨论过如何优化渲染性能了。

[00:11:06]  
So first of all, it's the DOM. Minimize the number of DOM you use within your DOM tree, and use virtualization when it's necessary. So minimize the number of graphic layers, but use them wisely when you need to optimize certain things. And also, avoid any potential reflows and just use the separate stacking context to isolate the elements mutation, and also avoid using the complex CSS selectors.首先，是DOM。尽量减少DOM树中使用的DOM数量，必要时使用虚拟化技术。所以要减少图形层的数量，但在需要优化某些内容时要合理使用它们。此外，要避免任何潜在的重排，只需使用单独的堆叠上下文来隔离元素的变化，同时避免使用复杂的CSS选择器。

[00:11:38]  
Try to implement some naming strategy so you can use any methodology that suit your application or use any CSS frameworks. So because the time it takes to compile the long CSS selector may impact your rendering performance if you have hundreds of complex selectors in the app. And also, try to utilize the CSS animations in your app, because they are GPU-accelerated, so you will not block your rendering thread.尝试实施一些命名策略，这样你就可以使用任何适合你的应用程序的方法，或者使用任何CSS框架。因为如果你在应用程序中有数百个复杂的选择器，编译冗长的CSS选择器所花费的时间可能会影响你的渲染性能。此外，尝试在你的应用程序中使用CSS动画，因为它们是由GPU加速的，所以不会阻塞你的渲染线程。

[00:12:11]  
And as a good practice, use the placeholders and the loaders to give some, use visual feedback while your application is loading. The JavaScript performance summary is very simple. The rule of thumb, don't block the UI thread at any cost. And you can achieve that by reducing your CPU usage and optimizing your search and access cost to the data.作为一种良好的实践，使用占位符和加载器来提供一些视觉反馈，尤其是在应用程序加载时。JavaScript性能总结非常简单。经验法则是，无论如何都不要阻塞UI线程。你可以通过降低CPU使用率以及优化数据的搜索和访问成本来实现这一点。

[00:12:37]  
And you need to reduce your RAM usage. And when you have lots of data that you store it in your global state, make sure you put this into some kind of hard drive storage. So IndexedDB is a very good example. And if you need to write and read your data, avoid putting this data into the any synchronous storage, such as local storage or session storage, because it will block your UI thread.而且你需要减少内存使用量。当你有大量数据要存储在全局状态中时，一定要把这些数据放到某种硬盘存储中。IndexedDB就是一个很好的例子。如果你需要读写数据，要避免将这些数据放入任何同步存储中，比如本地存储或会话存储，因为这会阻塞你的用户界面线程。

[00:13:06]  
And also one thing if you can utilize a synchronous job. So now that the Web Workers support it in many clients, you can put some heavy tasks to the Web Worker and allow Web Worker to sort it out in a separate thread, or you can utilize the server.另外还有一点，如果你能使用同步作业的话。现在许多客户端都支持Web Workers，你可以把一些繁重的任务交给Web Worker，让它在单独的线程中处理，或者你也可以利用服务器来处理。

[00:13:25]  
And that's it. So we've done all the sections of the presentation now, and I hope that all the sections were useful to you. And now, I think it's time for us to apply this knowledge in practice by actually doing the mock system design interview, we're gonna set up the board.就这样。我们现在已经完成了演示的所有部分，希望这些部分对大家都有用。现在，我认为是时候通过实际进行模拟系统设计面试来将这些知识应用到实践中了，我们要准备好白板。




