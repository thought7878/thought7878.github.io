

---

## “JavaScript 打包与加载”课程文字稿

Evgenii highlights strategies for optimizing JavaScript bundle size. The strategies include a multi-bundle compiler, code splitting, code prefetching, and code minification/compression. Other in-application techniques like deferred script loading are also discussed.
叶夫根尼强调了优化JavaScript捆绑包大小的策略。这些策略包括多捆绑包编译器、代码拆分、代码预加载以及代码压缩/精简。文中还讨论了其他应用内技术，如延迟脚本加载。


[00:00:00]  
>> Evgenii Ray: Also, the HTTP/2+ provides better header compression. If we take the average header size on HTTP/1, which is the 5 kilobytes, on HTTP/2, it's just the 12 bytes, which is 98% more efficient. So look at this line of code. Guess the bundle size for this line of code.>> 叶夫根尼·雷：此外，HTTP/2+提供了更好的头部压缩。如果我们以HTTP/1的平均头部大小为例，其为5千字节，而在HTTP/2中，这一大小仅为12字节，效率提高了98%。那么看看这段代码。猜猜这段代码的打包大小是多少。

[00:00:23]  
And if we try to think how much code will be generated after we compile this code, so for ES5 environment, it's 16.9 kilobyte of JavaScript code because we'll use the polyfills for that. For ES20 bundle, it's just 69 bytes. So you need to be aware of the environment you are trying to compile your application.

[00:00:53]  
And if we look at the Core JS size, so it's a 74 kilobytes of minified compressed code. But when it's uncompressed, the JavaScript parser will have to parse the whole 243 kilobytes of the code before you can actually execute your app. So the thing is, there are a few interesting facts about the modern JS.如果我们看看Core JS的大小，它是经过压缩和精简的74千字节代码。但当它未被压缩时，JavaScript解析器必须先解析整个243千字节的代码，然后你才能实际运行你的应用程序。所以，关于现代JS有一些有趣的事实。

[00:01:15]  
So ES6 already is supported by 98% of the client, while ES7 and 10 has the support of 96%, and ES12, 89%. So basically we are providing the polyfills for a very minority of the clients. And the way how can we try to optimize that is to instruct our JS Compiler to prepare multiple bundles.因此，98%的客户端已经支持ES6，而ES7和ES10的支持率为96%，ES12的支持率为89%。所以基本上，我们只为极少数客户端提供填充代码。我们可以尝试优化的方法是指示我们的JS编译器准备多个捆绑包。

[00:01:40]  
So it can be ES5 bundle, it can be ES10 bundle, and ES2024, which is the most modern one. So then we can instruct the server, based on the user agent, we can detect what's the browser engine we have. And we can return optimized HTML with the JavaScript assets for this client, so we'll reduce the payload size that the client receives.它可以是ES5打包文件，也可以是ES10打包文件，还有ES2024，这是最现代化的一种。然后我们可以根据用户代理指示服务器，检测到我们所使用的浏览器引擎。并且我们可以向该客户端返回带有JavaScript资源的优化后的HTML，这样就能减小客户端接收的有效负载大小。

[00:02:04]  
The next performance optimization technique is the code split. So essentially, we can have our bundle, which is 600 kilobytes, and in HTTP/1 world, this would be the best practice, but now it's anti-pattern. We actually encourage to split the code because it will load faster now. So we can split our code in the separate modules, and we can load the module dynamically and reduce the initial bundle load.下一个性能优化技术是代码分割。本质上，我们可以有一个600KB的包，在HTTP/1环境中，这会是最佳实践，但现在这是反模式。实际上，我们建议进行代码分割，因为这样加载速度会更快。我们可以将代码分割到不同的模块中，然后动态加载这些模块，从而减少初始包的加载量。

[00:02:35]  
We can go even farther and instruct the modules to load in In the background. So, for instance, we know that our application starts with model 1. But in some foreseeable future, we actually know that the model 2 and module 3 will be loaded. So we can instruct the browser using the link element with the rel = "prefetch" value to fetch this asset and cache in the browser cache.我们甚至可以更进一步，指示模块在后台加载。例如，我们知道我们的应用程序以模型1启动。但在可预见的将来，我们实际上知道模型2和模块3将会被加载。因此，我们可以使用带有rel = "prefetch"值的link元素来指示浏览器获取该资源并将其缓存到浏览器缓存中。

[00:03:07]  
So when we access it, we already have this resource. So there are two values that they can use. One is preload, so it's instruct the browser to load such asset under the high priority. And also there is a prefetch which basically loads in the background under the lower priority.所以当我们访问它时，我们已经拥有了这个资源。因此，有两个值可以使用。一个是preload，它指示浏览器以高优先级加载此类资源。另一个是prefetch，它主要在后台以较低优先级加载。

[00:03:24]  
And you can play around with that and you can basically prefetch all your JavaScript assets on the background, and when you access the specific module, it will be there and you will not see any loading. The next thing is the code minification and compression, which probably you all use that already.你可以对此进行尝试，基本上可以在后台预加载所有的JavaScript资源，这样当你访问特定模块时，资源已经就绪，你不会看到任何加载过程。接下来是代码压缩和精简，这可能你们已经都在使用了。

[00:03:47]  
So the minification is just refactoring our code. So this process included in every bundle now. So we're basically removing the longVariableName. We're also refactoring the function names and making the code more compact, so we can reduce on average the size by 20%. So from 1 megabyte, we went to 800 kilobyte.所以代码压缩只是对我们的代码进行重构。现在每个代码包都包含这个过程。我们主要是去掉那些长变量名，同时也会重构函数名，让代码更精简，这样平均能减少20%的大小。比如从1兆字节缩减到800千字节。

[00:04:11]  
So next is the compression. So the compression, there are two main algorithm that we can use for compression. One is gzip, so it's supported by most of the clients and the browsers and the servers, and also CDNs, and it provides a very good compression rate, around 80%. So also there is a Brotli, which is slightly newer format, and it's 20, 30% more efficient on average.接下来是压缩。关于压缩，我们可以使用两种主要算法。一种是gzip，它得到了大多数客户端、浏览器、服务器以及内容分发网络（CDN）的支持，压缩率非常高，大约为80%。另一种是Brotli，这是一种较新的格式，平均效率要高出20%到30%。

[00:04:38]  
And right now, it's supported by most of the browsers now, and you can also use that on your CDNs. And if we take an example, Lodash library, we'll see that from 530 kilobytes, with Brotli, we went to 73 kilobytes, while with the gzip, we went to 94 kilobytes.目前，大多数浏览器都支持它，你也可以在你的CDN上使用它。举个例子，Lodash库的大小原本是530千字节，使用Brotli压缩后变为73千字节，而使用gzip压缩后则变为94千字节。

[00:04:59]  
So the difference is 4%. But anyway, if we can compress more, why don't we do that?所以差异是4%。但无论如何，如果我们能压缩得更多，为什么不这么做呢？  
>> Evgenii Ray: So we applied the compression now, and we went from our 600 kilobyte package to slightly reduced one. And the next thing is to change the order of the script loading. So we can instruct the script to be loaded later.>> 叶夫根尼·雷：所以我们现在应用了压缩，把600千字节的包稍微缩小了一些。接下来要做的是改变脚本加载的顺序。这样我们就可以指示脚本稍后加载。

[00:05:28]  
So, for instance, you have some analytics or telemetry scripts that don't really impact the user experience because you load them on the background and you don't, they work, so they don't interact with your runtime code. So you can tell the browser that you need the scripts only once your page is loaded and everything is rendered.例如，你有一些分析或遥测脚本，它们并不会真正影响用户体验，因为你是在后台加载它们的，而且它们在运行时不会与你的运行时代码交互。所以你可以告诉浏览器，只有当页面加载完成且所有内容都已渲染后，才需要这些脚本。

[00:05:52]  
So you can use the defer flag. So you will improve your first screen loading, because if you use the normal synchronous loading, then the browser will load the first asset, then the second, then the third, and then the fourth. But since these scripts are kind of optional and our app can function without that, so we can tell the browser that, okay, I don't need the scripts for the first load, defer them, and let's optimize our first screen rendering.所以你可以使用defer标志。这样可以改善首屏加载速度，因为如果使用正常的同步加载，浏览器会先加载第一个资源，然后是第二个、第三个，接着是第四个。但由于这些脚本在某种程度上是可选的，而且我们的应用没有它们也能运行，所以我们可以告诉浏览器，没问题，我不需要这些脚本用于首次加载，推迟加载它们，这样就能优化首屏渲染了。

[00:06:21]  
>> Evgenii Ray: And here we applied the deferred load to the scripts. And that's it for the JavaScript optimization section.>> 叶夫根尼·雷：在这里，我们对脚本应用了延迟加载。JavaScript优化部分就到这里。
