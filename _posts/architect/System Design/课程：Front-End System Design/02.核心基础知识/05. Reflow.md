
Evgenii demonstrates the rendering pipeline as reflow occurs on the webpage. After the initial DOM and CSSOM subtrees are built, reflow will work through style, layout, paint, and composite phases. The pipeline required to paint the screen will rely either on the CPU or GPU, depending on the CSS properties used. GPU-based rendering will perform better than CPU-based rendering.  
叶夫根尼演示了在网页上**发生重排时渲染管线的工作过程**。在初始的 DOM 和 CSSOM 子树构建完成后，重排会依次经历**样式、布局、绘制、合成**这几个阶段。用于绘制屏幕的管线将依赖于所使用的 CSS 属性，要么是 CPU，要么是 GPU。*基于 GPU 的渲染性能将优于基于 CPU 的渲染*。


视频围绕浏览器`重排（reflow）`展开，介绍了重排相关的基础*概念、流程、性能影响、优化案例*，具体如下：
## 重排基础概念
[00:00]
首先提出重排（reflow）话题，*浏览器解析HTML和CSS时会生成两棵树*，分别是代表HTML对象的`DOM树`、包含所有应用于HTML元素CSS规则的`CSSOM树`，最终通过合并这两棵树构建`渲染树`。
![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/5c11feb581d90f794513e91619529f3d_MD5.jpeg]]

## 重排触发、多阶段流程
[00:35]
重排通常**由JavaScript触发**，**当JavaScript修改DOM树或样式**（如加载更多商品列表、渲染React应用时修改DOM）后，浏览器会进入多阶段流水线的重排过程，包括**重建DOM和CSSOM树、重新计算DOM并检查相关子树、重新计算所有样式**，之后进入**布局阶段重新计算元素位置和HTML属性**。其中**样式和布局阶段非常消耗CPU，频繁触发会阻塞`渲染线程`**。

## 重排的绘制与合成阶段
[01:52]
重排相关准备就绪后，进入`绘制阶段`，**利用GPU将位图绘制到屏幕，此阶段与CPU分离，不会阻塞渲染线程**；最后是`合成阶段`，**当屏幕有多层元素时，合成面会按正确顺序排列元素，确保内容正确显示**。

## 重排的实际示例
[02:40]
以维基百科页面为例，说明浏览器渲染页面**重排时会从上到下进行**，加载样式后可能需要执行页面完整重排，且重排时可能仅调整元素样式。

## 优化、非优化案例的对比
[03:10]
通过两千个矩形渲染的示例对比，`优化管线`**主要利用GPU，屏幕无延迟，能达到60帧每秒，CPU负载极低**；`非优化管线`在三秒内缓冲区填满，**CPU负载很高**，即便在16核Mac上也如此，若限制CPU，仅移动两千个矩形就需CPU全力工作。
## 重排优化的关键技术原理
[04:54]
应用`margin-top属性`时，浏览器**需重新计算每个元素（如两千个矩形）的位置**来渲染一帧，**消耗CPU**；而应用`translateY函数`，**仅移动像素并使用GPU绘制新像素集，因transform不使用CPU，从而实现优化**。
![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/3b473c31e6f760b23faa685d742c925f_MD5.jpeg]]

