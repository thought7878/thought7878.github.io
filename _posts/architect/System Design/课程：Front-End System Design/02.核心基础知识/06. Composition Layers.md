Evgenii explains the difference between render and graphic layers. A graphic layer is constructed when a render layer has 3D or perspective transform CSS properties. Graphic layers are also responsible for video, canvas, opacity animations, CSS filters, and z-index compositing. Graphic layers can drastically increase a web page's memory but perform better since they rely on the GPU.  
Evgenii 解释了渲染层和图形层之间的区别。当渲染层具有 3D 或透视变换的 CSS 属性时，会构建图形层。图形层还负责视频、画布、不透明度动画、CSS 滤镜以及 z-index 合成。图形层会显著增加网页的内存使用，但由于它们依赖 GPU，因此性能更佳。



视频讲述了浏览器渲染中CPU与GPU的协同工作、渲染层和图形层的概念、图形层的内存占用问题以及前端性能优化相关要点，具体如下：

- **浏览器渲染中CPU与GPU的使用差异**：旧版浏览器仅用CPU渲染页面，新版浏览器同时使用CPU和GPU并行处理以优化渲染；GPU擅长渲染大量内容，但需合理利用才能提升效率。
- **渲染对象树的构建**：浏览器为优化GPU渲染，会构建与DOM元素一一对应的渲染对象树；DOM元素包含所有HTML属性，渲染对象则知道如何用图形上下文在位图上绘制元素。
- **渲染层的创建条件与构建**：为高效使用GPU，引入渲染层概念；使用相对或绝对定位、元素进入堆叠上下文、根元素、使用CSS或滤镜等加速属性时会创建渲染层；根元素创建根渲染层，无特殊属性的元素（如body、主容器）的渲染对象分配到根图层，绝对定位元素会被提升为独立渲染层。
- **图形层的引入与构建**：因GPU处理数百个渲染图层仍效率不高，引入图形层；使用三维加速（如透视变化）时构建图形层；根渲染层初始化第一个图形层，不使用三维加速的渲染层会应用到单个图形层；图形层带有图形上下文，知道如何绘制渲染图层。
- **图形层的内存占用情况**：单个图形层会占用一定GPU内存（如示例中单个图形层占用7兆字节，后续示例中第一个图层占用8.7兆字节）；每个新创建的图形层会消耗额外虚拟内存（如超过半兆字节）；过多图形层会大量占用GPU内存，还可能影响系统内存使用，导致应用无响应。
- **图形层的合理使用建议**：图形层是构建复杂应用的强大工具，但需正确使用，否则可能导致性能下降；可将依赖复杂动画、高交互性的小部件提升到独立图形层以优化（如实现120帧流畅动画），静态页面无需将每个元素都提升为图形层；移动设备性能有限，更需关注图层使用，避免滥用。
- **前端性能优化的通用规则与参考资源**：通用规则是尽量减少重排操作，优先更改不触发完整渲染流程的属性；可通过“What Triggers CSS”（CSS触发器）网站查看更改CSS属性触发的处理流程；需避免滥用CSS引擎和JavaScript，不在页面堆砌过多内容，防止元素频繁变化导致浏览器崩溃或性能显著下降。
- **CSS变换与回流的性能对比及选择**：CSS变换比回流有更好优化效果，会占用GPU内存；应优先使用GPU而非CPU，因为CPU渲染会阻塞渲染过程，导致响应速度下降；但使用GPU（如CSS变换）时需注意控制图形层数量，避免内存过度占用。
- **不同场景下图层使用的内存消耗差异**：通常网站会占用约一百兆虚拟内存，初始图形层有固定内存开销；大量列表项若都提升到图形层，内存可能轻松占用两百兆；营销页面若堆砌过多动画等内容，可能消耗比正常展示页面多得多的资源（如达十倍）。