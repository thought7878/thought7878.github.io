Evgenii explains the difference between render and graphic layers. A graphic layer is constructed when a render layer has 3D or perspective transform CSS properties. Graphic layers are also responsible for video, canvas, opacity animations, CSS filters, and z-index compositing. Graphic layers can drastically increase a web page's memory but perform better since they rely on the GPU.  
Evgenii 解释了**渲染层和图形层之间的区别**。当渲染层具有 3D 或透视变换的 CSS 属性时，会构建图形层。图形层还负责视频、画布、不透明度动画、CSS 滤镜以及 z-index 合成。图形层会显著增加网页的内存使用，但由于它们依赖 GPU，因此性能更佳。



视频讲述了浏览器渲染中CPU与GPU的协同工作、渲染层和图形层的概念、图形层的内存占用问题以及前端性能优化相关要点，具体如下：

## 浏览器渲染中CPU与GPU的使用差异
[00:00]
*旧版浏览器仅用CPU渲染页面，新版浏览器同时使用CPU和GPU并行处理以优化渲染*；GPU擅长渲染大量内容，但需合理利用才能提升效率。
![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/5bb54e50e93996c33dc2291112c049f4_MD5.jpeg]]

## 渲染对象树的构建
[00:29]
浏览器**为优化GPU渲染，会构建与DOM元素一一对应的`渲染对象树 Render Object Tree`**；
DOM元素包含所有HTML属性，*渲染对象则知道如何用图形上下文在位图上绘制元素*。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/e2f8afb034b643a065258dcf38eeb3bf_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/71492e87c7ab64409a5b4a4044f559aa_MD5.jpeg]]

- **渲染层的创建条件与构建**：[01:29]为高效使用GPU，引入渲染层概念；使用相对或绝对定位、元素进入堆叠上下文、根元素、使用CSS或滤镜等加速属性时会创建渲染层；根元素创建根渲染层，无特殊属性的元素（如body、主容器）的渲染对象分配到根图层，绝对定位元素会被提升为独立渲染层。
- **图形层的引入与构建**：[03:14]因GPU处理数百个渲染图层仍效率不高，引入图形层；使用三维加速（如透视变化）时构建图形层；根渲染层初始化第一个图形层，不使用三维加速的渲染层会应用到单个图形层；图形层带有图形上下文，知道如何绘制渲染图层。
- **图形层的内存占用情况**：[04:36]单个图形层会占用一定GPU内存（如示例中单个图形层占用7兆字节，后续示例中第一个图层占用8.7兆字节）；每个新创建的图形层会消耗额外虚拟内存（如超过半兆字节）；过多图形层会大量占用GPU内存，还可能影响系统内存使用，导致应用无响应。
- **图形层的合理使用建议**：[04:46]图形层是构建复杂应用的强大工具，但需正确使用，否则可能导致性能下降；可将依赖复杂动画、高交互性的小部件提升到独立图形层以优化（如实现120帧流畅动画），静态页面无需将每个元素都提升为图形层；移动设备性能有限，更需关注图层使用，避免滥用。
- **前端性能优化的通用规则与参考资源**：[06:59]通用规则是尽量减少重排操作，优先更改不触发完整渲染流程的属性；可通过“What Triggers CSS”（CSS触发器）网站查看更改CSS属性触发的处理流程；需避免滥用CSS引擎和JavaScript，不在页面堆砌过多内容，防止元素频繁变化导致浏览器崩溃或性能显著下降。
- **CSS变换与回流的性能对比及选择**：[09:54]CSS变换比回流有更好优化效果，会占用GPU内存；应优先使用GPU而非CPU，因为CPU渲染会阻塞渲染过程，导致响应速度下降；但使用GPU（如CSS变换）时需注意控制图形层数量，避免内存过度占用。
- **不同场景下图层使用的内存消耗差异**：[08:45]通常网站会占用约一百兆虚拟内存，初始图形层有固定内存开销；大量列表项若都提升到图形层，内存可能轻松占用两百兆；营销页面若堆砌过多动画等内容，可能消耗比正常展示页面多得多的资源（如达十倍）。


## 课程文字稿

课程描述

The "Composition Layers" Lesson is part of the full, Front-End System Design course featured in this preview video. Here's what you'd learn in this lesson:“合成图层”课程是本预览视频中完整的前端系统设计课程的一部分。以下是你将在本课程中学到的内容：

Evgenii explains the difference between render and graphic layers. A graphic layer is constructed when a render layer has 3D or perspective transform CSS properties. Graphic layers are also responsible for video, canvas, opacity animations, CSS filters, and z-index compositing. Graphic layers can drastically increase a web page's memory but perform better since they rely on the GPU.叶夫根尼解释了渲染层和图形层之间的区别。当渲染层具有3D或透视变换CSS属性时，会构建图形层。图形层还负责视频、画布、不透明度动画、CSS滤镜和z-index合成。图形层会大幅增加网页的内存占用，但由于依赖GPU，其性能表现更好。

---

[00:00:00]  
Evgenii Ray: Now let's understand how the browsers utilize the GPU. So the old browsers used only the CPU to render the page, but the new browsers use CPU and GPU together in parallel to optimize the rendering. And let's now understand how the GPU is used via the browser. So would render four boxes here. 
叶夫根尼·雷：现在让我们来了解浏览器是如何利用GPU的。旧版浏览器*只使用CPU来渲染页面*，但新版浏览器会*同时并行使用CPU和GPU以优化渲染效果*。现在让我们来了解浏览器是如何使用GPU的。这里会渲染四个方框。

[00:00:23]  
Each box is absolutely positioned and slightly moved on top of each other. And here's our html tree. So apparently, for the browser to optimize the html for the GPU rendering, it needs to have some kind of rendering tree representation which is GPU aware so the browser constructs their render object tree.
每个盒子都是绝对定位的，并且彼此略微叠加。这是我们的HTML树。显然，**为了让浏览器针对GPU渲染优化HTML**，它需要有一种能被GPU识别的渲染树表示，因此浏览器会构建它们的渲染对象树。

[00:00:48]  
So where for each DOM element, we create a new render object. And as you can see, it's just one-to-one copy, but they have completely different properties that the DOM element contains all the information about html, or all its properties. While the Render Objects knows how to draw this element on the bitmap using the graphical context, which is passed from the top.
因此，*对于每个DOM元素，我们都会创建一个新的渲染对象*。如你所见，这只是一对一的复制，但它们具有完全不同的属性——*DOM元素包含所有关于HTML的信息或其所有属性*。而*渲染对象则知道如何使用从顶部传递下来的图形上下文在 bitmap 上绘制这个元素*。

[00:01:14]  
And as you can see, so the GPU is good at rendering many things, but if we imagine that every render object is responsible for drawing itself on the page, it doesn't look like a very optimized way to use the GPU. So that's why there is additional concept called Render Layer.
如你所见，GPU擅长渲染许多内容，但如果我们设想每个渲染对象都负责在页面上绘制自身，那这似乎并不是一种非常优化的GPU使用方式。这就是为什么会有一个名为“渲染层”的额外概念。

[00:01:33]  
So the Render Layer is constructed when we actually use the position relative or absolute. So when we move elements to the stacking context, so basically create a new layer. Also, it's constructed for the root element, so we always need to have a root layer where we render the things.
因此，当我们实际使用相对定位或绝对定位时，渲染层就会被构建。当我们将元素移至堆叠上下文时，基本上就会创建一个新层。此外，根元素也会构建渲染层，所以我们始终需要有一个根层来进行内容渲染。

[00:01:51]  
And when we utilize some accelerated context like Canvas or CSS filters. And let's try to construct the Render Layer. So if we take the first html Render Object, we'll see that because it's the root element, the first root Render Layer will be constructed. But then we have the body and the main tag.当我们使用一些加速上下文（如Canvas或CSS滤镜）时，我们来尝试构建渲染层。如果我们以第一个html渲染对象为例，会发现由于它是根元素，第一个根渲染层将会被构建。但之后我们还有body和main标签。

[00:02:14]  
Because the body and the main doesn't have any special properties, this Rendering Objects will be assigned to the root Render Layer. And now let's move on to these four divs element. So, because each of these div element is positioned absolutely, this means that we need to promote these objects to separate Render Layers.由于主体和主元素没有任何特殊属性，这些渲染对象将被分配到根渲染层。现在我们来看看这四个div元素。由于每个div元素都是绝对定位的，这意味着我们需要将这些对象提升到单独的渲染层。

[00:02:35]  
So that's why we created a new four Rendering Layers. And also this rendering layers will be applied to the root Render Layer. So each Render Layer kind of has a children property, and it stores the Render Layer as a linked list, in a stack order. So the last layer will be the the first rendered.这就是我们创建新的四个渲染层的原因。而且这些渲染层将应用于根渲染层。每个渲染层都有一个子属性，并以栈顺序的链表形式存储渲染层。因此，最后一个层将是第一个被渲染的。

[00:02:59]  
We may have hundreds of Render Layers, it's still not efficient to use the GPU for hundreds of objects. And remember, the GPU is good at rendering many things. So how does the browser go about that? Apparently, there is an additional layer called Graphic Layer, which is constructed when we use some 3D acceleration.我们可能有数百个渲染层，但为数百个对象使用GPU仍然效率不高。而且要记住，GPU擅长渲染大量内容。那么浏览器是如何处理这个问题的呢？显然，存在一个名为图形层的额外层，它是在我们使用某些3D加速时构建的。

[00:03:22]  
So it can be perspective change, or we use some video element where we need decoding from the GPU. And if we try to construct a Graphic Layer for that, so first, we'll start with a root Render Layer. Because it's created by html element, we initiate the first Graphic Layer, we need to have at least one when we load the page.所以这可能是视角的变化，或者我们使用了一些需要通过GPU解码的视频元素。如果我们尝试为此构建一个图形层，那么首先，我们会从一个根渲染层开始。因为它是由html元素创建的，我们会初始化第一个图形层，在加载页面时，我们至少需要有一个这样的层。

[00:03:47]  
So for the rest of the rendering layers, because they do not utilize any 3D acceleration, we don't actually need additional rendering layer. That's why all this rendering layer will be applied to the one Graphic Layer. So now we have a Graphic Layer that has the graphic context and knows how to draw the rendering layer.因此，对于其余的渲染层，由于它们不使用任何3D加速，我们实际上不需要额外的渲染层。这就是为什么所有这些渲染层都将应用于同一个图形层。所以现在我们有了一个图形层，它包含图形上下文，并且知道如何绘制渲染层。

[00:04:08]  
And now we have the full cycle of how browser renders things. But let's run a quick demo to see how this actually works. So if we open the following CodePen, and open the debug mode. Now we need to transition to the layer step.现在我们已经了解了浏览器渲染内容的完整流程。不过，让我们快速演示一下它的实际工作方式。如果我们打开下面的CodePen，并进入调试模式。现在我们需要过渡到图层步骤。  
>> Evgenii Ray: So we'll see that a single Graphic Layer right now is created, and it utilizes 8.7 megabytes of the GPU memory.>> 叶夫根尼·雷：所以我们会看到，现在创建了一个单独的图形层，它占用了8.7兆字节的GPU内存。

[00:04:42]  
So the key thing about Graphic Layers, we can utilize the Graphic Layer to optimize certain parts of the apps. So for instance, you could have the widget that relies on very advanced animations. Then you can say, hey, browser, I want this on a separate Graphic Layer so you can optimize this widget and I can see my snappy animation 120 FPS.所以关于图形层的关键是，我们可以利用图形层来优化应用程序的某些部分。例如，你可能有一个依赖非常高级动画的小部件。这时你可以告诉浏览器：“我希望这个小部件放在一个单独的图形层上，这样你就能对它进行优化，我就能看到流畅的120帧每秒的动画了。”

[00:05:06]  
But the thing about the Graphic Layer is it utilizes the CPU and the GPU RAM. So every time we create a new Graphic Layer, we actually take a hit on the browser resources. And it's very easy to prove by applying the styles to the box. And let's promote each box through separate Graphic Layer.但图形层的特点是它会占用CPU和GPU内存。所以每次我们创建新的图形层时，实际上都会消耗浏览器资源。这一点很容易通过给盒子应用样式来证明。我们来通过单独的图形层提升每个盒子的性能。

[00:05:30]  
So let's say, 那么我们来假设一下，  
>> Evgenii Ray: We can apply 3D transformation. And if we go back to the layer step, we'll see now that we have five graphic layers in total. And the first one still utilizes 8.7 megabytes, but each newly created one utilizes more than half megabyte of the virtual memory.>> 叶夫根尼·雷：我们可以应用3D变换。如果回到图层步骤，我们现在会看到总共有五个图形图层。第一个图层仍然占用8.7兆字节，但每个新创建的图层都占用超过0.5兆字节的虚拟内存。

[00:05:58]  
And the problem of that is, imagining you have at least with hundreds of elements inside, and you decided to promote these elements to the Graphic Layer. This means that you immediately consume around maybe 100 megabytes of the GPU memory. And GPU memory is not just used for the browser and rendering the page, it's used for the system.问题在于，假设你至少有数百个元素，并且你决定将这些元素提升到图形层。这意味着你会立即消耗大约100兆字节的GPU内存。而GPU内存不仅用于浏览器和页面渲染，还用于整个系统。

[00:06:21]  
And your application may become unresponsive because the system will have to utilize the additional swap cache. And when we use the swap, then we get the unresponsiveness of the app. So the summary for the Graphic Layers it's a very powerful thing to utilize when you build your complex apps, but you need to make sure that you utilize it right because it uses the VRAM and also the CPU.而且你的应用程序可能会变得无响应，因为系统将不得不利用额外的交换缓存。当我们使用交换功能时，应用程序就会出现无响应的情况。所以，对于图形图层来说，在构建复杂应用程序时，它是一个非常强大的可利用工具，但你需要确保正确使用它，因为它会占用显存和中央处理器（CPU）。

[00:06:54]  
So instead of optimizing the app you may end up de-optimizing your application.因此，你最终可能非但没有优化应用程序，反而让它变得更不优化。  
>> Speaker 2: Is there any good rule of thumb for avoiding CPU bound operations in CSS?>> 发言者2：在CSS中避免CPU密集型操作有什么好的经验法则吗？  
>> Evgenii Ray: There is a website called what triggers CSS or something, so you can actually see what is the pipeline will be triggered by changing the certain CSS properties, you just need to make sure.>> 叶夫根尼·雷：有一个网站叫“什么会触发CSS”之类的，所以你实际上可以看到更改某些CSS属性会触发什么样的流程，你只需要确认一下。

[00:07:21]  
So its always the rule of thumb, try and minimize any reflow. Always try to change the properties that do not trigger the full pipeline. So this is the rule of thumb. There is no good reason to just always use the full pipeline, because it always affects the application performance.因此，这始终是经验法则：尽量减少任何回流。始终尝试更改不会触发完整流程的属性。这就是经验法则。没有充分的理由总是使用完整流程，因为它总会影响应用程序的性能。

[00:07:41]  
>> Speaker 2: Yeah, I found it, it's csstriggers.com.>> 发言者2：是的，我找到了，是csstriggers.com。  
>> Evgenii Ray: Yeah. >> 叶夫根尼·雷：是的。  
>> Speaker 2: And then Lucas says 8.7 megabits sounds like a lot to me, am I wrong? And what could be a good healthy number?>> 发言者2：然后卢卡斯说，8.7兆比特对我来说听起来很多，是我错了吗？那一个合适的健康数值可能是多少呢？  
>> Evgenii Ray: No, actually it's a relatively small number. Usually websites utilized around hundreds megabytes of the virtual memory.>> 叶夫根尼·雷：不，实际上这个数字相对较小。通常网站使用的虚拟内存约为数百兆字节。

[00:08:03]  
And it doesn't grow linear, because we need to initialize the initial context, we always pay the price of this initial utilization. So it will be kind of the constant. But if you try to promote too many layers, then you may have an issue later.而且它不是线性增长的，因为我们需要初始化初始上下文，我们总是要为这种初始利用率付出代价。所以这会是一种常量。但如果你试图增加太多层，之后可能会出现问题。  
>> Speaker 2: Yeah, I think there's a tweet on about Frontend Masters that they were watching a course, and taking notes, and doing all these things on our website.>> 发言者2：是的，我记得有一条关于Frontend Masters的推文，说他们在我们的网站上观看课程、做笔记，还做了所有这些事情。

[00:08:38]  
And it was taking like one tenth the resources as another just marketing page that was just trying to show a couple animations or whatever. And how absurd it is, how people can abuse the CSS engine or just JavaScript in general, having so much on the page and things shifting around, like how much that it boats up the browser.而且它所占用的资源大约只有另一个仅试图展示几个动画之类的营销页面的十分之一。这多么荒谬啊，人们竟然会滥用CSS引擎，或者说广义上的JavaScript，在页面上堆砌如此多的内容，导致元素四处移动，这大大增加了浏览器的负担。

[00:09:03]  
>> Evgenii Ray: So it may impact the performance significantly. So for instance, if you have lists of items and each item will be promoted to the Graphic Layer, then I think it will take around 200 megabytes of memory easily. And we need to remember that the webinar is consumed mostly by mobile devices, and when we have the mobile device, we don't have such benefit.>> 叶夫根尼·雷：所以这可能会显著影响性能。例如，如果你有项目列表，且每个项目都要提升到图形层，那么我认为这很容易就会占用约200兆字节的内存。而且我们要记住，观看网络研讨会的大多是移动设备用户，而移动设备并没有这样的优势。

[00:09:26]  
We don't have RTX 4090 everywhere. [LAUGH] And that's why we need to be aware of the layers that we're utilizing in our app. Just make sure that you use them wisely. So for instance, if you have high activity widget that have using some nice animation, you can promote this to the separate layer.我们并非在所有地方都有RTX 4090。[笑] 这就是为什么我们需要留意应用程序中正在使用的图层。一定要明智地使用它们。例如，如果你有一个活跃度很高的小组件，它使用了一些不错的动画，你可以将其提升到单独的图层。

[00:09:46]  
But if you have a static page and you just promote every element to the Graphic Layer, then it's where we can get an issue.但如果你有一个静态页面，并且只是将每个元素都提升到图形层，那么这就可能会出现问题。  
>> Speaker 2: I have heard that CSS transforms are good optimizations over reflows. So, how do we correlate this now given transforms take a hit on the GPU memory?>> 发言者2：我听说CSS变换在减少重排方面是很好的优化。那么，考虑到变换会占用GPU内存，我们现在该如何平衡这一点呢？

[00:10:05]  
>> Evgenii Ray: So it's always better to utilize GPU than CPU, because when you utilize CPU you block the rendering thread and you will see that your responsiveness drops. So if you if you need to choose what to utilize always utilize GPU. You need to put a lot of effort to make sure that your app is unresponsive because of GPU.>> 叶夫根尼·雷：所以，使用GPU总是比使用CPU更好，因为当你使用CPU时，会阻塞渲染线程，你会发现响应速度下降。所以如果你需要选择使用什么，一定要用GPU。你得付出很大努力才能确保你的应用不会因为GPU而出现响应迟缓的问题。

[00:10:31]  
But it's very easy to make a few mistakes and then get a frame drop when you utilize the CPU.但在使用CPU时，很容易犯一些错误，进而导致掉帧。