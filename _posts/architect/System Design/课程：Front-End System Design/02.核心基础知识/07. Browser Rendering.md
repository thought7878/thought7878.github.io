
视频讲述了浏览器渲染相关的实践过程，包括构建各类上下文、检测脱离常规流元素以及构建不同树结构，具体如下：

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/2326f1a056592188fb52b426c77c6b0e_MD5.jpeg]]

## 初始化渲染第一步：处理HTML元素
[00:00]
渲染HTML元素时，DOM树更新并添加该元素，同时为每个DOM元素创建渲染对象，还会初始化根图形层和根渲染层，从默认的块级上下文和默认块格式开始（因使用根元素）。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/010f239f92d998c05ab9a1036d35c1ed_MD5.jpeg]]

## 第二步：渲染body元素
[01:02]
渲染body元素后，DOM树和渲染对象树均更新，其余部分保持不变。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/d7dd459c24794125cfcf7bfdf7ad0dc1_MD5.jpeg]]

## 第三步：渲染section标签
[01:13]
- 更新DOM树、渲染对象树。
- 无position、transform属性，因此*保持单个渲染层、单个图形层*。
- 因设置display: flex，*需更新格式化上下文树*，创建新的弹性格式化上下文，且弹性子项处于不同上下文会启动块格式化上下文，增加两个上下文。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/7af916ee8c8d3f5a058e2ab98b472e2b_MD5.jpeg]]


## 第四步：渲染绝对定位的span元素（带文本）
[02:05]
- 更新DOM树，添加两个新渲染对象；
- 因元素设置position: absolute，*更新渲染层树使其变为两个图层*，元素从默认布局环境移出，*创建新的堆叠上下文*，在该上下文中创建新默认块格式上下文并初始化内联环境。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/70d99ec8c4711b4c19f69c2969a9a40d_MD5.jpeg]]

## 第五步：渲染display: inline-block元素
[03:01]
- 更新DOM树和渲染对象树，图形层和渲染层树保持不变；
- 更新根节点，使用布局环境并从块格式上下文创建新块（因设置display: inline-block）。

![[_posts/architect/System Design/课程：Front-End System Design/02.核心基础知识/media/d44b503d7171af3cdf9b07b414172fc9_MD5.jpeg]]

- **渲染应用绝对定位与3D变换的元素**：[03:33]更新DOM树和渲染对象树，创建新渲染层且该渲染层分配到不同图形层（因启动新3D变换），同时创建新堆叠上下文，将tif标签启动的格式上下文放入其中，最终形成的堆叠上下文在浏览器中，根上下文之上会有覆盖的堆叠上下文且位于顶部。
- **回顾课程内容起点**：[04:25]课程最初从盒模型的边距和填充等基础概念开始，探讨绘画层次及其协同工作方式。

---

Evgenii revisits the browser rendering exercise and walks through building all formatting contexts, detecting elements outside normal flow, building a stacking context, and completing the DOM, RenderObject, RenderLayer, and GraphicLayer trees.
叶夫根尼重新审视了*浏览器渲染*练习，并逐步讲解了*如何构建所有格式化上下文、检测脱离正常流的元素、构建堆叠上下文*，以及*完成DOM树、渲染对象树、渲染层树、图形层树*。

### 课程文字稿

[00:00:00]  
Evgenii Ray: So now let's become browser, part two. So now we are slightly complicate the exercise. We are going to build all the formatting context. Also we are gonna detect all the elements outside of normal flow. And we're also going to build stacking context DOM, RenderObject tree, RenderLayer tree and the GraphicLayer trees.
叶夫根尼·雷：现在我们进入浏览器相关内容的第二部分。我们要稍微增加这个练习的复杂度。我们将构建所有的格式化上下文，还要检测所有脱离正常流的元素，同时我们也会构建堆叠上下文DOM、渲染对象树、渲染层树以及图形层树。

[00:00:20]  
So we can see how everything works together. The HTML is pretty simple and we're gonna render it line by line. So let's start with the step one. So we render the HTML element. So when we render HTML element so the DOM tree is updated. So we added this element to the tree, also the RenderObject is created.这样我们就能看到所有部分是如何协同工作的了。HTML 非常简单，我们将逐行渲染它。那我们从第一步开始吧。首先，我们渲染 HTML 元素。当我们渲染 HTML 元素时，DOM 树会被更新。我们会把这个元素添加到树中，同时也会创建 RenderObject。

[00:00:45]  
Because we create 100 objects for every DOM element, then the root GraphicLayer is initiated. And the root RenderLayer is initiated. And we start with a default stacking context and default blocks formatting context because we use the root element. So let's continue and render the body. When to render the body, the DOM tree is updated.因为我们会为每个DOM元素创建100个对象，然后根GraphicLayer会被初始化。根RenderLayer也会被初始化。由于我们使用根元素，所以我们从默认的堆叠上下文和默认的块级格式化上下文开始。那么我们继续渲染body。当要渲染body时，DOM树会更新。

[00:01:07]  
The RenderObject tree is updated, but rest is untouched.RenderObject 树会更新，但其余部分保持不变。  
Evgenii Ray: So next we render the section tag with a few flex items. So we updated our DOM tree. And we updated our RenderObject tree. Now, no position absolute apply to our any CSS transformation, we keep our single RenderLayer and we also keep our single GraphicLayer.
叶夫根尼·雷：接下来，我们用几个弹性项目渲染section标签。我们更新了DOM树，也更新了渲染对象树。现在，没有绝对定位应用于任何CSS变换，我们保留了单个渲染层，同时也保留了单个图形层。

[00:01:33]  
But now we need to update our formatting context tree. So since the display flex is assigned, we're creating a new flex formatting context. And one thing interesting is usually the div doesn't create the block formatting context. But because now it's a flex item and we are within different formatting context, this means that this instructs the browser that now the div element should initiate the block formatting context.但现在我们需要更新格式化上下文树。由于指定了display: flex，我们正在创建一个新的弹性格式化上下文。有趣的一点是，通常div不会创建块级格式化上下文。但因为现在它是一个弹性项，且处于不同的格式化上下文中，这意味着这会指示浏览器，现在这个div元素应该启动块级格式化上下文。

[00:02:00]  
So we get to two more contexts here. Okay, now let's render the absolutely position item with a span with some text. So we updated the DOM tree. We added two more rendering objects, and since the element has the position absolute assign to that, so we update our render layer tree.所以我们在这里又遇到了两个场景。好的，现在让我们用带有一些文本的 span 来渲染绝对定位的项目。我们更新了 DOM 树。我们又添加了两个渲染对象，而且由于该元素被赋予了绝对定位，所以我们更新了我们的渲染层树。

[00:02:24]  
And now we have two layers. So the next thing that we do is because the span or sorry, actually because we have the position absolute assign, we also move out the element from the default stacking context. So now we have a separate realm where we put all our elements.现在我们有两层了。接下来我们要做的是，因为这个跨度，或者抱歉，实际上是因为我们设置了绝对定位，我们还把元素从默认的堆叠上下文中移了出来。所以现在我们有了一个单独的区域来放置我们所有的元素。

[00:02:44]  
So we create a new stacking context. And within this stacking context, we created a new default block formatting context and initiated the inline formatting context. Yeah, I hope it's clear. [LAUGH] So now we are rendering the new div element and since this div element has the display inline block assigned, so this means we need to update the DOM tree, we also update the RenderObject tree.所以我们创建了一个新的堆叠上下文。在这个堆叠上下文中，我们创建了一个新的默认块级格式化上下文，并启动了行内格式化上下文。是的，希望这很清楚。[笑] 现在我们正在渲染这个新的div元素，由于这个div元素被指定为inline-block显示方式，这意味着我们需要更新DOM树，同时也要更新渲染对象树。

[00:03:14]  
GraphicLayer is untouched, RenderLayer tree is also untouched because we don't play with the staking context here. And now we're updating our root stacking context and creating a new block formatting context because the display inline block is assigned, okay? Let's render the last one. So here, we assigned the absolute positioning, but we also assigned the 3D transformation.GraphicLayer未受影响，RenderLayer树也未受影响，因为我们在这里不涉及堆叠上下文。现在我们要更新根堆叠上下文，并由于设置了inline block显示属性，创建一个新的块格式化上下文，明白吗？让我们渲染最后一个。在这里，我们设置了绝对定位，同时也设置了3D变换。

[00:03:39]  
So this means that we need to update the DOM tree. We also update the RenderObject tree. Then we create a new RenderLayer. But the difference is, this RenderLayer will be assigned to the different GraphicLayer. So because we initiated a 3D transformation. So we promoted this layer to the new GraphicLayer.这意味着我们需要更新DOM树。我们也会更新RenderObject树。然后我们会创建一个新的RenderLayer。但不同的是，这个RenderLayer将被分配到不同的GraphicLayer。因为我们启动了3D变换。所以我们将这个图层提升到了新的GraphicLayer。

[00:04:00]  
And we also initiated a new stacking context, where we placed the new formatting context initiated by the div tag.并且我们还创建了一个新的堆叠上下文，在其中放置了由div标签创建的新格式化上下文。  
>> Speaker 2: So the stacking context that we end up with at the end, if you were actually to view this in a browser, basically you'd have the root context. And then the stacking context one would be right on top of that, and the stacking context two.>> 发言者2：所以我们最终得到的堆叠上下文，如果你真的在浏览器中查看它，基本上会有一个根上下文。然后堆叠上下文一就在其上方，还有堆叠上下文二。

[00:04:19]  
>> Evgenii Ray: Yeah, it will be on top of the next one.>> 叶夫根尼·雷：是的，它会在另一个的上面。  
>> Speaker 2: Perfect, that was all I wanted to clarify, thank you.>> 发言者2：太好了，这就是我想弄清楚的所有事情，谢谢。  
>> Evgenii Ray: And we're done. So we initially started with the very simple concepts, just some box model margins and bottings. When we overused what are the painting layers and how they work together, and now we can call ourselves Jedai of reflow.>> 叶夫根尼·雷：我们完成了。我们最初从非常简单的概念开始，只是一些盒模型的边距和边框。当我们过度使用绘图图层以及它们如何协同工作时，现在我们可以称自己为回流的绝地武士了。