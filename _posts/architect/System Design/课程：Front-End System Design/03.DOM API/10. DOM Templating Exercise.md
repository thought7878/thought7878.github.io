



---

## “DOM模板练习”课程文字稿

Evgenii live codes an exercise that implements a card template. The HTML template element creates a fragment that can be manipulated without causing a reflow. Once the template is ready, it's added to the DOM using the appendChild method.
叶夫根尼**通过实时编码完成了一个实现卡片模板的练习**。HTML的template元素会创建一个片段，该片段可以被操作而不会导致回流。模板准备好后，会使用appendChild方法将其添加到DOM中。


[00:00:00]  
Evgenii Ray: We are going to do some live coding, a very simple exercise. So we have some html template that we need to utilize and we have our createCardComponent function. So we need to implement the function that takes the title and the body, this is the string variables. And sets it to the free tech and card_body_content.叶夫根尼·雷：我们将要进行一些实时编码，这是一个非常简单的练习。我们有一些需要利用的HTML模板，还有我们的createCardComponent函数。所以我们需要实现一个接收标题和正文（这两个都是字符串变量）的函数，并将其设置到free tech和card_body_content中。

[00:00:25]  
There are multiple ways how can you implement this, but let's see what we can do here. And here we call this function so this function should return HTML element. And then we append this element to the container. So to start with exercise, check out the repository. I hope you will have the link to repository in the chat, or you can also click on the slides.实现这一点有多种方法，但让我们看看在这里我们能做些什么。在这里我们调用这个函数，所以这个函数应该返回HTML元素。然后我们将这个元素添加到容器中。所以开始练习的话，去看看这个代码仓库吧。我希望你能在聊天记录里找到代码仓库的链接，或者你也可以点击幻灯片。

[00:00:53]  
And open the folder begin, and open the file index.html. We don't need any compiler or complex setup it will be enough just to work with HTML, use your favorite editor. And now I'm going to switch to the code. So I opened the index.html. So, here we have our container, then we have our HTML which is right now stored as a string.然后打开begin文件夹，再打开index.html文件。我们不需要任何编译器或复杂的设置，只需要处理HTML就行，用你喜欢的编辑器就可以。现在我要切换到代码部分了。我已经打开了index.html。在这里，我们有一个容器，还有当前以字符串形式存储的HTML内容。

[00:01:21]  
And also we have our HTML element, the function that creates our car element. Right now it's empty, so our goal will be to implement this. So, what can we do here? We could potentially just say, for instance, container. And then set the innerHTML. But then we would have to work with the string directly, and representing the HTML as a string is not the best way to do things.而且我们还有自己的HTML元素，也就是创建汽车元素的函数。现在它是空的，所以我们的目标是实现它。那么，我们在这里可以做些什么呢？比如，我们或许可以直接用container，然后设置innerHTML。但这样的话，我们就必须直接处理字符串，而将HTML表示为字符串并不是最佳的做法。

[00:01:52]  
So we want to have some kind of reusable way, how can we represent the templates. So, and apparently the innerHTML, we have the special tag called template, so we can remove this line and in the head I'm going to use the template tag. So what this template does, it basically stores your HTML in the lightweight object in memory.所以我们希望有某种可重用的方式来表示这些模板。显然，对于innerHTML，我们有一个名为template的特殊标签，所以我们可以删除这一行，然后在头部使用template标签。这个template标签的作用基本上是将你的HTML存储在内存中的轻量级对象里。

[00:02:22]  
So, this content is not querryable by any DOM API. So any external scripts will not be able to access this content. So, it's also not rendered on the final render tree. So if you use a try, tries to traverse the DOM tree, they will not be able to see that this template is utilized.因此，任何DOM API都无法查询此内容。所以任何外部脚本都无法访问此内容。而且，它也不会在最终的渲染树中呈现。因此，如果你尝试遍历DOM树，将无法看到这个模板被使用。

[00:02:47]  
It's kind of a lightweight representation of our card. We edit the card template into the template tag, and we also assign the ID. So the content of the template is not queryable, but the template is, so we need to clone the content of the template. So let's update, let's first query the template.这算是我们卡片的一种轻量表示形式。我们将卡片模板编辑到模板标签中，同时也会分配ID。所以模板的内容是不可查询的，但模板本身可以，因此我们需要克隆模板的内容。那么我们来更新一下，首先查询这个模板。

[00:03:09]  
So we can do document getElementById, and then we use our card template. So now we have the reference to the card template. Let's clone the content. As we know, the templates use the fragment, so we need to clone the content of the fragment for the special method that I'm going to show now.所以我们可以使用document getElementById，然后使用我们的卡片模板。现在我们有了卡片模板的引用。让我们克隆内容。我们知道，模板会使用片段，所以我们需要通过我现在要展示的特殊方法来克隆片段的内容。

[00:03:36]  
So we're gonna access the template. And the template has the property called content. So the content gives us the fragment that we need to work with. So, then I'm going to use the clone node. And I'm providing the true flag to do the deep call. And then I use the first element child that will return me the article.所以我们要访问这个模板。这个模板有一个名为content的属性。content会给我们需要处理的片段。然后，我会使用clone node方法。我提供true这个标志来进行深度克隆。之后，我会使用first element child，它会返回给我那篇文章。

[00:04:04]  
So by default the, first, it will return the fragment but we need to access this element, and this element is the element, and that's why we use the first element child. So now we have our article. We want to update the article content. So we need to set the card title and the card body content, so let's query that.因此，默认情况下，首先，它会返回该片段，但我们需要访问这个元素，而这个元素就是那个元素，这就是我们使用第一个子元素的原因。现在我们有了自己的文章。我们想要更新文章内容。所以我们需要设置卡片标题和卡片正文内容，那我们来查询一下吧。

[00:04:28]  
So let's call it cardTitle and cardBody and then we use the document querySelectorAll and then we're providing two selectors. The first one is the card title, then we need to pass the那我们就称它为cardTitle和cardBody，然后我们使用document querySelectorAll，接着提供两个选择器。第一个是卡片标题，然后我们需要传递  
Evgenii Ray: Card_body_content_class. So now we selected two elements, cardTitle and the cardBody. And now we want to update the text content of this elements.叶夫根尼·雷：Card_body_content_class。现在我们选中了两个元素，cardTitle和cardBody。现在我们想要更新这些元素的文本内容。

[00:05:02]  
So we use the text content property and then assign title. Then we need to use cardBody and then assign thE textContent to the body variable. Okay, now we're returning the card and if we run this example, so now we're creating a new card element and then we'll return this card element from the credit card component function.所以我们使用textContent属性，然后赋值title。接着我们需要使用cardBody，再将textContent赋值给body变量。好的，现在我们要返回这个卡片，并且如果我们运行这个示例，那么现在我们正在创建一个新的卡片元素，然后我们会从信用卡组件函数中返回这个卡片元素。

[00:05:32]  
Assign some random text and if we run the browser we see that this doesn't work, and let's see why [LAUGH]. And apparently, we're trying to set the text content so the property undefined. So probably we have a mistake in how we query things. Yeah, so we don't need to query the document, we need to query card.添加一些随机文本，然后如果我们运行浏览器，会发现这不起作用，让我们看看原因（笑）。显然，我们试图设置文本内容，但该属性未定义。所以可能是我们查询内容的方式有误。是的，我们不需要查询文档，我们需要查询卡片。

[00:05:57]  
So if we fix that, yeah, now we have our card rendered and all elements set. And this is it for the first exercise. Okay, let's have the quick look of how could we potentially solve that. The first solution would involve, had treating the article as a string. So we could create the placeholders within the context and just replace it with the replace function.所以如果我们解决了这个问题，没错，现在我们的卡片已经渲染完成，所有元素都设置好了。这就是第一个练习的全部内容。好的，让我们快速看看我们可能会如何解决这个问题。第一种解决方案包括将文章视为一个字符串。这样我们就可以在上下文中创建占位符，然后用替换函数来替换它。

[00:06:23]  
But this means we will need to work with a string. And then we could append the content using the innerHTML. But this is not the best way because we will have to pass the code content, here in innerHTML. And if we want to repeat this operation, then it's not the most efficient way.但这意味着我们需要处理一个字符串。然后我们可以使用innerHTML来追加内容。但这并不是最佳方法，因为我们必须在这里的innerHTML中传递代码内容。而且如果我们想重复这个操作，那它就不是最高效的方法了。

[00:06:45]  
So what we did is we just use the document fragment, which is the lightweight representation of HTML element. And since it's shielded from, causing reflow, we can do whatever we want in memory. So it can also be reused many times, and it says isolated from the queries. And yeah, we utilize it to keep our markup component in HTML, which is a very natural place where we should keep such things.所以我们所做的就是使用文档片段，它是HTML元素的轻量级表示。而且由于它不会导致回流，我们可以在内存中进行任何操作。它还可以被多次重用，并且与查询隔离开来。是的，我们利用它将标记组件保存在HTML中，这是保存此类内容的一个非常自然的地方。

[00:07:16]  
And then we just updated our function, and the solutions and here is the final solution. Before we jump to the next section, do we have any questions?然后我们刚刚更新了我们的函数和解决方案，这是最终的解决方案。在进入下一部分之前，大家有什么问题吗？  
Student: Can you just explain again briefly why doing it that way doesn't trigger reflow?学生：你能再简要解释一下为什么那样做不会触发回流吗？  
Evgenii Ray: Yeah, so when you modify the fragment, it's not within the DOM tree.是的，所以当你修改这个片段时，它并不在DOM树中。

[00:07:43]  
It's actually just in memory. So when you update any properties, so it doesn't trigger any reflow. So, if you could potentially have the element or in the DOM tree and you start updating the elements of the properties of this element, then this would cause reflow because the element already in a DOM tree.实际上它只是在内存中。所以当你更新任何属性时，它不会触发任何回流。因此，如果你可能在DOM树中有该元素，并且开始更新这个元素的属性，那么这会导致回流，因为该元素已经在DOM树中了。

[00:08:03]  
But since it's in memory, yeah, we can do any operations and it's disconnected from the main DOM tree. The only thing that counts the reflow is when we use a pen child. So the DOM API is actually pretty simple, it has some limited set of methods that we can utilize.但由于它在内存中，没错，我们可以执行任何操作，而且它与主DOM树是断开连接的。唯一会触发回流的情况是当我们使用pen子元素时。所以DOM API实际上相当简单，它有一些我们可以利用的有限方法集。

[00:08:21]  
And it's very useful if we're trying to build some low level things. But we need to think about the caveats that the DOM API has, for instance, make sure that you utilize the HTML life collection wisely. So don't query too many elements and then don't try to read the HTML left collection because it will result to quadratic time.如果我们想构建一些底层的东西，这会非常有用。但我们需要考虑DOM API存在的一些注意事项，例如，要确保明智地使用HTML实时集合。所以不要查询太多元素，也不要尝试读取HTML实时集合，因为这会导致二次时间复杂度。

[00:08:48]  
For most of the cases, the queries lecture has a good performance and you can just utilize it almost everywhere. So for rare cases when you really need to have the live collection, make sure that you work with a small subset of data to reduce any performance impact.在大多数情况下，查询演讲的表现都很好，你几乎可以在任何地方使用它。所以，在极少数你确实需要实时收集的情况下，确保只处理一小部分数据，以减少对性能的影响。