


---

## “DOM性能最佳实践”课程文字稿

Evgenii shares some performance best practices when querying DOM elements. Simplifying query selectors or using IDs for core containers can provide easy performance gains. This lesson also discusses the performance costs of adding and removing elements.
叶夫根尼分享了一些**查询DOM元素时的性能最佳实践**。*简化查询选择器*或*为核心容器使用ID可以轻松提升性能*。本节课还讨论了添加和移除元素的性能成本。


[00:00:00]  
Evgenii Ray: Let's move on to performance best practices, the first and the most obvious one, and the one overlooked the most is that we can actually improve the performance of querying by simplifying the selector. So, each time you use the complex selector, the CSS compiler needs to transpire this, and it takes more time, so you pay extra tax on using the complex selector.叶夫根尼·雷：让我们来谈谈性能最佳实践，第一个也是最明显、同时最容易被忽视的一点是，我们实际上可以通过简化选择器来提升查询性能。所以，每次你使用复杂选择器时，CSS编译器都需要对其进行转换，这会耗费更多时间，因此使用复杂选择器会让你付出额外的代价。

[00:00:28]  
So, you may notice that it's not significant, so you may pay like five milliseconds on the query to compile this lecture, but all these things are accumulating. So, if you do hundreds of queries, so it will result, maybe to 50 milliseconds, on average in the delay. But if we combine all possible optimizations with this one, the results can be quite significant.所以，你可能会注意到这并不显著，你可能只需花费约五毫秒来处理这个查询以整理这堂讲座，但所有这些时间都在累积。所以，如果你进行数百次查询，平均延迟可能会达到50毫秒。但如果我们将所有可能的优化与这一点相结合，结果可能会相当显著。

[00:00:55]  
Although the IDs is not the best practice, you still can utilize IDs for the core container when, for instance, you need to query the element from the very large tree. So, if we have some DOM tree that has 10,000 elements, if you query from HTML, then you need to go through 10,000 elements on the first query.虽然使用ID并非最佳实践，但在某些情况下，例如需要从非常大的树中查询元素时，你仍然可以为核心容器使用ID。因此，如果我们有一个包含10,000个元素的DOM树，若从HTML开始查询，那么在第一次查询时就需要遍历10,000个元素。

[00:01:18]  
But if you, for instance, could select this section with an ID, and then you know that this operation should be repeated multiple times, then you can just provide an end query from this section, and it will be just one operation. So, next section is adding and removing elements, and before we jump to that, any questions so far?但是，例如，如果你可以用一个ID选中这个部分，并且你知道这个操作需要重复多次，那么你只需要从这个部分提供一个结束查询，这就只需要一次操作。接下来的部分是添加和删除元素，在我们进入这部分之前，到目前为止还有什么问题吗？

[00:01:38]  
Speaker 1: So, you talked about understanding the differences between these methods being useful if you were gonna build something more low level. If you are working on something that is using a framework like React or Angular, are there recommendations you would make for improving performance or knowing what their methods are using under the hood?发言者1：所以，你提到如果要构建更底层的东西，理解这些方法之间的差异会很有用。如果你正在使用像React或Angular这样的框架进行开发，对于提升性能或了解这些框架的方法在底层使用了什么，你有什么建议吗？

[00:02:00]  
Or do you just trust that the library authors have spent a lot of time thinking about it [LAUGH]?或者你只是相信库的作者们已经花了很多时间去思考这个问题[笑]？  
Evgenii Ray: Yeah, when you utilize any library that manages the DOM for you, you just rely on this library. The only way you can possibly think you may use the DOM API within some effect in the React when you need to query things, this is the place where you could optimize potentially.叶夫根尼·雷：是的，当你使用任何为你管理DOM的库时，你只需依赖这个库。在React中，当你需要查询某些内容时，你可能会想到在某个effect中使用DOM API，这正是你可以进行潜在优化的地方。

[00:02:25]  
But trying to optimize a React is not a good idea because it's quite complex inside.但试图优化React并不是个好主意，因为它的内部相当复杂。  
Speaker 2: Is the cost of CSS only during compile time? Wouldn't the runtime of complex selectors also be about performance?发言者2：CSS的开销只在编译时产生吗？复杂选择器的运行时难道不也关乎性能吗？  
Evgenii Ray: No actually, first you compile your styles in CSS, this compiled when you initiate the page.叶夫根尼·雷：实际上不是这样的，首先你要在CSS中编译样式，这是在你启动页面时进行编译的。

[00:02:48]  
But when you execute the JavaScript with some query selector, this is dynamic selector, this means that should be compiled in runtime. So, you pay the cost every time you execute that, okay? So, let's now understand how we can add or remove elements, and when it comes to adding or removing, every method is bad.但是当你用一些查询选择器执行JavaScript时，这是动态选择器，意味着它需要在运行时编译。所以，你每次执行时都要付出相应的代价，明白吗？那么，现在让我们来了解如何添加或移除元素，而说到添加或移除，每种方法都有其不足。

[00:03:09]  
[LAUGH] So basically, we don't have a good, so the performance impact is always significant. So, there is no good method to insert the data because every time we modify, the DOM, it triggers the reflow. So, in our application, we want to minimize the reflow operation, but there are a few methods that particularly impact the performance.[笑声] 所以基本上，我们没有什么好办法，因此性能影响总是很显著。所以，没有很好的方法来插入数据，因为每次我们修改DOM时，都会触发回流。因此，在我们的应用程序中，我们希望尽量减少回流操作，但有一些方法对性能的影响尤其大。

[00:03:36]  
The first one is innerHTML, so when you use the innerHTML, you basically set the HTML of the element. The browser needs to involve the HTML parser to compile your HTML again, to do the full reflow, validate your HTML, and so on. So, you pay the cost of the parsing, same applies to insert a JSON HTML.第一个是innerHTML，当你使用innerHTML时，基本上是在设置元素的HTML内容。浏览器需要调用HTML解析器重新编译你的HTML，进行完整的重排、验证你的HTML等等。所以，你要付出解析的成本，插入JSON格式的HTML也是如此。

[00:03:59]  
Because we use the row HTML, the browser still needs to parse that. But if you need to modify the DOM, make sure that you don't utilize the inner HTML too often. It's okay to use this once per initialization, but if you expected to insert elements dynamically, then it's better to utilize the insert adjacent element or a penchant because it takes the compiled HTML object already and just renders this on a DOM.因为我们使用行内HTML，浏览器仍然需要对其进行解析。但如果你需要修改DOM，请确保不要过于频繁地使用innerHTML。在每次初始化时使用一次是没问题的，但如果希望动态插入元素，那么最好使用insertAdjacentElement或类似方法，因为它们会直接使用已编译的HTML对象，并将其渲染到DOM上。

[00:04:36]  
And we can see how it works, so the method is pretty flexible because it accepts the position where we can insert the element. The first one is before begin, which basically insert the element before the target element. So, we can try to insert that, and the element is inserted, so the after begin will give you the first child position.我们可以看到它是如何工作的，所以这个方法非常灵活，因为它接受我们可以插入元素的位置。第一个是“开始之前”，基本上是将元素插入到目标元素之前。我们可以试着插入，元素就被插入了，“开始之后”会给你第一个子元素的位置。

[00:05:02]  
Evgenii Ray: While the before end will render element as a last child, and after end will give you the position right after target element. This method is pretty flexible and can be used almost anywhere, then how do we remove elements. So, removing elements can be done through the remove method, basically we need to have a reference to the object, and we can also reset the whole HTML by setting the EMP string.叶夫根尼·雷：“before end”会将元素渲染为最后一个子元素，而“after end”会为你提供紧跟在目标元素之后的位置。这种方法相当灵活，几乎可以在任何地方使用，那么我们该如何移除元素呢？移除元素可以通过remove方法来完成，基本上我们需要有一个对象的引用，我们还可以通过设置空字符串来重置整个HTML。