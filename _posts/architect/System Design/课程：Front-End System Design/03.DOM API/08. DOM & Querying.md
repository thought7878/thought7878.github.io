
视频讲述了**DOM API的相关知识**，包括DOM API的概念、适用场景、相关对象与类层次结构，以及不同DOM查询方法的特点、性能等内容，具体如下：

- **DOM API概念与适用场景**：[00:00]穹顶API（DOM API）是一组用于操作DOM的方法，通常不直接使用，因多数库处理DOM变更（如React、Angular视图），但在构建底层库（处理虚拟化操作、DOM管理）、创建通用可移植组件（视频播放器、图表引擎）、构建作品集网站（简化结构、使应用更轻量）时需使用。
- **DOM相关对象介绍**：[01:04]全局对象window可全局访问且无需导入；document代表当前渲染页面的HTML元素，可通过window或直接作为全局对象访问；document上有body、head等快速访问链接，分别对应页面的body和head部分。
- **DOM类层次结构**：[01:51]HTML页面所有元素由HTMLElement表示，但DOM接口分配在Element原型（因DOM API还处理SVG、XML等）；Node类用于表示DOM树形结构的“树叶”，文本节点继承Node，用于包裹文本和HTML元素；HTML文档是例外，原型上分配DOM API且继承Node；窗口有HTML文档实例，代表浏览器视图查询方法，其原型无有趣属性。
- **getElementById查询方法**：[03:37]是最简单的DOM查询方法，浏览器加载页面时会构建元素哈希映射，遇id建立缓存（id映射到HTML引用），通过id获取元素的时间复杂度为O(1)，类似通过键访问对象。
- **getElementsByClassName查询方法**：[04:12]需遍历整个DOM树（广度优先搜索）查找含目标类名的元素，最坏情况时间复杂度为线性O(n)；但浏览器会利用哈希映射缓存，首次查询耗时，后续相同查询响应快；返回HTML集合（实时更新的遗留集合），DOM树修改会反映在集合中，读取成本高（每次读元素浏览器需重新解析树验证位置），但内存消耗低（直接用已有引用）。
- **getElementsByTagName查询方法**：[06:13]工作原理与getElementsByClassName相同，按标签名查询元素，同样返回实时更新的HTML集合，低内存开销但读取访问成本高，循环该集合可能导致二次方时间复杂度，不建议对大量元素使用。
- **querySelector查询方法**：[06:24]使用CSS选择器查询，时间复杂度取决于选择器复杂度，需支付选择器编译开销（选择器越复杂，编译时间越多），读取和内存成本较高；查询机制为深度优先搜索加哈希表，若用ID查询会转换为getElementById操作；返回NodeList（非实时更新，是元素副本），查询时增加内存开销，不建议查询过多内容。
- **querySelectorAll查询方法**：[08:57]性能略逊于getElementBy系列，但浏览器高度优化，平均性能接近；返回非实时更新的集合，DOM树移除元素可能导致集合中保留过时元素；因会复制所有元素，不建议用于查询过多元素。
- **查询与读取成本时间复杂度差异**：[09:43]以getElementsByTagName为例，查找目标元素最坏情况时间复杂度O(n)（需遍历所有元素），读取成本也为O(n)（维护实时更新的集合，每次访问集合浏览器需验证元素是否在DOM树中，最坏情况需重新解析所有元素）。
- **querySelectorAll返回非活集合原因**：[10:43]实时集合（如HTML集合）是遗留方案，有较多缺点且使用不当易出问题；普通应用开发无需管理实时集合，querySelectorAll返回非活集合更适合多数开发者，避免实时集合的弊端。
- **querySelectorAll影响内存原因**：[11:31]其返回的不是DOM中元素的引用，而是元素的副本，浏览器会创建具有相同值的新对象，虽修改副本属性会影响原始对象，但两者是独立对象，导致查询时增加额外内存开销。
- **浏览器缓存与查询方法性能差异**：[12:15]类名可能动态变化，缓存逻辑取决于浏览器引擎，不同浏览器（如Safari用WebAssembly编译本地课程，Chrome不使用）对相同查询方法的表现可能不同，无法保证下次查询一定因缓存更快。
- **各查询方法适用场景与注意事项**：[07:58]getElementBy系列（按id、类名、标签名）中，getElementById性能最佳，但过度依赖ID是反模式（命名空间共享）；getElementsByClassName和getElementsByTagName低内存开销但读取成本高，不建议大量元素场景；querySelector和querySelectorAll使用灵活（CSS选择器），但需注意内存开销和非实时更新特性，避免查询过多元素。



---

## 课程文字稿

Evgenii reviews the global objects and class hierarchy in the DOM API. Query methods are also discussed, and their time complexity, memory cost, and algorithms are compared. In general, getElementById provides the best space and time complexity performance. The querySelector and querySelectorAll have slightly worse performance, but due to caching and browser optimizations, the performance will improve with repetitive runs.
叶夫根尼回顾了**DOM API中的全局对象和类层次结构**。文中还讨论了*查询方法，并对它们的时间复杂度、内存成本和算法进行了比较*。总体而言，`getElementById`在空间和时间复杂度方面表现最佳。`querySelector`和`querySelectorAll`的性能稍差，但由于缓存和浏览器优化，重复运行时性能会有所提升。


[00:00:00]  
Evgenii Ray: So what is the DOM API? So the DOM API is a set of methods that we can utilize to manipulate a DOM. And usually, we don't use it directly because most of the libraries are handling the DOM mutations for us, for instance, React, Angular or Vue. But there are cases where we actually need to use the DOM API.叶夫根尼·雷：那么什么是DOM API呢？DOM API是一组我们可以用来操作DOM的方法。通常情况下，我们不会直接使用它，因为大多数库都会为我们处理DOM变更，例如React、Angular或Vue。但在某些情况下，我们确实需要使用DOM API。

[00:00:21]  
And one of that is when you're building some low-level library that works with virtualization or some DOM management. Also, it's used when you need to create some generic components that can be ported to any library or framework. It can be a video player or a chart engine. And also, for instance, you are building your portfolio website, and you want to minimize the blueprint of your application by not importing too many libraries.其中一种情况是，当你在构建一些涉及虚拟化或某种DOM管理的底层库时。此外，当你需要创建一些可移植到任何库或框架的通用组件时，也会用到它。这可能是一个视频播放器或图表引擎。再比如，你正在搭建自己的作品集网站，并且希望通过不导入过多库来简化应用的架构。

[00:00:51]  
So this way you can just use the DOM API and your app will be lightweight. So this section will give us a quick refresher on how to use the DOM API. So first, let's overview the objects that are available to us and how can we use the DOM API?这样一来，你就可以直接使用DOM API，而且你的应用程序会很轻量。所以本节将快速回顾一下如何使用DOM API。首先，让我们概述一下可用的对象以及如何使用DOM API。

[00:01:11]  
So the first global object that we are all aware of is the window. The window is the globally accessible object, so you don't need to import anything. The next one is the document, the document who presents HTML Element, basically, the page that we're currently rendering. And the document can be accessed for the Window or directly by referencing this as a Global Object.我们都知道的第一个全局对象是window。window是可全局访问的对象，因此你无需导入任何内容。下一个是document，document表示HTML元素，基本上就是我们当前正在渲染的页面。可以通过Window访问document，也可以直接将其作为全局对象来引用。

[00:01:40]  
Then we have some quick access links that we can use on the Document. It's a body and head gives us the body check and head respectively. Now let's go for the Class Hierarchy. All the elements on the HTML page are represented by HTMLElement. But apparently the HTMLElement doesn't have any DOM API assigned to that.然后我们有一些可以在文档上使用的快速访问链接。“body”和“head”分别为我们提供主体检查和头部检查。现在让我们来看类层次结构。HTML页面上的所有元素都由HTMLElement表示。但显然，HTMLElement没有分配任何DOM API。

[00:02:06]  
The DOM API is actually assigned to the element prototype. So why is that? Because the DOM API can actually work not with just HTML. So it can be also SVG elements or XML-like things. That's why the DOM API lives on the element prototype instead of HTMLElement. And we also have the Node.DOM API实际上被分配给了元素原型。这是为什么呢？因为DOM API实际上不仅可以处理HTML，还可以处理SVG元素或类XML的内容。这就是DOM API存在于元素原型而非HTMLElement上的原因。此外，我们还有Node。

[00:02:29]  
The DOM is a tree and somehow, we need to access the tree properties. So that's why we have a special class that's designed to represent a tree leaf, and this is the Node. And we have exception, which is a TextNode, which basically extends the Node plus. The TextNode is used when we use any text, then we need to wrap our text in the HTMLElement.DOM 是一棵树，我们需要以某种方式访问这棵树的属性。这就是为什么我们有一个专门设计用来表示树叶的特殊类，那就是 Node（节点）。我们还有一个例外情况，那就是 TextNode（文本节点），它基本上是在 Node 的基础上进行了扩展。当我们使用任何文本时，就会用到 TextNode，这时我们需要将文本包裹在 HTMLElement（HTML 元素）中。

[00:02:54]  
So the browser needs to somehow to represent the text that we place in our in our text. Then we have the HTMLDocument and HTMLDocument is outlier here because it has the DOM API assigned to its prototype, but it extends the Node. I don't know the reason why, but this is the exception in the whole hierarchy that we need to live with.所以浏览器需要以某种方式来呈现我们放入文本中的内容。然后我们有HTMLDocument，它在这里是个特例，因为它的原型上分配了DOM API，但它又继承自Node。我不知道原因是什么，但这是整个层级结构中的一个例外，我们只能接受它。

[00:03:17]  
And the next one is the Window. Basically, the Window has an instance of HTMLDocument and it doesn't have any interesting properties on its prototype, so it presents the Browser Viewport. Query methods, let's now understand how the browser queries elements on a page, how the DOM API queries the elements.下一个是窗口（Window）。从本质上来说，窗口包含一个HTMLDocument实例，其原型上没有任何有趣的属性，所以它代表着浏览器视口。现在让我们来了解查询方法，即浏览器如何查询页面上的元素，以及DOM API如何查询元素。

[00:03:37]  
So let's have first the most simple method, which is getElementByID. So when the browser reads the page, it constructs the Hashmap of the elements. So it reads the ID, and then it basically builds the cache where the ID is assigned to some HTML reference. So this means that when we try to getElementByID the Time Complexity and Read Costs is just O (1).那么我们先来看最简单的方法，即getElementByID。当浏览器读取页面时，它会构建元素的哈希表（Hashmap）。它会读取ID，然后基本上会建立一个缓存，其中ID被分配给某个HTML引用。这意味着当我们尝试使用getElementByID时，其时间复杂度和读取成本仅为O(1)。

[00:04:05]  
Because this is just basically accessing the object by its key. The situation is slightly different when it comes to getElementsByClassName. So to getElementsByClassName we need to actually traverse the whole tree, and the way the browser traverse a tree it's use the DFS approach. So it basically goes through the elements and finds all the all the elements on a page with the class text.因为这本质上只是通过键来访问对象。当涉及到getElementsByClassName时，情况略有不同。要使用getElementsByClassName，我们实际上需要遍历整个树，而浏览器遍历树的方式是采用深度优先搜索（DFS）方法。所以它基本上会遍历所有元素，找出页面上所有带有“text”类的元素。

[00:04:36]  
And the Time Complexity for this is linear, so we need to go for all elements in the worst case, but you see there is a star here. This is because the browser is quite smart, and it utilizes the Hashmap when you try to query things. So the first query will take some time, but if you execute the same query next time, it will be almost immediately because browser utilizes the caching mechanism.而它的时间复杂度是线性的，所以在最坏情况下，我们需要遍历所有元素，但你会看到这里有个星号。这是因为浏览器相当智能，当你尝试查询内容时，它会利用哈希表。因此，第一次查询会花费一些时间，但如果你下次执行相同的查询，几乎会立即完成，因为浏览器运用了缓存机制。

[00:05:04]  
And one thing about this method is also to trans the HTMLCollection. An HTMLCollection is actually a legacy Collection which has one interesting characteristic, it's life. So this means that if we modify the DOM Tree, and, for instance, remove one element from the DOM, this will be reflected on our HTMLCollection.这种方法还有一个特点，就是会转换HTMLCollection。HTMLCollection实际上是一种遗留的集合，它有一个有趣的特性，那就是它是动态的。这意味着如果我们修改DOM树，例如从DOM中移除一个元素，这种变化会反映在我们的HTMLCollection上。

[00:05:30]  
And that's why the Read Cost of the HTMLCollection is big O(N) and because every time we need to read a single element, the browser will parse the tree again to verify its position. So this is a disadvantage of this thing. But on the other hand, the memory cost is low because the browser doesn't need to clone any objects, it just takes the already existing references.这就是为什么HTMLCollection的读取成本是大O(N)级别的，因为每次我们需要读取单个元素时，浏览器都会重新解析树以验证其位置。所以这是它的一个缺点。但另一方面，其内存成本很低，因为浏览器不需要克隆任何对象，只需要使用已有的引用即可。

[00:06:00]  
So you can utilize the HTMLCollection when you're low on memory and you need to use as less memory as possible. Okay, the same way works the getElementByTagName. So there is no difference at all, it allows us to query things by detect. So the querySelector works slightly different. So it utilizes the CSS selector, so the time complexity depends on the selector that we use.所以当你内存不足且需要尽可能少地使用内存时，可以利用HTMLCollection。好的，getElementByTagName的工作方式也是如此。所以这两者完全没有区别，它们都允许我们通过检测来查询内容。而querySelector的工作方式略有不同。它利用CSS选择器，因此时间复杂度取决于我们使用的选择器。

[00:06:34]  
So we always space some text on compiling the selector. So this means that the more complex selector you have, the more time it takes to compile it for CSS. So the read access and the Memory Cost is big O (1) because we're just returning the single element. And the querying mechanism when we try to use the class names or the text, it's the same as the DFS.所以我们在编译选择器时总会在一些文本之间留出空间。这意味着你的选择器越复杂，为CSS编译它所花费的时间就越长。读取访问和内存成本是大O（1），因为我们只是返回单个元素。而当我们尝试使用类名或文本时，查询机制与深度优先搜索（DFS）相同。

[00:07:04]  
If we use the ID, then we gonna convert this statement to getElementByID instead. So one interesting thing about the querySelector, and this is the querySelectorAll, is because it returns the NodeList. The NodeList is not a type of collection, but it's not life, it's just basically the copy of the elements.如果我们使用ID，那么我们就要把这个语句转换成getElementByID。所以querySelector以及querySelectorAll有个有趣之处，就是它们会返回NodeList。NodeList不是一种集合类型，而且它不是动态的，本质上只是元素的副本。

[00:07:25]  
So what the browser does it just copies the HTML objects. And this means that we pay additional memory costs when we do the querying. So it's not advisable to query too many things because you may end up having the memory spike. But the read access is O(1) because you're just accessing the object directly from the array instead of traversing the tree again by maintaining the life collection.浏览器所做的就是复制HTML对象。这意味着我们在执行查询时会产生额外的内存成本。因此，不建议查询过多内容，因为这可能导致内存激增。但读取访问的时间复杂度是O(1)，因为你只需直接从数组中访问对象，而无需通过维护生存集合再次遍历树。

[00:07:51]  
And the querying mechanism is the same, DFS plus Hashmap. Quick summary, so the getElementsByID provide the best performance because the browser builds the cache. But you need to make sure that you utilize the ID space correctly. So it's basically apparent to you to rely on the IDs too much, because the ID name space is shared across your multiple components and just make sure that you don't overuse IDs in your app.而查询机制是相同的，即深度优先搜索加哈希表。简要总结一下，getElementsByID 提供了最佳性能，因为浏览器会构建缓存。但你需要确保正确使用 ID 空间。所以，很明显你也过度依赖 ID 了，因为 ID 命名空间在多个组件中是共享的，要确保在应用中不过度使用 ID。

[00:08:23]  
The getElementsByClassName or getElementsByTagName, provide a low memory overhead because it returns to live collection with just references to existing objects. But because the read access is high, so you need to make sure that you utilize this collection right. Because if you're going to loop for this collection, yes, it will convert to quadratic time.getElementsByClassName 或 getElementsByTagName 方法内存开销较低，因为它们返回的是实时集合，仅包含对现有对象的引用。但由于读取访问成本较高，因此需要确保正确使用这个集合。因为如果对该集合进行循环操作，其时间复杂度会变成二次方。

[00:08:50]  
And we don't want to do that in our app on the largest set of elements. The querySelector have slightly worse performance than getElementByID. But the browser itself heavily optimize any CSS selectors. So in different browsers, you may get different results, but on average, it's very close actually to getElementByID.而且我们不想在我们的应用程序中对最大的元素集合执行这种操作。querySelector的性能比getElementByID稍差一些。但浏览器本身会对任何CSS选择器进行深度优化。所以在不同的浏览器中，你可能会得到不同的结果，但平均来说，它实际上与getElementByID非常接近。

[00:09:13]  
But the elements that are returned from this query do not represent the live collections. So if you remove the element from the DOM Tree, you may end up having the stale element in your in your collection. Yeah, the same applies to the querySelectorAll, but because it copies all the elements, you don't want to query too many elements with this method.但此查询返回的元素并不代表实时集合。因此，如果你从DOM树中移除某个元素，你的集合中可能会留下过期元素。是的，这一点也适用于querySelectorAll，但由于它会复制所有元素，所以你不会希望用这种方法查询太多元素。

[00:09:39]  
Speaker 2: Could you clarify the difference between the time complexity of querying versus the read cost?发言者2：你能说明一下查询的时间复杂度和读取成本之间的区别吗？  
Evgenii Ray: Yeah, okay. So if we'll go back to getElementsByTagName, for instance. So the time complexity it takes to go through the elements, to find all the elements that we are looking for is big O(N) because we need to go through all elements in the worst case.叶夫根尼·雷：是的，好的。比如，我们回到getElementsByTagName这个方法。遍历元素以找到所有我们要找的元素，其时间复杂度是大O(N)，因为在最坏情况下，我们需要遍历所有元素。

[00:10:06]  
But the read cost is also big O(N) because we maintain the live collection. And when we maintain a live collection, this means the browser needs to verify that the element exists in the DOM Tree. So every time you're trying to access this live collection, the browser queries the elements again to verify that the element is still present.但读取成本也是O(N)级别的，因为我们要维护一个动态集合。而维护动态集合意味着浏览器需要验证该元素是否存在于DOM树中。所以，每次你尝试访问这个动态集合时，浏览器都会重新查询元素，以确认该元素是否仍然存在。

[00:10:30]  
That's why it can result to the Time Complexity, in the worst case, we'll need to parse all elements again.这就是为什么它会导致时间复杂度问题，在最坏的情况下，我们需要再次解析所有元素。  
Speaker 3: Is there a reason the querySelectorAll returns to non-live element lists compared to this one, for example, comparing or returning the live?发言者3：例如，与这个相比，为什么querySelectorAll返回的是非动态元素列表，而不是动态的呢？  
Evgenii Ray: So the live collection is actually legacy one, it's not recommended to use for normal cases.叶夫根尼·雷：所以实时收集实际上是遗留版本，不建议在常规情况下使用。

[00:10:59]  
And I guess the querySelector returns non-live collection because we needed to have some alternatives. The live collection has more drawbacks and if not used wisely, can lead to more issues. But in our application development, we don't really need to manage the live collections, and for most of the developers, the querySelectories the better go because it doesn't have the expensive read access.我猜querySelector返回的是非实时集合，因为我们需要一些替代方案。实时集合有更多缺点，而且如果使用不当，可能会引发更多问题。但在我们的应用开发中，我们其实不需要管理实时集合，对于大多数开发者来说，querySelector是更好的选择，因为它不存在高昂的读取开销。

[00:11:27]  
Speaker 2: Why would querySelectorAll impact memory while returning references to Nodes which already exist in the DOM?发言者2：querySelectorAll返回的是DOM中已存在节点的引用，为什么还会影响内存呢？  
Evgenii Ray: Not exactly, we actually return the copies. Basically, the browser creates a new object with the same values and the copies, and when you change the properties of these objects, it will impact the original object.叶夫根尼·雷：不完全是，我们实际上返回的是副本。基本上，浏览器会创建一个具有相同值和副本的新对象，当你更改这些对象的属性时，会影响到原始对象。

[00:11:56]  
But we have two separate objects basically, with the same properties and they're connected with each other for the proxy mechanism. So it's a slightly different, when we use the live collection, we actually guarantee we can actually reuse the real reference to the object instead.但基本上我们有两个独立的对象，它们具有相同的属性，并且通过代理机制相互连接。所以这有点不同，当我们使用实时集合时，实际上我们能确保可以转而重用对象的真实引用。  
Speaker 2: When you're saying that the cache would make things faster next time, are you always sure about that because class names can be dynamic?发言者2：你说缓存会让下次的速度更快，你对此总是确定的吗？因为类名可能是动态的。

[00:12:28]  
Evgenii Ray: So you can't control that because it's up to the browser engine. The same query methods can behave differently in Safari or Chrome depending on how developers optimize that. For instance, Safari browser uses the WebAssembly compilation for the native selectors, while the Chrome doesn't use that. Because they find that the performance of existing querySelectors is fine on average.叶夫根尼·雷：所以你无法控制这一点，因为这取决于浏览器引擎。相同的查询方法在Safari或Chrome中可能表现不同，这取决于开发者是如何优化的。例如，Safari浏览器对原生选择器使用WebAssembly编译，而Chrome则不这样做。因为他们认为现有的querySelectors的性能平均来说已经足够好了。

[00:12:56]  
So you can't guarantee the same results, and it's up to the engine. So the logic of caching the querySelector is quite complex, and yeah, no guarantee [LAUGH].所以你无法保证得到相同的结果，这取决于引擎。所以缓存querySelector的逻辑相当复杂，而且确实，无法保证（笑）。