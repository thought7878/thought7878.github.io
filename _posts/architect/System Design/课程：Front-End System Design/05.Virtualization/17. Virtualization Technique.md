


---

## “虚拟化技术”课程文字稿

Evgenii introduces virtualization, a UI optimization technique involving keeping data in memory while rendering only a limited subset to the screen. The virtualization code exercises are introduced. The beginning code project and steps required to implement the virtualization are explained.
叶夫根尼介绍了**虚拟化技术，这是一种用户界面优化技术，它会将数据保存在内存中，同时只向屏幕渲染有限的子集**。还介绍了虚拟化代码练习，并说明了初始代码项目以及实现虚拟化所需的步骤。


[00:00:00]  
Evgenii Ray: So let's move on to virtualization. So, the virtualization is UI optimization technique that involves maintaining the data in virtual memory while rendering only a limited subset of the data. And the purpose of this pattern is to minimize the number of elements in the DOM, and reduce the number of mutations, and reduce the CPU and the memory usage in general.叶夫根尼·雷：那我们来谈谈虚拟化。虚拟化是一种用户界面优化技术，它会将数据保存在虚拟内存中，同时只渲染数据的有限子集。这种模式的目的是最大限度地减少文档对象模型（DOM）中的元素数量，减少变更次数，并总体上降低CPU和内存的使用率。

[00:00:27]  
Because the larger the DOM tree we have on the page, the harder it is to maintain it for the browser and the more resources we utilize. So let's overview the concept first on the high-level. So when we set up the virtualization, usually it's organized in a way that you have the top observer and a bottom observer.因为页面上的DOM树越大，浏览器维护它就越困难，我们消耗的资源也越多。所以让我们先从宏观层面概述一下这个概念。在设置虚拟化时，通常的组织方式是有一个顶部观察器和一个底部观察器。

[00:00:50]  
So the top observer responsible for handling the case when you scroll up and the bottom observer when you scroll down, and also you have a viewport. When the viewport touches the bottom observer, then we trigger the callback that loads the next page of the data. So once the first page of the data is rendered, so this is item 1 and item 2, and as you can guess, the page size that we use here is 2.所以，顶部观察器负责处理向上滚动的情况，底部观察器负责处理向下滚动的情况，同时还有一个视口。当视口触碰到底部观察器时，我们就会触发加载下一页数据的回调函数。因此，当第一页数据渲染完成后，这里就是条目1和条目2，可想而知，我们这里使用的页面大小是2。

[00:01:21]  
Then we need to scroll down the viewport again to trigger it one more time, and then we render the item 3 and item 4. But the main difference with a lazy scrolling is because now when we touch the bottom observer again, we can't create more elements anymore. So this means that somehow we need to reuse already existing elements in the DOM to render the new content.然后我们需要再次向下滚动视口以再次触发它，接着渲染项目3和项目4。但与延迟滚动的主要区别在于，现在当我们再次触底观察器时，不能再创建更多元素了。这意味着我们需要以某种方式重用DOM中已有的元素来渲染新内容。

[00:01:56]  
So what do we do? We select items that we want to recycle. And this is the item 1 and item 2. And as you can see, our viewport in the area where we don't see the item 1 and item 2, so for the user, recycling these elements is not visible.那我们该怎么做呢？我们选择想要回收的物品。这是物品1和物品2。如你所见，在我们的视口区域，我们看不到物品1和物品2，所以对用户来说，回收这些元素是不可见的。

[00:02:15]  
So we need to pick the new space where we are going to move our elements, this will be right after the item 4 and item 3. And then we recycling element one by one. And once elements are moved to the desired location, now you can see that the top observers kind of see on the top, so we need to move this to make it before the item 3, while the bottom observer should be right after the item 2.所以我们需要选择将要移动元素的新位置，这个位置就在第4项和第3项之后。然后我们逐个回收元素。一旦元素被移动到目标位置，现在你可以看到顶部的观察器在顶部显示，所以我们需要移动它，让它位于第3项之前，而底部的观察器则应该在第2项之后。

[00:02:44]  
So once the recycle finished, we update the data, so now instead of showing item 1 and item 2, we show item 5 and item 6. And as a next step, we move our observers on the screen. This is the high-level overview. But to better understand the concept, let's actually code this.因此，一旦回收完成，我们就会更新数据，这样现在显示的就不是第1项和第2项，而是第5项和第6项。下一步，我们将屏幕上的观察者移动位置。这是一个大致的概述。但为了更好地理解这个概念，我们来实际编写代码演示一下。

[00:03:09]  
So make sure you check out the following branch, the virtualization-skeleton-start, and open the file name virtual-list. So, for most of the time, we're gonna use just this file. And let's overview the first two exercises that we are going to complete. So the first one we set up the skeleton.所以请确保你切换到下面这个分支，即virtualization-skeleton-start，并打开名为virtual-list的文件。大多数时候，我们只会用到这个文件。接下来，让我们概述一下我们将要完成的前两个练习。第一个练习是搭建框架。

[00:03:32]  
This means that we are going to render the basic template of our virtual list. That will be the top observer container, virtual list container, and the bottom observer. As a next step, we're going to set up the intersection observer to track the top observer element and the bottom observer element.这意味着我们将要渲染虚拟列表的基本模板。其中包括顶部观察器容器、虚拟列表容器和底部观察器。下一步，我们将设置交叉观察器来追踪顶部观察器元素和底部观察器元素。

[00:03:50]  
And we'll provide an empty callback that we're going to implement in the next sections. So let's get back to the code now. And here, if you want to follow along later, there are instructions here that you can use to implement it on your own, as well as the goal of the task.我们将提供一个空的回调函数，我们将在接下来的章节中实现它。现在让我们回到代码上来。如果你之后想跟着做，这里有一些指导说明，你可以用它们自己来实现，还有这个任务的目标。

[00:04:13]  
But meanwhile, we'll transition to the virtual-list.js file. So let's overview the basic structure. We already have some methods predefined. The first one is the margin that we're gonna use to space the cards. And also, we have some function that queries the top-observer and the bottom-observer element. And then we have the function that queries the virtual list container, and the main container that contains all our containers.但与此同时，我们将转到virtual-list.js文件。让我们来概述一下基本结构。我们已经预先定义了一些方法。第一个是我们将用来分隔卡片的边距。此外，我们还有一些函数用于查询顶部观察器和底部观察器元素。然后，我们有一个函数用于查询虚拟列表容器，以及包含我们所有容器的主容器。

[00:04:47]  
Then we have the y function that we're gonna utilize later. So what this function does, it takes the HTML element, and if we provide it any value, it just sets the attribute data-y to the element. And I'll explain why we need this in the next sections. And if we don't provide the value, it just tries to get this attribute from the element.然后我们有一个y函数，稍后会用到它。这个函数的作用是，它接收一个HTML元素，如果我们给它提供任何值，它就会给该元素设置data-y属性。我会在接下来的部分解释我们为什么需要这个。如果我们不提供值，它就会尝试从该元素获取这个属性。

[00:05:11]  
And if the value is provided, it returns the number. And if it's not, then we just return null. Next utility function is the translateY, which just returns the CSS transformation to move elements around. So this is just a handy function to return the CSS styling. Then we have the skeleton class for a virtual list.如果提供了该值，它会返回数字。如果没有提供，我们就只返回null。下一个实用函数是translateY，它仅返回用于移动元素的CSS变换。所以这只是一个用于返回CSS样式的便捷函数。然后我们有一个用于虚拟列表的骨架类。

[00:05:37]  
So, the constructor of VirtualList takes the root as a first parameter, which is the element where we want to render our virtual list. And then we have some set of properties that we are going to look at the next section. So then we have the toHTML file, which basically represents the kind of the render function, if we are speaking in React world.所以，VirtualList的构造函数将root作为第一个参数，root是我们要渲染虚拟列表的元素。然后我们有一些属性，下一部分我们会详细介绍。接下来是toHTML文件，它基本上类似于React中的渲染函数。

[00:06:03]  
So it returns the HTML template as a string that we're planning to use for our app. And there is also effect function that allows us to register any synchronous callbacks, for instance, intersection observer or something else. And the render function is very simple, it takes the root of the element and uses innerHTML and just renders the HTML that we provided as a string.因此，它将 HTML 模板作为字符串返回，我们计划将其用于我们的应用程序。此外，还有一个 effect 函数，允许我们注册任何同步回调，例如交叉观察器或其他东西。而 render 函数非常简单，它接收元素的根节点，使用 innerHTML，然后渲染我们作为字符串提供的 HTML。

[00:06:32]  
And then we register any asynchronous effects using this function. So you can ignore the rest for now.然后我们使用这个函数注册所有异步效果。所以现在你可以忽略剩下的部分。


