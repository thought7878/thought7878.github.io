


---

## “元素循环利用”课程文字稿


Evgenii recycles the elements in the virtualization exercise to avoid creating new elements. The new element positions are calculated based on the previous/next element values plus the margin offset. Absolute positioning is used for reordering the elements so the GPU is leveraged to ensure the best performance.
叶夫根尼在虚拟化操作中对元素进行复用，以避免创建新元素。新元素的位置是根据上一个/下一个元素的值加上边距偏移量计算得出的。为了重新排列元素，采用了绝对定位，这样可以利用GPU来确保最佳性能。



[00:00:00]  
>> Evgenii Ray: So we're going to loop through the whole pool starting from the first element. And the first element is item free because remember we swapped the places. Now the item free has the first position in the bowl, and we're also going to set up the previous pointer. The previous pointer will point to the previous element in the pool.>> 叶夫根尼·雷：所以我们要从第一个元素开始遍历整个池。第一个元素是空闲项，因为记住我们交换了位置。现在，空闲项在池的第一个位置，我们还要设置前向指针。前向指针将指向池中的前一个元素。

[00:00:21]  
And in case of the item 3, where the index is 0, we are going to use the last element of the array, treated as a circular q in this case. So when the minus 1 will give us the of the last element, okay? So how do we calculate the position of item 3, because the item 3 is the current one?而对于索引为0的第3项，在这种情况下，我们将使用数组的最后一个元素，此时数组被视为一个循环队列。所以，减1会得到最后一个元素的位置，对吧？那么，由于第3项是当前项，我们该如何计算它的位置呢？

[00:00:48]  
So we need to know the y attribute of the item 2, but we don't have any y attribute yet, we don't know the y position. So we are going to move all our cards to the separate staking context using the position absolute so every card will become absolutely positioned.所以我们需要知道项目2的y属性，但我们还没有任何y属性，也不知道y位置。因此，我们将使用绝对定位把所有卡片移到单独的堆叠环境中，这样每张卡片都会变成绝对定位。

[00:01:06]  
And now we're going to maintain their position on the screen by applying this CSS transformation. And to calculate the position of the of the card, we take the previous item, y position, then we sum the height of this item, then we sum the margin of this item, and then apply to item 3.现在我们将通过应用这种CSS变换来保持它们在屏幕上的位置。要计算卡片的位置，我们需要获取前一个元素的y坐标，然后加上这个元素的高度，再加上这个元素的外边距，最后应用到第三个元素上。

[00:01:36]  
But the thing is, when we just initialize our first cycle of virtualization, we don't have the data y set yet. So for this exact case, we initialize it to 0 on the first one, so our item 3 will be set as 0. So when we move to the next element and we move our pointers by 1, so now the current element is item 4, and the previous element is item 3.但问题是，当我们刚开始初始化第一个虚拟化周期时，还没有设置好数据y。所以在这种情况下，我们在第一个周期将其初始化为0，这样我们的第3项就会被设为0。然后当我们移到下一个元素并将指针移动1位时，现在当前元素是第4项，前一个元素是第3项。

[00:02:06]  
So what's going to happen now, we're going to access the y3 position, and remember, we set it to 0. So now we know how to calculate the next y, so we're going to use the y0, then we're going to access the height of the item 3 element, sum it, and plus the margin between these two elements.那么现在会发生什么呢，我们要访问y3位置，记住，我们把它设为0了。所以现在我们知道如何计算下一个y值了，我们会用y0，然后访问第3个元素的高度，把它们加起来，再加上这两个元素之间的边距。

[00:02:29]  
And then we're going to apply the CSS transformation to the element, so we move it to the right place. And the same applies to, as we cycle for the pool, we're gonna move our elements the same way until all elements are moved and the y position is initialized, okay?然后我们要对元素应用CSS变换，把它移到正确的位置。同样，当我们循环处理这个池时，我们要以同样的方式移动元素，直到所有元素都被移动，并且y坐标初始化完成，明白吗？

[00:02:50]  
Once the elements are moved, our next task will be to move the observer code here. So right now the top observer as you can see in not in the right position, so the observers should take the following positions that the top observer should be right before the item 3.元素移动完成后，我们的下一个任务是将观察器代码移到这里。现在，如你所见，顶部的观察器位置不正确，所以观察器应该放在以下位置：顶部观察器应位于项目3正前方。

[00:03:10]  
So we're gonna use the for the y of the first element in the pool which is the item 3. And the bottom observer will use the position of item 6 plus the height of item 6 plus the margin. So there moving down. So this is the most complex part of exercise.所以我们要使用池子里第一个元素的y值，也就是项目3的y值。底部的观察器会使用项目6的位置加上项目6的高度再加上边距。所以它们在向下移动。这是这个练习中最复杂的部分。

[00:03:29]  
So if you guys have any questions, please ask, and I'm going to be very slow as we proceed with the code. Let's get back to the code now.所以如果大家有任何问题，请尽管问，在我们处理代码的过程中，我会放慢速度。现在让我们回到代码上来。  
>> Evgenii Ray: So let's update our handle bottom observer code. Now we need to move our elements. So we're going to call another method called updateElementPosition.>> 叶夫根尼·雷：那么我们来更新一下句柄底部观察器的代码吧。现在我们需要移动我们的元素。所以我们要调用另一个名为updateElementPosition的方法。

[00:04:02]  
And it accepts the direction, which is the top or down, so we're gonna handle the down first.而且它接受方向参数，也就是向上或向下，所以我们先来处理向下的情况。  
>> Evgenii Ray: So when we're handling the element position, let's do exactly what we're described. So first of all, we need to get the references for the previous element and for the current element.>> 叶夫根尼·雷：所以在处理元素位置时，我们就按照之前描述的来做。首先，我们需要获取前一个元素和当前元素的引用。

[00:04:24]  
So we're going to look for the pool, starting from the index 0. Then we are going to,所以我们要从索引0开始寻找这个池。然后我们要，  
>> Evgenii Ray: Access our pool,>> 叶夫根尼·雷：访问我们的池，  
>> Evgenii Ray: Increase the index in each cycle. And now we want to access the previous element and the current. So for the previous element because we can't access position minus 1, we're gonna use the at function on the pool.>> 叶夫根尼·雷：在每个循环中增加索引。现在我们想要访问前一个元素和当前元素。对于前一个元素，由于我们无法访问位置减1的元素，我们将使用池上的at函数。

[00:04:59]  
So use pool at, and when the negative index is provided, then we kind of look backwards. So we can provide i -1, so we use -1 because we need two previous elements to the current cycle. So let's change it to let, okay. Now the current position is just basically indexing using the current index, okay?所以使用pool at，当提供负索引时，我们就会向后查找。所以我们可以提供i-1，之所以用-1，是因为我们需要当前周期的前两个元素。那我们把它改成let吧，好吗？现在，当前位置基本上就是用当前索引来进行索引，对吧？

[00:05:24]  
Now we have our previous and the current and remember the next step, now we need to check that the previous element has the y position set. So that now we need to utilize the y function that we already have in the code, so we check the y of the previous element, and it checks the data attribute that is set.现在我们有了之前的元素和当前的元素，并且记住了下一步，现在我们需要检查之前的元素是否设置了y坐标。所以现在我们需要使用代码中已有的y函数，这样我们就能检查之前元素的y值，并且它会检查所设置的数据属性。

[00:05:44]  
If it's not set, then we know that we need to initialize the current element with a 0. So now we set the 0 value to the to the first element. If it's not the case, now we can recalculate the position of the current element. So let's create a new variable called called newY.如果未设置，那么我们就知道需要将当前元素初始化为0。所以现在我们把0值赋给第一个元素。如果情况并非如此，现在我们可以重新计算当前元素的位置。那么我们来创建一个名为newY的新变量。

[00:06:08]  
And for that, we're gonna use the y position of the previous element plus the margin, we already have the constant for that. And we use a double margin because the margin comes from the previous element and from the current element. And then we're gonna use the previous element height, so we need to access the getBoundingClientRect, and we're gonna use the height property on that.为此，我们将使用前一个元素的y坐标加上边距，我们已经有了对应的常量。我们会使用双倍边距，因为边距来自前一个元素和当前元素。然后，我们要使用前一个元素的高度，所以需要调用getBoundingClientRect方法，并使用该方法返回的height属性。

[00:06:36]  
>> Evgenii Ray: Okay, now we have the newY position, we can set it to the element. So we're gonna use the y function and we're gonna set the current element with the newY position. But this is just a data at tribute, so nothing is moved yet. Now we need to move our element on the page, and we can do that by setting the transform style.>> 叶夫根尼·雷：好的，现在我们有了新的Y坐标位置，我们可以把它设置到元素上。所以我们要使用y函数，并用新的Y坐标位置来设置当前元素。但这只是一个数据属性，所以目前还没有任何东西被移动。现在我们需要在页面上移动我们的元素，我们可以通过设置变换样式来实现这一点。

[00:07:00]  
So we're gonna utilize the GPU now, to move the elements around because the CSS transformation utilized GPU. And we're gonna move our elements to the new separate stacking context. So we use the transform,所以我们现在要利用GPU来移动这些元素，因为CSS变换会用到GPU。而且我们要把元素移到新的独立堆叠上下文中。所以我们会使用transform属性，  
>> Evgenii Ray: And then we're gonna use our function that we already created and pass the newY, okay?>> 叶夫根尼·雷：然后我们要使用我们已经创建的函数，并传入newY，好吗？

[00:07:24]  
Now our element will be moved to the new position, but there is one thing missing still. We still need to move our observers. So let's do that now because this code will be same for the top and the bottom observer. Remember, we need to know the first element and the last element because the top observer will take the position right before the first element.现在我们的元素将被移动到新位置，但还有一件事没完成。我们仍然需要移动我们的观察器。所以现在就来做这件事吧，因为这段代码对于顶部和底部观察器来说是相同的。记住，我们需要知道第一个元素和最后一个元素，因为顶部观察器会位于第一个元素的正前方。

[00:07:51]  
And the last element will take the position right after the last element. So let's access the reference of the first element and the last, and we can just use the pool for that. So for the first element in the pool, we access the index 0. For the last element in the pool,而最后一个元素会占据最后一个元素正后方的位置。所以让我们获取第一个元素和最后一个元素的引用，我们可以直接使用这个池来实现。对于池中的第一个元素，我们访问索引0。对于池中的最后一个元素，  
>> Evgenii Ray: We can use at( -1).>> 叶夫根尼·雷：我们可以使用at(-1)。

[00:08:18]  
So let's calculate the position of the top observer. So the topY will be equals to the Y(first) element. This is pretty simple, but the position of bottom observer will be equals to the y of the last element. Plus margin and plus the height of the of the last element.那么让我们来计算顶部观察者的位置。顶部Y坐标将等于第一个元素的Y坐标。这很简单，但底部观察者的位置将等于最后一个元素的Y坐标，再加上边距和最后一个元素的高度。

[00:08:50]  
So now we need to move our observers. So we need to access the top and bottom observer and we can use what we already have this line here, the top observer and the bottom one. So let's apply the same transformation for the observer code, so we can copy this line, so now we have that we need to update the top transform attribute.所以现在我们需要移动我们的观察器。我们需要访问顶部和底部的观察器，并且可以使用我们已经有的这行代码，也就是顶部观察器和底部观察器。让我们对观察器代码应用同样的变换，所以我们可以复制这行代码，现在我们需要更新顶部的变换属性。

[00:09:10]  
Okay, so now we use the translateY and use the topY and for the bottom observer we apply the same transform and translateY(bottomY). Okay, now we can test our code, I think. So if we go to index html and then run our code, and you will see that it's actually doesn't work as we expected.好的，现在我们使用translateY并使用topY，对于底部观察器，我们应用相同的变换和translateY(bottomY)。我想现在我们可以测试我们的代码了。如果我们打开index.html然后运行代码，你会发现它实际上并没有像我们预期的那样工作。

[00:09:39]  
This is because the element at the moment are rendered in the normal flow, we haven't moved them to absolute position yet. So the Browser tries to render them as a normal flow, and then we also apply the transformation. So let's fix that by moving all our elements to the absolute position, so we can set the style, card, position, absolute.这是因为此刻元素是在正常流中渲染的，我们还没有将它们移动到绝对位置。所以浏览器会尝试以正常流的方式渲染它们，然后我们还会应用变换。所以让我们通过将所有元素移动到绝对位置来解决这个问题，这样我们就可以设置样式、卡片、位置、绝对定位了。

[00:10:10]  
And we can set the container, 我们可以设置容器，  
>> Evgenii Ray: To be position relative, to be the reference point for the card. And we can also set the width to 100% just to make sure that the the current takes 100%. So if we scroll down, now we see that everything seems to be rendered fine.>> 叶夫根尼·雷：要设置为相对定位，作为卡片的参考点。我们还可以将宽度设置为100%，以确保当前元素占满100%的宽度。这样，当我们向下滚动时，现在可以看到所有内容的渲染效果似乎都很好。

[00:10:33]  
Now we're moving all our top elements from top to bottom and if we scroll down, we see that everything is rendered, and we can verify that by going,现在我们正将所有顶部元素从上移到下，当我们向下滚动时，会看到所有内容都已渲染，我们可以通过查看来验证这一点。  
>> Evgenii Ray: To the developer tools and see the dorm tree. Now we have our elements inside and they positioned according to the data y attribute, and if we scroll down, you'll see that we're just changing the attributes.>> 叶夫根尼·雷：到开发者工具那里，看看这个dorm树。现在我们的元素都在里面，它们是根据data-y属性来定位的，如果你向下滚动，会发现我们只是在更改这些属性。

[00:11:02]  
The DOM is not modified at all. So we're basically, moving the pixels around. So that's how we implemented the bottom virtualization. But one thing is still not implemented is the top observer. So top observer is moved to the right position, which is the entry 40, but we still need to handle the callback here.DOM 完全没有被修改。所以基本上，我们只是在移动像素。这就是我们实现底部虚拟化的方式。但还有一件事尚未实现，那就是顶部观察器。顶部观察器已移至正确位置，即条目 40，但我们仍需要处理这里的回调。

[00:11:28]  
And this will be the next part of our exercise.这将是我们练习的下一部分。
