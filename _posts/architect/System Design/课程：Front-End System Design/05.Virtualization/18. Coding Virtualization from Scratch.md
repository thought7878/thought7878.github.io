


---

## 《从零开始编写虚拟化》课程文字稿

Evgenii implements the top and bottom observers for the virtualization container. These observers determine when to load and display additional cards. The handleIntersectionObserver method loops through all the entries and checks if any entry intersects either observer.
叶夫根尼**为虚拟化容器实现了顶部和底部观察器**。这些观察器用于确定何时加载和显示额外的卡片。handleIntersectionObserver方法会遍历所有条目，并检查是否有任何条目与任一观察器相交。



[00:00:00]  
Evgenii Ray: So let's proceed to our first exercise, which is creating this the following structure, where we have the container, top-observer element, bottom-observer element and the virtual-list. So let's proceed to our virtual-list file. And let's create this HTML template. So first we start with a container, then we should have a top-observer,叶夫根尼·雷：那么让我们开始第一个练习，也就是创建以下结构，其中包含容器、顶部观察器元素、底部观察器元素和虚拟列表。那么我们来看虚拟列表文件。我们来创建这个HTML模板。首先从容器开始，然后我们需要有一个顶部观察器，  
Evgenii Ray: Then we need to have the virtual-list.叶夫根尼·雷：然后我们需要有虚拟列表。

[00:00:36]  
Evgenii Ray: And then we want to have the bottom-observer.叶夫根尼·雷：然后我们想要一个底部观察器。  
Evgenii Ray: And let's convert it to HTML.叶夫根尼·雷：我们把它转换成HTML吧。  
Evgenii Ray: And type some utility text. So this will be the bottom-observer, oops, sorry. The next one will be, bottom-observer.叶夫根尼·雷：然后输入一些实用文本。所以这会是底部观察器，哦，抱歉。下一个会是，底部观察器。  
Evgenii Ray: So let's place it in the string now.叶夫根尼·雷：那我们现在就把它放到字符串里吧。  
Evgenii Ray: And trim it to remove any spaces.叶夫根尼·雷：然后修剪它以去除所有空格。

[00:01:15]  
So now we have our basic structure and we can check our index HTML, which already has the template that we used before in the previous exercises. And it also has the database that we already used before. And here we initialized our virtual-list with some properties right now, all there now.现在我们已经有了基本结构，可以查看索引HTML了，它已经包含了我们在之前的练习中使用过的模板。它还包含了我们之前已经使用过的数据库。现在我们在这里用一些属性初始化了虚拟列表，所有内容都在这里了。

[00:01:36]  
So if we run this HTML, we should see the basic structure, so top-observer and a bottom-observer, there are no elements rendered yet. So the next step would be to register the callback, so we need to have the observer that will track the intersection with the top-observer and the bottom-observer element.所以如果我们运行这段HTML，应该能看到基本结构，即top-observer和bottom-observer，目前还没有渲染任何元素。因此，下一步是注册回调函数，我们需要有一个观察器来追踪与top-observer和bottom-observer元素的交叉情况。

[00:01:58]  
So let's implement this one. We are going to transition to effect method and I'm going to use the utility function called intersectionObserver which will return. So basically, the wrapper around the observer constructor that we can use, so it doesn't have any special logic. It just observes the elements that we provided just to make the code cleaner.那我们来实现这个。我们将过渡到effect方法，我会使用一个名为intersectionObserver的工具函数，它会返回结果。所以基本上，这是对观察者构造函数的包装，我们可以使用它，它没有任何特殊逻辑。它只是观察我们提供的元素，让代码更简洁。

[00:02:27]  
So first, we need to provide, as the first parameter provides the targets that we want to track, and we already have the method code getObservers that will return the top-observer and the bottom-observer element. Then we need to provide a callback. So the callback accepts entries. And we already have the placeholder function just an empty one.首先，我们需要提供第一个参数，该参数指定我们想要跟踪的目标，而且我们已经有了getObservers方法代码，它会返回顶部观察器和底部观察器元素。然后我们需要提供一个回调函数。这个回调函数接收条目。我们已经有了一个占位符函数，只是一个空函数。

[00:02:52]  
So there is no logic in there, which is called handleintersectionObserver and we pass the entries inside. And now we can also provide the configuration for our observer. So let's call the threshold. So let's set up the threshold of 20%,所以这里面没有逻辑，这叫做handleintersectionObserver，我们把条目传进去。现在我们还可以为我们的观察器提供配置。我们来调用阈值吧。我们把阈值设置为20%。  
Evgenii Ray: Okay? So we can now test our file so we can open, or actually, let's first, validate that our code get fired.叶夫根尼·雷：好的？所以我们现在可以测试我们的文件了，这样我们就能打开它，或者说，实际上，我们先验证一下我们的代码是否能运行。

[00:03:30]  
So what we can do here is, 那么我们在这里可以做的是，  
Evgenii Ray: So let's do the basic handlings of entries. So first, we need to loop for the entries that we have.叶夫根尼·雷：那么我们来处理条目的基本操作吧。首先，我们需要遍历现有的条目。  
Evgenii Ray: Then there are two, basically two cases, either we have the top-observer or the bottom-observer. So but first, let's check that the entry is intersecting.叶夫根尼·雷：基本上有两种情况，要么是顶部观察者，要么是底部观察者。不过首先，我们来确认一下这个入口是否交叉。

[00:04:03]  
Evgenii Ray: And then we validate that entry.target.id should be equal to either the top-observer.叶夫根尼·雷：然后我们验证 entry.target.id 应该等于 top-observer。  
Evgenii Ray: In this case, we need to call the handleTopObserver method. The skeleton of this method already predefined in the template, but it doesn't have any code inside. And then we also have the,叶夫根尼·雷：在这种情况下，我们需要调用handleTopObserver方法。这个方法的框架已经在模板中预先定义好了，但里面没有任何代码。然后我们还有……  
Evgenii Ray: Bottom-observer, if the target ids the bottom-observer.叶夫根尼·雷：底部观察器，如果目标标识了底部观察器。

[00:04:38]  
So this both of functionally synchronize but let's specify that they don't return anything. And if we want to validate that the code works, let's just put some simple alert and say, the code works. So okay, now we can open our index.html, run it and see that, yeah, it works.所以这两者在功能上是同步的，但我们要明确它们不会返回任何内容。如果我们想验证代码是否能运行，只需添加一些简单的提示框，显示“代码可以运行”。好了，现在我们可以打开index.html，运行它，然后就能看到代码确实可以运行了。

[00:05:02]  
Okay, this where our first two exercises within one bigger exercise. And now the next part will be to render some cards when we intersect with the bottom-observer. Do we have any questions for these two parts?好的，这就是我们在一个更大的练习中包含的前两个练习。现在，下一部分是当我们与底部观察器相交时，渲染一些卡片。关于这两个部分，大家有什么问题吗？  
Speaker 2: In the y function, where we get the data-y attribute, is there any advantage to using get set attribute versus the data list API?发言者2：在y函数中，我们获取data-y属性时，使用get set属性相比数据列表API有什么优势吗？

[00:05:27]  
Or is it mostly just a matter of preference?或者这主要只是偏好问题？  
Evgenii Ray: It's a matter of preference, there is no clear advantage. So here you can either use the data list, but because I know exactly the name of the attribute, we can just use the get attribute. Maybe if you work with the multiple attributes then it might be useful to have data list.叶夫根尼·雷：这是个人偏好问题，没有明显的优势。所以在这里你可以使用数据列表，但因为我确切知道属性的名称，我们可以直接使用获取属性。如果你要处理多个属性，那么使用数据列表可能会有用。


