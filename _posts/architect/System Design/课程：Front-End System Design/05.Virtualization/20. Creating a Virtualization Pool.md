


---

## “创建虚拟化池”课程的文字记录

Evgenii implements a virtualization pool that manages how elements are stored in memory. This allows elements to be reused rather than generating a new element for every card in the data.
叶夫根尼实现了一个虚拟化池，该池用于管理元素在内存中的存储方式。这使得元素可以被重复使用，而不必为数据中的每个卡片都生成一个新元素。



[00:00:00]  
>> Evgenii Ray: Okay, so we completed the part 3, so now we have our start and end pointer and we also rendered the data, but the next part will be slightly more complex. So now we're going to initialize the pool of elements in the memory that we will maintain. So once we render item 1, 2, 3, and 4, we'll place them in the virtual memory array that we maintain.>> 叶夫根尼·雷：好的，我们已经完成了第三部分，现在我们有了起始指针和结束指针，也渲染了数据，但接下来的部分会稍微复杂一些。现在我们要初始化将在内存中维护的元素池。所以，一旦我们渲染了项目1、2、3和4，就会把它们放入我们维护的虚拟内存数组中。

[00:00:26]  
And when the user scrolls the viewport, when we scrolled down and triggered the bottom of the observer again, what we're gonna do first, we're going to slice array in half and swap the places. So, the item one and item 2 will become the last elements, while item 3 and 4 will become the first 1.当用户滚动视口时，当我们向下滚动并再次触发观察器底部时，我们首先要做的是将数组切成两半并交换位置。这样，第一项和第二项将成为最后一个元素，而第三项和第四项将成为前两项。

[00:00:49]  
Visually, there will be no changes yet because we don't utilize any, we don't move any elements yet. But as the first step, we need to update the how elements are stored in the memory. So we also update the start and end pointer, because now the start will start will start from the page two and the end will finish on the page three.从视觉上看，目前还不会有任何变化，因为我们尚未使用任何元素，也没有移动任何元素。但作为第一步，我们需要更新元素在内存中的存储方式。因此，我们也要更新起始指针和结束指针，因为现在起始位置将从第二页开始，结束位置将在第三页结束。

[00:01:12]  
So let's now let's jump to the next section of the code, okay, so we're back to the bottom observer. And as we mentioned before, now we can't just render elements as we scroll down, so we need to have some kind of a limit. And we can define this limit as a double of the page size, so we can create a new variable called this limit.那么现在我们来看代码的下一部分，好吗？我们回到底部观察器。正如我们之前提到的，现在我们不能只是在向下滚动时渲染元素，所以我们需要设置某种限制。我们可以将这个限制定义为页面大小的两倍，这样我们就可以创建一个名为“this limit”的新变量。

[00:01:42]  
>> Evgenii Ray: And it will be equal to the double of the page size, so we always maintain two pages in memory. And we also need to create a virtual memory array where we store our HTML elements that are created, because we need to have some reference to them. So if we scroll down now to the bottom observer, so here we can create more elements if the limit is reached.>> 叶夫根尼·雷：它将等于页面大小的两倍，所以我们始终在内存中保留两个页面。我们还需要创建一个虚拟内存数组，用于存储我们创建的HTML元素，因为我们需要有一些对它们的引用。所以如果我们现在向下滚动到底部观察器，那么当达到限制时，我们可以在这里创建更多元素。

[00:02:13]  
So what we need to do we need to check if this pool length is less than the limit that we set.所以我们需要做的是，检查这个池的长度是否小于我们设置的限制。  
>> Evgenii Ray: So we need to move this code under this condition and now we only append elements if the limit is reached and also we need to populate our pool with a new card element.>> 叶夫根尼·雷：所以我们需要在这个条件下移动这段代码，现在只有当达到限制时我们才添加元素，而且我们还需要用一个新的卡片元素来填充我们的池。

[00:02:41]  
>> Evgenii Ray: So now when the limit is reached we will not render any more elements and we can verify that by running the index.html again, so let's see if it works. So now we should render at max 20 elements, so there will be no new events page, so we reached the limit.>> 叶夫根尼·雷：所以现在当达到限制时，我们将不再渲染任何元素，我们可以通过再次运行index.html来验证这一点，让我们看看它是否有效。现在我们最多应该渲染20个元素，所以不会有新的事件页面，因为我们已经达到了限制。

[00:03:01]  
So the next part would be to exchange the data and swap the halves. How we do that is let's create a new function that will be responsible for that and let's call it, so it'll be called this update element.所以下一步是交换数据并交换两半。我们的做法是创建一个新的函数来负责这项工作，我们称之为“更新元素”。  
>> Evgenii Ray: So actually. >> 叶夫根尼·雷：所以实际上。  
>> Evgenii Ray: So we can do it right here, so if the limit is not reached, so we need to now cut our pool into the two halves and basically swap the places of these two halves.>> 叶夫根尼·雷：所以我们可以直接在这里操作，如果还没达到限制，那我们现在需要把我们的池子分成两半，基本上就是把这两半的位置互换一下。

[00:03:49]  
So let's cut our array using the slice function, so the first part of our array will be called recycle, because when used to recycle elements from the top, which is exactly the first half of the array. And then the next one will be called unchanged because we we're not playing to recycle them.那么让我们用切片函数来分割数组，数组的第一部分将被称为“recycle”，因为它用于从顶部回收元素，这正是数组的前半部分。接下来的部分将被称为“unchanged”，因为我们不打算对它们进行回收。

[00:04:11]  
Okay, so now I'm going to slice the pool into two halves, so I'm going to use the slice function and the first half and from its from zero to the page size and the last half starts from-好的，现在我要把这个池切成两半，所以我会使用切片函数，前半部分从0到页面大小，而后半部分从——  
>> Evgenii Ray: The props page size, so if you don't provide a second argument, then we just slice from the page size and to the end.>> 叶夫根尼·雷：关于道具页面大小，如果你不提供第二个参数，那么我们就从页面大小的位置开始切片，一直切到末尾。

[00:04:49]  
Okay, now we have our two parts, let's reinitialize the pool and swap the places like we saw on the slides. So we create, we update our pool and we do unchanged and then we concatenate the tree cycle array. So now in memory we actually switch the places, but it will not reflect on the UI, because right now it's just a memory operation.好的，现在我们有了这两个部分，让我们重新初始化池，并像我们在幻灯片上看到的那样交换位置。所以我们创建、更新我们的池，保持不变，然后拼接树循环数组。所以现在在内存中我们实际上交换了位置，但这不会反映在用户界面上，因为现在这只是一个内存操作。

[00:05:22]  
So now we need to update the data, so because we fetched some data here, so we can actually update the data of the elements. So the elements will not be moved yet, but we can still update the text content of these elements. So what we're gonna do is we're gonna call the update data that accepts the elements that we want to recycle and it also accepts the data that we just fetched.所以现在我们需要更新数据，因为我们在这里获取了一些数据，所以实际上我们可以更新元素的数据。这些元素暂时不会被移动，但我们仍然可以更新这些元素的文本内容。所以我们要做的是调用更新数据的函数，这个函数接收我们想要回收的元素，还接收我们刚刚获取的数据。

[00:05:52]  
And let's implement this one, so we need to loop for the data that we receive.那我们来实现这个，所以我们需要遍历接收到的数据。  
>> Evgenii Ray: And actually let's use the index cycle instead.>> 叶夫根尼·雷：实际上，我们还是用索引循环吧。  
>> Evgenii Ray: So we're gonna loop through the data>> 叶夫根尼·雷：所以我们要遍历这些数据  
>> Evgenii Ray: And now we are going to use our function that we provided, the update element, the update template.>> 叶夫根尼·雷：现在我们要使用我们提供的函数，即更新元素、更新模板。

[00:06:33]  
So the update template function accepts the new piece of data that we just fetched, and we can access it by using index. And then we need to provide an element that we want to update and we know this element because we're providing the elements array that we want to recycle.因此，更新模板函数接收我们刚刚获取的新数据块，我们可以通过索引来访问它。然后，我们需要提供一个想要更新的元素，而我们之所以知道这个元素，是因为我们提供了想要重新利用的元素数组。

[00:06:52]  
And we pass the element. Using the index, okay, now we are updating the data of our elements. And if we go back now to.然后我们传递这个元素。使用索引，好的，现在我们正在更新我们元素的数据。如果我们现在回到。  
>> Evgenii Ray: To the bottom observer, if we scroll down, so we reach the bottom, but then when you click the bottom observer again, you see we just updated the data of our cards.>> 叶夫根尼·雷：对于底部观察器，如果你向下滚动，我们会到达底部，但当你再次点击底部观察器时，你会发现我们刚刚更新了卡片的数据。

[00:07:25]  
And we can just continue this process and the data will be updated, but nothing is moved yet because we haven't applied any transformation. So we basically did exactly the separation, so we swapped the places with the array and also updated the day of these items. The next part will be to recalculate the real position of the elements and how we are going to do that.我们可以继续这个过程，数据会得到更新，但目前还没有任何内容被移动，因为我们尚未应用任何转换。所以从根本上来说，我们确实完成了分离操作，交换了数组的位置，并且更新了这些项目的日期。接下来的部分将是重新计算元素的实际位置，以及我们要如何进行这一操作。

