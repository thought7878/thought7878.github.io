


---

## “处理顶部虚拟化”课程文字稿

Evgenii concludes the virtualization exercise by handling intersections with the top observer. As the container is scrolled up, the elements are recycled to the top of the list. The scroll height calculation is used to maintain the same scroll position on the page.
叶夫根尼通过处理与顶部观察器的交叉点完成了虚拟化练习。当容器向上滚动时，元素会被回收至列表顶部。滚动高度计算用于维持页面上相同的滚动位置。

[00:00:00]  
>> Evgenii: Okay, let's continue our virtualization journey. So we basically built the following thing we rendered the. So we implemented the bottom virtualization now elements getting recycled from top. But the next step is to implement the top fertilization and in our case now the item 5 and 6 should go on top before the item 3 and 4.>> 叶夫根尼：好的，让我们继续我们的虚拟化之旅。我们基本上构建了这样一个东西——我们渲染了……我们现在实现了底部虚拟化，元素从顶部被回收利用。但下一步是实现顶部虚拟化，在我们这个案例中，现在第5项和第6项应该放在第3项和第4项之前的顶部。

[00:00:27]  
So what do we need to do here? So, we are basically going the backward direction now we need to exchange our arrays, the to house of the array, the item 5 and item 6 will go on top, while the item 3 and 4 will go on the bottom.那么我们现在需要做什么呢？我们现在基本上要往反方向操作，需要交换数组，数组中的元素5和元素6要放到上面，而元素3和元素4要放到下面。

[00:00:47]  
So it's basically the reverse of what we did for the bottom virtualization.所以这基本上与我们在底部虚拟化时所做的相反。  
>> Evgenii: And let's finish this part and then we'll continue to change in the position. Let's go back to the code now. So we are back to the code and let's handle the top observer position now.>> 叶夫根尼：我们先完成这部分，然后再继续调整位置。现在我们回到代码。好了，我们回到代码了，现在来处理顶部观察者的位置。

[00:01:16]  
>> Evgenii: So when we handle the top observer. We again needs to fetch the data>> 叶夫根尼：所以当我们处理顶部观察器时。我们再次需要获取数据  
>> Evgenii: But instead of using the nth pointer, we now need to use the start pointer. And when we fetch in the backward direction this means that we need to reduce the point value of the start.>> 叶夫根尼：但我们现在需要使用起始指针，而不是第n个指针。当我们沿反向获取数据时，这意味着我们需要减小起始指针的值。

[00:01:44]  
Since we're now rendering the start minus one page, and we also need to reduce the end pointer, so we're fetching our data now. We don't need to replicate this part, but we are going to slice our array again into the two halves. So we're going to copy over this code and now we exchange two halves, but the true recycle part will become unchanged because the first half on the array should be unchanged.既然我们现在要渲染起始页减一的页面，而且还需要减小结束指针，所以我们现在要获取数据。我们不需要重复这部分内容，但我们要再次将数组切分成两半。所以我们要复制这段代码，现在交换这两半，但真正需要循环利用的部分将保持不变，因为数组的前半部分应该是不变的。

[00:02:20]  
And the second part of the array should be marked as a to recycle. Then we are going to reinitialize our pool.数组的第二部分应标记为待回收。然后我们将重新初始化我们的池。  
>> Evgenii: And now the data that is unchanged, goes on top, while the data that needs to be recycled goes on to the bottom. Okay, now the pool is re-initialized.>> 叶夫根尼：现在，未更改的数据放在上面，而需要回收的数据放在下面。好了，现在这个池已经重新初始化了。

[00:02:48]  
We need to call the same method we've already implemented, which is the update data. And we pass our toRecycle array and the data that we want to. Well, I want to update. Wait a second. Yeah, maybe I made a mistake one second. So we need to actually do the toRecycle concut, and change, right?我们需要调用我们已经实现的同一个方法，也就是更新数据的方法。然后我们传入我们的toRecycle数组以及我们想要的数据。嗯，我想要更新。等一下。是的，也许我刚才犯了个错误。所以实际上我们需要对toRecycle进行拼接，然后修改，对吧？

[00:03:11]  
Thanks a lot. Good eye. Okay, so we're calling the update data function to again, update the data, the text data that we are receiving. And now we need to handle the case where we move elements from top, so we provide the top case. And here let's implement this branch now.非常感谢。眼光不错。好的，所以我们要再次调用更新数据函数，来更新我们收到的文本数据。现在我们需要处理从顶部移动元素的情况，所以我们提供了顶部的情况。现在让我们来实现这个分支。

[00:03:41]  
So, as we discussed in the slides, we need to now look backwards. So, we're going to loop starting from the page size, because we need to loop from the end of the page size. So, we're gonna use props.page size, -1. Then because we are loop looping backwards, we need to make sure that we are looping until we reach the zero index.那么，正如我们在幻灯片中讨论的，我们现在需要向后看。所以，我们要从页面大小开始循环，因为我们需要从页面大小的末尾开始循环。所以，我们会用props.page size减1。然后，因为我们是向后循环，我们需要确保循环一直进行到达到零索引为止。

[00:04:15]  
And then we do i++. 然后我们执行i++。  
>> Evgenii: So let's now understand how this will work. We'll see now that we're creating a new pointers. So the current pointer will start at the item 6 which will be the end of the first half of the data. So we are looping from the half of the array, but in the backwards direction while the next pointer will point us to the next rendered element.>> 叶夫根尼：现在让我们来了解这将如何运作。我们现在会看到，我们正在创建新的指针。当前指针将从项目6开始，这将是数据前半部分的末尾。所以我们从数组的一半开始循环，但方向是向后的，而下一个指针将指向我们下一个要渲染的元素。

[00:04:56]  
So if we check the item 6, so we should render this right before the item 3. So it means the item 3 is the next rendered elements. That's why we're accessing it for the next property and how do we determine the position of the item 6? So we're going to use the y position of item 3, then we need to subtract the margin, and we also need to subtract the height of the item 6, and then we'll get the final y position that we're setting.那么如果我们查看第6项，就应该在第3项之前渲染它。这意味着第3项是接下来要渲染的元素。这就是为什么我们要访问它的next属性，以及我们如何确定第6项的位置呢？我们将使用第3项的y坐标，然后需要减去边距，还要减去第6项的高度，这样就能得到我们要设置的最终y坐标了。

[00:05:37]  
And then since we're looping backwards, the current pointer will become item 5, and we're doing the same thing for item 6. We're accessing the y position of item 6, then subtracting the item 5 height minus the margin, and we have the generic formula here. And once the element moved, we basically do the same thing.然后，由于我们是反向循环，当前指针会指向第5项，我们对第6项做同样的操作。我们获取第6项的y坐标，然后减去第5项的高度再减去边距，这里我们有一个通用公式。一旦元素移动了，我们基本上就会重复同样的操作。

[00:06:06]  
The observer code will be the same, we just move the observer now to the top. So this part will not be changed. So let's get back to the code and update that. So we are five lines away.观察者代码是一样的，我们现在只是把观察者移到顶部。所以这部分不会改变。让我们回到代码并进行更新。我们还差五行。  
>> Evgenii: So now we need to access the current element and the next one.>> 叶夫根尼：所以现在我们需要获取当前元素和下一个元素。

[00:06:33]  
>> Evgenii: So for the current is just this pool and we're gonna use the index to access that. For the next one, we're gonna use this pool, i + 1.>> 叶夫根尼：所以当前的就是这个池，我们要使用索引来访问它。下一个，我们要用这个池，i + 1。  
>> Evgenii: Okay, and now we need to calculate the new y position for that. So the new y will be equal to the next.>> 叶夫根尼：好的，现在我们需要计算它的新y坐标。所以新的y值将等于下一个值。

[00:07:01]  
So we need to access the next wide position- the MARGIN x 2- the current height.所以我们需要获取下一个宽位置——MARGIN乘以2再减去当前高度。  
>> Evgenii: Okay, so now we have the new y and we're basically using the same code now. We are setting the current element to new y, and we use the current style transform to set the current y position.>> 叶夫根尼：好的，现在我们有了新的y值，而且我们基本上在使用相同的代码。我们将当前元素设置为新的y值，并使用当前样式的transform来设置当前的y位置。

[00:07:41]  
So the chord doesn't really differ from the from previous part, okay. Now the last thing that we need to handle is our top intersection observer should not be triggered when the page is zero, because if the page is zero, then nothing to be virtualized from to the to the top.所以这个和弦和之前的部分其实没有什么不同，对吧。现在我们需要处理的最后一件事是，当页面为零时，顶部交叉观察器不应该被触发，因为如果页面为零，那么就没有东西需要从顶部进行虚拟化处理。

[00:08:01]  
So, we need to introduce the condition here that validates that this start is more than zero. So, we don't trigger our observer. Okay, now we can run the code. So, let's get back to index.html and let's render the items. If we go now to the top, we should be able to see that elements will be moving to the top.所以，我们需要在这里引入一个条件，来验证这个起点是否大于零。这样，我们就不会触发我们的观察器了。好的，现在我们可以运行这段代码了。那么，让我们回到index.html，来渲染这些项目。如果我们现在滚动到顶部，应该就能看到元素会移动到顶部。

[00:08:36]  
>> Evgenii: Nope [LAUGH] this didn't work out, let's see.>> 叶夫根尼：不行[笑]，这没成功，让我们看看。  
>> Speaker 1: I think in the loop, since we are moving backwards through the list, let's see. Line two of seven, do you need to decrement i instead of.>> 发言者1：我认为在循环中，由于我们在反向遍历列表，让我们看看。七行中的第二行，你是否需要递减i而不是（递增）。  
>> Evgenii: That's true, good eye, [LAUGH]>> 叶夫根尼：没错，观察得真仔细，[笑]  
>> Evgenii: That's what I did one more time.>> 叶夫根尼：我又那么做了一次。

[00:09:07]  
>> Evgenii: And it still doesn't work, maybe we need to refresh the page, but let's see the container state. Okay, I feel like the top observer actually works, but it works in a slightly different way. Let's go to debugger point one more time>> 叶夫根尼：还是不行，或许我们需要刷新页面，但先看看容器状态。好的，我觉得顶部观察器其实是起作用的，只是方式略有不同。我们再去调试点看看  
>> Evgenii: Okay, and let's render things.>> 叶夫根尼：好的，我们来渲染内容吧。

[00:09:40]  
>> Evgenii: Okay, now we're going to the loop to see if the target ID is right.好的，现在我们要进入循环，看看目标ID是否正确。  
>> Evgenii: The target is top observer, so we go inside.>> 叶夫根尼：目标是顶级观察者，所以我们要进去。  
>> Evgenii: I see, okay. >> 叶夫根尼：我明白了，好的。  
>> Evgenii: The start pointer is zero, so we are not updating the start pointer.>> 叶夫根尼：起始指针为零，所以我们不更新起始指针。  
>> Evgenii: Okay, so first let's update the loop that cycle to validate that entry.target.id = bottom.observer.>> 叶夫根尼：好的，那我们先来更新循环，验证entry.target.id是否等于bottom.observer。

[00:10:16]  
To make sure that we don't fire the callback when the id is top observer. Now we need to validate that the start position is updating. Basically, when we do the bottom observer, we need to make sure that we update the start position here. So here, we need to increase the start by one.为确保在id为顶部观察器时不会触发回调，现在我们需要验证起始位置是否在更新。基本上，当我们处理底部观察器时，需要确保在此处更新起始位置。所以在这里，我们需要将起始值加1。

[00:10:35]  
And if we go back now, probably this should work.现在如果我们返回去，这可能应该能行。  
>> Evgenii: Okay. >> 叶夫根尼：好的。  
>> Evgenii: And let's go back to the top. Yay, it works. Okay, now we implemented the bottom virtualization, but there is one less thing. So when we scroll down, you see that our scroll bar is increasing, but when we scroll to the top, it's actually decreasing.>> 叶夫根尼：那我们回到顶部吧。太好了，成功了。好的，现在我们实现了底部虚拟化，但还少了一件事。你看，当我们向下滚动时，滚动条在变长，但当我们滚动到顶部时，它实际上在变短。

[00:11:10]  
So we need to handle the last case where we keep our scroll bar somehow. And it's just one line code change. When we do the bottom observer, let's access the container,所以我们需要处理最后一种情况，也就是以某种方式保留滚动条。这只需要修改一行代码。当我们进行底部观察时，让我们访问容器。  
>> Evgenii: getContainer and when we scroll down, let's set the style, the height of the container for the CSS to be equal to a scroll height.>> 叶夫根尼：获取容器，当我们向下滚动时，让我们设置样式，使CSS中容器的高度等于滚动高度。

[00:11:44]  
So we use the scroll height property that will give us the size of the scroll bar and we're gonna use pixels, that's it. So now every time we scroll down we should see that our container now has the height set. So when we scroll to the top we'll maintain our score bar.所以我们使用scroll height属性，它会给我们滚动条的大小，而且我们要用像素，就这样。所以现在每次我们向下滚动时，应该会看到我们的容器已经设置好了高度。当我们滚动到顶部时，我们会保持我们的滚动条。

[00:12:11]  
We implemented the virtualization from scratch.我们从零开始实现了虚拟化。  
>> Evgenii: And this is me not,>> 叶夫根尼：而我不是这样，  
>> Speaker 1: [LAUGH] >> 发言者1：[笑]  
>> Evgenii: [LAUGHl ] trying not to make a mistake in a coat [LAUGH].>> 叶夫根尼：[笑] 试着不在外套的事上出错[笑]。



