

---

## “虚拟化池问答”课程文字实录

Evgenii answers questions about virtualization, including the types of applications where virtualization is beneficial and the differences between virtualization and other lazy loading techniques.
叶夫根尼回答了有关虚拟化的问题，包括虚拟化在哪些类型的应用中有益，以及虚拟化与其他延迟加载技术之间的区别。



[00:00:00]  
>> Speaker 1: Could you just show the y function again?>> 发言者1：你能再展示一下y函数吗？  
>> Erik: Yep, so the y function accepts the element and the value. If the value is provided, then it tries to set this value as attribute. If is not provided, then we just get the attribute. And if the attribute exists, then we return the number.>> 埃里克：是的，所以y函数接收元素和值。如果提供了值，它就会尝试将该值设置为属性。如果没有提供值，我们就只获取属性。如果该属性存在，就返回数字。

[00:00:22]  
Here we do the cast because attribute is a string value. So we need to make sure that the y is the number. And then if it's not provided, then we return nope.我们在这里进行类型转换，因为属性是一个字符串值。所以我们需要确保y是数字。如果没有提供y，那么我们就返回“nope”。  
>> Speaker 2: Do you have a general rule of thumb when to reach for virtualization?>> 发言者2：在什么时候使用虚拟化，你有一个大致的经验法则吗？  
>> Erik: Yeah, I think the good rule of thumb is, when you work with the mobile apps where you need to make sure that you don't overuse the memory and you're expected to load many things, then the virtualization is a good way to go.>> 埃里克：是的，我认为一个不错的经验法则是，当你开发移动应用时，需要确保不过度使用内存，而且要加载很多内容，那么虚拟化就是一个很好的选择。

[00:00:53]  
For instance, mobile app of the social network, or when you're rendering the table with thousands of elements, then where it's the best place to invoke that. But for desktop apps, I think we need to adjust the limit of the elements because desktops have a good memory amount. And instead of rendering only 10 elements and then do the virtualization, we can actually allow having 200 elements before we recycle.例如，社交网络的移动应用，或者当你在渲染包含数千个元素的表格时，那么调用它的最佳位置在哪里。但对于桌面应用，我认为我们需要调整元素的限制，因为桌面电脑有足够的内存。我们不必只渲染10个元素然后进行虚拟化处理，实际上可以允许在回收前有200个元素。

[00:01:23]  
Or we can even disable the virtualization because for desktops, virtualization is not that relevant because now the desktop have a very good performance and CPU. So we don't really need to overcomplicate the design of our app. But for the mobile devices, that's the best way to go.或者我们甚至可以禁用虚拟化，因为对于台式机来说，虚拟化并不是那么重要，毕竟现在的台式机有着非常出色的性能和处理器。所以我们其实没必要把应用程序的设计搞得过于复杂。但对于移动设备而言，这是最佳的方案。  
>> Speaker 2: Someone said, most likely if you need to fetch the data in chunks.>> 发言者2：有人说，很可能是在你需要分块获取数据的情况下。

[00:01:52]  
>> Erik: So even if you need to fetch the data in chunks, you still can implement the lazy loading where you just update existing DOM tree without recycling the elements. Right now, the difference with virtualization, we always maintain a constant number of nodes. So we say limit is 20, so we can't exceed this amount.>> 埃里克：所以即使你需要分块获取数据，你仍然可以实现懒加载，只需更新现有的DOM树，而无需重新利用元素。目前，它与虚拟化的区别在于，我们始终保持固定数量的节点。比如说限制是20个，那么我们就不能超过这个数量。

[00:02:10]  
But when you do the lazy list, when you load the data in chunks, then you can just append new elements on the screen without thinking about how do I need to recycle the previous rendered elements.但是当你使用惰性列表，按块加载数据时，你就可以直接在屏幕上追加新元素，而无需考虑如何回收之前渲染的元素。  
>> Speaker 2: Yeah, it's generally, I've only seen it really affect desktop if there's thousands of elements or more, because it did work on a backlog management utility app, I think it was like five years ago or something like.>> 发言者2：是的，总的来说，我只见过它在有数千个或更多元素的情况下才会真正影响桌面端，因为大约五年前左右，我在一个待办事项管理实用程序应用上用过它，当时就是这种情况。

[00:02:40]  
I can't remember exactly how long ago it was, but I ran into performance issues with 1,000 elements, and it just was scrolling the list. Once it starts to feel sticky, that's a point you should consider-我不太记得具体是多久以前了，但我在处理1000个元素时遇到了性能问题，当时只是在滚动列表。一旦开始感觉卡顿，那就是你应该考虑（优化）的时候了——  
>> Erik: Yeah. >> 埃里克：是的。  
>> Speaker 2: A tool like this, if it's just not scrolling, it's smooth.>> 发言者2：像这样的工具，如果只是不滚动的话，是很流畅的。

[00:02:59]  
>> Erik: I also agree. I think the virtualization is used in some places where they actually don't need it. If you have 95% of your clients on desktop, why would you overcomplicate the design of your app? You can just render things in a DOM tree, yeah.>> 埃里克：我也同意。我认为虚拟化技术被用在了一些实际上并不需要它的地方。如果你的95%的客户都使用桌面端，那为什么要把应用程序的设计弄得过于复杂呢？你只需要在DOM树中渲染内容就行了，没错。  
>> Speaker 3: So when we set the position to absolute, and then we adjust the positioning, does that trigger a reflow?>> 发言者3：那么当我们将位置设置为绝对定位，然后调整定位时，这会触发回流吗？

[00:03:30]  
>> Erik: So when we set the position to absolute and we adjust the position, we trigger the reflow, but remember the pipeline. So there is a optimized pipeline where we trigger just the painting. Whether you move elements around, we say transform, you don't trigger the full pipeline, you just trigger the GPU pipeline, and it doesn't impact the rendering thread.>> 埃里克：所以当我们将位置设置为绝对定位并调整位置时，会触发回流，但要记住这个流程。有一种优化后的流程，只触发绘制。不管你如何移动元素，我们称之为变换，它不会触发完整流程，只会触发GPU流程，而且不会影响渲染线程。

[00:03:50]  
That's why it's fast. 这就是它速度快的原因。  
>> Speaker 3: Okay, [INAUDIBLE] That's the beta, essentially, [INAUDIBLE]>> 发言者3：好的，[听不清] 本质上，那就是测试版，[听不清]  
>> Erik: Yeah. >> 埃里克：是的。  
>> Speaker 2: How did position absolute solve the problem here?>> 发言者2：绝对定位是如何解决这里的问题的？  
>> Erik: So if you don't remove the elements from the normal flow, then they will take the position where they should be rendered. So you would need to adjust that.>> 埃里克：所以，如果你不把这些元素从正常流中移除，它们就会占据本应渲染的位置。因此你需要对此进行调整。

[00:04:17]  
But when we set it to absolute, then all the elements position are reset to top left most quarter. So we can adjust that position using the transformation. And we provided the relative container, which is the virtual list container as a reference point. So now all the elements use this container to calculate its position.但当我们将其设置为绝对定位时，所有元素的位置都会重置到最左上角的区域。因此，我们可以通过变换来调整该位置。而且我们提供了相对容器，即虚拟列表容器作为参考点。所以现在所有元素都使用这个容器来计算自身位置。

[00:04:41]  
So if using the normal flow, you would need to account the normal flow positioning that would overcomplicate the calculations.因此，如果使用正常流，你需要考虑正常流定位，这会使计算变得过于复杂。
