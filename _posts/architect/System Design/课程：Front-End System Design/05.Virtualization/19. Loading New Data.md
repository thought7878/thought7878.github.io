


---

## “加载新数据”课程的文字稿

Evgenii continues the virtualization exercise by loading data and displaying cards in the container. The initial data set is loaded and displayed. When the bottom observer comes into view, the next set of cards is loaded and displayed.
叶夫根尼*继续进行虚拟化练习*，他*加载数据并在容器中显示卡片*。初始数据集已加载并显示。当底部观察器进入视图时，下一组卡片将被加载并显示。


[00:00:00]  
>> Evgenii Ray: So we completed the step one and step two and the next part will be to load some data. So when our viewport touches the bottom observer, now we need to render some items. Basically, we're going to replicate the exercise that we did before on laser scroller, one thing you may also notice, since they, virtualization is the sliding window.>> 叶夫根尼·雷：所以我们已经完成了第一步和第二步，接下来要加载一些数据。当我们的视口触碰到底部观察器时，现在我们需要渲染一些项目。基本上，我们要重复之前在激光滚动器上做的练习，你可能还会注意到，因为它们的虚拟化是滑动窗口。

[00:00:26]  
So we also need to maintain the state where we keep the start and then pointer to know what exactly the window we're currently rendering. So we'll create a new start and then variables on the virtual list state and when we load the new chunk of data, we're gonna increment the end pointer to specify that now we're rendering the page 1 and page 2.因此，我们还需要维持一种状态，即保存起始指针和结束指针，以明确我们当前正在渲染的窗口具体是什么。所以，我们会在虚拟列表状态上创建新的起始和结束变量，当加载新的数据块时，我们会递增结束指针，以表明现在我们正在渲染第1页和第2页。

[00:00:53]  
So this will be our next part of the exercise, so let's get back to the code now.所以这将是我们练习的下一部分，现在让我们回到代码上来。  
>> Evgenii Ray: So here inside effect function,>> 叶夫根尼·雷：所以在这个effect函数内部，  
>> Evgenii Ray: So let's see, we call the handle intersection observer method, but now we need to implement the bottom observer, which already predefined here. So let's write some logic first, we need to fetch the data.>> 叶夫根尼·雷：让我们看看，我们调用了handle intersection observer方法，但现在我们需要实现底部观察器，它已经在这里预先定义了。所以我们先写一些逻辑，我们需要获取数据。

[00:01:26]  
So for that, 为此，  
>> Evgenii Ray: Actually, we need to look for the properties first that we are defining on the virtual list. So there are four properties that we are going to utilize, the first one is the getPage. So the getPage is just a function that takes the page number and returns the promise of some generic data.>> 叶夫根尼·雷：实际上，我们需要先确定在虚拟列表中定义的属性。我们将使用四个属性，第一个是getPage。getPage是一个接收页码并返回某种通用数据的Promise的函数。

[00:01:51]  
So it's kind of a data function that we're gonna use to fetch the next chunk of data. Then we have the getTemplate function, the getTemplate function accepts the single piece of data and returns the newly created HTML element. So we're gonna use that, so the virtual list will be able to accept some generic HTML template, so it's gonna work with any template.所以这算是一种数据函数，我们将用它来获取下一块数据。然后我们有getTemplate函数，这个函数接收单个数据并返回新创建的HTML元素。我们会用到这个函数，这样虚拟列表就能接收一些通用的HTML模板，从而适用于任何模板。

[00:02:15]  
So the template is defined by the user of our virtual list. And there is also updateTemplate function, which is very similar to getTemplate, but it also accepts the element which already exists in a virtual list. When we call the updateTemplate, instead of creating a new element, we take the new data and just update the existing element within the list.因此，该模板由我们虚拟列表的用户定义。此外，还有一个updateTemplate函数，它与getTemplate非常相似，但还会接收虚拟列表中已存在的元素。当我们调用updateTemplate时，不会创建新元素，而是获取新数据并仅更新列表中的现有元素。

[00:02:40]  
So we don't really create a new HTML element. And there is a page size. We need to know how many elements we render per single API call. This will tell us what is the limit that we can render on the page. So for instance, if the page size is 10, then we can say that we just want to render two pages of data all the time.所以我们实际上并没有创建新的HTML元素。而且存在一个页面大小的设置。我们需要知道每次API调用要渲染多少个元素。这会告诉我们在页面上可以渲染的上限是多少。例如，如果页面大小是10，那么我们可以说，我们始终只想渲染两页的数据。

[00:03:09]  
So this means 20 elements will be the maximum number of nodes in the virtual list. And let's go to index html first and define this attributes, right now they all now's, so first let's create a function that will generate the HTML element for us. So here I will, I'm going to build the function that's going to accept two arguments, they don't end the element, so let's start implementing this.这意味着虚拟列表中节点的最大数量将是20个。我们先来看index.html并定义这些属性，现在它们都是“now's”，所以首先我们要创建一个函数来为我们生成HTML元素。在这里，我要构建一个接受两个参数的函数，它们不会终止该元素，所以我们开始实现吧。

[00:03:44]  
So if the element is not provided, then we're going to use the document fragment that we already used before, to create a new HTML element, so let's do that. Template content call note through and then first element child, so it's basically the same thing that we already keep it for.所以，如果未提供该元素，我们将使用之前已经用过的文档片段来创建一个新的HTML元素，那我们就这么做吧。通过模板内容调用注释，然后获取第一个子元素，所以这基本上和我们之前一直做的是一样的。

[00:04:17]  
Now we want to update the cart element, we know that, we use the same data title and the body, so we want to update the title and the body of the cart, so let's query this cart title and cart body.现在我们想要更新购物车元素，我们知道，我们使用相同的数据标题和正文，所以我们想要更新购物车的标题和正文，那么让我们查询这个购物车标题和购物车正文。  
>> Evgenii Ray: So let's use cart query selector all, so we're gonna query the cart title and also cart body content, so now we need to update the cart title.>> 叶夫根尼·雷：那我们就用cart query selector all，这样我们就可以查询购物车标题和购物车主体内容，现在我们需要更新购物车标题。

[00:04:51]  
Okay, now we need to update the data that we received from, we need to update the data inside HTML element but that we received from API, so we use the text content attribute, let's modify it to title.好的，现在我们需要更新从API接收的数据，我们需要更新HTML元素内的数据，所以我们使用textContent属性，让我们把它修改为标题。  
>> Evgenii Ray: And then let's do cart body, text content, and Textcontent.tatum.body, and then we return the following cart.>> 叶夫根尼·雷：然后我们来处理购物车主体、文本内容和Textcontent.tatum.body，之后返回下面的购物车。

[00:05:21]  
So now we can just copy this function and use it as the get template and update template. So when we have the get template, only the datum is provided, so we always generate a new element. But when we use the MLA template, then the element is provided, so we reuse existing element and update the data.所以现在我们可以复制这个函数，并将其用作获取模板和更新模板。当我们使用获取模板时，只提供数据，因此我们总是生成一个新元素。但当我们使用MLA模板时，会提供元素，因此我们会重用现有元素并更新数据。

[00:05:44]  
Then the page size, we can set it to be 10, because I know that our mockdb returns 10 elements. And the getPage, we're going to use the db.getPage function, so let's use the pointer, and let's provide the pointer here. So let's now go back to the virtual list and use the properties that we set.那么页面大小，我们可以将其设置为10，因为我知道我们的mockdb会返回10个元素。而对于getPage，我们将使用db.getPage函数，所以让我们使用这个指针，并在这里提供该指针。现在让我们回到虚拟列表，使用我们设置的属性。

[00:06:10]  
So we're going to write the code in the handle bottom observer now, so first we need to fetch the data. Okay, so we're gonna use the properties that we set on our class and the property that I need is geth. So it's a function that will return the data, this function accepts the pointer and I know that we need to create a new pointer on the state.所以我们现在要在底部观察器处理程序中编写代码，首先需要获取数据。好的，我们要使用在类上设置的属性，我需要的属性是geth。这是一个会返回数据的函数，该函数接受指针，而且我知道我们需要在状态上创建一个新的指针。

[00:06:37]  
So let's assume that there is end pointer that will give us the latest rendered page number, and let's evade this data because I know that it should trust the promise. So let's create the end pointer and the start pointer on state so we initialize it to zero.那么我们假设存在一个结束指针，它会给我们最新的已渲染页码，我们来避开这个数据，因为我知道它应该信任这个承诺。所以我们要在状态中创建结束指针和开始指针，并将它们初始化为零。  
>> Evgenii Ray: And then, so we increasing the pointer by one when we can do in the bottom up server, so the next time it executes it will be one, two, and three and so on.>> 叶夫根尼·雷：然后，我们在自底向上的服务器中可以将指针增加1，这样下次执行时，指针就会是1、2、3，依此类推。

[00:07:15]  
Okay, now we need to convert the data to the HTML elements, so basically we're slightly repeating the exercise we did before, so let's create the fragment to accumulate all the.好的，现在我们需要将数据转换为HTML元素，所以基本上我们要稍微重复一下之前做过的练习，那我们来创建一个片段来累积所有的内容吧。  
>> Evgenii Ray: Now we're gonna look for the data>> 叶夫根尼·雷：现在我们要查找数据  
>> Evgenii Ray: And we're going to create a new cart>> 叶夫根尼·雷：我们将要创建一个新的购物车  
>> Evgenii Ray: And we are going to pass the data datum.title and datum.body.叶夫根尼·雷：我们将传递datum.title和datum.body的数据。

[00:07:58]  
>> Evgenii Ray: So there are the, there is a minor mistake, we need to utilize the properties that we set, so it's going to be the getTemplate function. So this template function accepts the datum, and since we're not reusing any element, so we're just generating the new cart. And then we just append the new card to the fragment, so we append the cart to the fragment.>> 叶夫根尼·雷：所以这里有一个小错误，我们需要利用我们设置的属性，所以应该用getTemplate函数。这个模板函数接收数据，而且由于我们不重用任何元素，所以我们只是生成新的卡片。然后我们只需把新卡片添加到片段中，把卡片添加到片段里。

[00:08:20]  
And once the this is appended and we generated all the content, now we can get the reference to our list, so we already have the function for that. Get virtual list, and then we append the fragment to the list, list append fragment.一旦完成了这个附加操作并生成了所有内容，现在我们就可以获取到列表的引用了，我们已经有了用于此目的的函数。获取虚拟列表，然后将片段附加到列表中，即列表附加片段。  
>> Evgenii Ray: So that's probably it, and now let's try to run our index.html to see if it works.>> 叶夫根尼·雷：大概就是这样了，现在我们来尝试运行index.html看看它能不能用。

[00:08:55]  
>> Evgenii Ray: I need to remove my word.>> 叶夫根尼·雷：我需要删掉我的话。  
>> Evgenii Ray: It definitely works, It's getting, so we place it somewhere here and let's remove that one,>> 叶夫根尼·雷：这肯定管用，已经开始了，我们把它放在这儿的某个地方，然后把那个去掉。  
>> Evgenii Ray: And refresh the page. So now if we scroll down.>> 叶夫根尼·雷：然后刷新页面。现在如果我们向下滚动。  
>> Evgenii Ray: We see that our new data is loaded, and this is the end of the current part.>> 叶夫根尼·雷：我们看到新数据已经加载完成，这就是当前部分的结尾。



