


---

## “观察者 API”课程文字稿

Evgenii introduces the Observer API, which includes APIs for detecting intersection, mutation, and resizing of elements. He walks through the Intersection Observer API. An observer is created from the IntersectionObserver constructor and configured with a callback and an object containing an element to check the intersection against and a threshold for the intersection.
叶夫根尼介绍了观察者API，其中包括**用于检测元素的交叉、突变和大小调整的API**。他详细讲解了交叉观察器API。观察器通过IntersectionObserver构造函数创建，并配置有一个回调函数以及一个对象，该对象包含一个用于检查交叉情况的元素和一个交叉阈值。



[00:00:00]  
Erik: So, the next section is the Observer API. So, the Observer API is interesting because this API was born from the pain of engineers. Because engineers had to create some very hacky solutions to common problems. So that's why the spec developers they they saw this pain and implemented the Observer API.埃里克：接下来要讲的是观察者API。这个API很有意思，因为它的诞生源于工程师们的痛点。工程师们过去为了解决一些常见问题，不得不采用一些非常不规范的解决方案。正因为如此，规范的制定者们看到了这种困扰，于是就开发了观察者API。

[00:00:27]  
An Observer API is very different comparing to traditional vent-based functions, and we're gonna explore why. So the Observer API has three main types. The first one is intersection and intersection observer is heavily used in the virtualization pattern or in the lazy components when you need to render the component, when the viewport reaches certain element.观察者API与传统的基于事件的函数有很大不同，我们将探究其原因。观察者API主要有三种类型。第一种是交叉观察器，它在虚拟化模式或延迟加载组件中被大量使用，当视口到达特定元素时，就需要渲染该组件。

[00:00:51]  
Or we can also use it for analytics to see what are the parts of websites that are the most visible to the user. And we can also build some dynamic UI elements. So the MutationObserver is very useful for building text editors because it allows us to track the changes in the subtree in a very performant way.或者我们也可以将其用于分析，以了解网站中哪些部分对用户来说最显眼。我们还可以构建一些动态的用户界面元素。因此，MutationObserver在构建文本编辑器时非常有用，因为它能以一种高效的方式跟踪子树中的变化。

[00:01:12]  
It's also heavily used in drawing tools. The Resize Observer helps us to track the resize of the elements, and it's heavily used in adaptive design charting tools. Where you have, for instance, a trading app and you have ten different charts, and the resize observer can be used there to update their toolbar as you resize the specific element.它在绘图工具中也有大量应用。Resize Observer 帮助我们追踪元素的尺寸变化，并且在自适应设计的图表工具中被大量使用。例如，在一个交易应用中，你有十个不同的图表，当你调整特定元素的尺寸时，Resize Observer 可以用来更新它们的工具栏。

[00:01:37]  
And it's also heavily used in drawing tools. So let starts start with the intersection observer. So if we look at how we track the intersection before in vanilla JavaScript, then you would query two elements, A and B. And then you would set up the interval, for instance, 15 milliseconds, and then you would calculate the coordinates and try to see if these two elements are intersecting.而且它在绘图工具中也被大量使用。那么我们就从交叉观察器开始说起吧。如果我们看看以前在原生JavaScript中是如何跟踪交叉情况的，你会查询两个元素A和B。然后你会设置一个时间间隔，比如15毫秒，接着计算坐标，并尝试判断这两个元素是否相交。

[00:02:05]  
So the issue of that is, imagine that you have multiple intersection observers set up on the page. This would lead to performance degradation because our callback queue will basically work only for the observers. So that's why the intersection observer was created. The idea of intersection observer is to track the intersection with the target element.问题在于，想象一下你在页面上设置了多个交叉观察器。这会导致性能下降，因为我们的回调队列基本上只会为这些观察器工作。这就是交叉观察器被创建的原因。交叉观察器的作用是追踪与目标元素的交叉情况。

[00:02:30]  
So the first important property is the target. So basically the element that we're tracking. So the single observer can track multiple elements on the page, so the observer itself is very reusable. Then we can also set up the root container that we are tracking intersection against. So by default it's a viewport, but you can also tell the observer a specific container that you're interested in.第一个重要的属性是目标，也就是我们要追踪的元素。单个观察器可以追踪页面上的多个元素，所以观察器本身的复用性很强。此外，我们还可以设置用于检测交叉情况的根容器。默认情况下，这个根容器是视口，但你也可以告诉观察器你所关注的特定容器。

[00:02:59]  
So one additional property is the threshold. It's basically the ratio, how much the element should be intersected before we fire the asynchronous callback. And also, the callback is the basically asynchronous function, and we implement this function as the as developers. So the difference with this observer is. The intersection event is tracked on the native level instead of the event level.另一个特性是阈值。它本质上是一个比例，指的是元素需要被交叉多少比例后，我们才会触发异步回调。此外，回调本质上是一个异步函数，我们作为开发者来实现这个函数。这种观察器的不同之处在于，交叉事件是在原生层面而非事件层面进行跟踪的。

[00:03:25]  
This means that it has much better performance. On average, intersection observers perform 50 times faster than the vanilla approach. That's why it's pretty safe to use it in the production apps. So the API of Intersection Observer is very simple. To create the Intersection Observer, we just need to use its constructor, its constructor accepts two parameters.这意味着它的性能要好得多。平均而言，交叉观察器的性能比普通方法快50倍。这就是为什么在生产应用中使用它是相当安全的。交叉观察器的API非常简单。要创建交叉观察器，我们只需要使用它的构造函数，该构造函数接受两个参数。

[00:03:53]  
The first one is the callback and the second one is the configuration object. The configuration object has two main properties, which is one root allows us to select the container that we're tracking intersection against. The threshold, basically the ratio of intersection. And the callback accepts two parameters. One is entries, which is the array of entries that they are currently intersecting.第一个是回调函数，第二个是配置对象。配置对象有两个主要属性，其中一个是root，它允许我们选择要追踪其交叉情况的容器。threshold本质上是交叉比例。而回调函数接受两个参数，一个是entries，即当前正在交叉的条目数组。

[00:04:21]  
And the callback is triggered in two cases. The first one when the target element intersects and the second one when the intersection is stopped. That's why we have the special property called isIntersecting to tell us if the entry is intersecting. We have the array instead of having a single element in the callback, we actually have an array because we may have multiple entries, being intersected in a single event.回调函数在两种情况下会被触发。第一种是目标元素发生交叉时，第二种是交叉状态停止时。这就是为什么我们有一个名为isIntersecting的特殊属性，它可以告诉我们该条目是否处于交叉状态。在回调函数中，我们使用的是数组而不是单个元素，实际上这是因为在单个事件中可能会有多个条目处于交叉状态。

[00:04:53]  
And then to observe the element, we need to call the observe function and provide the target element.然后，要观察该元素，我们需要调用observe函数并提供目标元素。

