



---

## 《使用IntersectionObserver实现无限滚动》课程文字稿

Students are instructed to implement an infinite scroll behavior using an intersection Observer. The observer is an element at the bottom of the pages. When it intersects the viewport, the next page of data will be loaded, and new card elements will be populated.
学生们被要求**使用交叉观察器实现无限滚动**行为。该观察器是页面底部的一个元素。当它与视口相交时，将加载下一页数据，并填充新的卡片元素。



[00:00:00]  
Evgenii Ray: Okay, so this section will be very, coding heavy we're going to utilize the intersection observer to create every simple version of infinite scroller. Where you just load the content once you're intersecting with the bottom observer. So there is no virtualization yet here, but it's a prerequisite exercise for the position board.叶夫根尼·雷：好的，所以这一部分会涉及大量编码，我们将利用交叉观察器来创建一个非常简单的无限滚动版本。当你与底部观察器相交时，就加载内容。所以这里还没有实现虚拟化，但这是职位公告板的一个预备练习。

[00:00:24]  
So check out the branch name called, 2-intersection-observer-begin, and if you're stuck somewhere, you can find the final solution branch. So basically, the prefix is end instead of begin. Okay, let's go to the code now. And hopefully, it will work this time. So let's go to exercise, and here we have our exercise.所以查看名为2-intersection-observer-begin的分支，如果你在某个地方遇到困难，可以找到最终的解决方案分支。基本上，前缀是end而不是begin。好的，现在我们来看代码。希望这次能成功。我们来看练习，这里就是我们的练习。

[00:00:55]  
So we are going to reuse the same card component that we are currently used before. And we already have everything set up and we have our Mock init database that we're gonna use to generate the data. So what it does, it takes the object as a sample and just returns similar objects to us.所以我们要复用之前用过的同一个卡片组件。而且我们已经完成了所有设置，还有用于生成数据的模拟初始化数据库。它的作用是，以这个对象为样本，然后给我们返回类似的对象。

[00:01:15]  
And then we already have the query selector that selects the list container, where we will we'll put all our cards and also the bottom observer. And if around this page to see how it looks like, we'll see that here's the our bottom observer, and now it doesn't do anything because we need to implement this.然后我们已经有了选择列表容器的查询选择器，我们将在其中放置所有卡片以及底部观察器。如果浏览这个页面看看它的样子，我们会发现这里是我们的底部观察器，现在它什么也做不了，因为我们需要实现它。

[00:01:35]  
So let's get back to the code now. So our goal first, is to initiate the intersection observer. So let's create one instance here.那我们现在回到代码上来。首先，我们的目标是初始化交叉观察器。那我们在这里创建一个实例吧。  
Evgenii Ray: Okay, so now we need to provide the callback, the callback accepts entries.叶夫根尼·雷：好的，现在我们需要提供这个回调函数，该回调函数接收条目。  
Evgenii Ray: And then we also need to provide the configuration. So I will set up the threshold of 0.2, and I'm okay to use the viewport as the intersection route.叶夫根尼·雷：然后我们还需要提供配置。所以我会将阈值设置为0.2，而且我可以接受使用视口作为交叉路径。

[00:02:08]  
So now we need to handle our entries, since I know that we have only one intersection entry, so I can destruct the array and have single entry here, so I don't need to loop for that. So now we can check if the entry is intersecting.所以现在我们需要处理我们的条目，因为我知道我们只有一个交叉条目，所以我可以对数组进行解构，在这里得到单个条目，这样就不需要为此进行循环了。现在我们可以检查这个条目是否正在交叉。  
Evgenii Ray: The next step is to fetch in new data.叶夫根尼·雷：下一步是获取新数据。

[00:02:33]  
So let's fetch in new data using our MockDB. So,那么让我们使用我们的MockDB获取新数据。那么，  
Evgenii Ray: Let's convert this call back to a synchronous one, and then use await on our DB, and then we have a method called getPage. The getPage accepts the pointer, which is the page number. So let's create one variable.叶夫根尼·雷：让我们把这个调用转回同步调用，然后在我们的数据库上使用await，之后我们有一个名为getPage的方法。getPage接收指针，也就是页码。所以我们来创建一个变量。

[00:02:58]  
Evgenii Ray: That will start with 0 and then every time we execute the callback, we're gonna increase it by 1. Okay, now we have our data, so we need to convert this data to HTML elements. So we can create the new fragment to accumulate all the DOM mutations we're planning to do.叶夫根尼·雷：这将从0开始，然后每次我们执行回调函数时，都会将其增加1。好了，现在我们有了数据，所以需要将这些数据转换为HTML元素。因此，我们可以创建新的片段来累积我们计划进行的所有DOM变更。

[00:03:20]  
So we create the new document fragment. And now we're going to look for the data.所以我们创建了新的文档片段。现在我们要查找数据。  
Evgenii Ray: And we're going to create the card using our createCard function.叶夫根尼·雷：我们将使用我们的createCard函数来创建卡片。  
Evgenii Ray: And then we are going to pass datum.title and datum.body.叶夫根尼·雷：然后我们要传递datum.title和datum.body。  
Evgenii Ray: So now we created our CardElement, we want to add this CardElement to our fragment.叶夫根尼·雷：现在我们已经创建了CardElement，我们想把这个CardElement添加到我们的片段中。

[00:03:58]  
So we use fragment.appendChild(card). We updated our fragment, so we now accumulate all the DOM updates within the same memory object. And once we finished updating the fragment, we can finally append the element to our list, which we already queried. So let's use list.appendChild(fragment). So instead of having, for instance, 10 operations, we now just have 1.所以我们使用fragment.appendChild(card)。我们更新了片段，这样现在所有的DOM更新都累积在同一个内存对象中。一旦完成对片段的更新，我们最终可以将该元素添加到我们已经查询过的列表中。所以让我们使用list.appendChild(fragment)。这样一来，举例来说，原本需要10次操作，现在只需要1次。

[00:04:28]  
And now the intersection observer is ready, we need to observe the element that we're trying to observe. So let's use observer.observe, and provide our element, which is already here, observerElement.现在交叉观察器已准备就绪，我们需要观察我们要观察的元素。所以让我们使用observer.observe，并提供我们的元素，也就是这里已有的observerElement。  
Evgenii Ray: And if we run this in the Browser, we'll see that now it still doesn't work, let's see why.叶夫根尼·雷：如果我们在浏览器中运行这个，会发现它仍然无法工作，让我们看看原因。

[00:04:54]  
Yeah, DB is not defined, let's check that.是的，DB未定义，我们来检查一下。  
Evgenii Ray: It's actually error, lowercase.叶夫根尼·雷：实际上这是个错误，要用小写。  
Evgenii Ray: So now we have our cards perfectly rendered. And when we go down, we render more data.叶夫根尼·雷：现在我们的卡片已经完美渲染好了。当我们向下滚动时，会渲染更多数据。  
Evgenii Ray: And that's it for our second exercise. So let's overview the solution. So we set up the intersection observer, created the fragment, and appended all the new CardElements to the fragment to minimize any dynamic DOM mutations.叶夫根尼·雷：我们的第二个练习就到这里。现在让我们回顾一下解决方案。我们设置了交叉观察器，创建了文档片段，并将所有新的卡片元素添加到该片段中，以尽量减少动态DOM的变更。

[00:05:36]  
And then we appended the full fragment to the list. And then we observed the bottom observerElement that we have here, and loaded the new content. So yeah, should be a pretty simple exercise. And if you're stuck somewhere, you always have the branch where you can check out the final solution.然后我们将完整的片段添加到列表中。接着，我们观察了这里的底部observerElement，并加载了新内容。所以，这应该是一个相当简单的练习。如果你在某个地方遇到困难，总有一个分支可以让你查看最终的解决方案。







