


---

## “MutationObserver”课程文字稿

Evgenii explains how the Mutation Observer API detects changes to elements in the DOM subtree. The types of mutations include changes to direct children, attributes, textContent, or any descendants in the subtree.
叶夫根尼解释了**Mutation Observer API如何检测DOM子树中元素的变化**。这些变化类型包括直接子元素、属性、textContent或子树中任何后代元素的变化。



[00:00:00]  
Eric: Let's go to the mutation observer now, so the mutation observer is different because it allows us to track the changes within the DOM subtree. So it's very useful for rich text editors, for instance, you are trying to select some data and apply the bold text. So the mutation observer will allow us to detect that.埃里克：现在我们来看看突变观察器，它有所不同，因为它能让我们追踪DOM子树中的变化。所以它在富文本编辑器中非常有用，例如，当你尝试选择一些数据并应用粗体文本时，突变观察器就能帮我们检测到这种变化。

[00:00:23]  
The huge benefit of the mutation observer, it's implemented on a native level. So previously in vanilla, how this mutation observer will be polyfilled is you're basically creating a proxy object that will track every mutation of any possible subtree. And this is implemented on a JavaScript level, so you would need to create, if you have a large subtree that would result to some memory issues and console on a native level, it's very fast.突变观察器的巨大优势在于它是在原生层面实现的。所以以前在原生JavaScript中，这种突变观察器的polyfill实现方式基本上是创建一个代理对象，用来跟踪任何可能的子树的每一次突变。而这是在JavaScript层面实现的，所以如果你有一个大型子树，就可能会导致一些内存问题，而在原生层面运行的话，速度会非常快。

[00:00:56]  
And the creation of the mutation observer is pretty simple, we just need to provide a single callback. There are no options to the constructor, and the callback accepts the mutation. And the observe function accepts two parameters, one is the target node that we're trying to observe, here, in this example, it's div, and the observer options.创建突变观察器非常简单，我们只需要提供一个回调函数。构造函数没有选项，而该回调函数会接收突变信息。观察函数接受两个参数，一个是我们要观察的目标节点，在这个例子中是div，另一个是观察器选项。

[00:01:17]  
And the observer options is a bit more complicated because we can track many things, so we can configure the observer to track only the child list. So this means that if we provide the child is true, then we go into track the section in each one because they are direct child of development.而观察者选项则稍微复杂一些，因为我们可以追踪很多东西，所以我们可以配置观察者只追踪子列表。这意味着如果我们将子项设为true，那么我们就会进入每个子项的追踪部分，因为它们是开发的直接子项。

[00:01:37]  
If we provide the attributes to true, this means that the mutation observer will track any changes in the attributes. And if you provide the character data then if we have any text content and we enter this content using the keyboard, then the mutation observer can detect these changes, like on changing, then on the inputs, and provide us with the mutation observer entry.如果我们将属性设为true，这意味着突变观察器将追踪属性的任何变化。而如果提供字符数据，那么当我们有任何文本内容并通过键盘输入该内容时，突变观察器能够检测到这些变化，比如在内容更改时、在输入操作时，并为我们提供突变观察器条目。

[00:02:06]  
And there is also one cool thing, is the subtree. So we can basically say that we want to track all the elements in the whole subtree, and we just need to provide the true flag here. We can also filter the attributes that we're currently looking for, and this will reduce the number of time the callback is called.而且还有一个很酷的功能，就是子树。所以我们基本上可以说，我们想要追踪整个子树中的所有元素，只需要在这里提供true标志就行。我们还可以过滤当前正在查找的属性，这会减少回调被调用的次数。

[00:02:27]  
So the best practice is to make sure that you configure the observer in the right way. Try not to overuse the properties, don't set them to true, because this will involve invoking the callback too many times.因此，最佳实践是确保以正确的方式配置观察者。尽量不要过度使用这些属性，不要将它们设置为true，因为这会导致回调被调用过多次数。  
Speaker 1: So just to clarify, the child list would just apply to direct descendants in the sub tree would be anything?发言者1：那么澄清一下，子列表是否只适用于子树中的直接后代？

[00:02:50]  
Eric: Yeah. 埃里克：是的。  
Speaker 1: Okay? 发言者1：好的？  
Eric: And there is a conflict if you apply Charlie's true and the subtree true, then the sub tree will not work because the search Charlie's has the preference, higher priority, okay? So the TLDR make sure that you configure these options right to reduce possible invocation of the observer callback.埃里克：而且，如果你应用了查理的真值和子树的真值，就会产生冲突，这样子树就无法正常工作了，因为搜索查理的真值具有更高的优先级，明白吗？所以简单来说，要确保正确配置这些选项，以减少观察者回调的可能调用。

[00:03:13]  
And the mutation record that the mutation observer provides us is basically has a few properties, so the type, so the type tells us which type of mutation happened. It can be the attribute changed or some data was entered or removed, or it they might be that we added a new DOM element in the direct child list.而突变观察器提供给我们的突变记录基本上有几个属性，其中类型这一属性会告诉我们发生了哪种类型的突变。可能是属性发生了变化，或者某些数据被输入或删除，也可能是我们在直接子元素列表中添加了新的DOM元素。

[00:03:36]  
So it also has the information about the target node, which was triggered the mutation observer. And we also have the edit nodes array that will give us any newly added nodes that were when we inserted some data in the DOM tree or remove nodes. And we can also access the old character data value to see what was the value before the mutation happened.因此，它也包含有关触发了突变观察器的目标节点的信息。我们还有编辑节点数组，它会为我们提供在DOM树中插入某些数据时新添加的节点，或者被移除的节点。我们还可以访问旧的字符数据值，以查看突变发生前的值是什么。

[00:04:02]  
And, again, the callback is pretty simple, we just need to look for a mutation, filtered by our type, and by our logic.而且，回调再次变得相当简单，我们只需要查找一个突变，按我们的类型和逻辑进行筛选即可。


