



---

## “MutationObserver 练习”课程文字稿

Students are instructed to create a mutation observer to detect text input and replace any supported tags with their corresponding HTML element.
学生们被要求创建一个突变观察器，以检测文本输入并将所有受支持的标签替换为其对应的HTML元素。


[00:00:00]  
Evgenii Ray: So I'm going to open this example in the full screen just to give you the idea what we're trying to build. So imagine the mark dominator where you can replace the content with some elements. So for instance, I want to replace this element with a heading. So the idea is to build such very simple examples of the market dominating to support h1 and h2 tag.叶夫根尼·雷：我打算全屏打开这个示例，好让你们明白我们要构建的是什么。想象一下这个标记控制器，你可以用一些元素替换其中的内容。比如，我想把这个元素替换成一个标题。我们的想法是构建这样非常简单的市场主导示例，以支持h1和h2标签。

[00:00:23]  
So if it's h1 because I have a normalizer, it will have the same styles. But if we check the example, we'll see that there is a h1 and h3 and as you can see, we can edit the direct content of the html element. So this is done through the content editable true attribute.所以，如果因为我有一个标准化器而使用h1，它会有相同的样式。但如果我们查看示例，会发现有一个h1和h3，而且如你所见，我们可以编辑html元素的直接内容。这是通过content editable true属性实现的。

[00:00:46]  
So if you have good examples of such capabilities and notion app, they heavily rely on such type of editing. So let's get back to the exercise. So first, let me read it, felt from the full screen and go back. So we're going to utilize the same example that we use before but we will add the content editable attribute to the section where we place the body text.所以，如果你有这类功能和Notion应用的好例子，它们在很大程度上依赖于这种编辑方式。那我们回到练习上来。首先，我读一下，从全屏退出，然后返回。我们将使用之前用过的同一个例子，但会在放置正文的部分添加content editable属性。

[00:01:16]  
And we're going to create the mutation observer and trick all the subtree changes and the checked data so we can verify that we actually use the h3, or h2, or h1 tag. Then we implement the callback for mutation observer, and when we type, we need to validate that the text that we typed matches the tag to relace the content and when then we will need to replace that.我们将创建一个突变观察器，追踪所有子树变化和已检查的数据，这样我们就能验证是否确实使用了h3、h2或h1标签。然后，我们为突变观察器实现回调函数，当我们输入时，需要验证输入的文本是否与标签匹配，以替换内容，之后我们就需要进行替换操作。

[00:01:44]  
Make sure you're using the single observer for all rendered cards. Yep, and let's jump to exercise. Here's the branch name to start your work. Let's get back to the code. We have the same file in the index html file so that our template is here. But the create card element function now is in the utils.js, so we don't need to pay attention to that and also use the same Moog db.确保你对所有渲染的卡片都使用同一个观察器。没错，我们来开始练习吧。这是开始工作的分支名称。我们回到代码上来。我们在index html文件中有相同的文件，所以我们的模板就在这里。但创建卡片元素的函数现在在utils.js中，所以我们不需要关注这一点，同时使用相同的Moog数据库。

[00:02:10]  
And here we listed all the supported elements that we want to track h2, h2, and h3. That is also function called Get Heading that is very simple. It just it checks the text content of the element and then creates the specific html element.在这里，我们列出了所有我们想要跟踪的支持元素：h2、h2和h3。还有一个名为“获取标题”的函数，它非常简单。它只是检查元素的文本内容，然后创建特定的html元素。  
Evgenii Ray: So let's get back to our index html now.叶夫根尼·雷：那我们现在回到我们的index html吧。

[00:02:36]  
And here we need to initiate our mutation observer. And once we implemented the callback, we need to register that when we create the cart before we append them on the screen. So let's do that. So first of all the mutation observer accepts the mutation entries. So let's call it entries.在这里，我们需要初始化我们的突变观察器。一旦我们实现了回调函数，就需要在创建购物车并将其添加到屏幕上之前进行注册。那我们开始吧。首先，突变观察器会接收突变条目。我们就称它为条目吧。

[00:02:59]  
Now we need to look for the mutation entries.现在我们需要查找突变条目。  
Evgenii Ray: And so what we need to access, we need to get the target element.叶夫根尼·雷：所以我们需要访问的是，我们需要获取目标元素。  
Evgenii Ray: So when we got our target element, we also need now to filter out the mutation. So we are looking for the charted data type of mutation, and now we also want to check that, the target.textContent.叶夫根尼·雷：所以当我们获取到目标元素时，我们现在还需要过滤掉这种变化。我们正在寻找变化的图表数据类型，而且现在我们还想检查一下目标的文本内容。

[00:03:42]  
Evgenii Ray: That the element matches the following tech. So we can verify that by using this supported element, then we can have the has that will verify that the textContent matches any element in a collection. And if it does, then we are going to replace, we are going to create a new heading and use the getHeading method and pass our target node.叶夫根尼·雷：该元素与以下技术相匹配。因此，我们可以通过使用这个受支持的元素来验证这一点，然后我们可以使用has方法来验证textContent是否与集合中的任何元素匹配。如果匹配，我们将进行替换，我们将创建一个新标题，并使用getHeading方法，同时传递我们的目标节点。

[00:04:13]  
Okay, so now we have our heading method, we can now replace the target element using the method called replace with. So it basically replaces the target with a new heading element. And now we also want to focus on the newly created element. So now the mutation observer is implemented, but we still need to track the elements.好的，现在我们有了标题方法，我们可以使用名为replace with的方法来替换目标元素。所以它基本上是用一个新的标题元素替换目标元素。现在我们还想聚焦于新创建的元素。所以现在已经实现了突变观察器，但我们仍然需要跟踪这些元素。

[00:04:40]  
So here in the appendChild, what are we're gonna use is, we're gonna use the mutation observer, observe, and then our card element and the configuration. We're gonna use the subtree property to verify that. We do the deep check and the character data to true. The rest will be false.所以在appendChild中，我们要用到的是突变观察器（mutation observer）的observe方法，然后是我们的卡片元素和配置。我们会使用subtree属性来验证这一点。我们要进行深度检查，并将character data设为true。其余的则设为false。

[00:05:02]  
Evgenii Ray: And if we open the, the last thing that we forgot is we need to add the content editable property to the section here to let the user edit the content. Okay, now if we run this example, now the content should be editable. And if we replace the tag with h3, we see that now the heading popped up.叶夫根尼·雷：而且如果我们打开的话，我们忘记的最后一件事是，我们需要在这里的部分添加content editable属性，让用户能够编辑内容。好的，现在如果我们运行这个示例，内容应该是可编辑的了。而且如果我们用h3替换这个标签，我们会看到标题现在弹出来了。

[00:05:29]  
Okay, so this was the mutation observer exercise. And here is the summary. So we created a mutation observer, accessed the target and a type of mutation, checked that the type is charged data. Check that the text content contains the specific set of characters we're looking for. Generate the heading element and replace it with a new element, yep.好的，这就是突变观察器的练习。以下是总结。我们创建了一个突变观察器，访问了目标和突变类型，检查该类型是否为已更改的数据。检查文本内容是否包含我们要找的特定字符集。生成标题元素并将其替换为新元素，是的。

[00:05:56]  
Speaker 2: Is there a possibility of infinite recursion here where you're changing the target element and then it causes the mutation to fire again?发言者2：这里是否存在无限递归的可能？也就是你更改了目标元素，然后这又导致突变再次触发？  
Evgenii Ray: Yes. So you need to be careful how you change that. So here, we do not check. We check only the character data mutation. It's basically when you type.叶夫根尼·雷：是的。所以你在修改这部分内容时需要小心。在这里，我们不进行检查。我们只检查字符数据的变更。基本上就是在你输入的时候。

[00:06:18]  
But because we insert the element and we update the element before we insert the data, the recursion is not happening.但由于我们在插入数据之前先插入了元素并更新了该元素，所以递归没有发生。  
Speaker 2: On a personal note, we use Google's CAPTCHA and the only way that we could detect that certain things were loaded was with the mutation observer because it was like they keep the third party APIs, in a sandbox or whatever.发言者2：就我个人而言，我们使用谷歌的验证码，而我们能够检测到某些内容已加载的唯一方法是使用突变观察器，因为他们似乎把第三方应用程序接口放在了沙箱之类的环境中。

[00:06:45]  
And it's just like the only way to know if this dom was changed was with that API is interesting.有趣的是，了解这个DOM是否发生变化的唯一方法就是通过那个API。  
Evgenii Ray: You could potentially do the interval where you traverse the specific dom and looking for a sort an element, but it would be much slower than the Mutation observer.叶夫根尼·雷：你或许可以设置一个时间间隔，在这段时间里遍历特定的DOM并查找排序元素，但这会比Mutation Observer慢得多。

[00:07:03]  
Speaker 2: Yeah, and this way we were able to see is this element changed and if so, okay, then run our code. It was much more efficient. So it's good API.发言者2：是的，通过这种方式，我们能够看到这个元素是否发生了变化，如果发生了变化，就运行我们的代码。这样效率高多了。所以这是个不错的应用程序接口。  
Evgenii Ray: Any more questions before we jump to the next section?叶夫根尼·雷：在我们进入下一部分之前，还有其他问题吗？  
Speaker 2: Someone else's said they use mutation observer in a chrome extension to make sure that the extension stays in sync with the rest of the web page that it was modifying.发言者2：有人说他们在Chrome扩展程序中使用突变观察器，以确保该扩展程序与其正在修改的网页其他部分保持同步。

[00:07:32]  
Evgenii Ray: I think the grammarly, the popular exception for checking the grammar also use the mutation observer. They basically check what you enter on the data, but such extension may reduce your website performance.叶夫根尼·雷：我认为Grammarly这个流行的语法检查工具也使用了突变观察器。它们基本上会检查你输入的数据，但这类扩展程序可能会降低你的网站性能。  
Speaker 2: Yeah for sure. 是的，那是肯定的。  
Evgenii Ray: On the callbacks.叶夫根尼·雷：关于回调函数。



