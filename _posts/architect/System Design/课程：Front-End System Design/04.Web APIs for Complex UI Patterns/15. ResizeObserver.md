


---

## 《ResizeObserver》课程文字稿

Evgenii explains there are two methods for tracking when the window or elements are resized. The resize event and corresponding media queries fire when the window size changes. CSS Container Queries and the Resize Observer API fire when elements are resized.
叶夫根尼解释说，**有两种方法可以跟踪窗口或元素何时被调整大小**。当窗口大小改变时，会触发resize事件和相应的媒体查询。当元素被调整大小时，会触发CSS容器查询和Resize Observer API。



[00:00:00]  
Erik: So, let's overview the methods of how we can do changes when we resize things. So, for instance, if we resize the window, then we have two main methods, how can we do the changes on the web page. First is CSS media queries, it's used when we built adaptive design or it's the resize event.埃里克：那么，让我们概述一下在调整元素大小时可以采用的更改方法。例如，如果我们调整窗口大小，那么在网页上实现更改主要有两种方法。第一种是CSS媒体查询，它用于我们构建自适应设计时，另一种是resize事件。

[00:00:26]  
When we track the element size, then there are two other options, that is a re-size observer that allows us to fire the callback, and there is a CSS container query that allows us to change the UI. So let's compare all of these methods from the performance-wise. So the CSS media query is, performance-wise is the best way to do the adaptive layout cases when you don't need to actually execute any JS callback.当我们追踪元素大小时，有另外两种选择，一种是尺寸调整观察器，它能让我们触发回调函数，另一种是CSS容器查询，它可以用来改变用户界面。所以让我们从性能角度来比较所有这些方法。因此，在不需要实际执行任何JS回调的自适应布局情况下，从性能角度来说，CSS媒体查询是最佳方式。

[00:00:57]  
But it has some limitation, we can't fire any callback, and we also can track specific element. So, for this specific reason, the CSS container queries implemented, so we can set up the container that we're and based on this container size, we can change the children, Lisa has styles.但它存在一些局限性，我们无法触发任何回调，也无法跟踪特定元素。因此，出于这个特定原因，CSS容器查询得以实现，这样我们就可以设置我们所在的容器，并根据该容器的大小来改变子元素的样式，莉萨有相关样式。

[00:01:18]  
So it's also pretty super fast, and it allows us to track the elements. But the problem is that we still can't fire any JS callbacks on that. Then we have the resize event, so the resize event is super slow. This, may be one of common reason why your application is potentially slow.所以它的速度也非常快，而且能让我们追踪元素。但问题是，我们仍然无法在这上面触发任何JS回调。然后我们还有resize事件，这个事件的速度非常慢。这可能是导致你的应用程序可能变慢的常见原因之一。

[00:01:35]  
The reason why the resize event is slow, is it relies on standard DOM events, and as you know, when we fire any event in the DOM. So first, the event goes from top to the target element, and then event goes from bottom to the top again, so this is called bubbling mechanism.resize事件之所以缓慢，是因为它依赖于标准的DOM事件，而且如你所知，当我们在DOM中触发任何事件时，事件首先会从顶部传递到目标元素，然后再从底部传回顶部，这就是所谓的冒泡机制。

[00:01:56]  
And every time resize event is fired, we actually need to traverse the whole DOM tree internally to provide the target element with an event. So, this is one reason why it's slow. The second one is it's fired too often. So if you try to set up a resize event for the window object, it can be fired like 5,000 times in just a small resize.而且每次触发 resize 事件时，我们实际上需要在内部遍历整个 DOM 树，以便为目标元素提供事件。这就是它速度慢的一个原因。第二个原因是它触发得太频繁。所以，如果你尝试为窗口对象设置 resize 事件，仅仅是一次小的调整，它就可能被触发 5000 次。

[00:02:20]  
So, you usually debounce that, but it allows us to track the window size and fire the callback. But the issue is, we still cannot track the specific element size. So, my recommendation would be to not to use resize event unless you really need this or you're supporting some legacy clients.所以，通常你会对其进行防抖处理，但这样我们就能跟踪窗口大小并触发回调函数。不过问题在于，我们仍然无法跟踪特定元素的大小。所以，我的建议是，除非你确实需要或者要支持一些旧版客户端，否则不要使用resize事件。

[00:02:43]  
So, it's always better to rely on ResizeObserver instead because the ResizeObserver was designed specifically for this case where you need to track resize of the different elements in a very fast way. So, the ResizeObserver on average round 10 times faster than the resize event. It also supports the callback, so we can fire the GIS callback on certain element resize and we can track multiple elements with that.所以，最好还是依赖ResizeObserver，因为ResizeObserver就是专门为这种需要快速跟踪不同元素大小变化的情况而设计的。平均来说，ResizeObserver比resize事件快大约10倍。它还支持回调，所以我们可以在特定元素大小变化时触发GIS回调，并且可以用它来跟踪多个元素。

[00:03:13]  
So, we can combine the CSS media queries with a ResizeObserver to build our complex adaptive view layout cases. And before we jump to overview of ResizeObserver. So, the ResizeObserver has the most simple API actually. So, ResizeObserver constructor doesn't take any more arguments except the callback. And the callback has just, and the callback itself has the observer resize entries, but let's first understand what are the properties that observe method takes.所以，我们可以将CSS媒体查询与ResizeObserver结合起来，以构建复杂的自适应视图布局案例。在我们开始概述ResizeObserver之前，先说明一下，ResizeObserver实际上拥有最简单的API。ResizeObserver构造函数除了回调函数外，不接受任何其他参数。而这个回调函数本身包含了观察者的尺寸变化条目，不过我们先来了解一下observe方法所接受的参数属性。

[00:03:48]  
So, it just one property, which is the box, and you can stop the box as a content box or the border box. So in case of the content box, we'll just track the size of this blue rectangle. So if you change the padding or the border, the observer will not be triggered.所以，它只有一个属性，就是这个盒子，你可以将这个盒子设为内容盒或边框盒。如果是内容盒的话，我们只会追踪这个蓝色矩形的尺寸。所以，如果你改变内边距或边框，观察器不会被触发。

[00:04:03]  
And if we use the border box, then we utilize both the border and the padding in the resize event calculations. And the ResizeObserver entry has a slightly weird property set. So it has the border box size, content box size, and as you can see, it's an array of boxes.如果我们使用边框盒，那么在调整大小事件的计算中，我们会同时利用边框和内边距。ResizeObserver 条目有一个略显奇怪的属性设置。它包含边框盒大小、内容盒大小，而且如你所见，它是一个盒子数组。

[00:04:25]  
Why it's an array of boxes? Why it's just not a single box? Apparently, so, the spec developers, so right now, you will always have a single element in this array. But the spec developers, they think that in the future we will have HTML elements that may be not just a single box, but may contain multi-column layout in one single element.为什么它是一个盒子数组？为什么不只是一个单一的盒子呢？显然，规范开发者认为，目前这个数组中总是只有一个元素。但规范开发者们觉得，未来我们可能会遇到这样的HTML元素：它们不再只是单一的盒子，而是在一个元素中包含多列布局。

[00:04:50]  
That's why we need to track multiple columns within single element. And in the future, we're gonna use this array of boxes. So, they, but right now, you will always have just a single element because no there are no such multicolumn elements at the current spec. So, also, there is a target element that we are going to use, which gives us the element that trigger three sides observer.这就是为什么我们需要在单个元素内跟踪多个列。而且在未来，我们会使用这个框数组。不过现在，你始终只会有一个元素，因为在当前规范中没有这样的多列元素。此外，还有一个我们将要使用的目标元素，它为我们提供了触发三面观察器的元素。

[00:05:20]  
The callback is implemented similar way. It takes the entries and we need to look for the entries and to access the width or the high properties. So we use the first element of the water box size. So as you can see, so because we always know that it's just a single element, then we use the zero index here.回调的实现方式类似。它接收条目，我们需要查找这些条目并访问宽度或高度属性。所以我们使用water box尺寸的第一个元素。正如你所看到的，因为我们总是知道它只是一个单独的元素，所以这里我们使用索引0。

[00:05:42]  
And here we have the inline size and the block size. So, inline size corresponds to the width, the block size corresponds to the height. And then we can set up the ResizeObserver for multiple boxes and trigger the callback这里我们有内联尺寸和块级尺寸。内联尺寸对应宽度，块级尺寸对应高度。然后我们可以为多个盒子设置ResizeObserver并触发回调函数。


