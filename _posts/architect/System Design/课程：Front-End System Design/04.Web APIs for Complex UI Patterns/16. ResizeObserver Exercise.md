



---

## “ResizeObserver 练习”课程文字稿

Students are instructed to create a Resize Observer to monitor the size of box elements as they are resized. If their width and height is below 150 pixels, a border radius is added so they appear as a circle. This lesson also includes a summary of the ResizeObserver API
学生们被要求创建一个Resize Observer，以监控盒子元素在调整大小时的尺寸。如果它们的宽度和高度低于150像素，就会添加一个边框半径，使它们看起来像一个圆形。本课程还包括对ResizeObserver API的总结。


[00:00:00]  
Evgenii Ray: And again, it's exercise time. We are going to build a simple exercise where when you resize your rectangle, it becomes the circle when the rectangle size is less than 150 pixels. So here now we have four nice circles and if we re resize back, it's again, rectangle.叶夫根尼·雷：再来一次，到练习时间了。我们要做一个简单的练习，当你调整矩形大小时，当矩形尺寸小于150像素时，它会变成圆形。现在我们有四个漂亮的圆形，要是我们把尺寸调回去，它又会变回矩形。

[00:00:24]  
And you need to check out the following branch, 4-resize-observer-start. And we are going to create a resized observer and track all this four elements and fire the code back. So let's get back to the code now.你需要检出以下分支：4-resize-observer-start。我们将创建一个尺寸调整观察器，追踪这四个元素并触发代码。现在让我们回到代码中。  
Evgenii Ray: So I'm opening the ResizeObserverBegin branch. And here,叶夫根尼·雷：所以我正在打开ResizeObserverBegin分支。而且在这里，  
Evgenii Ray: We already have all the boxes set up.叶夫根尼·雷：我们已经设置好了所有的方块。

[00:00:51]  
So I guess what we need to do is, so first let's initiate the observer.所以我想我们需要做的是，首先让我们初始化这个观察器。  
Evgenii Ray: And then provide the callback.叶夫根尼·雷：然后提供回调函数。  
Evgenii Ray: So we're gonna loop through our entries.叶夫根尼·雷：所以我们要遍历我们的条目。  
Evgenii Ray: Then on an entry, we're gonna access the target element.叶夫根尼·雷：然后在一个条目上，我们要访问目标元素。  
Evgenii Ray: Then we need the box, so we're gonna use borderBoxSize.叶夫根尼·雷：然后我们需要这个框，所以我们要使用borderBoxSize。

[00:01:45]  
And we know that the borderBoxSize is the array of a single element, so we select the box. And now we need to check that the box.blockSize is less than 150 pixels. And the box.inlineSize is also less than 150. Then if it's less than 150, we just need to update the target styles.我们知道borderBoxSize是一个包含单个元素的数组，所以我们选择这个盒子。现在我们需要检查这个盒子的blockSize是否小于150像素，同时box.inlineSize是否也小于150像素。如果两者都小于150像素，我们只需要更新目标样式即可。

[00:02:14]  
So we set the style and we set borderRadius equals to 100%. And then we also set target style.border. And let's apply the 4 pixels border instead. And if it's not the case then we just reset the styles again. So we can just copy this over, paste it. And set the unset flag.所以我们设置了样式，并将borderRadius设为100%。然后我们还设置了target style.border。我们来改用4像素的边框。如果情况并非如此，我们就再次重置样式。所以我们可以直接复制这个，粘贴上去。然后设置unset标志。

[00:02:47]  
Evgenii Ray: So now our observer is created. Let's, query the book settlements, boxes = document.querySelectorAll, and then provide the class name of the box.叶夫根尼·雷：现在我们的观察器已经创建好了。让我们查询书籍结算，boxes = document.querySelectorAll，然后提供这个盒子的类名。  
Evgenii Ray: And then for each box,叶夫根尼·雷：然后对于每个盒子，  
Evgenii Ray: We just register the app server. And if we run the browser now, we should see that now it works.叶夫根尼·雷：我们刚刚注册了应用服务器。如果我们现在运行浏览器，应该会看到它已经可以正常工作了。

[00:03:20]  
So we have our four rectangles that resize, becomes a circle and rectangular again. So the main idea of the resize observer is very useful for the application where you have multiple windows. So for instance, it can be trading app. And the very common use case, you have some charts on your training app.所以我们有四个可以调整大小的矩形，它们会变成圆形，然后又变回矩形。因此， resize observer（ resize 观察器）的主要理念对于有多个窗口的应用程序非常有用。例如，它可以是交易应用程序。在一个非常常见的使用场景中，你的交易应用程序上会有一些图表。

[00:03:41]  
And you need to update the toolbar, how the toolbar looks like for each chart. So you can set up one observer to track all the charts on the page, and then the toolbar will be updated with a single observer. And let's quickly overview the solution. So we basically created the observer, loop through the all entries, and check if the size less than 150 on the target element.而且你需要更新工具栏，以及每个图表对应的工具栏样式。所以你可以设置一个观察器来跟踪页面上的所有图表，这样工具栏就可以通过单个观察器进行更新。让我们快速概述一下这个解决方案。我们基本上是创建了一个观察器，遍历所有条目，并检查目标元素的尺寸是否小于150。

[00:04:05]  
We update the styles and then unset them if it's not the case. Then we create all the boxes and register the observer.我们更新样式，如果情况并非如此，就取消设置这些样式。然后我们创建所有的盒子并注册观察器。  
Speaker 2: So it changes once you hit that 150, but as you keep moving it, if you're staying under that 150, is it still reapplying those styles over and over again?发言者2：所以一旦达到150，它就会发生变化，但如果继续调整，且数值保持在150以下，它是否还会反复应用那些样式呢？

[00:04:25]  
Basically is it- 基本上是——  
Evgenii Ray: Yeah, so the callback is fired. So you still need to probably debounce your callback to make sure that it's not firing too often, but it will be much more performant than your resize event.叶夫根尼·雷：是的，所以回调函数会被触发。所以你可能仍然需要对回调函数进行防抖处理，以确保它不会过于频繁地触发，但这会比你的 resize 事件性能好得多。  
Speaker 2: For sure. 当然。  
Evgenii Ray: So observer API is a very performant way for implementing complex patterns.所以观察者API是实现复杂模式的一种非常高效的方式。

[00:04:48]  
So if you're in your application, you have a legacy way how you implement such things for instance, with intersection user type is set to interval, or with resizer event. You're trying to check the element size, then it's better to replace with Observer API. Observer API already have 99, 98% support of the clients, so for the rest 2% of the clients, you still can do the polyfill that will not be as performant, but at least for 98% of the client, you will deliver a good app experience.所以，如果你在开发应用程序时，采用了传统方式来实现这类功能，例如将交叉用户类型设置为间隔，或者使用调整器事件。你试图检查元素大小，那么最好用Observer API来替代。Observer API已经获得了99%、98%的客户端支持，因此对于剩下2%的客户端，你仍然可以使用性能可能稍逊的填充工具，但至少对于98%的客户端，你能提供良好的应用体验。

[00:05:23]  
Speaker 2: Do the inline size and box size values change when text is being written vertically, like in Japanese? Or can you assume that inline is always horizontal and block is always-发言者2：当文本像日语那样垂直书写时，行内尺寸和盒尺寸的值会发生变化吗？或者可以假设行内始终是水平的，而块始终是——  
Evgenii Ray: Yeah, this changes with the settings LTR or RTL, and if you render things from top to bottom, but instead you can change the perspective how you render things.叶夫根尼·雷：是的，这会随着从左到右（LTR）或从右到左（RTL）的设置而变化，而且如果你是从上到下渲染内容的话，但你也可以改变渲染内容的视角。

[00:05:49]  
Then the inline size will track the height instead and the other property will track the width. So you need to check the CSS spec exactly when it happens.那么内联尺寸将转而跟踪高度，而另一个属性将跟踪宽度。因此，你需要准确查阅CSS规范，了解这种情况何时发生。  
Speaker 2: One more question, does mutation observer with sub tree true for poor performance if we have 1,000 child nodes?发言者2：再问一个问题，如果我们有1000个子节点，设置subtree为true的突变观察器（mutation observer）会不会影响性能？  
Evgenii Ray: So it might be an issue on the low hardware, but because the mutation observer is actually implemented on a native level, then the performance should be still good.叶夫根尼·雷：所以这在低端硬件上可能是个问题，但由于突变观察器实际上是在原生层面实现的，其性能应该仍然不错。

[00:06:22]  
But it's always better to provide the specific configuration what you track. Make sure that you don't track too many things. If you want to track just the character data across the whole tree, then make sure you filter out the attributes changes and the DOM node changes. So this way you can optimize the performance.但最好还是提供你所追踪的具体配置。确保不要追踪过多内容。如果你只想追踪整个树中的字符数据，那么一定要过滤掉属性变化和DOM节点变化。这样你就能优化性能了。

[00:06:42]  
But of course, if you're trying to track 10,000 elements then even on a native level, you may end up having the issues. The way how you can optimize tracking, for instance, how the markdown editors do that. So when you select specifically client, so instead of tracking the full document child tree, you set up the observer dynamically on this specific line selected by the user.但当然，如果你试图追踪10,000个元素，那么即使在原生层面，你也可能最终遇到这些问题。优化追踪的方法，比如markdown编辑器的做法。当你专门选择客户端时，你不会追踪整个文档的子树，而是在用户选择的特定行上动态设置观察器。

[00:07:10]  
And when the user types, you track only single line of data. And that's how you can optimize the mutation observer.当用户输入时，你只需跟踪单行数据。这就是优化突变观察器的方法。




