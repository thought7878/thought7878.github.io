视频讲述了*应用程序UI状态构建*的相关知识，包括*数据的分类、属性，设计原则，数据规范化方法，搜索优化手段，内存管理、存储选择*等内容，具体如下：

## 数据的分类与属性
[00:00]
存储在UI上的数据包含*数据类和数据属性*两个方面。**数据类**有`应用配置`（如用户主题、语言等）、`UI元素状态`（如Google文档中元素的特殊格式状态）、`服务器存储数据`（从服务器获取用于渲染UI新元素的数据）；**数据属性**包括`访问级别`（全局或本地）、`读写频率`（高频率读写需用异步存储或运行时内存）、`数据大小`（数据越大越可能阻塞UI读取）。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/93bf6bd9f1a99260b8eb2c43f1b2a7e3_MD5.jpeg]]

## 应用状态设计的通用原则
[01:50]
一是**确保数据访问成本最低，数据应至少在常数时间内可访问**，
二是考虑*搜索优化使应用内搜索操作快速*；
三是**优化内存使用**，避免存储过多内容**导致资源过度占用和内存耗尽**。
![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/f8a4dbf7e8084f093d7283fa778efee4_MD5.jpeg]]

## 即时通讯应用案例、初始存储问题
[02:35]
以即时通讯应用*渲染联系人列表*（含数千条消息）为例，*直接将所有数据存入全局状态，存在问题*，访问特定联系人的特定消息**需两次筛选**，**遍历数组获取单个元素效率低，非最佳方案**。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/6bc38535e292353d96a793206af92456_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/28784e8a6ce2bf878e4289f03626f45d_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/5dcef86bd3f9947e8c8c0c78ea20ea9c_MD5.jpeg]]

## 数据规范化、范式应用
[03:44]
`数据规范化 Data Normalization`是数据库广泛使用的概念，**目的**是优化访问性能和数据结构，提升代码可读性，遵循范式规则（共七种，UI应用常用两到三种）。
`第一范式`要求对象**字段原子化，减少嵌套结构**；
`第二范式`要求所有字段应理想地依赖于实体，将依赖的非主键的字段拆分到独立对象，**key为主键（id）、value为包含字段的对象**；
`第三范式`强化非主键仅依赖实体主键的规则，进一步解耦数据。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/95e88b4f634d7faf0260b6039e95a4ba_MD5.jpeg]]

第一范式：
![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/9ebc47314e417b5b06c334992066b6d0_MD5.jpeg]]

第一范式->第二范式：
![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/16e96609e94dda26d5849520024976e7_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/18193d51fc86f2c9fc3043a7feb6181d_MD5.jpeg]]

第二范式->第三范式：
![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/f923a99d1d0618737034ae9dc23d2061_MD5.jpeg]]


### 即时通讯应用数据规范化实践
[08:10]
将即时通讯状态转换为第二范式，减少嵌套层级，移除对话和消息的嵌套，存储对话ID而非对象，创建新的对话类型（含ID和标题），确定各数据（联系人、消息、对话）的主键，通过ID快速访问对应数据。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/48394296ab4760f8a600136a0c6a2a6d_MD5.jpeg]]

### 搜索优化方法
[09:38]
**为解决数组查找特定消息需遍历的问题**。
构建`倒排索引表`，提取*消息内容词语作为键*，存储消息ID、出现位置及时间戳。可*利用异步任务（如Web Worker、事件循环空闲周期）构建*。
还可*构建复合键作为倒排键*，存储所有可能前缀类型及消息ID、时间戳，实现*前缀搜索*。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/e17db2d61fe4e61bc3176f84088da5fd_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/bcc74f82d3f9a49967d1ffd498256dc7_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/8a7fa2e5eaacb48b6ae46c79a79e5a7a_MD5.jpeg]]


### 内存优化、数据分片
[12:20]
**倒排索引表可能过大耗尽内存**。
可将未激活对话等数据*外包到独立存储*（如硬盘存储），实现数据分片(sharding)，类似数据库分片概念，*仅在需要时将数据从硬盘存储加载回运行时内存*，释放无用数据让垃圾回收器回收空间。

我们把这个元素移到单独的存储中，本质上是对数据进行了分片处理。这基本上就类似于浏览器中的数据库概念，在这种数据库里，你*不会只有一个大型的数据库实例，而是会有多个分片，数据会被部分存储在这些不同的分片当中*。**当你执行查询时，实际上是在从不同的分片进行查询**。这里的情况也是如此，但我们**仅限于两个分片。一个是我们的全局状态，也就是运行时内存。第二个是我们的硬盘**。因此，当我们将元素移至硬盘时，我们会让JavaScript引擎利用内存中的所有对象，并让垃圾回收器释放空间。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/44028ba4160c47da202778f144c99a76_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/fa8655b7ceaf84ff40a30bc51c377d0d_MD5.jpeg]]

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/08675ede40fa72aa876a3d8c7f3c853e_MD5.jpeg]]

## 浏览器存储API对比
[14:15]
`浏览器存储API`有三种类型：
- `会话存储`适合存储**小型非持久**数据，*会话结束数据清除*；
- `本地存储`适合存储**小型**数据（如用户偏好），**支持持久化**，但二者均**仅支持字符串类型**且**同步操作易阻塞UI线程**；
- `IndexedDB存储`**容量大**（平均为3GB），**支持索引（含复合索引）、多种数据类型**，**异步操作**不阻塞UI线程，适合**存储复杂对象和实现搜索功能**。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/e3bb78a71ff93be6517de2bf1bd17576_MD5.jpeg]]

## 应用状态设计总结
[16:06]
设计应用状态需先明确数据规模，结构化数据并利用范式优化访问成本，需搜索操作则构建索引，存储大量数据时转移到硬盘存储；根据数据读写频率和大小选择合适存储类型，频繁读取的小型数据用同步存储（本地存储或会话存储），提升应用响应速度。

![[_posts/architect/System Design/课程：Front-End System Design/06.Application State & Network Connectivity/media/0b2e94720902620cda1068bd86e8fae9_MD5.jpeg]]

---

## “应用状态设计”课程文字稿

Evgenii discusses strategies for managing state in an application. Understanding the trade-offs between IndexedDB, SessionStorage, and LocalStorage and normalizing forms will help optimize access costs. Indexes should be used if an in-app search is required.
叶夫根尼讨论了**应用程序中状态管理的策略**。*了解IndexedDB、SessionStorage和LocalStorage之间的权衡以及表单规范化，将有助于优化访问成本*。如果需要应用内搜索，则应使用索引。



[00:00:00]  
>> Evgenii Ray: Let's discuss how we built the UI state in our applications. So the data that we store on the UI has two properties. It actually has two things, the data class, so the type of data that we store, and the data properties. The data type, the data classes can be the app configuration, like user theme, locale, font size, or accessibility settings.>> 叶夫根尼·雷：让我们来讨论一下我们是如何在应用程序中构建用户界面状态的。我们存储在用户界面上的数据有两个属性。实际上它包含两方面，一是数据类，即我们存储的数据类型；二是数据属性。数据类型、数据类可以是应用程序配置，比如用户主题、区域设置、字体大小或辅助功能设置。

[00:00:25]  
It can also be the UI elements state, for instance, in Google Docs, you can select some special formatting and your element will keep the state. Or it can be the server data that we store from the server and use to render a new elements in the UI. Then we have the data properties.它也可以是用户界面元素的状态，例如，在谷歌文档中，你可以选择一些特殊格式，你的元素将保持该状态。或者，它可以是我们从服务器存储的、用于在用户界面中渲染新元素的服务器数据。然后我们就有了数据属性。

[00:00:51]  
Each data class can have different data properties, for instance, the access level, should the data be global or local, read and write frequency. So if we expect that the data is read often, so there is a high frequency write or read, then we can't us synchronous storages because we'll block the UI thread.每个数据类可以有不同的数据属性，例如访问级别、数据应是全局的还是局部的、读写频率等。因此，如果我们预计数据会被频繁读取，即存在高频的写入或读取操作，那么我们就不能使用同步存储，因为这会阻塞用户界面线程。

[00:01:14]  
So we need to make sure that this data either in the synchronous storage or in our runtime memory. So it's also the size, the larger the data, there is a high chance that we'll block our UI thread because we'll need to utilize a lot of CPU to process such data.所以我们需要确保这些数据要么在同步存储中，要么在我们的运行时内存中。因此，数据的大小也很重要，数据越大，我们阻塞UI线程的可能性就越高，因为我们需要占用大量CPU来处理这类数据。

[00:01:38]  
If you're trying to parse 500 megabytes file, then it will take a lot of time to actually read this data and also process this data into the object. And there are some general principles that we can apply when we design the application state. The first one, the more generic one, we need to make sure that the access cost to this data is minimal.如果你要解析一个500兆字节的文件，那么实际读取这些数据并将其处理成对象会花费大量时间。在设计应用程序状态时，我们可以遵循一些通用原则。第一条，也是更具普遍性的一条，就是我们需要确保对这些数据的访问成本降至最低。

[00:02:04]  
So our data should be accessible at least in the constant time. Once we optimize that, we can think about the search optimization. We need to make sure that the search operation in our app is fast. And the last part, we need to somehow optimize the memory usage. The more things we store in the application, the more likely we're going to utilize too many objects, and we can easily bloat our RAM.因此，我们的数据至少应该能在常数时间内访问。一旦对此进行了优化，我们就可以考虑搜索优化了。我们需要确保应用程序中的搜索操作速度很快。最后一点，我们需要以某种方式优化内存使用。我们在应用程序中存储的东西越多，就越有可能使用过多的对象，这样很容易导致内存膨胀。

[00:02:35]  
So let's get the practical kind of example. So we have the Messenger app where we render the contact list, and each contact has a conversation where we can have thousands of messages potentially.那么我们来举一个实际的例子。比如我们有一个即时通讯应用，在这个应用中我们会显示联系人列表，而每个联系人都有一个对话，这个对话中可能有数千条消息。  
>> Evgenii Ray: And how would you optimize that? So the most obvious approach will be just to put everything into the context state and the global state.>> 叶夫根尼·雷：那你会如何优化呢？最明显的方法就是把所有东西都放进上下文状态和全局状态中。

[00:03:03]  
But there is a problem with that. So if you want to access a contact with id Jane Smith, and we want to find any message with id 5, then we're going to do two hoops. First, we're gonna filter out the contacts, then we're going to filter out the messages.但这存在一个问题。所以，如果你想访问ID为Jane Smith的联系人，并且我们想找到ID为5的任何消息，那么我们需要进行两个步骤。首先，我们要筛选出联系人，然后再筛选出消息。

[00:03:22]  
This is although acceptable, it's still not the best way because if we have potentially thousands of messages, then we need to traverse the whole array just to access single element. This is not the way we want to design our app. So the first technique that we can use to optimize our data is to change how we store it.虽然这是可以接受的，但它仍然不是最佳方式，因为如果我们有潜在的数千条消息，那么我们需要遍历整个数组才能访问单个元素。这不是我们设计应用程序想要采用的方式。因此，我们可以用来优化数据的第一个技巧是改变存储数据的方式。

[00:03:51]  
And there is a concept called data normalization. So the data normalization has been around for, I think, 20 or 30 years already. So it's a concept used and the database is heavily. The goals of data normalization is to provide optimized access performance and also provide the optimized structure, how we store the data.有一种概念叫做数据规范化。我认为，数据规范化已经存在二三十年了。这是一个被广泛使用的概念，在数据库中应用尤为频繁。数据规范化的目标是提供优化的访问性能，以及提供优化的数据存储结构。

[00:04:15]  
And if we have a unified structure, how we store things in a state, it increases the readability of our code and for maintenance. And data normalization operates with the normal forms, they're in total seven normal forms. And the farther you go, the more you normalized. In the UI apps we usually utilize only two or three normal forms, and let's go through the process of data normalization.如果我们有一个统一的结构，以及在状态中存储内容的方式，这会提高代码的可读性和可维护性。数据规范化遵循范式，总共有七种范式。规范化程度越高，你走得就越远。在用户界面应用程序中，我们通常只使用两到三种范式，下面我们来了解一下数据规范化的过程。

[00:04:47]  
So if we take the first example where we have a simple object with the id and name and then it has the job and location. So right now it's a non-normalized object. So we can optimize this by applying the first normal form, and what the first normal form does is tells us that every field on your object should be atomic.那么，如果我们看第一个例子，其中有一个包含id、名称的简单对象，然后它还有职位和地点信息。目前这是一个非规范化的对象。我们可以通过应用第一范式来优化它，第一范式的作用是告诉我们，对象上的每个字段都应该是原子性的。

[00:05:12]  
So we need to reduce any nesting in our objects. So we just flatten the nested objects here.所以我们需要减少对象中的任何嵌套。因此，我们只需在这里将嵌套对象扁平化。  
>> Evgenii Ray: The job object becomes the job_id and job_title, and the location becomes country_code and the country_name. Also the first normal form tells us that there should be the primary key, and we know that we already have the primary key, which is the id that we can utilize.>> 叶夫根尼·雷：工作对象会变成job_id和job_title，地点会变成country_code和country_name。此外，第一范式告诉我们应该有主键，而且我们知道我们已经有了主键，也就是我们可以使用的id。

[00:05:45]  
So next, we can convert our first normal form to the second normal form. And what the second normal form does, it tells us that all our fields now ideally should depend on the entity. So if we look at the following fields, the job_id and job_title, the job_title actually depends on the job_id, although it also depends on our user object.接下来，我们可以将第一范式转换为第二范式。第二范式的作用是，它告诉我们现在所有的字段理论上都应该依赖于实体。所以，如果我们看以下字段，job_id和job_title，job_title实际上依赖于job_id，尽管它也依赖于我们的用户对象。

[00:06:15]  
So the data summarization tells us that we need to decouple this into the separate table in the database concept, but in our case, it will be the separate object. So we move our job to the jobs table. Now we have the key, which is UIE as a job id, and now we have the information relevant to this job.因此，数据总结告诉我们，在数据库概念中，我们需要将其拆分为单独的表，但在我们的案例中，它将是单独的对象。所以我们把工作移到了工作表中。现在我们有了键，即作为作业ID的UIE，并且现在我们有了与该作业相关的信息。

[00:06:39]  
And we also normalized the user jobs, so we can access what type of job the user has by providing the id. So now all our entities depend on the primary key. There is a third normal form.而且我们还对用户职位进行了规范化处理，这样我们就可以通过提供ID来获取用户的职位类型。所以现在我们所有的实体都依赖于主键。这符合第三范式。  
>> Evgenii Ray: Actually, yeah, also we move the countries to separate table. There is a third normal form that tells us the main difference from the second one.>> 叶夫根尼·雷：实际上，是的，我们还把国家移到了单独的表格中。第三范式指出了它与第二范式的主要区别。

[00:07:11]  
We say that non-primary keys should depend on the entity primary key. But the third normal form enforces this rule, saying that it should depend only on the primary key, and the difference is very subtle. So if we look at the UIE job, it has a title and department.我们说非主键应该依赖于实体的主键。但第三范式强化了这一规则，指出非主键应该只依赖于主键，这里的区别非常细微。所以，如果我们看看UIE的工作，它有一个标题和部门。

[00:07:31]  
So department really might not be directly related to the UI or to the title. So we want to decouple that to say, okay, the department should directly depend on the UIE id. So we move the department to additional table and now we can access the department type by providing the job id.因此，部门可能确实与用户界面（UI）或标题没有直接关联。所以我们希望将其解耦，也就是说，部门应该直接依赖于UIE标识。因此，我们将部门移至附加表中，现在我们可以通过提供职位标识来获取部门类型。

[00:07:59]  
The third normal form sometimes is excessive. Usually on the UI, we use the second normal form. So it's up to your case if you want to apply an app. So if we go back to our Messenger example, let's try to convert our non-normalized data, the state of the Messenger, to second normal form.第三范式有时过于严苛。通常在用户界面上，我们会使用第二范式。因此，是否要在应用程序中采用它取决于具体情况。那么回到我们的Messenger示例，让我们尝试将非规范化的数据，也就是Messenger的状态，转换为第二范式。

[00:08:24]  
So first we want to reduce the nesting. So we want to remove the conversation and the messages. So once we remove the conversation and the messages objects from from a table. Now we apply the Atomic Fields rules. Now we store the conversation_ id instead of the object, and on the message we also store the conversation_id.所以首先我们要减少嵌套。我们想要移除会话和消息。一旦我们从表中移除会话和消息对象。现在我们应用原子字段规则。现在我们存储conversation_id而不是对象，在消息上我们也存储conversation_id。

[00:08:52]  
And we also create a new type called conversation, which has the id and the title, and we also remove the messages from the conversation.并且我们还创建了一种名为对话的新类型，它包含ID和标题，同时我们还从对话中移除了消息。  
>> Evgenii Ray: Now we identify the primary keys. So for the contact, it will be id, for the message, it's a message_id, for the conversation, it's also id.>> 叶夫根尼·雷：现在我们来确定主键。联系人的主键是id，消息的主键是message_id，会话的主键也是id。

[00:09:14]  
And then we store these fields on the global state. So now to access the message with a certain id, we just provide an id. And it will return us the message, the same for conversation and for the contact. So although, you still may notice that to find specific message in the array, we still need to traverse all the messages.然后我们将这些字段存储在全局状态中。所以现在，要访问具有特定ID的消息，我们只需提供一个ID。它会返回给我们该消息，对话和联系人的情况也是如此。不过，你可能仍然会注意到，要在数组中找到特定的消息，我们仍然需要遍历所有消息。

[00:09:37]  
How can we optimize even that? So let's move on to the second principle, minimize the search cost.我们如何进一步优化这一点呢？那么让我们来看第二个原则：最小化搜索成本。  
>> Evgenii Ray: So we could potentially build an index table, which we'll call inverted index table. It's called inverted because the content of the entity becomes the key in this sense. So what we're gonna do, we're gonna extract all the words from the message content.>> 叶夫根尼·雷：所以我们有可能构建一个索引表，我们称之为倒排索引表。之所以叫“倒排”，是因为从这个意义上来说，实体的内容成了键。所以我们要做的是，从消息内容中提取所有的单词。

[00:10:08]  
And then we're gonna build the index table where the key is the word from the content of the message, and we're gonna store the id of the message where this content appears. And a timestamp that will help us to sort out search results in the timestamp order. So later, we can utilize some asynchronous job to build this inverted index table.然后我们要构建一个索引表，其中键是来自消息内容的单词，我们会存储该内容出现的消息的ID，以及一个时间戳，这个时间戳将帮助我们按时间顺序对搜索结果进行排序。这样一来，我们之后就可以利用一些异步任务来构建这个倒排索引表。

[00:10:41]  
This can be a web worker, that will access the IndexedDB and store it in the storage, or you can use the idle cycle of your event loop to build this index table in your application. But you may notice that, okay, I can search by the word. But what if I want to search by the prefix?这可以是一个网络工作线程，它会访问IndexedDB并将其存储在存储器中，或者你可以利用事件循环的空闲周期在应用程序中构建这个索引表。但你可能会注意到，好吧，我可以按单词进行搜索。但如果我想按前缀搜索呢？

[00:11:05]  
Can we improve it even further? And apparently we can, we can use the composite key for the invertening of this table. So now we're gonna store all personal prefixes of the word and keep the message id and the timestamp. So if we type in the search bar, for instance, ja, this will give us all the messages where we saw the ja in the conversation thread.我们还能进一步改进它吗？显然是可以的，我们可以使用复合键来反转这个表。所以现在我们要存储这个词的所有个人前缀，并保留消息ID和时间戳。例如，如果我们在搜索栏中输入“ja”，这将为我们显示所有在对话线程中出现过“ja”的消息。

[00:11:39]  
So we can store in JavaScript the string as array because the key should be always a string. That's where the storage comes in. So before we discuss the storage, let's understand how we're gonna manage the memory. So, yep?所以我们可以在JavaScript中把字符串存储为数组，因为键应该始终是字符串。这就是存储的用武之地。那么在讨论存储之前，我们先来了解一下我们要如何管理内存。好吗？  
>> Speaker 2: So in this example, there's just two messages, but in theory, if you had multiple messages that started with hey, those would all end up under that single either [CROSSTALK] composite key->> 发言者2：所以在这个例子中，只有两条消息，但理论上，如果你有多个以“嘿”开头的消息，它们最终都会归到那个单一的——[交叉通话]复合键之下。

[00:12:13]  
>> Evgenii Ray: Yeah, so you will have multiple tuples here.是的，所以这里会有多个元组。  
>> Speaker 2: Okay. >> 发言者2：好的。  
>> Evgenii Ray: So the inverted index table may become large. So for instance, we may have already a 1,000 of messages in each conversation thread, so we don't want to blow the memory of the device. So how can we optimize that?>> 叶夫根尼·雷：所以倒排索引表可能会变得很大。例如，每个对话线程中可能已经有1000条消息，所以我们不希望占用过多设备内存。那么我们该如何优化呢？

[00:12:35]  
Right now, we have the conversation with John, but we know that there are two more conversation that are not active. So we can just select them from the state, since we know the conversation ID, and we can filter out the entries. Now what we can do, we can outsource that to the separate storage.现在，我们正在和约翰交谈，但我们知道还有另外两个未激活的对话。所以我们可以从状态中选择它们，因为我们知道对话ID，而且我们可以筛选出这些条目。现在我们能做的是，把这个任务交给单独的存储系统来处理。

[00:13:01]  
So we move this element to the separate storage, and we basically sharded our data. So it's basically, the database concept in the browser where, in the database, you don't have the single large DB instance. So you have a shard and you store your data partially in multiple shards.
所以我们把这个元素移到单独的存储中，本质上是对数据进行了分片处理。这基本上就类似于浏览器中的数据库概念，在这种数据库里，你不会只有一个大型的数据库实例，而是会有多个分片，数据会被部分存储在这些不同的分片当中。

[00:13:22]  
And when you do the query, you're actually querying from the different shards. The same way happens here, but we are limited to two shards. One is our global state, which is runtime memory. And the second one is our hard drive. So when we move elements to the hard drive, we let the JavaScript engine to utilize all the objects from the memory and let the garbage collector free up the space.
当你执行查询时，实际上是在从不同的分片进行查询。这里的情况也是如此，但我们仅限于两个分片。一个是我们的全局状态，也就是运行时内存。第二个是我们的硬盘。因此，当我们将元素移至硬盘时，我们会让JavaScript引擎利用内存中的所有对象，并让垃圾回收器释放空间。

[00:13:48]  
And for instance, if we selected the new conversation and we want to load the data back to the store, we can utilize the storage to just populate this back to our runtime memory. And we basically are going to swap back and forth the data. And now the question is, what type of storage should I use to achieve such behavior?
例如，如果我们选择了新的对话，并且想要将数据加载回存储中，我们可以利用存储器将其重新填充到运行时内存中。基本上，我们会来回交换数据。现在的问题是，我应该使用哪种类型的存储来实现这种行为？

[00:14:17]  
And let's do the quick overview. So the storage API provides three types of storages for us. It's the Indexed DB, local storage, and the session storage. So the session storage is good for storing some small non-persistent data, so it stores things only for one single session. When the user closes the website, the session is destroyed and the data is wiped.让我们快速浏览一下。存储API为我们提供了三种类型的存储方式，分别是Indexed DB、本地存储和会话存储。会话存储适合存储一些小型的非持久性数据，它只在单个会话中存储数据。当用户关闭网站时，会话会被销毁，数据也会被清除。

[00:14:46]  
The local storage on the other hand is good for storing small things, it can be user preferences, you can also store non-persistent data and discard it if you want. But the local storage provides persistence. But the problem with the local storage and the session storage, they only support the string type and they are asynchronous.另一方面，本地存储适合存储小数据，比如用户偏好，你也可以存储非持久性数据，并在需要时将其丢弃。但本地存储具有持久性。不过，本地存储和会话存储存在一个问题，它们只支持字符串类型，而且是异步的。

[00:15:07]  
So if you have a data that you expect to read a lot and write, then you will block the UI thread, and it will impact your application responsiveness. So what do we need to do to re-implement the behavior we discussed previously on the slides? So the IndexedDB, on the other hand, has the almost unlimited storage capacity, on average 3 gigabytes, and it also supports indexing.所以，如果你有一个你期望频繁读写的数据，那么你会阻塞UI线程，这会影响你的应用响应性。那么，我们需要做些什么来重新实现我们之前在幻灯片上讨论过的行为呢？另一方面，IndexedDB拥有几乎无限的存储容量，平均为3GB，并且它还支持索引。

[00:15:34]  
So we can create a composite index we discussed and store the key as a set of prefixes. And we can actually enable this search using the IndexedDB, so we can utilize this index. And also the IndexedDB supports multiple type of data, which is very useful when we store complex objects.所以我们可以创建一个我们讨论过的复合索引，并将键存储为一组前缀。实际上，我们可以使用IndexedDB来启用这种搜索，这样就能利用这个索引了。而且IndexedDB支持多种数据类型，这在我们存储复杂对象时非常有用。

[00:15:56]  
And it's also non-blocking. So it's a synchronous, it means that we will not block the UI thread in this case.而且它还是非阻塞的。所以这是同步的，意思是在这种情况下我们不会阻塞UI线程。  
>> Evgenii Ray: So the summary for application state design is first, you need to know your scale. Always start with the way how you structure your data, and use normal forms to provide optimized access cost.>> 叶夫根尼·雷：所以关于应用状态设计的总结是，首先，你需要了解自己的规模。始终从数据的结构化方式入手，并使用范式来优化访问成本。

[00:16:23]  
And use indexes if you're planning to do the search operations in your app. If you think that you will need to store a good amount of data in your state, then offload the data to a hard drive. For us as developers, it's basically, the free space that we can use.如果你打算在应用程序中执行搜索操作，请使用索引。如果你认为需要在状态中存储大量数据，那么就将数据转移到硬盘上。对我们开发者来说，这基本上就是我们可以使用的空闲空间。

[00:16:42]  
It will improve your responsiveness of the app. And also you need to be mindful about the type of storage you use. Utilize the data properties, if you expect it to read the data a lot, use the asynchronous storage. For small things, utilize the local storage or the session storage.这将提高你的应用程序的响应速度。而且你还需要留意所使用的存储类型。如果需要频繁读取数据，请利用数据属性，使用异步存储。对于小型数据，则使用本地存储或会话存储。

[00:17:03]  
And that's it for the application state design.关于应用状态设计的内容就这些了。
