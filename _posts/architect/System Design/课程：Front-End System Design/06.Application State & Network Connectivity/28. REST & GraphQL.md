

视频讲述了在应用中引入GraphQL需考虑的代价、REST与GraphQL的选择决策因素以及GraphQL的适用场景，具体如下：

## 引入GraphQL的代价
[00:00]
引入GraphQL时，需添加新的客户端库以配合服务器的GraphQL API，添加新的客户端缓存层维护缓存，还需新的状态管理器确保客户端与服务器同步，同时可能影响网页包体积。


## 应用规模对API选择的影响
[00:56]
若应用非常小，使用经典REST足够，无需GraphQL，因GraphQL会增加复杂度；若为中型或大型应用，则需进一步考虑其他因素来选择API。


## 公共API规划对API选择的影响
[01:07]
对于中型或大型应用，若计划构建公共API，经典REST可能是更好选择，因为大多数客户端期望REST API。


## 请求比例与团队/预算对API选择的影响
[01:24]
当中型或大型应用不规划公共API时，需看请求比例，若大部分请求是只读且预算或团队规模有限，REST更合适，可利用默认HTTP服务器缓存和客户端缓存简化架构；若团队规模大或预算充足，仍可选择GraphQL，但需进一步判断是否使用同构类型。


## 同构类型对API选择的影响
[01:58]
同构类型指服务器数据类型在客户端间共享且关系紧密，若符合此情况，GraphQL可能值得考虑；若不符合，需进行大量数据转换，经典REST仍是更好选择。


## 包体积与API模型复杂度对API选择的影响
[02:23]
若包体积增加500KB关键，且经典REST需要复杂API模型，期望返回同一对象不同变体，这种情况下GraphQL可能是好选择。


## GraphQL的适用场景
[02:54]
GraphQL在复杂应用中价值最高，能帮助简化架构，例如在交易应用中，可通过GraphQL内部层封装短轮询、WebSocket等不同数据源的复杂性，包含订阅处理不同数据源，开发者在整个应用中使用同一订阅，内部由不同协议支持，简化从服务器获取数据的方式，减少技术差异和不同代码风格，保持统一，便于维护统一代码；在数据有多种变体时也适用，简单场景仍可用常规REST API。


## 后续内容预告
[05:12]
下一节将讨论应用程序的性能优化。

---

## “经典REST与GraphQL”课程文字稿

Evgenii compares classic REST APIs with GraphQL. Adding a GraphQL API introduces additional complexity, including requiring client libraries, caching layers, client state management for syncing data with the server, and the potential impact on JavaScript bundle size. GraphQL can also reduce complexity by providing a single API for client applications but multiple network implementations on the server.
叶夫根尼将经典的REST API与GraphQL进行了比较。添加GraphQL API会带来额外的复杂性，包括需要客户端库、缓存层、用于与服务器同步数据的客户端状态管理，以及对JavaScript包大小可能产生的影响。GraphQL也可以通过为客户端应用程序提供单一API来降低复杂性，但服务器上需要有多个网络实现。


[00:00:00]  
>> Evgenii Ray: Okay, REST vs GraphQL, so generally, when you want to introduce the GraphQL in your application, you need to think about the consequences. So it's you're adding the new client library to work with the server with your GraphQL API. You're adding the new additional client caching layer that maintains the cache for you.>> 叶夫根尼·雷：好的，REST与GraphQL，通常来说，当你想在自己的应用中引入GraphQL时，需要考虑其带来的影响。你要添加新的客户端库，以便通过GraphQL API与服务器交互。你还要添加新的额外客户端缓存层，由它来为你维护缓存。

[00:00:22]  
And you also add in a new state manager that ensures that your client is synced with a server. And there is also a potential impact on the web bundle size. So this is the tax that you pay when you introduce the GraphQL. And I would say, GraphQL is great, but there are use cases when you actually want to fall back to REST.而且你还加入了一个新的状态管理器，以确保你的客户端与服务器保持同步。这还可能会对网络包大小产生影响。所以这就是你引入GraphQL时需要付出的代价。我想说的是，GraphQL很棒，但在某些用例中，你实际上还是会想转而使用REST。

[00:00:46]  
So let's go for the schema. So I try to draw the decision diagram. [LAUGH] And so first, parameter that you need to consider is your application size. If it's a very small app, then you'll be fine with a classic REST. You don't need GraphQL, because GraphQL complicates things.那我们来看看这个模式吧。我试着画一个决策图。（笑）首先，你需要考虑的参数是你的应用规模。如果是一个非常小的应用，那么使用传统的REST就足够了。你不需要GraphQL，因为GraphQL会让事情变得复杂。

[00:01:05]  
If it's a medium or large size app, the next point is, are you planning to consider the public API? If you are planning to build the public API, then probably the classic REST is the way to go because most of the clients expect to have the REST API.如果是中型或大型应用程序，接下来要考虑的是，你是否打算开发公共API？如果计划开发公共API，那么经典的REST可能是合适的选择，因为大多数客户端都希望使用REST API。

[00:01:20]  
Then the next point is, how many of your requests are read-only? So if the good chunk of your request are read-only and you have a limited budget or the team size, then the REST would be better because you will be able to utilize the default HTTP server cache and the client cache.接下来一点是，你的请求中有多少是只读的？所以，如果你的大部分请求是只读的，并且你预算有限或团队规模较小，那么REST会更好，因为你可以利用默认的HTTP服务器缓存和客户端缓存。

[00:01:42]  
So you would simplify your architecture. But if you have the large team size or you have unlimited budget, you can still go with GraphQL. But one question you would ask is, do you use isomorphic types? Isomorphic types is when your server data types are shared between the clients, so they have a very close relation.所以你会简化你的架构。但如果你有庞大的团队规模或者预算不受限制，你仍然可以选择GraphQL。不过你会问一个问题，那就是你是否使用同构类型？同构类型指的是服务器数据类型在客户端之间共享，因此它们之间存在非常紧密的联系。

[00:02:08]  
So if this is the case, then the GraphQL might be considered. If it's not the case, then you need to do lots of transformation of the data, then it's probably the classic REST still better way to go. And then, is it critical for your bundle size to be increased by 1,500 kilobytes?那么，如果情况是这样的，或许可以考虑GraphQL。如果情况并非如此，那么你需要对数据进行大量转换，这时经典的REST可能仍然是更好的选择。此外，增加1500千字节的包大小对你来说是否至关重要？

[00:02:30]  
And if it's yes, again, classic REST. And do you expect to have your API model to be complex? Are you expecting to return different variation of the same object? In this case, the GraphQL might be a good decision, so we can choose the GraphQL. So as you can see, there are more nos than yes, but let me try to be unbiased.如果答案是肯定的，那同样，这是典型的REST风格。你是否期望你的API模型会很复杂？你是否期望返回同一对象的不同变体？在这种情况下，GraphQL可能是个不错的选择，所以我们可以选择GraphQL。正如你所见，否定的答案比肯定的多，但我会尽量保持客观。

[00:02:55]  
The GraphQL actually provides the most values in the Complex Apps. It's actually can help you to simplify the architecture sometimes. Consider the following case where you have a trading app, and within this trading API, you have three endpoints. One is using short polling, another one's WebSockets, and so they get orders that gives you your current orders, use the short polling.实际上，GraphQL 在复杂应用中能提供最大价值。它有时确实能帮助你简化架构。试想以下情况：你有一个交易应用，在这个交易 API 中，有三个端点。一个使用短轮询，另一个使用 WebSocket，通过短轮询可以获取订单，从而得知你当前的订单情况。

[00:03:20]  
Real time price, we're using WebSockets and getOrderUpdates using the server-sent events. So in your web application, you will have to use three different ways how you get the updates from your endpoints. So you can encapsulate these complexity on the internal layer by basically, having the GraphQL that has a subscription that implements different source stream.实时价格方面，我们使用WebSocket，并通过服务器发送事件获取订单更新。因此，在你的Web应用程序中，你必须使用三种不同的方式从端点获取更新。所以，你可以通过让GraphQL具有实现不同源流的订阅，在内部层封装这些复杂性。

[00:03:49]  
The source stream is just interface of the endpoint you're going to utilize. So the source stream can implement the short polling, the WebSockets, or server-sent events. So you can implement this on the source stream level. So your developers will use the same subscription across the whole application, but internally it will be backed by different protocols.源流只是你将要使用的端点的接口。因此，源流可以实现短轮询、WebSocket 或服务器发送事件。你可以在源流级别实现这一点。这样，你的开发人员将在整个应用程序中使用相同的订阅，但在内部它将由不同的协议支持。

[00:04:16]  
So this way, you can actually simplify the way how you fetch the data from the server, minimizing different code style and maintaining unified code. So this is the case where the GraphQL can really help. And I stand to the point that the GraphQL really helps in the Complex Apps where you have lots of variations of the data that you receive, and so on.这样一来，你实际上可以简化从服务器获取数据的方式，减少不同的代码风格，并保持代码的统一性。这正是GraphQL能真正发挥作用的场景。我坚持认为，GraphQL在复杂应用中确实很有帮助，比如在那些你会收到大量不同数据变体的应用中等等。

[00:04:44]  
And for simple cases, you will be good with a normal REST API.而对于简单的情况，使用普通的REST API就足够了。  
>> Evgenii Ray: And we're done, this is the section for network connectivity. So we basically walk through the different types of the APIs and now you have the good overview, what we can use. And you definitely need to work with the server folks to provide you such endpoints, but it's always good to understand what are the types of the protocols available to us.>> 叶夫根尼·雷：好了，这就是关于网络连接的部分。我们大致介绍了不同类型的API，现在大家应该对我们可以使用的工具有了清晰的了解。你们肯定需要和服务器端的同事合作，让他们为你们提供这样的端点，但了解我们可用的协议类型总是很有好处的。

[00:05:12]  
And the next section will be the performance optimization of our application.接下来的部分将是我们应用程序的性能优化。
