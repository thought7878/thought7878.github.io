
视频围绕店铺管理应用的网络通信需求，介绍了相关*网络协议、轮询技术的特点、问题与适用场景*，具体如下：

## 引入应用场景与核心问题
[00:00]
以构建店铺管理应用为背景，提出两个核心功能需求，即追踪新订单和与员工聊天，进而引出实现这些功能所需的技术及技术栈问题，并说明将先概述可用协议。


## UDP协议特点及应用
[00:27]
UDP协议不保证服务器发送的数据包能被客户端完整接收，存在数据丢失可能，但其主要优势是速度快，广泛用于视频流传输，即便丢失部分数据包导致视频流质量下降也影响不大，且未收到响应时服务器可继续发送。


## TCP协议特点、连接过程
[01:26]
TCP协议能确保客户端完整接收服务器发送的数据，通过“三次握手”建立连接，先由客户端发送同步包请求连接，服务器回复同步确认包表示可连接，客户端再确认后开始通信；不过TCP通常比UDP慢，核心优势是保证数据完整性。


## 相关衍生协议
[02:35]
网页运行的基本协议是TCP，HTTP 1.1、HTTP 2均基于TCP，其中HTTP 2继承HTTP 1特性且依赖TCP支持；WebSocket不使用HTTP协议发起后续请求，仅首次请求用HTTP，之后升级到TCP，完全基于TCP；基于HTTP 2的服务和事件是服务器推送技术；谷歌开发的Quick协议底层使用UDP，HTTP/3（视频中误称GDP Free）基于Quick协议，使HTTP从依赖TCP转向UDP；WebRTC用于流媒体传输。


## 长轮询与短轮询
[04:14]
长轮询和短轮询通过每隔指定时间（如20秒）调用常规GET请求（如用fetch请求）实现获取新订单等功能，实现简单，无需额外基础设施。


### 长轮询与短轮询的问题（一）：资源与能耗
[04:42]
依赖HTTP协议，建立连接时需进行类似“高速公路握手”的过程，速度较慢；建立HTTP连接会打开新的TCP套接字，消耗CPU资源且增加电量消耗；HTTP 1请求头部数据未压缩，每次请求可能发送50千字节头部数据，虽HTTP 2压缩头部数据有所改善，但仍需握手过程；在移动设备上，使用长轮询时设备会处于能耗较高的全双工模式，仅保持一个套接字打开，2000毫安电池约四小时就会耗尽。


### 长轮询与短轮询的问题（二）：延迟与状态
[07:33]
在移动设备处于高铁等场景切换网络基站时，需重新建立连接、发送头部信息并完成握手，多次切换会显著增加延迟；基于REST API的轮询请求无状态，切换连接时会丢失状态，需在服务器端重新搭建相关基础设施，长期支持对移动应用而言成本更高。



### 长轮询与短轮询的适用场景
[09:30]
长轮询实现简单、成本低且无需额外基础设施，适合桌面应用，因桌面应用无需考虑网络带宽、延迟（固定连接不切换基站）和电量消耗问题；但不适用于移动应用，也需为网页应用采用不同技术。




---

## “网络连接”课程文字稿

Evgenii reviews UDP and TCP protocols and explains UDP doesn't guarantee the order of the data packets received across the network. Other network considerations are discussed, including energy consumption and latency. This lesson also includes the pros and cons of using long polling
叶夫根尼（Evgenii）回顾了UDP和TCP协议，并解释了UDP无法保证通过网络接收的数据包的顺序。还讨论了其他网络方面的考量，包括能耗和延迟。本节课还涵盖了使用长轮询的优缺点。




[00:00:00]  
>> Evgenii Ray: So let's talk about how we talk to the server. Imagine that we're trying to build the Shop Administration app with two main endpoints. The one is to track new orders, the second one is to chat with employees. What are the technologies we would use for that, and what is the stack?>> 叶夫根尼·雷：那我们来谈谈如何与服务器通信。假设我们要构建一个商店管理应用，它有两个主要端点。一个用于跟踪新订单，另一个用于与员工聊天。我们会使用哪些技术，技术栈是什么？

[00:00:21]  
So let's first overview the protocols available to us. So there are two main protocols. One is UDP, the second one is TCP. The UDP is the protocol that doesn't guarantee the package from the server received in the full size. So when you receive the data from the UDP, you just request the server and the server does not ensure that the data is received by the client.那么我们先来概述一下可用的协议。主要有两种协议，一种是UDP，另一种是TCP。UDP是一种不保证从服务器接收的数据包完整的协议。所以当你通过UDP接收数据时，你只是向服务器发出请求，而服务器并不确保客户端能收到数据。

[00:00:57]  
So this means there is some data loss in process. This protocol is heavily used in video streaming where you can lose some data packages from file to transfer. So your video stream quality may lose some bytes, but it's not critical. So it basically provides the response and if the response is not provided, that's fine.这意味着在过程中存在一些数据丢失。该协议在视频流中被大量使用，在文件传输过程中可能会丢失一些数据包。因此，你的视频流质量可能会丢失一些字节，但这并不严重。所以，它基本上会提供响应，如果没有提供响应，也没关系。

[00:01:23]  
The server can continue to fire the response, but TCP is different. TCP ensures that the data requested by the client and sent by the server is received in full. So for that, it does the 3-way handshake. So basically, it calls the server with a synchronous package to tell, okay, server, I want to connect with you.服务器可以继续发送响应，但TCP有所不同。TCP确保客户端请求且服务器发送的数据被完整接收。为此，它会执行三次握手。基本上，它会用一个同步数据包呼叫服务器，告知对方：“好的，服务器，我想和你建立连接。”

[00:01:52]  
Then the server sends the sync acknowledge package, saying that, okay, client, I can also connect with you. And then the clients finally acknowledge, okay, let's have the conversation now. So this 3-way sync provides the kind of insurance that the data between the client and the server is received.然后服务器发送同步确认包，意思是，好的，客户端，我也可以和你连接。然后客户端最终确认，好的，我们现在开始对话吧。因此，这种三次同步提供了一种保障，确保客户端和服务器之间的数据能被接收。

[00:02:14]  
So and then the client makes a request. So and as you can see this because we need to do free network trips now, the TCP is generally slower than the UDP. So the main benefit of UDP is speed, while the TCP ensures data validity.然后客户端发出请求。正如你所看到的，因为我们现在需要进行多次网络传输，所以TCP通常比UDP慢。因此，UDP的主要优势是速度，而TCP则能确保数据的有效性。  
>> Evgenii Ray: And there are some branches of these protocols.>> 叶夫根尼·雷：而且这些协议还有一些分支。

[00:02:35]  
So the first and how, basically, the web runs is the HTTP protocol. The HTTP 1.1 is based on TCP, and there is also HTPP 2, which is basically the new protocol, but it still inherits the properties of HTPP 1, and it's still backed by the TCP and there are also web sockets.那么，首先，从根本上来说，网络的运行依赖于HTTP协议。HTTP 1.1基于TCP，此外还有HTTP 2，它本质上是一种新协议，但仍继承了HTTP 1的特性，且依然以TCP为支撑，另外还有WebSocket。

[00:02:58]  
So web sockets slightly different because they do not utilize htpp 1. They use htpp 1 only to initiate the first request for the server, and then they upgrade to TCP. So it's basically, the web sockets are fully TCP-based. And there is a server sent events that are based on htpp 2, which is the server push technology.所以WebSocket略有不同，因为它们不使用HTTP 1。它们仅使用HTTP 1来发起对服务器的第一个请求，然后升级到TCP。所以基本上，WebSocket是完全基于TCP的。还有基于HTTP 2的服务器发送事件，这是一种服务器推送技术。

[00:03:19]  
And we're gonna look at all of this protocols just in a few slides. Then there is a UDP, and UDP, there is a protocol developed by Google called QUIK. And QUIK is using the UDP under the hood. And the new protocol, HTPP 3, is actually based on the QUIK, which is based on UDP.我们将在几张幻灯片中了解所有这些协议。然后是UDP，还有一个由谷歌开发的基于UDP的协议，名为QUIK。而新的协议HTPP 3实际上是基于QUIK的，而QUIK则基于UDP。

[00:03:38]  
So we are moving from TCP to UDP soon for the ICP 3 protocol. And also there is a web RTC which is used for the streaming and even this stream now is stream probably for the web RTC now.所以我们很快将把ICP 3协议从TCP转向UDP。此外，还有用于流媒体的Web RTC，而现在这个流可能就是Web RTC的流。  
>> Evgenii Ray: Okay, let's get back to the examples with our application examples, so we have the first endpoint getting new orders.>> 叶夫根尼·雷：好的，让我们回到我们的应用示例，第一个端点是获取新订单。

[00:04:07]  
So how would we design this? So the first thing that we could use is the technique called long polling or short polling. It's basically making the normal get call every specify timeframe, for instance, every 20 seconds, and it's very easy to implement. So we can just set up the interval and use the fetch request and call the server every 20 seconds.那么我们该如何设计呢？首先，我们可以使用一种叫做长轮询或短轮询的技术。它本质上是在特定的时间间隔内发出常规的GET请求，例如每20秒一次，而且这种技术很容易实现。我们只需要设置一个时间间隔，然后使用fetch请求，每20秒调用一次服务器即可。

[00:04:37]  
So what are the issue of the log polling for getting new orders? So the first one is the HTTP protocol. Since we need to establish the 3-way handshake with the server, it will be pretty slow. And when we establish the HTTP connection, we open a new TCP socket.那么，通过日志轮询获取新订单存在哪些问题呢？首先是HTTP协议的问题。由于我们需要与服务器建立三次握手，这会非常慢。而且，当我们建立HTTP连接时，会打开一个新的TCP套接字。

[00:05:03]  
And TCP socket apparently takes CPU and also drains energy as a result. And it also has the property of an inefficient network usage because when you establish the connection with the server, you send the metadata, which is the headers, with the request. And if you are on HTTP 1, then the header data is not compressed and you may end up sending 50 kilobytes every request of just any header data and HTTP 2 improve the situation by compressing the headers.显然，TCP套接字会占用CPU，进而消耗能量。而且它还存在网络使用效率低下的问题，因为当你与服务器建立连接时，会随请求一起发送元数据，也就是头部信息。如果你使用的是HTTP 1，那么头部数据不会被压缩，每发送一次请求，可能仅头部数据就会达到50千字节，而HTTP 2通过压缩头部信息改善了这一情况。

[00:05:35]  
But we still have this 3-way handshake that we need to establish. And there is one thing is that the low polling and short polling actually drains the battery of the mobile devices because you need to maintain your TCP socket open. And when your TCP socket is open, the key thing how the mobile module is structured.但我们仍然需要建立这个三次握手。还有一点是，低轮询和短轮询实际上会消耗移动设备的电池，因为你需要保持TCP套接字处于打开状态。而当你的TCP套接字打开时，关键在于移动模块的结构方式。

[00:05:59]  
So in your phone, your mobile network module has two modes. One is model, it's basically, receive only, when this module in the receive only mode. So it's very energy efficient, but it can only receive the data. But there is also a duplex mode where you can send the data and receive the data.所以在你的手机里，移动网络模块有两种模式。一种是单工模式，基本上就是只能接收，当这个模块处于仅接收模式时，它的能效非常高，但只能接收数据。不过还有一种双工模式，在这种模式下你既可以发送数据，也可以接收数据。

[00:06:22]  
And it's not energy efficient as a result. So when we use the long polling, the mobile device utilizes a duplex antenna. So it receives the data and sends the data. And if we run a quick experiment, for instance, we have the 2,000 battery, and we know the average energy drain.因此，它的能效并不高。所以当我们使用长轮询时，移动设备会使用双工天线。这样它既接收数据又发送数据。如果我们做一个快速实验，例如，我们有2000毫安时的电池，并且我们知道平均能耗。

[00:06:42]  
So it takes only almost four hours to drain the full battery by maintaining just one socket opened. And I attached a link to the research paper that you can use if you are interested in reading the whole paper. So this is the problem number one, CPU utilization and the energy drain.因此，仅保持一个插槽打开，耗尽满电电池只需将近四个小时。如果你有兴趣阅读整篇论文，我附上了该研究论文的链接。这就是第一个问题，即CPU利用率和能耗问题。

[00:07:05]  
So this is not an issue for desktop apps where we don't think about the battery of the device because we are plugged into energy network. But this isn't a big deal for the mobile devices. Where we need to be very network and energy efficient because we have limited network bandwidth and the battery.因此，这对于桌面应用来说不是问题，因为我们无需考虑设备的电池，毕竟它们是连接到电网的。但这对移动设备来说却很重要。因为移动设备的网络带宽有限，且依赖电池供电，所以我们需要确保其网络使用和能耗都非常高效。

[00:07:31]  
The second problem is the latency. The long polling and short polling latency can be initial mobile devices. And this happens when, for instance, you are on the fast train or in a fast car, and then you are connected to some network tower. So then you sit on your train, you may end up losing the connection and reconnecting to the new network tower.第二个问题是延迟。长轮询和短轮询的延迟可能源于移动设备。例如，当你在高速行驶的火车或汽车上，连接到某个信号塔时，就会出现这种情况。你坐在火车上时，可能会断开连接，然后重新连接到新的信号塔。

[00:07:54]  
So now you need to reestablish the connection again, send the address and do the 3-way handshake. And if you change your network towers multiple times, imagine that the latency can be significantly increased. And also, the problem with the long polling is that you need to re-implement reconnection. Every request to the server, which is done through the REST API is stateless.所以现在你需要重新建立连接，发送地址并完成三次握手。而且如果你多次切换网络基站，可想而知延迟会显著增加。此外，长轮询的问题在于你需要重新实现重连功能。通过REST API向服务器发出的每个请求都是无状态的。

[00:08:23]  
So you will lose the state and you will need to re-implement some infrastructure on the server side to do this. So in a long run for the mobile applications, it's actually costs more to support the long polling money wise, of course. So what is the summary then? So the long polling is very good.所以你会丢失状态，并且需要在服务器端重新实现一些基础设施来做到这一点。因此，从长远来看，对于移动应用程序而言，支持长轮询在资金方面的成本实际上更高，这是肯定的。那么总结是什么呢？长轮询其实非常好。

[00:08:50]  
It's very easy and cheap to implement, and definitely there is no additional infrastructure required, unless you work with the mobile apps. If you work with the mobile apps, then there is an issue that it's not battery efficient because it's used CPU to maintain the TCP socket. And it's also not network and data efficient because you send in the headers with a request when you do the 3-way handshake and when you try to request the data, yet you are trying to receive.它的实施非常简单且成本低廉，而且绝对不需要额外的基础设施，除非你使用移动应用程序。如果你使用移动应用程序，那么就会存在一个问题，即它的电池效率不高，因为它需要使用CPU来维持TCP套接字。此外，它的网络和数据效率也不高，因为在进行三次握手以及尝试请求数据（尽管你实际是想接收数据）时，你都要在请求中发送头部信息。

[00:09:19]  
And if you're on HTTP 1, the situation is even worse, because HTTP 1 sends too much overhead data. And so what is the use case then? The use case is actually for, the long polling can be used with desktop apps where we don't care about the network bandwidth and also about the latency because we're stationary.而如果你使用的是HTTP 1，情况会更糟，因为HTTP 1会发送过多的额外数据。那么它的使用场景是什么呢？实际上，长轮询可以用于桌面应用，在这种情况下，我们不需要在意网络带宽和延迟，因为设备是固定不动的。

[00:09:44]  
We do not connect to different mobile towers and also we do not care about the energy drain. So it's also pretty cheap to implement for desktop users and it's pretty well suited, but when it comes to mobile web application, then you would need to consider a different technique.我们不会连接到不同的移动信号塔，也不关心能量消耗的问题。因此，对于桌面用户来说，它的实施成本相当低，也非常适用，但涉及到移动网络应用时，就需要考虑采用不同的技术了。
