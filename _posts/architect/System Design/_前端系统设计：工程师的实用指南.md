---
title: "📐 Frontend System Design: A Practical Guide for Engineers"
source: https://medium.com/@mukeshsharma20120/frontend-system-design-a-practical-guide-for-engineers-075ac37cfdfc
author:
  - "[[Mukesh sharma]]"
published: 2025-04-25
created: 2025-10-22
description: "📐 Frontend System Design: A Practical Guide for Engineers Designing performant, scalable, and user-friendly frontend systems isn’t just about writing clean code — it’s about carefully …"
tags:
---

Designing performant, scalable, and user-friendly frontend systems isn’t just about writing clean code — it’s about carefully crafting architecture, APIs, data models, performance strategies, and accessibility into one seamless experience.  
*设计高性能、可扩展且用户友好的前端系统*并不仅仅意味着编写干净的代码——它还涉及到**精心构建架构、API、数据模型、性能策略和可访问性**，*将它们融合为一个无缝的体验*。

In this blog, we’ll walk through a step-by-step frontend system design guide you can use for projects, interviews, or personal learning. 🎉  
在这篇博客中，我们将*逐步介绍一个前端系统设计指南*，你可以将其*用于项目、面试或个人学习*。 🎉

## RADIO — Frontend System Design Framework
RADIO — 前端系统设计框架

A handy acronym to remember key pillars when designing frontend systems:  
一个方便的缩写词，*用于记住设计前端系统时的关键支柱*：

### R — Requirements 
R — 需求

👉 Clearly define **what the system needs to do** and **why** it’s being built.  
👉 **明确定义系统需要做什么以及为什么要构建它**。  

Questions to ask:
**需要提出的问题：**
- What are the core user stories? 📖  
	核心用户故事是什么？ 📖
- Are there any constraints (time, tech, security)? ⏳🔒  
	有什么限制（时间、技术、安全）？⏳🔒
- Which devices and browsers need support? 💻  
	需要支持哪些设备和浏览器？💻
- Any accessibility (a11y) needs?  
	需要无障碍（a11y）支持吗？♿
- Offline support or responsiveness expected? 📶  
	需要离线支持或响应式设计吗？📶

**Example:** 
示例：  
A dashboard for monitoring orders in real-time with mobile and desktop support.  
一个*支持移动端和桌面端的实时订单监控面板*。

### A — Architecture 
A — 架构

👉 Decide **how the frontend will be structured** and how it will communicate with other parts of the system.  
👉 **确定前端的*结构*、它如何与其他系统部分进行*通信***。

Key considerations:
关键考量：

- Monolithic SPA, MPA, or Micro-frontend?  
	单体式 `SPA`、`MPA`还是`微前端`？
- Which framework/library? (React ⚛️, Vue, Angular 🅰️)  
	使用哪个`框架/库`？（React ⚛️、Vue、Angular 🅰️）
- State management strategy (Redux, Zustand 🦦, Context API)  
	`状态管理`策略（Redux、Zustand、Context API）
- Routing mechanism (React Router, Next.js Routing)  
	`路由机制`（React Router，Next.js 路由）
- CI/CD pipelines and deployment strategies  
	`CI/CD` 管道和`部署策略`
- CDN usage for asset delivery  
	使用 `CDN` 进行资源交付

**Example:**
示例：  
Use Next.js for SSR (Server-Side Rendering) with React, Zustand for state management, and Vercel for deployment.  
使用 Next.js 进行 React 的 SSR（服务器端渲染），使用 Zustand 进行状态管理，并使用 Vercel 进行部署。

### D — Data Model (Client)
D — 数据模型（客户端）

👉 Design the **structure of data on the client side** — how it will be stored, retrieved, and updated.  
👉 **设计客户端数据结构**——如何存储、检索和更新数据。

Things to define:
需要定义的事项：

- Data types and shapes (use TypeScript for type safety)  
	**数据类型和形状**（使用 `TypeScript` 以确保类型安全）
- Normalization vs. nested structures  
	**规范化与嵌套结构**
- Caching strategy (SWR, React Query)  
	**缓存策略**（`SWR`、`React Query`）
- LocalStorage/SessionStorage use cases  
	LocalStorage/SessionStorage 使用场景
- Data flow diagram **数据流程图**

**Example:**
示例：  

A `User` object:
```c
type User = {
  id: string;
  name: string;
  email: string;
  avatarUrl?: string;
};
```

### I — API Model
I — API 模型

👉 Plan **how the frontend will interact with backend APIs**.  
👉 规划**前端将如何与后端 API 交互**。

Consider:
考虑：

- API endpoint structure and naming conventions   
	API 端点*结构和命名规范*
- Error handling patterns (try-catch, toast notifications)   
	**错误处理模式**（try-catch、toast 通知） 
- Authentication (JWT, OAuth)   
	**认证**（JWT、OAuth） 
- Pagination, filtering, sorting capabilities   
	**分页、筛选、排序功能** 
- API versioning **API 版本控制** 
- Rate limiting and retries   
	**速率限制和重试** 

**Example:**
示例：  
`GET /api/v1/users?page=2&limit=20&sort=name`

### O — Optimizations / Performance
O — 优化/性能

👉 Focus on **making the frontend fast and smooth** for users.  
👉 专注于让前端对用户**快速且流畅**。

Important areas:
重要领域：

- Code splitting and lazy loading   
	**代码拆分和懒加载** 
- Image optimization (Next.js Image, WebP)   
	**图片优化**（Next.js Image, WebP） 
- Reducing bundle size **减少打包体积**
- Tree shaking 🌿 **摇树优化** 🌿
- Debouncing and throttling for expensive operations ⏳  
	**节流和防抖**用于昂贵操作 ⏳
- Accessibility optimizations  
	**无障碍优化** ♿
- Core Web Vitals monitoring  
	**核心网络指标监控** 
- SEO strategies for SSR/SSG apps  
	SSR/SSG 应用的 **SEO 策略** 
- Pre-fetching data on route hover for better perceived speed  
	在路由悬停时**预加载数据**以提升感知速度 

**Example:**
示例：  
Use React.lazy for lazy-loading routes and components, compress images via Next.js Image component.  
使用 React.lazy 进行路由和组件的懒加载，通过 Next.js Image 组件压缩图片。

## 需求（10% — 功能与非功能）
Requirement (10% — Functional & Non-Functional)


When designing a frontend system, it’s crucial to start by defining both **functional** and **non-functional requirements**. This ensures we build what users need while maintaining high standards for performance, accessibility, and scalability.  
在设计前端系统时，首先要明确功能性和非功能性需求。这能确保我们构建用户所需的功能，同时保持高性能、可访问性和可扩展性。

### 功能性需求
Functional Requirements


(🧠 *What the system should do*)  
(🧠 **系统应实现的功能**)

Let’s imagine we’re building a **Facebook-like app** :  
让我们假设我们正在构建一个*类似 Facebook 的应用程序：*

- **Feed** that displays a **list of posts** (with text, images, videos)  
	显示帖子列表的 Feed（包含文本、图片、视频）
- Ability for users to **comment on posts**  
	用户可以评论帖子
- Support different **post types**:  
	支持不同类型的帖子：
- Text 文本
- Image 图片
- Video 视频
- Link previews 链接预览
-  **Infinite scrolling** for the feed (fetch more content as the user scrolls down)  
	 无限滚动（随着用户向下滚动，获取更多内容）
- **Like, share, and bookmark** actions on posts  
	对帖子进行点赞、分享和收藏操作
- 🛎️ Real-time **notifications** for likes/comments using websockets or long-polling  
	🛎️ 使用 `websockets` 或`长轮询`实现点赞/评论的**实时通知**
- **Search** functionality for posts, people, and pages  
	搜索帖子、用户和页面的功能

**Why important?
为什么重要？**  
Functional requirements shape what your app can do for users and are directly tied to user journeys and features.  
`功能需求`决定了你的应用能为用户做什么，它们直接与用户旅程和功能相关联。

### 非功能需求
Non-Functional Requirements


( *How the system should behave*)  
( 系统应该如何表现)

**Mobile-friendly / Responsive Design**  
移动端友好/响应式设计
- Should work seamlessly across devices (mobile, tablet, desktop)  
	应在各种设备（手机、平板、桌面）上无缝运行
- Touch-friendly interactions  
	触控友好的交互
- Optimized images and layouts for smaller screens  
	为小屏幕优化的图像和布局

**Offline Support** 
离线支持
- Use Service Workers or App Shell Model for caching static assets and latest feed data  
	使用 Service Workers 或 App Shell 模型来缓存静态资源和最新动态数据
- Show “You are offline” banner with limited functionalities  
	显示“您已离线”横幅，并限制功能

**A11y (Accessibility) Friendly**  
无障碍（Accessibility）友好
- Screen reader support (ARIA labels)  
	支持屏幕阅读器（ARIA 标签）
- Keyboard navigability 键盘导航
- Color contrast compliance  
	色彩对比符合要求
- Text alternatives for images (alt attributes)  
	图像文本替代（alt 属性）

 **Internationalization (i18n)**  
 国际化（i18n）
- Support for multiple languages and regions  
	支持多种语言和地区
- Date, time, number, and currency formatting based on locale  
	根据地区设置日期、时间、数字和货币格式
- RTL (Right-To-Left) support for languages like Arabic/Hebrew  
	支持阿拉伯语/希伯来语等从右到左的语言（RTL）

**Performant** 
高效
- Fast Time-to-Interactive (TTI)  
	快速交互时间 (TTI)
- Optimize Core Web Vitals:  
	优化核心网络指标：
- Largest Contentful Paint (LCP)  
	最大内容绘制 (LCP) 
- First Input Delay (FID)
	首次输入延迟 (FID)
- Cumulative Layout Shift (CLS)  
	累积布局偏移 (CLS)
- Use lazy loading for images/videos  
	对图片/视频使用懒加载
- Prefetch routes and data where possible  
	尽可能预取路由和数据

**Nice to Have: Napkin Math**  
可选功能：纸巾数学
- A quick estimation of expected traffic and system load to guide architecture decisions and observability setup:  
	对预期流量和系统负载的快速估算，以指导架构决策和可观测性设置：
- Estimated daily active users: 500K  
	预计每日活跃用户：50 万
- 📸 Average posts per day: 1M  
	📸 每日平均帖子数：100 万
- Average comments per post: 10  
	📈 每篇帖子的平均评论数：10
- 🖥️ Expected concurrent users: 10K  
	🖥️ 预期并发用户数：10K
- Helps design API rate limits, cache strategies, and monitoring thresholds  
	有助于设计 API 速率限制、缓存策略和监控阈值

**Why important?
为什么重要？**  
Non-functional requirements ensure your system is not only functional but also **usable, scalable, and maintainable** in the long run 🌱.  
`非功能性需求`确保您的系统不仅功能齐全，而且在长期内也**易于使用、可扩展和维护** 🌱.

## 架构 (10% — 高级架构)
Architecture (10% — High-Level Architecture)

When designing frontend system architecture, it’s crucial to think through how the system will be structured. Start simple — then scale and layer in complexity responsibly as needed.  
在设计前端系统架构时，需要***仔细思考系统的结构***。*从简单开始——然后根据需要负责任地逐步增加复杂性和层次*。

### 高级架构概述
High-Level Architecture Overview

At a high level, your frontend system typically consists of:  
**从高级角度看，你的前端系统通常由以下部分组成：**
1. UI Components  UI 组件
2. State Management  状态管理
3. Routing 路由
4. Services (API/Utilities)  
	服务 (API/工具)
5. Assets 资产
6. Infrastructure (Build, Deploy, CDN)  
	基础设施（构建，部署，CDN）

### 关键组件分解
Key Components Breakdown

Let’s assume we’re designing a **Facebook-like application**. Here’s how the core component structure would look:  
让我们假设我们正在设计一个*类似 Facebook 的应用程序*。以下是核心组件结构的样子：

### 简洁 UI（原子设计方法——可选但有效）
Simple UI (Atomic Design Approach — Optional but Effective)

Break UI down into:
***将 UI 分解为：***

- Atoms → smallest components  
	**原子** → 最小组件  
	*E.g.*: Button, Input, Avatar, Icon  
	例如：按钮、输入框、头像、图标
- Molecules → combinations of atoms  
	**分子** → 原子的组合  
	*E.g.*: SearchBar (Input + Icon), CommentForm (Input + Button)  
	例如：SearchBar (输入框 + 图标), CommentForm (输入框 + 按钮)
- Organisms  → groups of molecules and/or atoms  
	**有机体** → 分子和/或原子的组合  
	*E.g.*: PostCard (Avatar + Text + Image + LikeButton + CommentList)  
	例如：PostCard (头像 + 文本 + 图片 + 点赞按钮 + 评论列表)
- Templates → layout structure with placeholder components  
	**模板** → 使用占位组件的布局结构  
	*E.g.*: FeedTemplate (Sidebar + FeedList + NotificationsBar)  
	例如：FeedTemplate (侧边栏 + FeedList + 通知栏)
- Pages → actual pages rendered via routes  
	**页面** → *通过路由渲染的实际页面*  
	*E.g.*: `/home`, `/profile/:id`, `/notifications`  
	例如： `/home` ， `/profile/:id` ， `/notifications`

### 组件架构
Component Architecture

#### Pages 
页面

- `HomePage`
- `ProfilePage` 👤
- `PostDetailsPage` 📝
- `NotificationsPage` 🛎️

Each page routes to a specific view and manages layout + content composition.  
每个页面路由到特定的视图，并管理布局和内容组合。

#### State Management 
状态管理

Handle global or shared state via:  
通过以下方式处理**全局或共享状态：**
- Context API (lightweight)  
	Context API (轻量级)
- Redux / Zustand (scalable)  
	Redux / Zustand (可扩展)
- React Query / SWR (server state)  
	React Query / SWR (服务器状态)

Example:
示例：
- `AuthContext` — user info, login status  
	`AuthContext` — 用户信息，登录状态
- `FeedState` — list of posts, loading state  
	`FeedState` — 帖子列表，加载状态
- `NotificationState` — unread count, messages  
	`NotificationState` — 未读消息数

#### Services 
服务

Isolate external calls:
隔离外部调用：

- `apiService.js` — fetch data from backend APIs  
	`apiService.js` — 从后端 API 获取数据
- `imageUploadService.js` — handle media uploads  
	`imageUploadService.js` — 处理媒体上传
- `notificationService.js` — manage real-time updates  
	`notificationService.js` — 管理实时更新

Use abstraction to decouple business logic from UI.  
使用抽象将业务逻辑与 UI 解耦。

#### Assets 
资产

Organize static files:
组织静态文件：

- Images (logos, placeholders)  
	图片（标志、占位符）
- Icons (SVGs, icon libraries)  
	图标（SVG、图标库）
- Styles (Tailwind / CSS modules)  
	样式（Tailwind / CSS 模块） 

#### Infrastructure 
基础设施

- Vite / Webpack for bundling  
	Vite / Webpack 用于打包
- CI/CD pipelines (GitHub Actions, Vercel)  
	CI/CD 管道（GitHub Actions, Vercel）
- CDN (for images, JS bundles)   
	CDN（用于图片、JS 包） 
- Service Workers for offline support
	Service Workers 用于离线支持

### 架构图
Visual Diagram (Text-based)
基于文本的视觉图表


```c
+------------------+
|     Pages        |
+--------+---------+
         |
  +------+------+
  |   Components  |
  +------+------+
         |
  +------+------+
  |    State     |
  |  Management  |
  +------+------+
         |
  +------+------+
  |    Services   |
  +------+------+
         |
  +------+------+
  |     Assets    |
  +------+------+
         |
  +------+------+
  | Infrastructure|
  +---------------+
```

## Data Model (20%)
数据模型 (20%)

In frontend system design, the **data model defines the shape of data on the client side** . It ensures predictable, type-safe, and efficient rendering of UI components.  
在前端系统设计中，**`数据模型`定义了客户端数据的形状、形式** 。它确保了 UI 组件的可预测、类型安全以及高效的渲染。

### Client Data Model Overview
客户数据模型概述

Imagine we’re designing a **Facebook-like app**. The client needs to store:  
想象我们正在设计一个类似 Facebook 的应用。客户需要存储：

- `user` data `user` 数据
- `settings` data `settings` 数据
- `feed` data (posts, comments, likes, etc.)  
	`feed` 数据（帖子、评论、点赞等）
- app-wide state like loading/error indicators  
	全局状态，如加载/错误指示器

### Data Structures 
数据结构

Let’s define these using **TypeScript-like pseudocode** 📝:  
让我们使用类似 TypeScript 的伪代码来定义这些 📝：

### App Data Structure 
应用数据结构

```c
app = {
  user: User,
  settings: UserSettings,
  feed: Feed,
  notifications: Notifications,
  isLoading: boolean,
  error: string | null,
};
```

### User 
用户

```c
User = {
  id: string,
  name: string,
  avatarUrl: string,
  bio: string,
  email: string,
  createdAt: string,
  isOnline: boolean,
};
```

### User Settings 
用户设置

```c
UserSettings = {
  theme: 'light' | 'dark',
  language: string,
  notificationsEnabled: boolean,
  privacy: 'public' | 'friends' | 'private',
};
```

### Feed 
信息流

```c
Feed = {
  items: FeedItem[],
  page: number,
  size: number,
  totalCount: number,
};
```

### Feed Item 
内容项

```c
FeedItem = {
  id: string,
  author: User,
  content: StyledText[],
  media: MediaItem[],
  createdAt: string,
  likes: number,
  likedByCurrentUser: boolean,
  comments: Comment[],
  type: 'text' | 'image' | 'video' | 'link',
};
```

### Comment 
评论

```c
Comment = {
  id: string,
  author: User,
  text: string,
  createdAt: string,
};
```

### Notifications 通知

```c
Notifications = {
  items: NotificationItem[],
  unreadCount: number,
};
```

**NotificationItem**

```c
NotificationItem = {
  id: string,
  message: string,
  createdAt: string,
  isRead: boolean,
};
```

### StyledText (用于丰富内容渲染)
StyledText (for rich content rendering)

```c
StyledText = {
  text: string,
  style: 'normal' | 'bold' | 'italic' | 'underline' | 'link',
  color?: string,
  linkUrl?: string,
};
```

*Example:示例：*

```c
[
  { text: "Check this out!", style: "bold" },
  { text: "https://example.com", style: "link", linkUrl: "https://example.com" }
]
```

### MediaItem

```c
MediaItem = {
  id: string,
  type: 'image' | 'video',
  url: string,
  thumbnailUrl?: string,
};
```

### 摘要图表 (基于文本)
Summary Diagram (Text-based)

```c
App
├── User 👤
├── Settings
├── Feed 📰
│   ├── FeedItem 📝
│   │   ├── Content (StyledText[])
│   │   ├── Media 🎞️
│   │   └── Comments 💬
├── Notifications 🛎️
└── UI State (isLoading, error)
```

### Why is This Important?
为什么这很重要？

✅ Predictable, structured, type-safe UI rendering  
✅ 可预测、结构化、类型安全的 UI 渲染  
✅ Simplifies debugging, caching, and API consumption  
✅ 简化调试、缓存和 API 调用  
✅ Scalable — easy to extend as features grow  
✅ 可扩展——随着功能增长易于扩展  
✅ Reduces bugs by enforcing consistent data contracts  
✅ 通过强制执行一致的数据契约来减少错误

## API (20%)

When building a frontend system, choosing the right API strategy is crucial for performance, scalability, and user experience 🎯.  
在构建前端系统时，选择正确的 API 策略对于性能、可扩展性和用户体验至关重要 🎯。  
Let’s break it down:  
让我们来分解一下：

### HTTP Overview 
HTTP 概述

Modern frontend apps typically communicate with backend services using **HTTP protocols**. Here’s a quick comparison between **HTTP/1.1** and **HTTP/2**:  
现代前端应用通常使用 HTTP 协议与后端服务进行通信。以下是 HTTP/1.1 和 HTTP/2 之间的快速比较：

### HTTP/1.1

- 📉 **Limited concurrent connections** (usually 6–8 per domain)  
	📉 有限的并发连接（通常每个域名 6-8 个）
- ⏳ **Synchronous blocking queue** — each request waits its turn  
	⏳ 同步阻塞队列 — 每个请求依次等待
- **Returns plain text or JSON**  
	返回纯文本或 JSON
- ❌ **Explicitly closes connections** after each request-response cycle  
	❌ 每次请求-响应周期后显式关闭连接
- 📨 **Single TCP connection sends one piece of data at a time**  
	📨 单个 TCP 连接每次只发送一块数据

### HTTP/2

- **Solves single-connection issue via multiplexing**  
	🚀 通过多路复用解决单连接问题
- 📶 **Multiple parallel streams** over one TCP connection  
	📶 在一个 TCP 连接上支持多个并行流
- Supports **rich data (JSON, images, binary)**  
	📦 支持丰富数据（JSON、图像、二进制）
- **Parallel, faster requests**  
	并行、更快的请求
- **One TCP connection can send multiple streams at once**  
	一个 TCP 连接可以同时发送多个流
- 🌱 **Built-in header compression and improved prioritization**  
	🌱 内置的头部压缩和改进的优先级

**Verdict:结论：**  
HTTP/2 massively improves performance and efficiency for modern web apps.  
HTTP/2 大幅提升了现代网络应用的性能和效率。

### API Options
API 选项

Let’s explore different ways a frontend can fetch or receive data from a server 📡:  
让我们探讨前端获取或从服务器接收数据的不同方式📡：

### Polling / Long Polling / REST API
轮询 / 长轮询 / REST API

**🔁 What is it? 它是什么？**

- The client sends a request at regular intervals to check for new data.  
	客户端定期发送请求以检查新数据。
- Or in **long polling**, the client holds the connection open until the server responds.  
	或者在长轮询中，客户端保持连接打开直到服务器响应。

**✅ Pros:✅ 优点：**

- 📖 Simple to implement 📖 易于实现
-  Works well with HTTP/2  
	 与 HTTP/2 兼容良好
-  Easy to load balance across servers  
	 易于在服务器间进行负载均衡

**❌ Cons:❌ 缺点：**

- ⏳ Higher latency for near real-time updates  
	⏳ 更高的延迟，难以实现近乎实时的更新
-Connection timeouts possible  
	🔌 可能出现连接超时
- More network traffic overhead with frequent polling  
	📈 频繁轮询会导致更多的网络流量开销

### GraphQL

**What is it?它是什么？**

- A modern, flexible query language for APIs, allowing clients to fetch exactly the data they need.  
	一种现代、灵活的 API 查询语言，允许客户端获取他们确切需要的数据。

**✅ Pros:✅ 优点：**

- Fetch multiple resources in a single request  
	📦 单个请求中获取多个资源
- 🛠️ Type-safe queries (helps prevent errors)  
	🛠️ 类型安全的查询（有助于防止错误）
-  Compatible with HTTP/2  
	 兼容 HTTP/2
- Avoids over-fetching or under-fetching data  
	避免过度获取或获取不足的数据

**❌ Cons:❌ 缺点：**

- 📉 Can have longer latency for large, complex queries  
	📉 对于大型复杂查询，可能存在更高的延迟
-Requires connection timeouts handling  
	🔌 需要处理连接超时
- Traffic overhead for deeply nested or frequent queries  
	📈 对于深层嵌套或频繁查询，存在流量开销

**✨ Bonus:✨ 奖励：**  
Supports **subscriptions (over WebSockets)** for real-time updates too!  
支持订阅（通过 WebSockets）以实现实时更新！

### WebSockets

** What is it? 它是什么？**

- A protocol for **bidirectional, persistent communication** between client and server.  
	客户端和服务器之间进行双向、持久通信的协议。

**✅ Pros:✅ 优点：**

- Real-time data delivery  
	实时数据传输
- 📶 Single TCP connection for continuous communication  
	📶 单一 TCP 连接实现持续通信
- 🔥 Super fast, ideal for chat apps, live feeds, or gaming  
	🔥 极快速度，适合聊天应用、实时信息流或游戏

**❌ Cons:❌ 缺点：**

- 🔧 Harder to load balance  
	🔧 负载均衡更困难
- 🖥️ More resource-intensive on servers  
	🖥️ 服务器资源消耗更大
- 🔒 Can struggle with corporate firewalls/proxies  
	🔒 难以应对企业防火墙/代理

### Server-Sent Events (SSE)
服务器发送事件 (SSE)

**What is it?它是什么？**

- Allows the server to push updates to the client over a single HTTP connection (unidirectional).  
	允许服务器通过单个 HTTP 连接向客户端推送更新（单向）。

**✅ Pros:✅ 优点：**

-  HTTP/2 compatible  兼容 HTTP/2
- Efficient for one-way data streams (news feed updates, notifications)  
	适用于单向数据流（新闻更新、通知）
-  Easier to load balance compared to WebSockets  
	 与 WebSocket 相比，负载均衡更简单

**❌ Cons:❌ 缺点：**

- 🔙 **Unidirectional only** (server → client)  
	🔙 仅单向（服务器→客户端）
-  Not suitable for full-duplex communication like chats or games  
	 不适用于聊天或游戏等全双工通信

## Performance (40% of time)
性能 (40%的时间)

Performance is **crucial for frontend system design** because it directly impacts user experience, SEO, engagement, and retention 📊. Here’s a comprehensive guide covering **network optimization, rendering, caching, observability, and security**.  
性能对于前端系统设计至关重要，因为它直接影响用户体验、SEO、参与度和留存率 📊。这是一份涵盖网络优化、渲染、缓存、可观察性和安全的综合指南。

###  Network Optimization  
网络优化

### Compression 
压缩

- **Brotli 🔥** — modern, better compression ratio than Gzip  
	Brotli 🔥 — 现代，比 Gzip 压缩率更好
- **Gzip** — widely supported, fallback compression  
	Gzip — 广泛支持，备用压缩

👉 **Set up server to serve compressed assets.**  
👉 设置服务器以提供压缩资源。  
Check browser support and configure fallback.  
检查浏览器支持并配置回退方案。

### Caching 
缓存

- **Browser Cache, Service Worker Cache, and CDN Caching  
	浏览器缓存、服务工作者缓存和 CDN 缓存**  
	Strategies:策略：
- `Cache-Control`, `ETag`, `Expires` headers  
	`Cache-Control` ， `ETag` ， `Expires` 标头
- **Apollo Client Caching** (for GraphQL data caching)  
	Apollo Client 缓存（用于 GraphQL 数据缓存）
- HTTP caching for static assets (images, fonts, JS bundles)  
	静态资源（图片、字体、JS 打包文件）的 HTTP 缓存

👉 **Cache smartly**: dynamic content short TTL, static long TTL.  
👉 智能缓存：动态内容短 TTL，静态内容长 TTL。

###  Batch Requests  
批量请求

- **Group multiple small API calls into one bigger request** when possible (avoids request overhead)  
	在可能的情况下，将多个小 API 调用合并为一个较大的请求（避免请求开销）
- **Apollo batching** or REST endpoint batching  
	Apollo 批量处理或 REST 端点批量处理

👉 Reduces latency and server load 📉.  
👉 降低延迟和服务器负载 📉。

### Image Optimization 
图片优化

- Use a **microservice or CDN (like Cloudinary/Imgix)**  
	使用微服务或 CDN（如 Cloudinary/Imgix）
- Serve **compressed, correctly sized images** by viewport  
	按视口大小提供压缩、正确尺寸的图片
- Use modern formats: **WebP, AVIF**  
	使用现代格式：WebP、AVIF

👉 Huge savings in network transfer.  
👉 大幅节省网络传输量。

### Bundle Splitting 
打包拆分

- **Lazy load** components only when needed  
	按需懒加载组件
- Split code into chunks (`vendor.js`, `app.js`, `route-specific.js`)  
	将代码拆分成块（ `vendor.js` ， `app.js` ， `route-specific.js` ）
- Compress and minimize bundles  
	压缩并最小化包

👉 Reduces initial page load time and improves TTI .  
👉 减少初始页面加载时间并提升 TTI 。

### Rendering Optimization
渲染优化

- **Responsive Design**: Mobile-first  
	响应式设计：移动优先 
- **Prevent race conditions** in concurrent requests  
	防止并发请求中的竞态条件  
	👉 Use **cancellation tokens**, **deduping requests**  
	👉 使用取消令牌，去重请求
- **Application Cache 应用缓存**  
	👉 Use **LocalStorage**, **SessionStorage**, **IndexedDB**, **Cookies** smartly  
	👉 智能使用 LocalStorage、SessionStorage、IndexedDB、Cookies  
	👉 Prefer **Service Workers** for offline-ready apps  
	👉 优先使用 Service Workers 开发离线应用
- **Loading States / Error States / Success Handling  
	加载状态 / 错误状态 / 成功处理**  
	👉 UX-friendly states are vital for smooth experiences.  
	👉 友好的用户体验状态对流畅体验至关重要。
- **Server-Side Rendering (SSR)  
	服务器端渲染 (SSR)**  
	👉 Use **Next.js** for better SEO & faster FCP (First Contentful Paint)  
	👉 使用 Next.js 以提升 SEO 和更快的 FCP（首次内容绘制）
- **Defer Non-Critical Resources  
	延迟非关键资源**  
	👉 `async` / `defer` for scripts  
	👉 `async` / `defer` 用于脚本  
	👉 Focus on **above-the-fold content**  
	👉 关注首屏内容
- **Hydration 水合**  
	👉 Prioritize visible content, then progressively load rest  
	👉 优先加载可见内容，然后渐进式加载其余部分
- **Preload Important Resources  
	预加载重要资源**  
	👉 Use `<link rel="preload">` for fonts, hero images, and above-the-fold JS  
	👉 使用 `<link rel="preload">` 为字体、英雄图片和首屏 JS
- **Tree Shaking 🌳 摇树优化 🌳**  
	👉 Remove unused code during build (with tools like Webpack, Vite)  
	👉 在构建过程中移除未使用的代码（使用 Webpack、Vite 等工具）
- **Visualization Optimization  
	可视化优化**  
	👉 For long lists, use **windowing/virtualization** (e.g., react-window, react-virtualized)  
	👉 对于长列表，使用窗口化/虚拟化（例如，react-window，react-virtualized）
- **Avoid layout thrashing & reflows  
	避免布局抖动和重排**  
	👉 Use CSS animations instead of JS  
	👉 使用 CSS 动画而不是 JS  
	👉 Inline critical CSS in components or via CSS-in-JS libraries  
	👉 在组件中内联关键 CSS 或通过 CSS-in-JS 库

### 可观测性/跟踪
Observability / Tracking

Track key performance and behavioral metrics:  
跟踪关键性能和行为指标：

- **TTI (Time to Interactive)  
	TTI（交互响应时间）**
- **FCP (First Contentful Paint)  
	FCP（首次内容绘制）**
- **Network request start/end logs  
	网络请求开始/结束日志**
- **Render times for components  
	组件渲染时间**
- Error logging with tools like **Sentry**  
	使用 Sentry 等工具进行错误日志记录
- Performance tracking via **Web Vitals**  
	通过 Web Vitals 进行性能追踪

👉 Use **Lighthouse** or **WebPageTest** for audits.  
👉 使用 Lighthouse 或 WebPageTest 进行审核。

### 可访问性 (A11y) 最佳实践
Accessibility (A11y) Best Practices

**Why?为什么？**  
👉 Accessibility ensures your app can be used by **everyone — including people with disabilities**. It’s also great for SEO, legal compliance, and overall user experience.  
👉 可访问性确保您的应用可以被所有人使用——包括残障人士。它对 SEO、法律合规性和整体用户体验也非常有益。

### REM Font Sizes 
REM 字体大小

- Use **rem** (root em) units instead of px for font sizes  
	使用 rem（根 em）单位代替 px 设置字体大小  
	👉 Respects user’s browser/system font size preferences  
	👉 尊重用户浏览器/系统字体大小偏好
```c
font-size: 1.2rem;
```

### Cross-Device Testing 
跨设备测试

- Test on:测试对象：
- Mobile (Android, iOS) 移动设备（Android、iOS）
- 🖥️ Desktop (different browsers)  
	🖥️ 桌面设备（不同浏览器）
- 📺 Tablets 📺 平板电脑  
	👉 Ensure layouts, touch interactions, and font scaling work well everywhere.  
	👉 确保布局、触摸交互和字体缩放在所有地方都能良好运行。

### 合适的对比度
Proper Contrast 


- Maintain **sufficient color contrast** between text and background  
	保持文本和背景之间足够的颜色对比度
- Follow **WCAG 2.1 guidelines**:  
	遵循 WCAG 2.1 指南：
- Normal text: **4.5:1** 正常文本：4.5:1
- Large text: **3:1** 👉 Use tools like **Color Contrast Checker** or browser dev tools to test  
	大号文本：3:1 👉 使用颜色对比检查工具或浏览器开发者工具进行测试

### 键盘导航
Keyboard Navigation 

- Ensure all interactive elements:  
	确保所有交互元素：
- Are reachable via **Tab key**  
	可通过 Tab 键访问
- Use **Enter/Space** to activate  
	使用 Enter/Space 键激活
- Have **visible focus states**  
	具有可见的焦点状态
```c
button:focus {
  outline: 2px solid #007bff;
}
```

### HTML5 语义元素
HTML5 Semantic Elements

- Use appropriate semantic tags:  
	使用适当的语义标签：
- `<header>`, `<nav>`, `<main>`, `<article>`, `<footer>`  
	👉 Helps screen readers, SEO, and structure your layout properly  
	👉 帮助屏幕阅读器、SEO，并正确地构建你的布局

### ARIA Roles 
ARIA 角色

- Use **ARIA (Accessible Rich Internet Applications) attributes** only when native HTML lacks functionality. Examples:  
	仅在原生 HTML 缺少功能时使用 ARIA（可访问的丰富互联网应用）属性。例如：
```c
<div role="alert">Error message</div>
<ul role="list">
  <li role="listitem">Item 1</li>
</ul>
```

👉 Don’t overuse ARIA if HTML5 semantics already work.  
👉 如果 HTML5 语义已经足够，不要过度使用 ARIA。

###  安全最佳实践
Security Best Practices 

**Why?为什么？**  
👉 Protects your users’ data and ensures your app’s integrity against attacks 🚨  
👉 保护用户数据，确保应用程序在攻击下的完整性 🚨

###  Cross-Site Scripting (XSS) 
跨站脚本攻击 (XSS)

- Always **sanitize user inputs** before rendering  
	渲染前始终对用户输入进行消毒
- Use frameworks that auto-escape content (React, Angular)  
	使用自动转义内容的框架（React、Angular）
- Set **Content Security Policy (CSP)** headers  
	设置内容安全策略 (CSP) 头部
```c
Content-Security-Policy: default-src 'self';
```

### Rate Limiting 
速率限制

- Protect APIs from abuse (DDoS, brute-force attempts)  
	保护 API 免受滥用（DDoS、暴力破解尝试）
- Implement server-side:在服务器端实现：
- Request limit per IP/user  
	每个 IP/用户的请求限制
- Temporary blocks after repeated failed attempts  
	连续多次尝试失败后的临时阻止
- Use tools like **Express-rate-limit (Node.js)**, API Gateway throttling  
	使用 Express-rate-limit (Node.js)、API 网关限流等工具

###  Cross-Origin Resource Sharing (CORS) 
跨域资源共享 (CORS)

- Restrict which domains can interact with your API  
	限制哪些域名可以与你的 API 交互
- Configure server CORS policy securely:  
	安全配置服务器 CORS 策略：
```c
Access-Control-Allow-Origin: https://yourapp.com
```

👉 Avoid `Access-Control-Allow-Origin: *` in production.  
👉 避免在生产环境中使用 `Access-Control-Allow-Origin: *` 。

## 最后的思考
Final Thoughts


✅ Great frontend system design balances **performance, accessibility, security, and scalability**.  
✅ 优秀的前端系统设计在性能、可访问性、安全性和可扩展性之间取得平衡。  
✅ Start with clear requirements, design modular architecture, optimize APIs, and always test across devices.  
✅ 从明确的需求开始，设计模块化架构，优化 API，并始终在多种设备上进行测试。  
✅ Measure everything — what gets measured gets improved 📊.  
✅ 衡量一切——被衡量的事物都会得到改进 📊。
