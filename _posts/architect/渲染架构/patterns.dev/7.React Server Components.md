---
title: "React Server Components"
source: "https://www.patterns.dev/react/react-server-components/"
author:
published:
created: 2025-12-15
description: "Server Components compliment SSR, rendering to an intermediate abstraction without needing to add to the JavaScript bundle"
tags:
  - "clippings"
---
React’s [Server Components](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) enable **modern UX with a server-driven mental model**. This is quite different from Server-side Rendering (SSR) of components and results in significantly [smaller](https://twitter.com/sophiebits/status/1341098388062756867) client-side JavaScript bundles.  
React 的服务器组件通过服务器驱动的思维模型实现现代用户体验。这与组件的服务器端渲染（SSR）有很大不同，并显著减小了客户端 JavaScript 包的大小。

> **Update (React 18+ / Next.js 13+):** React Server Components are now a **production reality** in Next.js 13+ with the App Router. Unlike classic SSR, RSCs allow you to render part of your UI on the server *ahead of time* without sending the associated JS to the client—dramatically shrinking client bundles (early reports show 20%+ reductions). The Container/Presentational pattern is a great candidate for RSC: the “container” (data-fetching logic) can be a Server Component that fetches data and passes it as props to a presentational Client Component, meaning the fetching logic never ships to the browser.  
> 更新（React 18+ / Next.js 13+）：在 Next.js 13+ 的 App 路由器中，React 服务器组件已成为生产环境的现实。与经典 SSR 不同，RSC 允许你在服务器上提前渲染 UI 的一部分，而无需将相关的 JS 发送到客户端——这极大地缩小了客户端包（早期报告显示减少了 20%+）。容器/展示模式非常适合 RSC：其中“容器”（数据获取逻辑）可以是一个服务器组件，它获取数据并将其作为 props 传递给展示性客户端组件，这意味着获取逻辑永远不会发送到浏览器。
> 
> In Next.js App Router, you no longer use `getServerSideProps` —instead, any React component in the `app/` directory can be async to fetch data on the server. React Server Components are *not* a replacement for SSR—they complement it. You typically use RSC for the majority of the page (rendered and streamed as part of SSR), and add `'use client'` directives for components that need interactivity.  
> 在 Next.js 应用路由器中，你不再使用 `getServerSideProps` —取而代之的是， `app/` 目录中的任何 React 组件都可以异步从服务器获取数据。React 服务器组件并非 SSR 的替代品，而是对其的补充。通常情况下，你使用 RSC 来渲染和流式传输页面的大部分内容（作为 SSR 的一部分），并为需要交互性的组件添加 `'use client'` 指令。
> 
> **Server Actions** (stabilizing in React 19/20) allow you to define form or event handlers on the server using `'use server'` directive and call them from client components, further blurring the line between client and server.  
> 服务器操作（在 React 19/20 中稳定）允许你使用 `'use server'` 指令在服务器上定义表单或事件处理器，并从客户端组件中调用它们，进一步模糊了客户端和服务器之间的界限。

The direction of this work is exciting. React Server Components are now production-ready in frameworks like Next.js 13+ with the App Router. The following resources may be of interest:  
这项工作的方向令人兴奋。React 服务器组件现在在 Next.js 13+ 及更高版本的应用路由器框架中已准备好投入生产。以下资源可能对你感兴趣：

- The [RFC](https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md) is worth reading as is [Dan and Lauren’s talk](https://www.youtube.com/watch?v=TQQPAU21ZUw&feature=emb_title) worth watching.  
	RFC 值得阅读，Dan 和 Lauren 的演讲也值得观看。
- [Next.js App Router documentation](https://nextjs.org/docs/app) for the modern approach to Server Components  
	Next.js 应用路由器文档：现代 Server Components 方法
- [Shopify Hydrogen and Server Components  
	Shopify Hydrogen 和 Server Components](https://shopify.dev/custom-storefronts/hydrogen/framework/react-server-components)

---

## Server-side rendering limitations服务器端渲染的限制

Today’s Server-side rendering of client-side JavaScript can be suboptimal. JavaScript for your components is rendered on the server into an HTML string. This HTML is delivered to the browser, which can appear to result in a fast First Contentful Paint or Largest Contentful Paint.  
今天的客户端 JavaScript 服务器端渲染可能不够理想。组件的 JavaScript 在服务器上渲染成 HTML 字符串。这个 HTML 会被发送到浏览器，这可能会造成快速的首屏内容渲染或最大内容渲染。

However, JavaScript still needs to be fetched for interactivity which is often achieved via a hydration step. Server-side rendering is generally used for the initial page load, so post-hydration you’re unlikely to see it used again.  
然而，JavaScript 仍然需要被获取以实现交互性，这通常通过一个水合步骤来实现。服务器端渲染通常用于初始页面加载，所以在水合之后你不太可能再看到它的使用。

With React Server Components, our components can be refetched regularly. An application with components which rerender when there is new data can be run on the server, limiting how much code needs to be sent to the client.  
通过 React 服务器组件，我们的组件可以定期重新获取。一个包含在数据更新时重新渲染组件的应用程序可以在服务器上运行，从而限制需要发送到客户端的代码量。

> \[RFC\]: Developers constantly have to make choices about using third-party packages. Using a package to render some markdown or format a date is convenient for us as developers, but it increases code size and hurts performance for our users  
> \[RFC\]: 开发者不断需要在使用第三方包之间做出选择。使用一个包来渲染一些 markdown 或格式化日期对我们开发者来说很方便，但这会增加代码体积并影响用户的性能。

NoteWithMarkdown.js

```jsx
1// *Before* Server Components
2import marked from "marked"; // 35.9K (11.2K gzipped)
3import sanitizeHtml from "sanitize-html"; // 206K (63.3K gzipped)
4

5function NoteWithMarkdown({text}) {
6  const html = sanitizeHtml(marked(text));
7  return (/* render */);
8}
```

---

## Server Components 服务器组件

React’s new Server Components compliment Server-side rendering, enabling rendering into an intermediate abstraction format without needing to add to the JavaScript bundle. This both allows merging the server-tree with the client-side tree without a loss of state and enables scaling up to more components.  
React 的新服务器组件补充了服务器端渲染，能够在不需要向 JavaScript 包中添加内容的情况下渲染到中间抽象格式。这既允许在不丢失状态的情况下将服务器树与客户端树合并，又能够扩展到更多组件。

Server Components are not a replacement for SSR. When paired together, they support quickly rendering in an intermediate format, then having Server-side rendering infrastructure rendering this into HTML enabling early paints to still be fast. We SSR the Client components which the Server components emit, similar to how SSR is used with other data-fetching mechanisms.  
服务器组件不是对服务器端渲染的替代。当它们结合使用时，支持快速以中间格式渲染，然后由服务器端渲染基础设施将此内容渲染为 HTML，从而确保早期绘制仍然快速。我们对服务器组件发出的客户端组件进行服务器端渲染，这类似于服务器端渲染与其他数据获取机制的使用方式。

This time however, the JavaScript bundle will be significantly smaller. Early explorations have shown that bundle size wins could be significant (-18-29%), but the React team will have a clearer idea of wins in the wild once further infrastructure work is complete.  
然而，这次 JavaScript 包的大小将显著减小。早期的探索表明，包大小的减少可能非常显著（-18-29%），但 React 团队将在进一步的基础设施工作完成后，对实际应用中的收益有更清晰的认识。

> \[RFC\]: If we migrate the above example to a Server Component we can use the exact same code for our feature but avoid sending it to the client - a code savings of over 240K (uncompressed):  
> \[RFC\]: 如果我们将上述示例迁移到服务器组件，我们可以使用完全相同的代码来实现我们的功能，但避免将其发送到客户端——节省了超过 240K 的代码量（未压缩）：

NoteWithMarkdown.server.js

```jsx
1import marked from "marked"; // zero bundle size
2import sanitizeHtml from "sanitize-html"; // zero bundle size
3

4function NoteWithMarkdown({text}) {
5  // same as before
6}
```

---

## Automatic Code-Splitting自动代码拆分

It’s been considered a best-practice to only serve code users need as they need it by using code-splitting. This allows you to break your app down into smaller bundles requiring less code to be sent to the client. Prior to Server Components, one would manually use `React.lazy()` to define “split-points” or rely on a heuristic set by a meta-framework, such as routes/pages to create new chunks.  
使用代码拆分只服务用户需要的功能已被视为最佳实践。这使你能够将应用拆分为更小的包，从而减少发送到客户端的代码量。在服务器组件出现之前，人们需要手动使用 `React.lazy()` 来定义“拆分点”，或者依赖元框架设定的启发式规则，例如路由/页面来创建新的代码块。

PhotoRenderer.js

```jsx
1// *Before* Server Components
2import React from "react";
3

4// one of these will start loading *when rendered on the client*:
5const OldPhotoRenderer = React.lazy(() => import("./OldPhotoRenderer.js"));
6const NewPhotoRenderer = React.lazy(() => import("./NewPhotoRenderer.js"));
7

8function Photo(props) {
9  // Switch on feature flags, logged in/out, type of content, etc:
10  if (FeatureFlags.useNewPhotoRenderer) {
11    return <NewPhotoRenderer {...props} />;
12  } else {
13    return <PhotoRenderer {...props} />;
14  }
15}
```

**Some of the challenges with code-splitting are:  
代码拆分的一些挑战包括：**

- Outside of a meta-framework (like Next.js), you often have to tackle this optimization manually, replacing `import` statements with dynamic imports.  
	在元框架（如 Next.js）之外，你通常需要手动处理这种优化，将 `import` 语句替换为动态导入。
- It might delay when the application begins loading the component impacting the user-experience.  
	这可能会延迟应用程序开始加载组件的时间，从而影响用户体验。

Server Components introduce automatic code-splitting treating all normal imports in Client components as possible code-split points. They also allow developers to select which component to use much earlier (on the server), allowing the client to fetch it earlier in the rendering process.  
服务器组件引入了自动代码拆分，将客户端组件中的所有普通导入视为可能的代码拆分点。它们还允许开发人员在更早的时间（在服务器上）选择使用哪个组件，使客户端能够在渲染过程中更早地获取它。

PhotoRenderer.server.js

```jsx
1import React from "react";
2

3// one of these will start loading *once rendered and streamed to the client*:
4import OldPhotoRenderer from "./OldPhotoRenderer.client.js";
5import NewPhotoRenderer from "./NewPhotoRenderer.client.js";
6

7function Photo(props) {
8  // Switch on feature flags, logged in/out, type of content, etc:
9  if (FeatureFlags.useNewPhotoRenderer) {
10    return <NewPhotoRenderer {...props} />;
11  } else {
12    return <PhotoRenderer {...props} />;
13  }
14}
```

---

## Will Server Components replace Next.js SSR?服务器组件会取代 Next.js 的服务器端渲染吗？

No. They are quite different. Initial adoption of Server Components will actually be experimented with via meta-frameworks such as Next.js as research and experimentation continue.  
不，它们差异很大。随着研究和实验的持续进行，Server Components 的初始采用将通过 Next.js 等元框架进行实验。

To summarize a [good explanation](https://news.ycombinator.com/item?id=25499171) of the differences between Next.js SSR and Server Components from Dan Abramov:  
总结 Dan Abramov 对 Next.js SSR 和 Server Components 差异的良好解释：

- **Code for Server Components is never delivered to the client.** In many implementations of SSR using React, component code gets sent to the client via JavaScript bundles anyway. This can delay interactivity.  
	Server Components 的代码永远不会发送到客户端。在许多使用 React 的 SSR 实现中，组件代码仍然通过 JavaScript 包发送到客户端。这可能会延迟交互性。
- **Server components enable access to the back-end from anywhere in the tree.** When using Next.js, you’re used to accessing the back-end via getServerProps() which has the limitation of only working at the top-level page. Random npm components are unable to do this.  
	服务器组件可以从树中的任何位置访问后端。在使用 Next.js 时，你通常通过 getServerProps() 访问后端，但这仅限于在顶层页面工作。随机的 npm 组件无法做到这一点。
- **Server Components may be refetched while maintaining Client-side state inside of the tree.** This is because the main transport mechanism is much richer than just HTML, allowing the refetching of a server-rendered part (e.g such as a search result list) without blowing away state inside (e.g search input text, focus, text selection)  
	服务器组件可以在树中维护客户端状态的同时被重新获取。这是因为主要的传输机制比单纯的 HTML 要丰富得多，允许重新获取服务器渲染的部分（例如搜索结果列表），而不会破坏内部状态（例如搜索输入文本、焦点、文本选择）。

Some of the early integration work for Server Components will be done via a webpack plugin which:  
Server Components 的一些早期集成工作将通过一个 webpack 插件来完成，该插件：

- Locates all Client components  
	定位所有客户端组件
- Creates a mapping between IDs => chunk URLs  
	创建一个 ID 到 chunk URL 的映射
- A Node.js loader replaces imports to Client components with references to this map.  
	一个 Node.js 加载器将导入的 Client 组件替换为对这个映射的引用。
- Some of this work will require deeper integrations (e.g with pieces such as Routing) which is why getting this to work with a framework like Next.js will be valuable.  
	这项工作的一部分需要更深层次的集成（例如与路由等组件），这就是为什么将其与 Next.js 等框架配合使用会很有价值的原因。

As Dan notes, one of the goals of this work is to enable meta-frameworks to get much better.  
正如 Dan 所指出的，这项工作的一个目标是为元框架提供更好的支持。

---

To learn more about this work, [watch the talk from Dan and Lauren](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html), read the [RFC](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) and do check out the [Server Components demo](http://github.com/reactjs/server-components-demo) to play around with this work. With thanks to Sebastian Markbåge, Lauren Tan, Joseph Savona and Dan Abramov for their work on Server Components.  
要了解更多关于这项工作，请观看 Dan 和 Lauren 的演讲，阅读 RFC，并务必查看 Server Components 演示来体验这项工作。感谢 Sebastian Markbåge、Lauren Tan、Joseph Savona 和 Dan Abramov 在 Server Components 方面的工作。

**Interesting relevant threads:  
有趣的关联线程：**

- [Lauren Tan on Server Components  
	劳伦·谭关于服务器组件的讨论](https://twitter.com/sugarpirate_/status/1341141198258524163)
- [Sophie Alpert explaining them  
	索菲·阿尔珀特解释它们](https://twitter.com/sophiebits/status/1341098388062756867)
- [Sebastian Markbåge with a discussion on hydration  
	Sebastian Markbåge 与关于 hydration 的讨论](https://twitter.com/sebmarkbage/status/1341102430147276803)
- [HN discussion thread HN 讨论帖](https://news.ycombinator.com/item?id=25497065)