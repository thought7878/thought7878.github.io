---
title: "Progressive Hydration"
source: "https://www.patterns.dev/react/progressive-hydration/"
author:
published:
created: 2025-12-15
description: "Delay loading JavaScript for less important parts of the page"
tags:
  - "clippings"
---
A server rendered application uses the server to generate the HTML for the current navigation. Once the server has completed generating the HTML contents, which also contains the necessary CSS and JSON data to display the static UI correctly, it sends the data down to the client. Since the server generated the markup for us, the client can quickly parse this and display it on the screen, which produces a fast First Contentful Paint!  
服务器渲染的应用程序使用服务器生成当前导航的 HTML。一旦服务器完成生成 HTML 内容（这些内容还包含显示静态 UI 所需的 CSS 和 JSON 数据），它就会将数据发送到客户端。由于服务器为我们生成了标记，客户端可以快速解析这些内容并在屏幕上显示，从而产生快速的首屏内容绘制时间！

Although server rendering provides a faster First Contentful Paint, it doesn’t always provide a faster Time To Interactive. The necessary JavaScript in order to be able to interact with our website hasn’t been loaded yet. Buttons *may* look interactive, but they aren’t interactive (yet). The handlers will only get attached once the JavaScript bundle has been loaded and processed. This process is called *hydration*: React checks the current DOM nodes, and hydrates the nodes with the corresponding JavaScript.  
尽管服务器渲染提供了更快的首屏内容绘制时间，但它并不总是提供更快的交互时间。能够与我们的网站交互所需的 JavaScript 尚未加载。按钮可能看起来是可交互的，但实际上还不是（目前）。处理程序只有在 JavaScript 打包文件加载并处理后才会被附加。这个过程称为 hydration：React 检查当前的 DOM 节点，并用相应的 JavaScript 为这些节点进行 hydration。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056521/patterns.dev/prog-rehy-1.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056521/patterns.dev/prog-rehy-1.mp4" type="video/mp4"></video>

The time that the user sees non-interactive UI on the screen is also refered to as the uncanny valley: although users may think that they can interact with the website, there are no handlers attached to the components yet. This can be a frustrating experience for the user, as the UI may look like it’s frozen!  
用户看到屏幕上非交互式 UI 的时间也被称为恐怖谷效应：尽管用户可能认为可以与网站交互，但组件上还没有绑定处理器。这可能会让用户感到沮丧，因为 UI 看起来像是冻结了！

It can take a while before the DOM components that were received from the server are fully hydrated. Before the components can be hydrated, the JavaScript file needs to be loaded, processed, and executed. Instead of hydrating the entire application at once, like we did previously, we can also *progressively hydrate* the DOM nodes. Progressive hydration makes it possible to individually hydrate nodes over time, which makes it possible to only request the minimum necessary JavaScript.  
从服务器接收的 DOM 组件完全水化可能需要一段时间。在组件可以水化之前，需要加载、处理并执行 JavaScript 文件。我们不仅可以像之前那样一次性水化整个应用程序，还可以逐步水化 DOM 节点。逐步水化使得可以随着时间的推移逐个水化节点，这使得只需要请求最小必要的 JavaScript。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056522/patterns.dev/prog-rehy-2.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056522/patterns.dev/prog-rehy-2.mp4" type="video/mp4"></video>

By progressively hydrating the application, we can delay the hydration of less important parts of the page. This way, we can reduce the amount of JavaScript we have to request in order to make the page interactive, and only hydrate the nodes once the user needs it. Progressive hydration also helps avoid the most common SSR Rehydration pitfalls where a server-rendered DOM tree gets destroyed and then immediately rebuilt.  
通过逐步为应用程序进行水合，我们可以延迟页面中不那么重要部分的水合。这样，我们可以减少需要请求的 JavaScript 数量，以便使页面变得可交互，并且只在用户需要时才进行节点的水合。渐进式水合还有助于避免最常见的 SSR 水合陷阱，即服务器渲染的 DOM 树被销毁，然后立即重建。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056521/patterns.dev/prog-rehy-5.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056521/patterns.dev/prog-rehy-5.mp4" type="video/mp4"></video>

Progressive hydration allows us to only hydrate components based on a certain condition, for example when a component is visible in the viewport. In the following example, we have a list of users that gets progressively hydrated once the list is in the viewport. The purple flash shows when the component has been hydrated!  
渐进式水合允许我们根据特定条件仅对组件进行水合，例如当组件在视口中可见时。在以下示例中，当列表进入视口时，用户列表会逐步进行水合。组件水合时会出现紫色闪烁！

client.js

server.js

App.js

Hydrator.js

Stream.js

```jsx
1import React from "react";
2import ReactDOM from "react-dom";
3

4function interopDefault(mod) {
5  return (mod && mod.default) || mod;
6}
7

8export function ServerHydrator({ load, ...props }) {
9  const Child = interopDefault(load());
10

11  return (
12    <section>
13      <Child {...props} />
14    </section>
15  );
16}
17

18export function Hydrator(props) {
19  const ref = React.useRef(null);
20

21  React.useEffect(() => {
22    new IntersectionObserver(async ([entry], obs) => {
23      if (!entry.isIntersecting) return;
24      obs.unobserve(ref.current);
25      const Child = interopDefault(await props.load());
26      setTimeout(
27        () => ReactDOM.hydrate(<Child {...props} />, ref.current),
28        1000
29      );
30    }).observe(ref.current);
31  }, [props]);
32

33  return (
34    <section
35      ref={ref}
36      dangerouslySetInnerHTML={{ __html: "" }}
37      suppressHydrationWarning
38    />
39  );
40}
```

[Open CodeSandbox 打开 CodeSandbox](https://codesandbox.io/embed/streamingrendering2-dgf8z)

Although it happens fast, you can see that the initial UI is the same as the UI in its hydrated state! Since the initial HTML contained the same information and styles, we can seamlessly make the components interactive without any flashy or jumpy UI. Progressive hydration makes it possible to conditionally make certain components interactive, while this can go completely unnoticed to your app’s users.  
虽然这个过程很快，但你可以看到初始 UI 与完全水合状态下的 UI 是相同的！由于初始 HTML 包含了相同的信息和样式，我们可以无缝地使组件变得可交互，而不会出现任何闪烁或跳动的 UI。渐进式水合使得我们可以有条件地使某些组件变得可交互，而用户完全可能完全察觉不到这一点。

---

## Progressive Hydration Implementation渐进式水合实现

In the section on implementing SSR with React, we discussed client-side hydration for an app that is rendered on the server. Hydration allows client-side React to recognize the ReactDOM components that are rendered on the server and attach events to these components. Thus, it introduces continuity and seamlessness for an SSR app to function like a CSR app once it is available on the client.  
在关于使用 React 实现 SSR 的章节中，我们讨论了在服务器上渲染的应用程序的客户端水合。水合允许客户端 React 识别服务器上渲染的 ReactDOM 组件，并将事件附加到这些组件上。因此，它为 SSR 应用程序在客户端可用时像 CSR 应用程序一样运行引入了连续性和无缝性。

For all components on the page to become interactive via hydration, the React code for these components should be included in the bundle that gets downloaded to the client. Highly interactive SPAs that are largely controlled by JavaScript would need the entire bundle at once. However, mostly static websites with a few interactive elements on the screen, may not need all components to be active immediately. For such websites sending a huge React bundle for each component on the screen becomes an [overhead](https://addyosmani.com/blog/rehydration/).  
为了让页面上的所有组件通过水合变得可交互，这些组件的 React 代码应该包含在下载到客户端的包中。高度交互的 SPAs 主要由 JavaScript 控制，需要一次性下载整个包。然而，大部分是静态的网站，屏幕上只有一些交互元素，可能不需要所有组件立即激活。对于这类网站，为屏幕上的每个组件发送一个巨大的 React 包会变成一种负担。

Progressive Hydration solves this problem by allowing us to hydrate only certain parts of the application when the page loads. The other parts are hydrated progressively as required.  
渐进式水合通过允许我们在页面加载时只水合应用程序的某些部分来解决这个问题。其他部分则根据需要逐步水合。

![SSR vs progressive hydration](https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1616962404/patterns.dev/Rendering-ProgressiveHydration.svg)

With Progressive hydration, the “You may also like” and “Other content” components can be hydrated later.  
通过渐进式水合，"您可能还喜欢"和"其他内容"组件可以稍后进行水合。

Instead of initializing the entire application at once, the hydration step begins at the root of the DOM tree, but the individual pieces of the server-rendered application are activated over a period of time. The hydration process may be arrested for various branches and resumed later when they enter the viewport or based on some other trigger. Note that, the loading of resources required to perform each hydration is also deferred using code-splitting techniques, thereby reducing the amount of JavaScript required to make pages interactive.  
一次初始化整个应用程序，而是在 DOM 树的根处开始水合步骤，但服务器渲染的应用程序各个部分会在一段时间内逐步激活。水合过程可能会因各种分支而暂停，并在它们进入视口或基于其他触发条件时继续。请注意，执行每次水合所需的资源加载也通过代码拆分技术被延迟，从而减少了使页面交互所需的 JavaScript 量。

The idea behind progressive hydration is to provide a great performance by activating your app in chunks. Any progressive hydration solution should also take into account how it will impact the overall user experience. You cannot have chunks of screen popping up one after the other but blocking any activity or user input on the chunks that have already loaded. Thus, the requirements for a holistic progressive hydration implementation are as follows.  
渐进式水合的理念是通过分块激活应用来提供出色的性能。任何渐进式水合解决方案都应该考虑它将如何影响整体用户体验。你不能让屏幕的一块块内容一个接一个地弹出，但同时又阻塞已加载内容块上的任何活动或用户输入。因此，一个全面的渐进式水合实现要求如下。

1. Allows usage of SSR for all components.  
	允许所有组件使用 SSR。
2. Supports splitting of code into individual components or chunks.  
	支持将代码拆分为单个组件或代码块。
3. Supports client side hydration of these chunks in a developer defined sequence.  
	支持按开发者定义的顺序在客户端逐个为这些代码块进行水合。
4. Does not block user input on chunks that are already hydrated.  
	已水合的代码块不会阻塞用户输入。
5. Allows usage of some sort of a loading indicator for chunks with deferred hydration.  
	允许对延迟水合的代码块使用某种加载指示器。

[React concurrent mode](https://reactjs.org/docs/concurrent-mode-patterns.html) will address all these requirements once it is available to all. It allows React to work on different tasks at the same time and switch between them based on the given priority. When switching, a partially rendered tree need not be committed, so that the rendering task can continue once React switches back to the same task.  
React 并发模式将在其可用时解决所有这些需求。它允许 React 同时处理不同任务，并根据给定的优先级在它们之间切换。切换时，无需提交部分渲染的树，这样一旦 React 切换回同一任务，渲染任务就可以继续。

Concurrent mode can be used to implement progressive hydration. In this case, hydration of each of the chunks on the page, becomes a task for React concurrent mode. If a task of higher priority like user input needs to be performed, React will pause the hydration task and switch to accepting the user input. Features like [lazy(), Suspense()](https://reactjs.org/docs/code-splitting.html#reactlazy) allow you to use declarative loading states. These can be used to show the loading indicator while chunks are being lazy loaded. SuspenseList() can be used to define the priority for lazy loading components.[This](https://codesandbox.io/s/floral-worker-xwbwv) demo shared by [Dan Abramov](https://twitter.com/dan_abramov/status/1200111677833973760) shows concurrent mode in action and implements progressive hydration.  
并发模式可用于实现渐进式水合。在这种情况下，页面上的每个代码块的水合都成为 React 并发模式的任务。如果需要执行更高优先级的任务，如用户输入，React 将暂停水合任务并切换到接受用户输入。lazy()、Suspense()等功能允许你使用声明式加载状态。这些功能可用于在代码块懒加载时显示加载指示器。SuspenseList()可用于定义懒加载组件的优先级。Dan Abramov 分享的这段演示展示了并发模式的使用，并实现了渐进式水合。

React concurrent mode can also be combined with another React feature  
React 并发模式还可以与其他 React 功能结合使用

- [Server Components](https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md). This will allow you to refetch components from the server and render them on the client as they stream in instead of waiting for the whole fetch to finish. Thus, the client’s CPU is put to work even as we wait for the network fetch to finish.  
	服务器组件。这将允许你从服务器重新获取组件，并在它们流式传输到客户端时渲染它们，而不是等待整个获取完成。因此，即使我们在等待网络获取完成时，客户端的 CPU 也在工作。

While the React concurrent mode based progressive hydration implementation is still getting ready, many other contenders for a partial hydration implementation are available. Progressive hydration was demonstrated at [Google I/O ‘19](https://www.youtube.com/watch?v=k-A2VfuUROg&t=960s). The [demo for progressive hydration](https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples/tree/master/react-progressive-hydration) showed the use of a Hydrator component to hydrate selected sections of the page. Multiple implementations have spawned from this for different client-side frameworks. Implementations are also available for Vue, Angular and Next.js.  
虽然基于 React 并发模式的渐进式水合实现仍在准备中，但许多其他用于部分水合实现的竞争者已经可用。渐进式水合在 Google I/O ‘19 上进行了演示。渐进式水合的演示展示了使用 Hydrator 组件来水合页面选定部分。由此衍生出了多种针对不同客户端框架的实现。Vue、Angular 和 Next.js 也有可用的实现。

Let is take a quick look at one such method using Preact and Next.js  
让我们快速看一下使用 Preact 和 Next.js 的一种方法。

[This](https://github.com/LukasBombach/next-super-performance) is a POC for partial hydration using  
这是一个用于部分水合的 POC

1. `pool-attendant-preact:` A library that implements partial hydration with preact x.  
	`pool-attendant-preact:` 一个使用 preact 实现部分 hydration 的库。
2. `next-super-performance:` A Next.js plugin that uses this library to improve client-side performance.  
	`next-super-performance:` 一个使用该库来提升客户端性能的 Next.js 插件。

The `pool-attendant-preact` library includes an API called `withHydration` which lets you mark your more interactive components for hydration. These will be hydrated first. You can use this to define your page content as follows.  
`pool-attendant-preact` 库包含一个名为 `withHydration` 的 API，它允许你标记更交互式的组件进行水合。这些组件将首先被水合。你可以使用它来定义页面内容，如下所示。

```jsx
import Teaser from "./teaser";

import { withHydration } from "next-super-performance";

const HydratedTeaser = withHydration(Teaser);

export default function Body() {

  return (

    <main>

      <Teaser column={1} />

      <HydratedTeaser column={2} />

      <HydratedTeaser column={3} />

      <Teaser column={1} />

      <Teaser column={2} />

      <Teaser column={3} />

      <Teaser column={1} />

      <Teaser column={2} />

      <Teaser column={3} />

    </main>

  );

}
```

The component `HydratedTeaser` in columns 2 and 3 will be hydrated first. You can now hydrate the remaining components on the client using the `hydrate()` API which is also included in the library.  
列 2 和列 3 中的组件 `HydratedTeaser` 将首先被水合。您现在可以使用库中包含的 `hydrate()` API 在客户端水合其余组件。

```jsx
import { hydrate } from "next-super-performance";

import Teaser from "./components/teaser";

hydrate([Teaser]);
```

The component `HydrationData` is used to write serialized props to the client. It will ensure that the required props are available to the components being hydrated.  
组件 `HydrationData` 用于将序列化的 props 写入客户端。它将确保所需的 props 对正在被激活的组件可用。

```jsx
import Header from "../../components/header";

import Main from "../../components/main";

import { HydrationData } from "next-super-performance";

export default function Home() {

  return (

    <section>

      <Header />

      <Main />

      <HydrationData />

    </section>

  );

}
```

---

## Pros and Cons 优点和缺点

Progressive hydration provides server-side rendering with client-side hydration while also minimizing the cost of hydration. Following are some of the advantages that can be gained from this.  
渐进式水合提供了服务器端渲染，同时支持客户端水合，并最小化了水合的成本。以下是一些由此带来的优势。

1. **Promotes code-splitting**: Code-splitting is an integral part of progressive hydration because chunks of code need to be created for individual components that are lazy- loaded.  
	促进代码拆分：代码拆分是渐进式水合的重要组成部分，因为需要为懒加载的各个组件创建代码块。
2. **Allows on-demand loading for infrequently used parts of the page**: There may be components of the page that are mostly static, out of the viewport and/or not required very often. Such components are ideal candidates for lazy loading. Hydration code for these components need not be sent when the page loads. Instead, they may be hydrated based on a trigger.  
	允许按需加载页面中不常用的部分：页面上可能有大部分是静态的、不在视口内和/或很少需要使用的组件。这些组件是懒加载的理想候选对象。加载这些组件的 hydration 代码不需要在页面加载时发送。相反，它们可以根据触发器进行 hydration。
3. **Reduces bundle size:** Code-splitting automatically results in a reduction of bundle size. Less code to execute on load helps reduce the time between FCP and TTI.  
	减小包体积：代码分割会自动减小包体积。加载时需要执行的代码更少，有助于缩短 FCP 和 TTI 之间的时间。

> **Note (React 18+): Use `<Suspense>` with `lazy()` for Hydration Control  
> 注意（React 18+）：使用 `<Suspense>` 与 `lazy()` 进行 hydration 控制**
> 
> React 18’s Concurrent Features now address the progressive hydration requirements: selective hydration on interaction means if the user tries to interact with a not-yet-hydrated part, React will prioritize hydrating that part—this is built-in.  
> React 18 的并发特性现在可以满足渐进式水合的需求：交互式选择性水合意味着如果用户尝试与尚未水合的部分交互，React 将优先水合该部分——这是内置的。
> 
> A practical pattern is to wrap non-critical components in a `<Suspense fallback={...}>`. On the server, render a lightweight placeholder, and code-split the real component with `React.lazy`. For example:  
> 一个实用的模式是将非关键组件包裹在 `<Suspense fallback={...}>` 中。在服务器端，渲染一个轻量级的占位符，并使用 `React.lazy` 对真实组件进行代码拆分。例如：
> 
> ```jsx
> const Comments = React.lazy(() => import('./Comments'));
> 
> // ...
> 
> <Suspense fallback={null}>
> 
>   <Comments {...props} />
> 
> </Suspense>
> ```
> 
> This streams a placeholder in the SSR output and doesn’t block the rest of the page. The `Comments` component hydrates once its code is fetched. In Next.js, use `next/dynamic` with `{ ssr: false }` for truly client-only widgets, or Suspense for parts that can be temporarily left as loading. The key is to make the user perceive the app as interactive as soon as possible, even if under the hood some parts activate slightly later.  
> 这会在 SSR 输出中流式传输一个占位符，并且不会阻塞页面的其余部分。 `Comments` 组件在其代码被获取后会进行一次水合。在 Next.js 中，使用 `next/dynamic` 与 `{ ssr: false }` 来实现真正的客户端仅组件，或者使用 Suspense 来处理可以暂时保留为加载状态的部分。关键在于尽快让用户感知到应用是交互式的，即使底层某些部分稍后才激活。

On the downside, progressive hydration may not be suitable for dynamic apps where every element on the screen is available to the user and needs to be made interactive on load. This is because, if developers do not know where the user is likely to click first, they may not be able to identify which components to hydrate first.  
然而，渐进式水合可能不适用于所有屏幕元素都可供用户使用且需要在加载时变为交互式的动态应用。这是因为，如果开发者不知道用户可能首先点击哪里，他们可能无法确定首先需要水合哪些组件。