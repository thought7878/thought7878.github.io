---
title: "Selective Hydration"
source: "https://www.patterns.dev/react/react-selective-hydration/"
author:
published:
created: 2025-12-15
description: "How to use combine streaming server-side rendering with a new approach to hydration, selective hydration"
tags:
  - "clippings"
---
In [previous articles](https://www.patterns.dev/posts/ssr), we covered how SSR with hydration can improve user experience. React is able to (quickly) generate a tree on the server using the `renderToString` method that the `react-dom/server` library provides, which gets sent to the client after the entire tree has been generated. The rendered HTML is non interactive, until the JavaScript bundle has been fetched and loaded, after which React walks down the tree to hydrate and attaches the handlers.  
在之前的文章中，我们介绍了 SSR（服务器端渲染）结合 hydration 如何提升用户体验。React 能够通过 `renderToString` 库提供的 `react-dom/server` 方法在服务器上（快速）生成一棵树，并在整棵树生成完毕后将其发送给客户端。渲染的 HTML 是非交互式的，直到 JavaScript 包被获取并加载后，React 才会遍历这棵树进行 hydration 并附加事件处理器。

However, this approach can lead to some performance issues due to some limitations with the current implementation.  
然而，由于当前实现的某些限制，这种方法可能会导致一些性能问题。

Before the server-rendered HTML tree is able to get sent to the client, all components need to be ready. This means that components that may rely on an external API call or any process that could cause some delays, might end up blocking smaller components from being rendered quickly.  
在服务器渲染的 HTML 树能够发送给客户端之前，所有组件都需要准备就绪。这意味着那些可能依赖外部 API 调用或任何可能导致延迟的过程的组件，可能会阻塞较小组件的快速渲染。

Besides a slower tree generation, another issue is the fact that React only hydrates the tree once. This means that before React is able to hydrate any of the components, it needs to have fetched the JavaScript for all of the components before it’s able to hydrate any of them. This means that smaller components (with smaller bundles) have to wait for the larger components’s code to be fetched and loaded, until React is able to hydrate anything on your website. During this time, the website remained non-interactive.  
除了树生成速度较慢之外，另一个问题是 React 只对树进行一次水合。这意味着在 React 能够水合任何组件之前，它需要先获取所有组件的 JavaScript 代码才能开始水合。这意味着具有较小包的小组件必须等待较大组件的代码被获取和加载，直到 React 能够水合网站上的任何内容。在此期间，网站保持非交互状态。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1631144761/patterns.dev/selective-hydration-before.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1631144761/patterns.dev/selective-hydration-before.mp4" type="video/mp4"></video>

React 18 solves these problems by allowing us to combine streaming server-side rendering with a new approach to hydration: Selective Hydration!  
React 18 通过允许我们结合流式服务器端渲染与一种新的水合方法解决了这些问题：选择性水合！

---

Instead of using the `renderToString` method that we covered earlier, we can now stream render HTML using the new `pipeToNodeStream` method on the server.  
我们现在可以使用服务器上的新 `pipeToNodeStream` 方法流式渲染 HTML，而不是使用我们之前介绍过的 `renderToString` 方法。

This method, in combination with the `createRoot` method and `Suspense`, makes it possible to start streaming HTML without having to wait for the larger components to be ready. This means that we can lazy-load components when using SSR, which wasn’t (really) possible before!  
结合 `createRoot` 方法、 `Suspense` 方法，这种方法使得我们可以在不必等待较大组件准备就绪的情况下开始流式传输 HTML。这意味着在使用 SSR 时，我们可以懒加载组件，这在之前（实际上）是不可能的！

*This is a simplified example inspired by [this codesandbox](https://codesandbox.io/s/festive-star-9hfqt?file=/src/index.js:193-320)  
这是一个受此 codesandbox 启发的简化示例*

The `Comments` component, which earlier slowed down the tree generation and TTI, is now wrapped in `Suspense`. This tells React to not let this component slow down the rest of the tree generation. Instead, React inserts the fallback components as the initially rendered HTML, and continues to generate the rest of the tree before it’s sent to the client.  
之前会减慢树生成和 TTI 的 `Comments` 组件，现在被包裹在 `Suspense` 中。这告诉 React 不要让这个组件减慢树生成的其余部分。相反，React 将回退组件作为初始渲染的 HTML，并在发送到客户端之前继续生成树的其余部分。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/eo_9/v1631144841/patterns.dev/selective-hydration-after.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/eo_9/v1631144841/patterns.dev/selective-hydration-after.mp4" type="video/mp4"></video>

In the meantime, we’re still fetching the external data that we need for the `Comments` component.  
与此同时，我们仍在获取 `Comments` 组件所需的的外部数据。

Selective hydration makes it possible to already hydrate the components that were sent to the client, even before the `Comments` component has been sent!  
选择性水化使得在 `Comments` 组件发送给客户端之前，就可以预先水化那些已经发送的组件！

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/eo_12/v1631144841/patterns.dev/selective-hydration-after.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/eo_12/v1631144841/patterns.dev/selective-hydration-after.mp4" type="video/mp4"></video>

Once the data for the `Comments` component is ready, React starts streaming the HTML for this component, as well as a small `<script>` to replace the fallback loader.  
一旦 `Comments` 组件的数据准备就绪，React 就开始为这个组件流式传输 HTML，同时还会传输一个小 `<script>` 来替换备用加载器。

React starts the hydration after the new HTML has been injected.  
React 在新的 HTML 注入后开始执行水化。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1631147513/patterns.dev/selective-hydration-after-2.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1631147513/patterns.dev/selective-hydration-after-2.mp4" type="video/mp4"></video>

---

React 18 fixes some issues that people often encountered when using SSR with React.  
React 18 修复了一些人们在使用 React 进行 SSR 时经常遇到的问题。

Streaming rendering allows you to start streaming components as soon as they’re ready, without risking a slower FCP and TTI due to components that might take longer to generate on the server.  
流式渲染允许你一旦组件准备好就开始流式传输，而不用担心由于某些组件在服务器上生成可能需要更长时间而导致 FCP 和 TTI 变慢。

Components can be hydrated as soon as they’re streamed to the client, since we no longer have to wait for all JavaScript to load to start hydrating and can start interacting with the app before all components have been hydrated.  
组件可以在被流式传输到客户端后立即进行水合，因为我们不再需要等待所有 JavaScript 加载才开始水合，并且可以在所有组件都完成水合之前就开始与应用交互。

> **Note (React 18+): Best Practices for Selective Hydration  
> 注意（React 18+）：选择性水合的最佳实践**
> 
> Use Suspense boundaries in your SSR code to delineate independent chunks of UI—each Suspense boundary can hydrate independently. Structure your code so that any heavy data-fetching component is inside a Suspense, so it doesn’t delay the initial HTML or hydration of siblings. Next.js automatically wraps each route segment in a Suspense boundary for you (via `loading.js`).  
> 在你的 SSR 代码中使用 Suspense 边界来划分独立的 UI 块——每个 Suspense 边界可以独立地完成水合。组织你的代码，确保任何重量级的数据获取组件都位于 Suspense 内部，这样就不会延迟初始 HTML 或兄弟组件的水合。Next.js 会自动为你将每个路由段包裹在 Suspense 边界中（通过 `loading.js` ）。
> 
> If writing your own SSR, use `renderToPipeableStream()` (or `renderToReadableStream`) instead of the older `renderToNodeStream`, and provide an `onShellReady` callback to flush early HTML. React will attach event listeners progressively as chunks come in.  
> 如果自己编写 SSR，请使用 `renderToPipeableStream()` （或 `renderToReadableStream` ）代替旧的 `renderToNodeStream` ，并提供一个 `onShellReady` 回调来提前刷新 HTML。React 会随着代码块的接收逐步附加事件监听器。
> 
> **Ensure critical interactive components are not inside a loading fallback** when they appear on screen, or if they are, that the fallback is very short-lived. If a user sees a button, it should be hydratable immediately. Verify you’re not using legacy APIs—use `hydrateRoot` correctly for React 18+ to benefit from these performance boosts.  
> 确保关键交互组件在屏幕上出现时不在加载回退中，或者如果存在回退，则回退时间非常短。如果用户看到按钮，应该立即可以进行水合。验证你没有使用遗留 API——对于 React 18+，应正确使用 `hydrateRoot` 来受益于这些性能提升。

---

## References 参考文献

- [New Suspense SSR Architecture in React 18  
	React 18 中的新 Suspense SSR 架构](https://github.com/reactwg/react-18/discussions/37)