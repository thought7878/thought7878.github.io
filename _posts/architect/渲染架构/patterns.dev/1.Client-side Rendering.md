---
title: "Client-side Rendering"
source: "https://www.patterns.dev/react/client-side-rendering/"
author:
published:
created: 2025-12-15
description: "Render your application's UI on the client"
tags:
  - "clippings"
---
In Client-Side Rendering (CSR) only the barebones HTML container for a page is rendered by the server. The logic, data fetching, templating and routing required to display content on the page is handled by JavaScript code that executes in the browser/client. CSR became popular as a method of building single-page applications. It helped to blur the difference between websites and installed applications.  
在`客户端渲染（CSR）`中，**服务器仅渲染页面最基本的 HTML 容器**。页面显示内容**所需的逻辑、数据获取、模板、路由**，**由在浏览器/客户端执行的 JavaScript 代码处理**。CSR 作为*构建单页应用程序*的方法而流行起来。它有助于*模糊网站和安装应用程序之间的区别*。

To better appreciate the benefits provided by other patterns, let us first take a deeper look at Client-Side Rendering (CSR) and find out which are the situations where it works great and what are its drawbacks.  
*为了更好地理解其他模式带来的好处*，让我们先深入了解一下客户端渲染（CSR），找出它在哪些情况下*表现优异*以及*它的缺点*是什么。

---

## 基本结构
Basic structure 

Consider this simple example for showing and [updating the current time](https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element) on a page using React.  
考虑这个简单的例子，展示如何在 React 页面中*显示和更新当前时间*。

index.js
```jsx
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById("root"));
}

setInterval(tick, 1000);

```
index.html
```html
<div id="root"></div>
```

The HTML consists of just a single root `<div>` tag. Content display and updates on the other hand are handled completely in JavaScript. There is no round trip to the server and rendered HTML is updated in-place. Here time could be replaced by any other real-time information like exchange rates or stock prices obtained from an API and displayed without refreshing the page or a round trip to the server.  
*HTML 仅包含一个根 `<div>` 标签*。而**内容显示和更新则完全由 JavaScript 处理**。没有往返服务器的过程，渲染的 HTML 会原地更新。*这里的时间可以被替换为任何其他实时信息*，如从 API 获取的汇率或股票价格，而无需刷新页面或往返服务器即可显示。

---

## JavaScript 打包和性能
JavaScript bundles and Performance

As the complexity of the page increases to show images, display data from a data store and include event handling, the complexity and size of the JavaScript code required to render the page will also increase. CSR resulted in large JavaScript bundles which increased the FCP and TTI of the page.  
**随着页面复杂度增加**，需要显示图片、从数据存储中读取数据、包含事件处理，**渲染页面所需的 JavaScript 代码的复杂度和大小也会增加**。**CSR 导致了大型 JavaScript 打包，增加了页面的 FCP 和 TTI**。

![[_posts/architect/渲染架构/patterns.dev/media/0e642d67841c37ef095e463c6c4634a9_MD5.png]]

Image Source: [https://www.youtube.com/watch?v=k-A2VfuUROg&feature=youtu.be](https://www.youtube.com/watch?v=k-A2VfuUROg&feature=youtu.be)  
图片来源：https://www.youtube.com/watch?v=k-A2VfuUROg&feature=youtu.be

As shown in the above illustration, as the size of bundle.js increases, the FCP and TTI are pushed forward. This implies that the user will see a blank screen for the entire duration between FP and FCP.  
**如上图所示，随着 bundle.js 大小的增加，FCP 和 TTI 被推迟**。这意味着**用户在 FP 和 FCP 之间的整个时间段内会看到一个*空白屏幕***。

---

## 优点和缺点
Pros and Cons 

With React most of the application logic is executed on the client and it interacts with the server through API calls to fetch or save data. Almost all of the UI is thus generated on the client. The entire web application is loaded on the first request. As the user navigates by clicking on links, no new request is generated to the server for rendering the pages. The code runs on the client to change the view/data.  
**使用 React 时，大部分应用逻辑在客户端执行，并通过 API 调用与服务器交互以获取或保存数据**。*因此几乎所有 UI 都在客户端生成*。**整个 Web 应用在第一次请求时加载**。*当用户通过点击链接进行导航时，不会向服务器生成新的请求来渲染页面。代码在客户端运行以改变视图/数据*。

CSR allows us to have a Single-Page Application that supports navigation without page refresh and provides a great user experience. As the data processed to change the view is limited, routing between pages is generally faster making the CSR application seem more responsive. CSR also allows developers to achieve a clear separation between client and server code.  
CSR 使我们能够拥有一个支持**无页面刷新**的导航且**提供出色用户体验**的单页面应用程序。*由于改变视图的数据处理是有限的*，**页面之间的路由通常更快**，使得 CSR 应用程序**看起来更加响应迅速**。CSR 还允许开发者**在客户端和服务器代码之间实现清晰的分离**。

> **Note (React 18+): Reevaluate Pure CSR for Initial Loads  
> 注释（React 18+）：重新评估初始加载的纯客户端渲染**
> 
> While CSR yields a rich interactive experience after load, it has well-known drawbacks for first-page load performance and SEO. Today’s best practice is to **avoid pure-CSR for content-rich or public-facing pages**. Instead, use hybrid approaches (SSR/SSG plus hydration) for the initial render. Frameworks like Next.js now default to pre-rendering pages on the server (or at build time) and then hydrating on the client.  
> 虽然 `CSR` 在加载后能提供丰富的交互体验，但它**对首屏加载性能和 SEO 存在众所周知的问题**。如今**最佳实践**是*避免对内容丰富或面向公众的页面使用纯 CSR*。相反，**应采用混合方法（SSR/SSG +水合）进行初始渲染**。*像 Next.js 这样的框架*现在默认在服务器（或构建时）预渲染页面，然后在客户端进行水合。
> 
> Server-rendering HTML can drastically improve FCP and make content indexable for search engines. React 18’s improvements (automatic batching, Suspense, streaming) make SSR + hydration very performant. React 18 also introduced **Progressive Hydration** and **Selective Hydration** which mitigate the traditional TTI gap—React can hydrate parts of the UI as their scripts arrive or as the user interacts.  
> `服务器端渲染` HTML 可以**显著提升 FCP**，并使内容**对搜索引擎可索引**。*React 18 的改进*（`自动批处理`、`Suspense`、`流式传输`）*使 SSR+hydration 性能非常出色*。React 18 还引入了`渐进式 hydration` 和`选择性 hydration`，**缓解了传统的 TTI 差距**——React 可以在其脚本到达时或用户交互时 hydration UI 的各个部分。
> 
> **Conclusion:** Pure CSR (loading a big bundle and rendering everything on client) is generally **discouraged for large apps**. Use SSR/SSG for initial content and hydrate on the client. If you *do* use CSR (e.g., an internal dashboard where SEO doesn’t matter), apply aggressive code-splitting and use React 18’s `<Suspense>` with lazy-loaded components to defer loading non-critical parts of the UI.  
> ***结论：*** 对于大型应用，*纯 CSR*（加载大包并在客户端渲染所有内容）*通常不被推荐*。**使用 SSR/SSG 加载初始内容，并在客户端 hydration**。如果你确实使用 CSR（例如，SEO 不重要的内部仪表盘），**应用激进的代码拆分，并使用 React 18 的 `<Suspense>` 与懒加载组件来延迟加载非关键 UI 部分**。

Despite the great interactive experience that it provides, there are a few pitfalls to this CSR.  
尽管它提供了极好的交互体验，但这种客户端渲染（CSR）还是**存在一些陷阱**。

1. **SEO considerations:** Most web crawlers can interpret server rendered websites in a straight-forward manner. Things get slightly complicated in the case of client-side rendering as large payloads and a waterfall of network requests (e.g for API responses) may result in meaningful content not being rendered fast enough for a crawler to index it. Crawlers may understand JavaScript but there are limitations. As such, some workarounds are required to make a client-rendered website SEO friendly.  
	`SEO` 考量：大多数网络爬虫能够直接解析服务器渲染的网站。但在客户端渲染的情况下，事情会稍微复杂一些，因为大量的有效载荷和网络请求（例如 API 响应）*可能导致有意义的內容无法被爬虫足够快地渲染，从而影响其索引*。爬虫可能理解 JavaScript，但存在局限性。因此，需要一些解决方案来使客户端渲染的网站对 SEO 友好。
2. **Performance**: With client-side rendering, the response time during interactions is greatly improved as there is no round trip to the server. However, for browsers to render content on client-side the first time, they have to wait for the JavaScript to load first and start processing. Thus users will experience some lag before the initial page loads. This may affect the user experience as the size of JS bundles get bigger and/or the client does not have sufficient processing power.  
	`性能`：通过客户端渲染，*交互过程中的响应时间得到显著提升，因为没有往返服务器的过程*。然而，浏览器*在客户端首次渲染内容时*，必须先等待 JavaScript 加载并开始处理。**因此，用户在初始页面加载前会经历一些延迟**。**当 JS 包体变大以及/或者客户端处理能力不足时，这可能会影响用户体验**。
3. **Code Maintainability:** Some elements of code may get repeated across client and server (APIs) in different languages. In other cases, clean separation of business logic may not be possible. Examples of this could include validations and formatting logic for currency and date fields.  
	`代码可维护性`：某些代码元素可能会在客户端和服务器（API）的不同语言中重复出现。在其他情况下，可能无法实现业务逻辑的清晰分离。这种情况的例子可能包括*货币和日期字段的验证和格式化逻辑*。
4. **Data Fetching**: With client-side rendering, data fetching is usually event-driven. The page could initially be loaded without any data. Data may be subsequently fetched on the occurrence of events like page-load or button-clicks using API calls. Depending on the size of data this could add to the load/interaction time of the application.  
	`数据获取`：在客户端渲染中，*数据获取通常是事件驱动的*。页面初始加载时可能没有数据。数据可以在页面加载或按钮点击等事件发生时通过 API 调用随后获取。根据数据的大小，这可能会增加应用的加载/交互时间。

The importance of these considerations may be different across applications. Developers are often interested in finding SEO friendly solutions that can serve pages faster without compromising on the interaction time. Priorities assigned to the different performance criteria may be different based on application requirements. Sometimes it may be enough to use client- side rendering with some tweaks instead of going for a completely different pattern.  
这些考虑的重要性在不同应用中可能有所不同。开发者通常希望找到*既能快速服务页面又不影响交互时间的 SEO 友好解决方案*。根据应用需求，分配给不同性能标准的优先级可能会有所不同。有时使用一些调整的客户端渲染就足够了，而无需采用完全不同的模式。

---

## 提升 CSR 性能
Improving CSR performance

Since performance for CSR is inversely proportional to the size of the JavaScript bundle, the best thing we can do is structure our JavaScript code for optimal performance. Following is a list of pointers that could help.  
**由于 CSR 的性能与 JavaScript 包的大小成反比**，我们**能做的最好的事情**就是*为最佳性能来构建我们的 JavaScript 代码*。*以下是一系列建议*，可能有助于此目的。

- **Budgeting JavaScript**: Ensure that you have a reasonably tight JavaScript budget for your initial page loads. An initial bundle of < 100-170KB minified and gzipped is a good starting point. Code can then be loaded on-demand as features are needed  
	`预算 JavaScript`：确保*为初始页面加载合理地控制 JavaScript 预算*。**一个初始包在压缩和 gzip 后小于 100-170KB** 是一个好的起点。*然后代码可以根据需要按需加载*。
- **Preloading**: This technique can be used to preload critical resources that would be required by the page, earlier in the page lifecycle. Critical resources may include JavaScript which can be preloaded by including the following directive in the `<head>` section of the HTML.  
	`预加载`：这种技术可用于*在页面生命周期早期预加载页面所需的关键资源*。关键资源可能包括 JavaScript，可以通过在 HTML 的 `<head>` 部分包含以下指令来预加载。
```jsx
<link rel="preload" as="script" href="critical.js" />
```

This informs the browser to start loading the `critical.js` file before the page rendering mechanism starts. The script will thus be available earlier and will not block the page rendering mechanism thereby improving the performance.  
*这会通知浏览器在页面渲染机制开始之前就开始加载 `critical.js` 文件*。因此**脚本将更早可用，并且不会阻塞页面渲染机制，从而提高性能**。

- Lazy loading: With lazy loading, you can identify resources that are non-critical and load these only when needed. Initial page load times can be improved using this approach as the size of resources loaded initially is reduced. For example., a chat widget component would generally not be needed immediately on page load and can be lazy loaded.  
	`懒加载`：通过懒加载，你可以**识别非关键资源**，并**在需要时才加载这些资源**。这种方法**可以减少初始页面加载时间，因为初始加载的资源大小得以减小**。例如，聊天小部件组件通常在页面加载时并不立即需要，可以采用懒加载。
- Code Splitting: To avoid a large bundle of JavaScript code, you could start splitting your bundles. Code-Splitting is supported by bundlers like [Webpack](https://webpack.js.org/guides/code-splitting/) where it can be used to create multiple bundles that can be dynamically loaded at runtime. Code splitting also enables you to lazy load JavaScript resources.  
	`代码拆分`：**为了避免一个庞大的 JavaScript 代码包**，你可以开始**拆分你的代码包**。代码拆分*由 Webpack 等打包工具支持*，它可用于创建可以*在运行时动态加载的多个代码包*。代码拆分还使你**能够惰性加载 JavaScript 资源**。
- Application shell caching with service workers: This technique involves caching the application shell which is the minimal HTML, CSS, and JavaScript powering a user interface. Service workers can be used to cache the application shell offline. This can be useful in providing a native single-page app experience where the remaining content is loaded progressively as needed.  
	`使用service worker进行应用壳缓存`：这种技术涉及*缓存应用壳*，即**驱动用户界面的最小 HTML、CSS 和 JavaScript**。service worker可用于*离线缓存应用壳*。这有助于提供原生单页应用体验，其中*剩余内容根据需要逐步加载*。

With these techniques, CSR can help to provide a faster Single-Page Application experience with a decent FCP and TTI. Next, we will see what is available at the other end of the spectrum with Server-Side Rendering.  
利用这些技术，CSR 可以帮助提供更快的单页应用程序体验，具有合理的首次内容绘制（FCP）和首次输入时间（TTI）。接下来，我们将看看在另一端（即服务器端渲染）有哪些可用选项。