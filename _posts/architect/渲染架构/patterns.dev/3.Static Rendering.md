---
title: "Static Rendering"
source: "https://www.patterns.dev/react/static-rendering/"
author:
published:
created: 2025-12-15
description: "Deliver pre-rendered HTML content that was generated when the site was built"
tags:
  - "clippings"
---
Based on our discussion on SSR, we know that a high request processing time on the server negatively affects the TTFB. Similarly, with CSR, a large JavaScript bundle can be detrimental to the FCP, LCP and TTI of the application due to the time taken to download and process the script.  
基于我们对 SSR 的讨论，我们知道服务器上高请求处理时间会负面影响 TTFB。类似地，在 CSR 中，由于下载和处理脚本所需的时间，一个庞大的 JavaScript 包可能会对应用的 FCP、LCP 和 TTI 造成损害。

Static rendering or static generation (SSG) attempts to resolve these issues by delivering pre-rendered HTML content to the client that was generated when the site was built.  
静态渲染或静态生成（SSG）试图通过向客户端交付在网站构建时预渲染的 HTML 内容来解决这些问题。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617429548/patterns.dev/static-generation-1.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617429548/patterns.dev/static-generation-1.mp4" type="video/mp4"></video>

A static HTML file is generated ahead of time corresponding to each route that the user can access. These static HTML files may be available on a server or a CDN and fetched as and when requested by the client.  
一个静态 HTML 文件会在用户访问之前预先生成，对应于用户可以访问的每个路由。这些静态 HTML 文件可以存储在服务器或 CDN 上，并根据客户端的请求随时获取。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617496085/patterns.dev/static-generation-2.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617496085/patterns.dev/static-generation-2.mp4" type="video/mp4"></video>

Static files may also be cached thereby providing greater resiliency. Since the HTML response is generated in advance, the processing time on the server is negligible thereby resulting in a faster TTFB and better performance. In an ideal scenario, client-side JS should be minimal and static pages should become interactive soon after the response is received by the client. As a result, SSG helps to achieve a faster FCP/TTI.  
静态文件也可以被缓存，从而提供更高的容错性。由于 HTML 响应是在预先生成的，因此服务器上的处理时间可以忽略不计，从而实现更快的 TTFB 和更好的性能。在理想情况下，客户端 JS 应该尽量少，静态页面在客户端接收到响应后应尽快变得交互。因此，SSG 有助于实现更快的 FCP/TTI。

![](https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1617497570/patterns.dev/Screen_Shot_2021-04-03_at_5.52.41_PM.png)

---

## Basic Structure 基本结构

As the name suggests, static rendering is ideal for static content, where the page need not be customized based on the logged-in user (e.g personalized recommendations). Thus static pages like the ‘ *About us* ’, ‘ *Contact us* ‘,*Blog* pages for websites or product pages for e-commerce apps, are ideal candidates for static rendering. Frameworks like Next.js, Gatsby, and VuePress support static generation. Let us start with this simple [Next.js example](https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation#about-us-page-static-generation-without-data) of static content rendering without any data.  
顾名思义，静态渲染非常适合静态内容，其中页面无需根据登录用户进行定制（例如个性化推荐）。因此，像“关于我们”、“联系我们”、网站博客页面或电商应用的产品页面等静态页面非常适合静态渲染。Next.js、Gatsby 和 VuePress 等框架支持静态生成。让我们从一个简单的 Next.js 示例开始，展示没有数据时的静态内容渲染。

**Next.js:**

```
// pages/about.js

export default function About() {

  return (

    <div>

      <h1>About Us</h1>

      {/* ... */}

    </div>

  );

}
```

When the site is built (using `next build`), this page will be pre-rendered into an HTML file `about.html` accessible at the route `/about`.  
当站点构建时（使用 `next build` ），此页面将被预渲染为一个 HTML 文件 `about.html` ，可在路由 `/about` 访问。

---

## SSG with Data 带数据的静态生成

Static content like that in ‘About us’ or ‘Contact us’ pages may be rendered as-is without getting data from a data-store. However, for content like individual blog pages or product pages, the data from a data-store has to be merged with a specific template and then rendered to HTML at build time.  
静态内容，如“关于我们”或“联系我们”页面中的内容，可以直接渲染而无需从数据存储中获取数据。然而，对于个人博客页面或产品页面等内容，需要在构建时将数据存储中的数据与特定模板合并，然后渲染为 HTML。

The number of HTML pages generated will depend on the number of blog posts or the number of products respectively. To get to these pages, you may also have listing pages which will be HTML pages that contain a categorized and formatted list of data items. These scenarios can be addressed using Next.js static rendering. We can generate listing pages or individual item pages based on the available items. Let us see how.  
生成的 HTML 页面数量将取决于博客文章的数量或产品的数量。为了访问这些页面，您可能还需要列表页面，这些页面将包含分类和格式化的数据项列表。这些情况可以使用 Next.js 静态渲染来解决。我们可以根据可用的项目生成列表页面或单个项目页面。让我们看看如何实现。

### Listing Page - All Items列表页面 - 所有项目

Generation of a listing page is a scenario where the content to be displayed on the page depends on external data. This data will be fetched from the database at build time to construct the page. In Next.js this can be achieved by exporting the function `getStaticProps()` in the page component. The function is called at build time on the build server to fetch the data. The data can then be passed to the page’s `props` to pre-render the page component. Let us look at the code for generating a product listing page which was originally shared as part of [this post](https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation#all-products-page-static-generation-with-data).  
生成列表页面的场景是页面显示的内容依赖于外部数据。这些数据将在构建时从数据库中获取以构建页面。在 Next.js 中，这可以通过在页面组件中导出 `getStaticProps()` 函数来实现。该函数在构建服务器上构建时被调用以获取数据。然后可以将数据传递给页面的 `props` 以预渲染页面组件。让我们看看生成产品列表页面的代码，该代码最初作为本文的一部分分享的。

```
// This function runs at build time on the build server

export async function getStaticProps() {

  return {

    props: {

      products: await getProductsFromDatabase(),

    },

  };

}

// The page component receives products prop from getStaticProps at build time

export default function Products({ products }) {

  return (

    <>

      <h1>Products</h1>

      <ul>

        {products.map((product) => (

          <li key={product.id}>{product.name}</li>

        ))}

      </ul>

    </>

  );

}
```

The function will not be included in the client-side JS bundle and hence can even be used to fetch the data directly from a database.  
该函数不会被包含在客户端 JS 包中，因此甚至可以直接从数据库获取数据。

### Individual Details Page - Per Item个人详情页 - 按项显示

In the above example, we could have an individual detailed page for each of the products listed on the listing page. These pages could be accessed by clicking on the corresponding items on the listing page or directly through some other route.  
在上述示例中，我们可以为列表页中列出的每个产品创建一个个人详情页。这些页面可以通过点击列表页中的相应项目或通过其他路径直接访问。

Assume we have products with product ids `101`, `102`, `103`, and so on. We need their information to be available at routes `/products/101`, `/products/102`,`/products/103` etc. To achieve this at build time in Next.js we can use the function ` getStaticPaths()` in combination with [dynamic routes](https://nextjs.org/docs/routing/dynamic-routes).  
假设我们有产品，其产品 ID 为 `101` 、 `102` 、 `103` 等。我们需要在 `/products/101` 、 `/products/102` 、 `/products/103` 等路径上提供这些产品的信息。在 Next.js 中，我们可以在构建时使用 ` getStaticPaths()` 函数结合动态路由来实现这一点。

We need to create a common page component `products/[id].js` for this and export the function `getStaticPaths()` in it. The function will return all possible product ids which can be used to pre-render individual product pages at build time. The following Next.js skeleton available [here](https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation#individual-product-page-static-generation-with-data) shows how to structure the code for this.  
我们需要为这个功能创建一个通用的页面组件 `products/[id].js` ，并在其中导出 `getStaticPaths()` 函数。该函数将返回所有可能的产品 ID，这些 ID 可用于在构建时预渲染个人产品页面。以下 Next.js 骨架代码展示了如何构建此功能的代码结构。

```
// pages/products/[id].js

// In getStaticPaths(), you need to return the list of

// ids of product pages (/products/[id]) that you'd

// like to pre-render at build time. To do so,

// you can fetch all products from a database.

export async function getStaticPaths() {

  const products = await getProductsFromDatabase();

  const paths = products.map((product) => ({

    params: { id: product.id },

  }));

  // fallback: false means pages that don't have the correct id will 404.

  return { paths, fallback: false };

}

// params will contain the id for each generated page.

export async function getStaticProps({ params }) {

  return {

    props: {

      product: await getProductFromDatabase(params.id),

    },

  };

}

export default function Product({ product }) {

  // Render product

}
```

The details on the product page may be populated at build time by using the function `getStaticProps` for the specific product id. Note the use of the fallback: false indicator here. It means that if a page is not available corresponding to a specific route or product Id, the 404 error page will be shown.  
产品页面上的详细信息可能通过使用特定产品 ID 的 `getStaticProps` 函数在构建时进行填充。请注意这里的 fallback: false 指示符。这意味着如果对应于特定路由或产品 ID 的页面不存在，将显示 404 错误页面。

Thus we can use SSG to pre-render many different types of pages.  
因此我们可以使用 SSG 来预渲染多种不同类型的页面。

## SSG - Key ConsiderationsSSG - 关键注意事项

As discussed, SSG results in a great performance for websites as it cuts down the processing required both on the client and the server. The sites are also SEO friendly as the content is already there and can be rendered by web-crawlers with no extra effort. While performance and SEO make SSG a great rendering pattern, the following factors need to be considered when assessing the suitability of SSG for specific applications.  
正如所讨论的，静态网站生成（SSG）为网站带来了出色的性能，因为它减少了客户端和服务器所需的处理量。这些网站对搜索引擎优化（SEO）也很友好，因为内容已经存在，而无需额外努力即可被网络爬虫渲染。虽然性能和 SEO 使 SSG 成为一种优秀的渲染模式，但在评估 SSG 是否适用于特定应用时，需要考虑以下因素。

> **Note (React 18+ / Next.js 13+): Modern Static Generation  
> 注意（React 18+ / Next.js 13+）：现代静态生成**
> 
> In Next.js 13’s App Router, `getStaticProps` and `getStaticPaths` have their equivalents in **`generateStaticParams`** (for dynamic routes) and the ability to fetch data in an async component for static generation. For example, instead of exporting `getStaticProps` from a page component file, you can write an async component that fetches data (which by default will be done at build-time if you don’t use dynamic fetch options).  
> 在 Next.js 13 的 App 路由器中， `getStaticProps` 和 `getStaticPaths` 在 `generateStaticParams` （用于动态路由）中具有对应，并且可以在异步组件中获取数据以进行静态生成。例如，你可以在页面组件文件中导出 `getStaticProps` ，或者编写一个异步组件来获取数据（默认情况下，如果你不使用动态获取选项，数据将在构建时获取）。
> 
> **Use Incremental Static Regeneration (ISR) for Freshness:** If you have pages that are mostly static but need periodic updates, set a `revalidate` interval or use on-demand revalidation. In Next.js 13+ App Router, you achieve this by using `fetch(..., { next: { revalidate: 60 } })` inside a Server Component, or by exporting `export const revalidate = 60`. Next.js also provides **tag-based and path-based revalidation** (e.g., `revalidatePath` or `revalidateTag`) for fine-grained control when content changes.  
> 使用增量静态再生（ISR）保持新鲜度：如果你的页面大部分是静态的但需要定期更新，可以设置 `revalidate` 间隔或使用按需再验证。在 Next.js 13+ App 路由器中，你可以通过在服务器组件中使用 `fetch(..., { next: { revalidate: 60 } })` 或导出 `export const revalidate = 60` 来实现这一点。Next.js 还提供了基于标签和基于路径的再验证（例如 `revalidatePath` 或 `revalidateTag` ），以便在内容变化时进行细粒度控制。
> 
> **Partial Prerendering (PPR):** A recent development in Next.js 14+ is Partial Prerendering, which allows a page to be *partially* statically rendered at build time and partially filled in at request time, giving “the best of SSG’s TTFB and SSR’s freshness.”  
> 部分预渲染（PPR）：Next.js 14+ 中的一项新功能是部分预渲染，它允许页面在构建时部分静态渲染，并在请求时部分填充，从而实现“SSG 的 TTFB 和 SSR 的新鲜度的最佳结合。”

1. **A large number of HTML files:** Individual HTML files need to be generated for every possible route that the user may access. For example, when using it for a blog, an HTML file will be generated for every blog post available in the data store. Subsequently, edits to any of the posts will require a rebuild for the update to be reflected in the static HTML files. Maintaining a large number of HTML files can be challenging.  
	大量 HTML 文件：每个用户可能访问的每个可能路由都需要生成单独的 HTML 文件。例如，在用作博客时，数据存储中每个可用的博客文章都会生成一个 HTML 文件。随后，对任何文章的编辑都需要重新构建，以便更新反映在静态 HTML 文件中。维护大量 HTML 文件可能具有挑战性。
2. **Hosting Dependency:** For an SSG site to be super-fast and respond quickly, the hosting platform used to store and serve the HTML files should also be good. Superlative performance is possible if a well-tuned SSG website is hosted right on multiple CDNs to take advantage of edge-caching.  
	托管依赖：为了使 SSG 站点超级快速并快速响应，用于存储和提供 HTML 文件的托管平台也应该很好。如果经过良好调优的 SSG 网站直接托管在多个 CDN 上以利用边缘缓存，则可以实现卓越性能。
3. **Dynamic Content:** An SSG site needs to be built and re-deployed every time the content changes. The content displayed may be stale if the site has not been built + deployed after any content change. This makes SSG unsuitable for highly dynamic content.  
	动态内容：每当内容发生变化时，SSG 站点都需要重新构建和重新部署。如果站点在内容更改后没有进行构建+部署，则显示的内容可能已经过时。这使得 SSG 不适合高度动态的内容。

---
