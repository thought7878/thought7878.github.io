---
title: "Incremental Static Generation"
source: "https://www.patterns.dev/react/incremental-static-rendering/"
author:
published:
created: 2025-12-15
description: "Update static content after you have built your site"
tags:
  - "clippings"
---
Static Generation (SSG) addresses most of the concerns of SSR and CSR but is suitable for rendering mostly static content. It poses limitations when the content to be rendered is dynamic or changing frequently.  
静态生成（SSG）解决了 SSR 和 CSR 的大部分问题，但适用于渲染大部分静态内容。当要渲染的内容是动态的或频繁变化时，它会带来限制。

Think of a growing blog with multiple posts. You wouldn’t possibly want to rebuild and redeploy the site just because you want to correct a typo in one of the posts. Similarly, one new blog post should also not require a rebuild for all the existing pages. Thus, SSG on its own is not enough for rendering large websites or applications.  
想象一个不断增长的博客，有多篇帖子。你不可能因为想纠正其中一篇帖子中的一个拼写错误就重建和重新部署整个网站。同样，一篇新的博客帖子也不应该需要重建所有现有页面。因此，仅靠 SSG 不足以渲染大型网站或应用程序。

The Incremental Static Generation (iSSG) pattern was introduced as an upgrade to SSG, to help solve the dynamic data problem and help static sites scale for large amounts of frequently changing data. iSSG allows you to update existing pages and add new ones by pre-rendering a subset of pages in the background even while fresh requests for pages are coming in.  
增量静态生成（iSSG）模式被引入作为 SSG 的升级版，以帮助解决动态数据问题，并帮助静态网站扩展以处理大量频繁变化的数据。iSSG 允许你在后台预渲染页面子集，即使页面有新的请求进来时，也能更新现有页面并添加新页面。

---

## Sample Code 示例代码

iSSG works on two fronts to incrementally introduce updates to an existing static site after it has been built.  
iSSG 在两个层面上工作，以在静态网站构建完成后，逐步引入更新。

1. Allows addition of new pages  
	允许添加新页面
2. Allows updates to existing pages also known as Incremental Static “Re”generation  
	允许更新现有页面，也称为增量静态“重新”生成

### Adding New pages 添加新页面

The lazy loading concept is used to include new pages on the website after the build. This means that the new page is generated immediately on the first request. While the generation takes place, a fallback page or a loading indicator can be shown to the user on the front-end. Compare this to the SSG scenario discussed earlier for individual details page per product. The 404 error page was shown here as a fallback for non-existent pages.  
懒加载概念用于在构建后向网站添加新页面。这意味着新页面会在第一次请求时立即生成。在生成过程中，可以在前端向用户显示备用页面或加载指示器。与之前讨论的每个产品详情页面的 SSG 场景相比，这里显示了 404 错误页面作为不存在页面的备用方案。

Let us now look at the Next.js code required for lazy-loading the non-existent page with iSSG.  
现在让我们看看使用 iSSG 懒加载不存在的页面的 Next.js 代码。

pages/products/\[id\].js

```jsx
1// In getStaticPaths(), you need to return the list of
2// ids of product pages (/products/[id]) that you'd
3// like to pre-render at build time. To do so,
4// you can fetch all products from a database.
5export async function getStaticPaths() {
6  const products = await getProductsFromDatabase();
7

8  const paths = products.map((product) => ({
9     params: { id: product.id }
10  }));
11

12

13  // fallback: true means that the missing pages
14  // will not 404, and instead can render a fallback.
15  return { paths, fallback: true };
16}
17

18// params will contain the id for each generated page.
19export async function getStaticProps({ params }) {
20  return {
21    props: {
22      product: await getProductFromDatabase(params.id)
23    }
24  }
25}
26

27

28export default function Product({ product }) {
29  const router = useRouter();
30

31  if (router.isFallback) {
32    return <div>Loading...</div>;
33  }
34

35  // Render product
36}
```

Here, we have used `fallback: true`. Now if the page corresponding to a specific product is unavailable, we show a fallback version of the page, eg., a loading indicator as shown in the Product function above. Meanwhile, Next.js will generate the page in the background. Once it is generated, it will be cached and shown instead of the fallback page. The cached version of the page will now be shown to any subsequent visitors immediately upon request. For both new and existing pages, we can set an expiration time for when Next.js should revalidate and update it. This can be achieved by using the revalidate property as shown in the following section.

### Update Existing pages

To re-render an existing page, a suitable timeout is defined for the page. This will ensure that the page is revalidated whenever the defined timeout period has elapsed. The timeout could be set to as low as 1 second. The user will continue to see the previous version of the page, till the page has finished revalidation. Thus, iSSG uses the [stale-while-revalidate](https://web.dev/stale-while-revalidate/) strategy where the user receives the cached or stale version while the revalidation takes place. The revalidation takes place completely in the background without the need for a full rebuild.  
要重新渲染一个现有页面，会为该页面定义一个合适的超时时间。这将确保在定义的超时时间段过后，页面会进行重新校验。超时时间可以设置为低至 1 秒。在页面完成重新校验之前，用户会继续看到页面的旧版本。因此，iSSG 使用陈旧校验策略，即用户在重新校验过程中会收到缓存或陈旧版本的页面。重新校验完全在后台进行，无需进行完整重建。

Let us go back to the example for generating a static listing page for products based on the data in the database. To make it serve a relatively dynamic list of products, we will include the code to set the timeout for rebuilding the page. This is what the code will look like after including the timeout.  
让我们回到基于数据库中产品数据生成静态产品列表页面的示例。为了让它能够服务于一个相对动态的产品列表，我们将包含设置页面重建超时时间的代码。包含超时时间后，代码将如下所示。

pages/products/\[id\].js

```jsx
1// This function runs at build time on the build server
2export async function getStaticProps() {
3  return {
4    props: {
5      products: await getProductsFromDatabase(),
6      revalidate: 60, // This will force the page to revalidate after 60 seconds
7    }
8  }
9}
10

11// The page component receives products prop from getStaticProps at build time
12export default function Products({ products }) {
13  return (
14    <>
15      <h1>Products</h1>
16      <ul>
17        {products.map((product) => (
18          <li key={product.id}>{product.name}</li>
19        ))}
20      </ul>
21    </>
22  )
23}
```

The code to revalidate the page after 60 seconds is included in the `getStaticProps()` function. When a request comes in the available static page is served first. Every one minute the static page gets refreshed in the background with new data. Once generated, the new version of the static file becomes available and will be served for any new requests in the subsequent minute. This feature is available in Next.js 9.5 and above.  
重新验证页面的代码包含在 `getStaticProps()` 函数中。当有请求进来时，会先提供可用的静态页面。每分钟静态页面会在后台用新数据刷新。一旦生成，新版本的静态文件就会可用，并在接下来的分钟内为任何新请求提供服务。此功能在 Next.js 9.5 及以上版本中可用。

---

## Advantages 优势

iSSG provides all the advantages of SSG and then some more. The following list covers them in detail.  
iSSG 提供了 SSG 的所有优势，并且还有更多。以下列表详细介绍了这些优势。

1. **Dynamic data**: The first advantage is obviously why iSSG was envisioned. Its ability to support dynamic data without a need to rebuild the site.  
	动态数据：第一个优势显然是 iSSG 被构想出来的原因。它能够在无需重建网站的情况下支持动态数据。
2. **Speed**: iSSG is at least as fast as SSG because data retrieval and rendering still takes place in the background. There is little processing required on the client or the server.  
	速度：iSSG 至少和 SSG 一样快，因为数据检索和渲染仍然在后台进行。客户端或服务器几乎不需要进行大量处理。
3. **Availability**: A fairly recent version of any page will always be available online for users to access. Even if the regeneration fails in the background, the old version remains unaltered.  
	可用性：任何页面的相对较新版本都将始终在线供用户访问。即使背景中的再生失败，旧版本也保持不变。
4. **Consistent**: As the regeneration takes place on the server one page at a time, the load on the database and the backend is low and performance is consistent. As a result, there are no spikes in latency.  
	一致性强：由于再生过程是在服务器上一页一页进行的，因此数据库和后端的负载较低，性能保持一致。结果，延迟没有峰值。
5. **Ease of Distribution**: Just like SSG sites, iSSG sites can also be distributed through a network of CDN’s used to serve pre-rendered web pages.  
	易于分发：与 SSG 站点一样，iSSG 站点也可以通过用于提供预渲染网页的 CDN 网络进行分发。

> **Note (React 18+ / Next.js 13+): On-Demand Revalidation  
> 注意（React 18+ / Next.js 13+）：按需再验证**
> 
> A new best practice is to use **On-Demand Revalidation** when possible. Next.js provides APIs (e.g., `res.revalidate` in API routes, or `revalidatePath` and `revalidateTag` in App Router) to trigger revalidation of specific pages immediately after content changes, rather than waiting for the next timed interval. This ensures users see updates almost instantly while still benefiting from CDN-cached pages.  
> 一种新的最佳实践是在可能的情况下使用按需再验证。Next.js 提供了 API（例如，API 路由中的 `res.revalidate` ，或在 App Router 中的 `revalidatePath` 和 `revalidateTag` ）来触发内容变更后立即重新验证特定页面，而不是等待下一个定时间隔。这确保用户几乎可以立即看到更新，同时仍然受益于 CDN 缓存的页面。
> 
> For **fallback pages**, the pattern of using `fallback: true` in `getStaticPaths` remains valid. In Next.js 13 App Router, fallback behavior is handled by the `loading.js` conventions automatically. Audit your `getStaticPaths`: you can pre-build only popular entries and allow others to build on demand, improving build times.  
> 对于备用页面，使用 `fallback: true` 在 `getStaticPaths` 中的模式仍然有效。在 Next.js 13 应用路由器中，备用行为由 `loading.js` 规范自动处理。检查你的 `getStaticPaths` ：你可以预先构建热门条目，并允许其他条目按需构建，从而提高构建时间。
> 
> **Edge caching and ISR:** Platforms like Vercel and Cloudflare let you run ISR on the edge. Ensure that when a page revalidates, the new content invalidates CDN caches globally. ISR is now a **standard practice** for large sites—refine it with targeted revalidation and good loading states.  
> 边缘缓存和 ISR：像 Vercel 和 Cloudflare 这样的平台允许你在边缘运行 ISR。确保当页面重新验证时，新内容会全局使 CDN 缓存失效。ISR 现在已成为大型网站的标准做法——通过定向重新验证和良好的加载状态来优化它。