---
title: "Server-side Rendering"
source: "https://www.patterns.dev/react/server-side-rendering/"
author:
published:
created: 2025-12-15
description: "Generate HTML to be rendered on the server in response to a user request"
tags:
  - "clippings"
---
Server-side rendering (SSR) is one of the oldest methods of rendering web content. SSR generates the full HTML for the page content to be rendered in response to a user request. The content may include data from a datastore or external API.  
`服务器端渲染（SSR）`是**渲染网页内容最古老的方法之一**。SSR 会**根据用户请求生成完整的 HTML 页面内容**。这些内容可能包括**来自数据存储或外部 API 的数据**。

![[serverside-rendering-1.webm]]

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617495417/patterns.dev/serverside-rendering-1.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1617495417/patterns.dev/serverside-rendering-1.mp4" type="video/mp4"></video>

The connect and fetch operations are handled on the server. HTML required to format the content is also generated on the server. Thus, with SSR we can avoid making additional round trips for data fetching and templating. As such, rendering code is not required on the client and the JavaScript corresponding to this need not be sent to the client.  
*连接和获取操作*在服务器上处理。*用于格式化内容的 HTML* 也在服务器上生成。因此，通过 SSR 我们可以**避免为数据获取和模板化进行额外的往返请求**。因此，**渲染代码不需要在客户端，相应的 JavaScript 也不必发送到客户端**。

With SSR every request is treated independently and will be processed as a new request by the server. Even if the output of two consecutive requests is not very different, the server will process and generate it from scratch. Since the server is common to multiple users, the processing capability is shared by all active users at a given time.  
在服务器端渲染中，*每个请求都被独立处理，服务器会将其作为新的请求进行处理*。即使两个连续请求的输出差异不大，服务器也会从头开始处理和生成。*由于服务器被多个用户共享，其处理能力在特定时间内由所有活跃用户共同使用*。

---

## 经典服务器端渲染实现
Classic SSR Implementation

Let us see how you would create a page for displaying the current time using classic SSR and JavaScript.  
让我们看看如何*使用经典服务器端渲染*和 JavaScript 创建一个显示当前时间的页面。

index.html
```html
<!DOCTYPE html>
<html>
   <head>
       <title>Time</title>
   </head>
   <body>
       <div>
       <h1>Hello, world!</h1>
       <b>It is <div id=currentTime></div></b>
       </div>
   </body>
</html>
```
index.js
```js
function tick() {
    var d = new Date();
    var n = d.toLocaleTimeString();
    document.getElementById("currentTime").innerHTML = n;
}
setInterval(tick, 1000);
```

Note how this is different from the CSR code that provides the same output. Also note that, while the HTML is rendered by the server, the time displayed here is the local time on the client as populated by the JavaScript function `tick()`. If you want to display any other data that is server specific, e.g., server time, you will need to embed it in the HTML before it is rendered. This means it will not get refreshed automatically without a round trip to the server.  
注意这与提供相同输出的客户端渲染代码有何不同。同时请注意，虽然 HTML 由服务器渲染，但这里显示的时间是 JavaScript 函数 `tick()` 在客户端填充的本地时间。如果你想要显示任何特定于服务器的数据，例如服务器时间，你需要在 HTML 渲染之前将其嵌入其中。这意味着如果没有往返服务器的请求，它将不会自动刷新。

---

## 优点和缺点
Pros and Cons 

Executing the rendering code on the server and reducing JavaScript offers the following advantages.  
*在服务器上执行渲染代码并减少 JavaScript* 提供了以下**优势**：

### 更少的 JS 可以加快 FCP 和 TTI
Lesser JavaScript leads to quicker FCP and TTI

In cases where there are multiple UI elements and application logic on the page, SSR has considerably less JavaScript when compared to CSR. The time required to load and process the script is thus lesser. FP, FCP and TTI are shorter and FCP = TTI. With SSR, users will not be left waiting for all the screen elements to appear and for it to become interactive.  
当页面上有多个 UI 元素和应用逻辑时，**与 CSR 相比，SSR 的 JavaScript 显著减少（渲染任务在服务端；客户端不需要执行渲染任务，消除了渲染页面所需的 JS）**。**因此，加载和处理脚本所需的时间也更少**。**FP、FCP 和 TTI 的时间都更短**，且 FCP=TTI。使用 SSR 时，用户不会一直等待所有屏幕元素出现并变得可交互。

![[_posts/architect/渲染架构/patterns.dev/media/3aba044def90991aa4284d1e963b1665_MD5.png]]

Image Source:[https://developers.google.com/web/updates/2019/02/rendering-on-the-web](https://developers.google.com/web/updates/2019/02/rendering-on-the-web)  
图片来源：https://developers.google.com/web/updates/2019/02/rendering-on-the-web

### 为客户端 JS 提供额外预算
Provides additional budget for client-side JavaScript

Development teams are required to work with a JS budget that limits the amount of JS on the page to achieve the desired performance. With SSR, since you are directly eliminating the JS required to render the page, it creates additional space for any third party JS that may be required by the application.  
开发团队需要使用 JS 预算来*限制页面上的 JS 量，以实现所需的性能*。使用 SSR 时，**由于你直接消除了渲染页面所需的 JS**，*这就为应用程序可能需要的任何第三方 JS 创造了额外的空间*。

### SEO 启用
SEO enabled 

Search engine crawlers are easily able to crawl the content of an SSR application thus ensuring higher search engine optimization on the page.  
搜索引擎爬虫*可以轻松地抓取 SSR 应用的页面内容*，从而*确保页面获得更高的搜索引擎优化*。

> **Note (React 18+): Adopt Streaming SSR with Suspense  
> 注意（React 18+）：采用带有 Suspense 的流式 SSR**
> 
> Traditional SSR renders the full HTML on the server for each request. React 18 introduced **Streaming Server-Side Rendering**, which sends HTML to the client in chunks as it’s generated, rather than waiting for the whole render to finish. This significantly improves TTFB and LCP—users see the page shell almost immediately.  
> 传统的 SSR 会在服务器上为每个请求渲染完整的 HTML。React 18 引入了流式服务器端渲染，它会在生成 HTML 的同时将 HTML 分块发送给客户端，而不是等待整个渲染完成。这显著提升了 TTFB 和 LCP——用户几乎能立即看到页面框架。
> 
> If your SSR implementation uses older APIs like `ReactDOMServer.renderToString` or `renderToNodeStream`, consider upgrading to `renderToPipeableStream` (Node) or `renderToReadableStream` (for edge environments) introduced in React 18. These APIs support Suspense boundaries, allowing you to send partial content and display a `<Suspense fallback>` for slow parts.  
> 如果你的 SSR 实现使用像 `ReactDOMServer.renderToString` 或 `renderToNodeStream` 这样的旧 API，建议升级到 React 18 中引入的 `renderToPipeableStream` （Node）或 `renderToReadableStream` （用于边缘环境）。这些 API 支持 Suspense 边界，允许你发送部分内容并在慢速部分显示 `<Suspense fallback>` 。
> 
> **React Server Components:** Perhaps the biggest change is the rise of **React Server Components (RSC)**. RSCs allow you to render part of your UI on the server *ahead of time* without sending the associated JS to the client, dramatically shrinking client JS bundles. The Container/Presentational pattern is a great candidate for RSC: the “container” (data-fetching logic) can be a Server Component that fetches data and passes it as props to a presentational Client Component.  
> React 服务器组件：最大的变化可能是 React 服务器组件（RSC）的兴起。RSC 允许你在服务器上提前渲染 UI 的一部分，而无需将相关的 JS 发送到客户端，从而显著减小客户端 JS 打包文件的大小。容器/展示模式非常适合 RSC：所谓的“容器”（数据获取逻辑）可以是一个获取数据并将其作为 props 传递给展示式客户端组件的服务器组件。

SSR works great for static content due to the above advantages. However, it does have a few disadvantages because of which it is not perfect for all scenarios.  
由于上述优势，SSR 非常适合静态内容。然而，它也存在一些缺点，因此并非适用于所有场景。

### 慢的 TTFB
Slow TTFB 

Since all processing takes place on the server, the response from the server may be delayed in case of one or more of the following scenarios  
由于所有处理都在服务器上进行，在以下一种或多种情况下，服务器响应可能会延迟：

- Multiple simultaneous users causing excess load on the server.  
	多个用户同时使用导致服务器负载过高。
- Slow network 网络缓慢
- Server code not optimized.  
	服务器端代码未优化。

Since all code is not available on the client, frequent round trips to the server are required for all key operations causing full page reloads. This could increase the time between interactions as users are required to wait longer between operations. A single-page application is thus not possible with SSR.  
由于所有代码都未在客户端可用，所有关键操作都需要频繁往返服务器，导致全页重新加载。这可能会增加交互之间的时间，因为用户需要在操作之间等待更长时间。因此，SSR 无法实现单页应用程序。

To address these drawbacks, modern frameworks and libraries allow rendering on both server and client for the same application. We will go into details of these in the following sections. First, let’s look at a simpler form of SSR with Next.js.  
为了解决这些缺点，现代框架和库允许为同一应用程序在服务器和客户端进行渲染。我们将在下一节中详细讨论这些内容。首先，让我们看看 Next.js 中更简单的 SSR 形式。

---

## 使用 Next.js 进行服务器端渲染
SSR with Next.js 

The Next.js framework also supports SSR. This pre-renders a page on the server on every request. It can be accomplished by exporting an async function called [`getServerSideProps()`](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering) from a page as follows.  
Next.js 框架也支持服务器端渲染。它会在每次请求时在服务器上预渲染页面。可以通过以下方式从页面中导出一个名为 `getServerSideProps()` 的异步函数来实现。

```js
export async function getServerSideProps(context) {
  return {
    props: {}, // will be passed to the page component as props
  };
}
```

The context object contains keys for HTTP request and response objects, routing parameters, querystring, locale, etc.  
上下文对象包含 HTTP 请求和响应对象的键、路由参数、查询字符串、区域设置等。

The following implementation shows the use of `getServerSideProps()` for rendering data on a page formatted using React. The full implementation can be found [here](https://medium.com/swlh/fetching-and-hydrating-a-next-js-app-using-getserversideprops-and-getstaticprops-65bfe42afed8).  
以下实现展示了在 React 格式化的页面上使用 `getServerSideProps()` 渲染数据。完整实现可在此处找到。

users/page.jsx
```jsx
// data fetched from an external data source using `getServerSideProps`

const Users = ({ users, error }) => {
 return (
   <section>
     <header>
       <h1>List of users</h1>
     </header>
     {error && <div>There was an error.</div>}
     {!error && users && (
       <table>
         <thead>
           <tr>
             <th>Username</th>
             <th>Email</th>
             <th>Name</th>
           </tr>
         </thead>
         <tbody>
           {users.map((user, key) => (
             <tr key={key}>
               <td>{user.username}</td>
               <td>{user.email}</td>
               <td>{user.name}</td>
             </tr>
           ))}
         </tbody>
       </table>
     )}
   </section>
 );
};

export async function getServerSideProps() {
 // Fetch data from external API
 const res = await fetch("https://jsonplaceholder.typicode.com/users")
 const data = await res.json();

 // Pass data to the page via props
 return { props: { data } }
}

export default Users;
```

---

## React for the Server

React can be rendered isomorphically, which means that it can function both on the browser as well as other platforms like the server. Thus, UI elements may be rendered on the server using React.  
React 可以进行同构渲染，这意味着它既可以在浏览器上运行，也可以在其他平台如服务器上运行。因此，UI 元素可以使用 React 在服务器上进行渲染。

React can also be used with universal code which will allow the same code to run in multiple environments. This is made possible by using Node.js on the server or what is known as a Node server. Thus, universal JavaScript may be used to fetch data on the server and then render it using isomorphic React.  
React 还可以与通用代码一起使用，这将允许相同的代码在多个环境中运行。这是通过在服务器上使用 Node.js 或所谓的 Node 服务器来实现的。因此，通用 JavaScript 可以用于在服务器上获取数据，然后使用同构 React 进行渲染。

Let us take a look at the react functions that make this possible.  
让我们来看看使这一切成为可能的 React 函数。

```js
ReactDOMServer.renderToString(element);
```

This function returns an HTML string corresponding to the React element. The HTML can then be rendered to the client for a faster page load.  
这个函数返回一个与 React 元素对应的 HTML 字符串。然后可以将 HTML 渲染到客户端，以实现更快的页面加载。

The [`renderToString()`](https://reactjs.org/docs/react-dom-server.html#rendertostring) function may be used with [`ReactDOM.hydrate()`](https://reactjs.org/docs/react-dom.html#hydrate). This will ensure that the rendered HTML is preserved as-is on the client and only the event handlers attached after load.  
`renderToString()` 函数可与 `ReactDOM.hydrate()` 一起使用。这将确保渲染的 HTML 在客户端保持原样，并且仅在加载后附加的事件处理程序才会被处理。

To implement this, we use a `.js` file on both client and server corresponding to every page. The `.js` file on the server will render the HTML content, and the `.js` file on the client will hydrate it.  
要实现这一点，我们在客户端和服务器上为每个页面使用相应的 `.js` 文件。服务器上的 `.js` 文件将渲染 HTML 内容，而客户端上的 `.js` 文件将为其注入活力。

Assume you have a React element called `App` which contains the HTML to be rendered defined in the universal `app.js` file. Both the server and client-side React can recognize the `App` element.  
假设你有一个名为 `App` 的 React 元素，它包含在通用的 `app.js` 文件中定义的待渲染 HTML。服务器端和客户端的 React 都能识别 `App` 元素。

The `ipage.js` file on the server can have the code:  
服务器上的 `ipage.js` 文件可以有如下代码：

```js
app.get("/", (req, res) => {
  const app = ReactDOMServer.renderToString(<App />);
});
```

The constant `App` can now be used to generate the HTML to be rendered. The ipage.js on the client side will have the following to ensure that the element `App` is hydrated.  
常量 `App` 现在可用于生成要渲染的 HTML。客户端的 ipage.js 将包含以下内容以确保元素 `App` 被水合。

```js
ReactDOM.hydrate(<App />, document.getElementById("root"));
```

A complete example of SSR with React can be found [here](https://www.digitalocean.com/community/tutorials/react-server-side-rendering).  
一个完整的 React SSR 示例可以在这里找到。