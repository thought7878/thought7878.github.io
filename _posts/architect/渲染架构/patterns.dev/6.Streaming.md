---
title: "Streaming Server-Side Rendering"
source: "https://www.patterns.dev/react/streaming-ssr/"
author:
published:
created: 2025-12-15
description: "Generate HTML to be rendered on the server in response to a user request"
tags:
  - "clippings"
---
We can reduce the Time To Interactive while still server rendering our application by *streaming server rendering* the contents of our application. Instead of generating one large HTML file containing the necessary markup for the current navigation, we can split it up into smaller chunks! Node streams allow us to stream data into the response object, which means that we can continuously send data down to the client. The moment the client receives the chunks of data, it can start rendering the contents.  
我们可以在服务器端渲染应用程序的同时减少交互时间，通过流式服务器端渲染应用程序的内容。与其生成一个包含当前导航所需标记的大型 HTML 文件，我们可以将其拆分成更小的块！Node 流允许我们将数据流式传输到响应对象，这意味着我们可以持续地将数据发送到客户端。一旦客户端接收到数据块，它就可以开始渲染内容。

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056525/patterns.dev/ssr-1.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056525/patterns.dev/ssr-1.mp4" type="video/mp4"></video>

React’s built-in `renderToNodeStream` makes it possible for us to send our application in smaller chunks. As the client can start painting the UI when it’s still receiving data, we can create a very performant first-load experience. Calling the `hydrate` method on the received DOM nodes will attach the corresponding event handlers, which makes the UI interactive!  
React 的内置 `renderToNodeStream` 功能使我们能够以更小的块发送应用程序。由于客户端在接收数据时就可以开始绘制 UI，我们可以创建一个非常高性能的首次加载体验。在接收到的 DOM 节点上调用 `hydrate` 方法将附加相应的事件处理程序，这使得 UI 具有交互性！

<video width="100%" src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056525/patterns.dev/ssr-2.mp4" controls=""><source src="https://res.cloudinary.com/ddxwdqwkr/video/upload/f_auto/v1609056525/patterns.dev/ssr-2.mp4" type="video/mp4"></video>

Let’s say we have an app that shows the user thousands of cat facts in the `App` component!  
假设我们有一个应用程序，在 `App` 组件中向用户展示数千个猫的事实！

server.js

```jsx
1import React from "react";
2import path from "path";
3import express from "express";
4import { renderToNodeStream } from "react-dom/server";
5

6import App from "./src/App";
7

8const app = express();
9

10// app.get("/favicon.ico", (req, res) => res.end());
11app.use("/client.js", (req, res) => res.redirect("/build/client.js"));
12

13const DELAY = 500;
14app.use((req, res, next) => {
15  setTimeout(() => {
16    next();
17  }, DELAY);
18});
19

20const BEFORE = \`
21<!DOCTYPE html>
22  <html>
23    <head>
24      <title>Cat Facts</title>
25      <link rel="stylesheet" href="/style.css">
26      <script type="module" defer src="/build/client.js"></script>
27    </head>
28    <body>
29      <h1>Stream Rendered Cat Facts!</h1>
30      <div id="approot">
31\`.replace(/
32s*/g, "");
33

34app.get("/", async (request, response) => {
35  try {
36    const stream = renderToNodeStream(<App />);
37    const start = Date.now();
38

39    stream.on("data", function handleData() {
40      console.log("Render Start: ", Date.now() - start);
41      stream.off("data", handleData);
42      response.useChunkedEncodingByDefault = true;
43      response.writeHead(200, {
44        "content-type": "text/html",
45        "content-transfer-encoding": "chunked",
46        "x-content-type-options": "nosniff"
47      });
48      response.write(BEFORE);
49      response.flushHeaders();
50    });
51    await new Promise((resolve, reject) => {
52      stream.on("error", err => {
53        stream.unpipe(response);
54        reject(err);
55      });
56      stream.on("end", () => {
57        console.log("Render End: ", Date.now() - start);
58        response.write("</div></body></html>");
59        response.end();
60        resolve();
61      });
62      stream.pipe(
63        response,
64        { end: false }
65      );
66    });
67  } catch (err) {
68    response.writeHead(500, {
69      "content-type": "text/pain"
70    });
71    response.end(String((err && err.stack) || err));
72    return;
73  }
74});
75

76app.use(express.static(path.resolve(__dirname, "src")));
77app.use("/build", express.static(path.resolve(__dirname, "build")));
78

79const listener = app.listen(process.env.PORT || 2048, () => {
80  console.log("Your app is listening on port " + listener.address().port);
81});
```

[Open CodeSandbox 打开 CodeSandbox](https://codesandbox.io/embed/serverstream-fc8op)

The `App` component gets stream rendered using the built-in `renderToNodeStream` method. The initial HTML gets sent to the response object alongside the chunks of data from the App component,  
`App` 组件使用内置的 `renderToNodeStream` 方法进行流式渲染。初始 HTML 会与 App 组件的数据块一起发送到响应对象。

index.html

```html
1<!DOCTYPE html>
2<html>
3  <head>
4    <title>Cat Facts</title>
5    <link rel="stylesheet" href="/style.css" />
6    <script type="module" defer src="/build/client.js"></script>
7  </head>
8  <body>
9    <h1>Stream Rendered Cat Facts!</h1>
10    <div id="approot"></div>
11  </body>
12</html>
```

[Open CodeSandbox 打开 CodeSandbox](https://codesandbox.io/embed/serverstream-fc8op)

This data contains useful information that our app has to use in order to render the contents correctly, such as the title of the document and a stylesheet. If we were to server render the `App` component using the `renderToString` method, we would have had to wait until the application has received all data before it can start loading and processing this metadata. To speed this up, `renderToNodeStream` makes it possible for the app to start loading and processing this information as it’s still receiving the chunks of data from the App component!  
这些数据包含我们的应用需要用来正确渲染内容的有用信息，例如文档的标题和样式表。如果我们使用 `renderToString` 方法在服务器端渲染 `App` 组件，我们将不得不等待应用收到所有数据后才能开始加载和处理这些元数据。为了加快这一过程， `renderToNodeStream` 使得应用能够在仍然从 App 组件接收数据块的同时开始加载和处理这些信息！

> To see more examples on how to implement Progressive Hydration and Server Rendering, visit [this GitHub repo](https://github.com/GoogleChromeLabs/progressive-rendering-frameworks-samples).  
> 要查看更多关于如何实现渐进式水合和服务器渲染的示例，请访问这个 GitHub 仓库。

> [See how styled-components use streaming rendering to optimize the delivery of stylesheets  
> 看看 styled-components 如何使用流式渲染来优化样式表的传输](https://medium.com/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03)

---

## Concepts 概念

Like progressive hydration, streaming is another rendering mechanism that can be used to improve SSR performance. As the name suggests, streaming implies chunks of HTML are streamed from the node server to the client as they are generated. As the client starts receiving “bytes” of HTML earlier even for large pages, the TTFB is reduced and relatively constant. All major browsers start parsing and rendering streamed content or the partial response earlier. As the rendering is progressive, it results in a fast FP and FCP.  
与渐进式水合类似，流式传输是另一种可以用来提升 SSR 性能的渲染机制。顾名思义，流式传输意味着 HTML 代码块会随着生成过程从节点服务器流式传输到客户端。由于客户端即使对于大型页面也能更早地开始接收 HTML 的“字节”，因此 TTFB（首次内容字节时间）会减少并保持相对稳定。所有主流浏览器都会更早地开始解析和渲染流式内容或部分响应。由于渲染是渐进式的，因此可以实现快速的首屏绘制（FP）和首次内容绘制（FCP）。

Streaming responds well to network backpressure. If the network is clogged and not able to transfer any more bytes, the renderer gets a signal and stops streaming till the network is cleared up. Thus, the server uses less memory and is more responsive to I/O conditions. This enables your Node.js server to render multiple requests at the same time and prevents heavier requests from blocking lighter requests for a long time. As a result, the site stays responsive even in challenging conditions.  
流式传输能够很好地应对网络背压。如果网络拥堵无法传输更多字节，渲染器会收到信号并停止流式传输，直到网络恢复正常。这样一来，服务器使用的内存更少，对 I/O 条件的响应也更及时。这使得您的 Node.js 服务器能够同时处理多个请求，并防止较重的请求长时间阻塞较轻的请求。因此，即使在具有挑战性的条件下，网站也能保持响应性。

---

## React for Streaming

React introduced support for streaming in React 16 released in 2016. The following API’s were included in the ReactDOMServer to support streaming.  
React 在 2016 年发布的 React 16 中引入了对流的支持。ReactDOMServer 中包含了以下 API 来支持流。

1. **[`ReactDOMServer.renderToNodeStream(element)`](https://reactjs.org/docs/react-dom-server.html#rendertonodestream)**: The output HTML from this function is the same as [`ReactDOMServer.renderToString(element)`](https://reactjs.org/docs/react-dom-server.html#rendertostring) but is in a Node.js [readablestream](https://nodejs.org/api/stream.html#stream_readable_streams) format instead of a string. The function will only work on the server to render HTML as a stream. The client receiving this stream can subsequently call [ReactDOM.hydrate()](https://reactjs.org/docs/react-dom.html#hydrate) to hydrate the page and make it interactive.  
	`ReactDOMServer.renderToNodeStream(element)`: 该函数的输出 HTML 与 `ReactDOMServer.renderToString(element)` 相同，但格式为 Node.js 可读的流格式，而不是字符串。该函数只能在服务器上工作，以流的形式渲染 HTML。接收此流的客户端可以随后调用 ReactDOM.hydrate() 来为页面注入状态并使其变得可交互。
2. **[`ReactDOMServer.renderToStaticNodeStream(element)`](https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream)**: This corresponds to [`ReactDOMServer.renderToStaticMarkup(element)`](https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup). The HTML output is the same but in a stream format. It can be used for rendering static, non-interactive pages on the server and then streaming them to the client.  
	`ReactDOMServer.renderToStaticNodeStream(element)`: 这对应于 `ReactDOMServer.renderToStaticMarkup(element)` 。HTML 输出相同，但格式为流。它可用于在服务器上渲染静态、非交互式页面，然后将其流式传输到客户端。

> **Note (React 18+): Use `renderToPipeableStream` Instead of `renderToNodeStream`  
> 注意（React 18+）：使用 `renderToPipeableStream` 代替 `renderToNodeStream`**
> 
> In React 18, `renderToNodeStream` has been replaced by **`renderToPipeableStream`** (for Node HTTP streams) and **`renderToReadableStream`** (for Web Streams API in edge runtimes). The new APIs support Suspense boundaries, allowing you to send partial content and even display a `<Suspense fallback>` for slow parts.  
> 在 React 18 中， `renderToNodeStream` 已被替换为 `renderToPipeableStream` （用于 Node HTTP 流）和 `renderToReadableStream` （用于边缘运行时的 Web Streams API）。新的 API 支持 Suspense 边界，允许你发送部分内容，甚至为慢速部分显示 `<Suspense fallback>` 。
> 
> The new API supports `onShellReady` and `onAllReady` callbacks. Use `onShellReady` (which fires when the shell is ready to stream) to flush any critical scripts and begin streaming to the client. React will handle flushing Suspense boundaries automatically.  
> 新的 API 支持 `onShellReady` 和 `onAllReady` 回调。使用 `onShellReady` （当外壳准备好流式传输时触发）来刷新任何关键脚本并开始向客户端流式传输。React 将自动处理 Suspense 边界的刷新。
> 
> **Error Handling:** Ensure you handle streaming errors using the `onError` callback of `renderToPipeableStream`. In a modern app, you might stream a friendly error component instead of a raw stack trace if an error happens after partial content was sent.  
> 错误处理：确保使用 `onError` 的 `renderToPipeableStream` 回调来处理流式错误。在现代应用中，如果部分内容已发送后发生错误，你可能需要流式传输一个友好的错误组件，而不是原始的堆栈跟踪。
> 
> Using the modern API ensures compatibility with React’s concurrency features—the older `renderToNodeStream` does not support Suspense properly.  
> 使用现代 API 可确保与 React 的并发功能兼容——较旧的 `renderToNodeStream` 无法正确支持 Suspense。

The readable stream output by both functions can emit bytes once you start reading from it. This can be achieved by piping the readable stream to a writable stream such as the response object. The response object progressively sends chunks of data to the client while waiting for new chunks to be rendered.  
这两个函数产生的可读流可以在你开始从中读取时发出字节。这可以通过将可读流传递到一个可写流（例如响应对象）来实现。响应对象在等待新的数据块进行渲染时，逐步将数据块发送给客户端。

Putting it all together, let us now look at the code skeleton for this as published [here](https://mxstbr.com/thoughts/streaming-ssr/).  
将所有内容整合起来，现在让我们看看这里发布的这个代码框架。

server.js

```jsx
1import { renderToNodeStream } from 'react-dom/server';
2import Frontend from '../client';
3

4app.use('*', (request, response) => {
5  // Send the start of your HTML to the browser
6  response.write('<html><head><title>Page</title></head><body><div id="root">');
7

8  // Render your frontend to a stream and pipe it to the response
9  const stream = renderToNodeStream(<Frontend />);
10  stream.pipe(response, { end: 'false' });
11  // Tell the stream not to automatically end the response when the renderer finishes.
12

13  // When React finishes rendering send the rest of your HTML to the browser
14  stream.on('end', () => {
15    response.end('</div></body></html>');
16  });
17});
```

[Open CodeSandbox 打开 CodeSandbox](https://codesandbox.io/embed/serverstream-fc8op)

A comparison between TTFB and First Meaningful Paint for normal SSR Vs Streaming is available in the following image.  
TTFB 和 First Meaningful Paint 在普通 SSR 与流式传输之间的对比，可以在以下图片中找到。

![](https://res.cloudinary.com/ddxwdqwkr/image/upload/f_auto/v1616883053/patterns.dev/renderingwebap--03wnu5khnrzr.png)

Image Source: [https://mxstbr.com/thoughts/streaming-ssr/](https://mxstbr.com/thoughts/streaming-ssr/)  
图片来源: https://mxstbr.com/thoughts/streaming-ssr/

---

## Streaming SSR - Pros and Cons流式 SSR - 优缺点

Streaming aims to improve the speed of SSR with React and provides the following benefits  
流式处理旨在通过 React 提高 SSR 的速度，并提供以下优势

1. **Performance Improvement:** As the first byte reaches the client soon after rendering starts on the server, the TTFB is better than that for SSR. it is also more consistent irrespective of the page size. Since the client can start parsing HTML as soon as it receives it, the FP and FCP are also lower.  
	性能提升：由于在服务器端开始渲染后不久第一个字节就能到达客户端，因此 TTFB（首次字节时间）优于传统 SSR。而且无论页面大小如何，性能都更加稳定。由于客户端在收到 HTML 后可以立即开始解析，因此 FP（首次内容绘制）和 FCP（首次内容绘制）也更低。
2. **Handling of Backpressure**: Streaming responds well to network backpressure or congestion and can result in responsive websites even under challenging conditions.  
	处理背压：流式传输能够很好地应对网络背压或拥塞，即使在具有挑战性的条件下也能实现响应式网站。
3. **Supports SEO**: The streamed response can be read by search engine crawlers, thus allowing for SEO on the website.  
	支持 SEO：流式响应可以被搜索引擎爬虫读取，从而允许在网站上实现 SEO。

It is important to note that streaming implementation is not a simple find-replace from `renderToString` to `renderToNodeStream()`. There are cases where the code that works with SSR may not work as-is with streaming. Following are some examples where migration may not be easy.  
需要注意的是，流式传输的实现并非简单的从 `renderToString` 替换为 `renderToNodeStream()` 。在某些情况下，适用于服务器端渲染的代码可能无法直接用于流式传输。以下是一些迁移可能不简单的例子。

1. Frameworks that use the server-render-pass to generate markup that needs to be added to the document before the SSR-ed chunk. Examples are frameworks that dynamically determine which CSS to add to the page in a preceding `<style>` tag, or frameworks that add elements to the document `<head>` while rendering. A workaround for this has been discussed [here](https://medium.com/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03#:~:text=Streaming%20server%2Dside%20rendering%20was,handle%20back%2Dpressure%20more%20easily.).  
	使用服务器渲染传递来生成需要在 SSR 块之前添加到文档中的标记的框架。例如，在之前的 `<style>` 标签中动态确定要添加到页面上的 CSS 的框架，或者在渲染时向文档添加元素的框架。针对这个问题，这里已经讨论过一种解决方案。
2. Code, where renderToStaticMarkup is used to generate the page template and renderToString calls are embedded to generate dynamic content. Since the string corresponding to the component is expected in these cases, it cannot be replaced by a stream. An example of such code provided [here](https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67) is as follows.  
	代码中，使用 renderToStaticMarkup 生成页面模板，并将 renderToString 调用嵌入以生成动态内容。在这些情况下，期望组件对应的字符串，因此不能被流替换。此处提供的此类代码示例如下。
```
res.write("<!DOCTYPE html>");

res.write(renderToStaticMarkup(

 <html>

   <head>

     <title>My Page</title>

   </head>

   <body>

     <div id="content">

       { renderToString(<MyPage/>) }

     </div>

   </body>

 </html>);
```

Both Streaming and Progressive Hydration can help to bridge the gap between a pure SSR and a CSR experience. Let us now compare all the patterns that we have explored and try to understand their suitability for different situations.  
流式传输和渐进式水合都可以帮助缩小纯服务器端渲染（SSR）和客户端渲染（CSR）体验之间的差距。现在，让我们比较一下我们已经探索过的所有模式，并尝试了解它们在不同情况下的适用性。