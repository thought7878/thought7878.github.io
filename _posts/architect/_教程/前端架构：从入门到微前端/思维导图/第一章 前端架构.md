# 1.1 为什么需要软件架构 
## 1.1.1 什么是软件架构

## 1.1.2 开发人员需要怎样的软件架构
### 第一个重点便是因地制宜
- 小公司无法照搬BAT级公司的架构：大公司拥有大量的资源、基础设施、优秀人才
- 小公司若想实现大公司的架构：时间上的长时间投入，或者有强力的技术人员

### 软件架构需要的人才：高质量（有质量）地完成系统的设计

### 软件架构应包含以下内容：
#### 系统间关系：该系统与其他系统之间的关系（调用关系、依赖关系等）
#### 系统内关系：系统内各子系统之间的关系（如前端应用与后端应用，以怎样的方式通信，需要怎样的通信机制）

#### 应用内架构：应用内部的框架、组件，并清楚地表示出它们之间的关系

#### 规范和原则：指导项目中的开发人员，编写出符合需求的代码，以构建出设计中的架构

#### 瀑布型项目（包含类级别的架构，即一个类应该提供怎样的接口，存在怎样的继承关系）

#### 敏捷型项目（）

# 1.2 架构的设计
## 架构设计（并非只是技术工作，包含了一系列复杂的工作），其范围包括：
### 软件工程
### 开发实践
### 业务交付

## 架构设计的步骤： 
### （1）收集利益相关者的需求
- 用户的需求
- 产品经理（业务人员）、项目经理（项目负责人）等相关者的需求

### （2）与相应的技术人员（如开发人员、测试人员）讨论，了解架构上的潜在限制 
 
### （3）寻找潜在的可行性技术方案 
### （4）整理出功能列表中的功能性需求和跨功能性需求 
###  （5）找出会严重影响开发的风险点 
### （6）和技术委员会、利益相关者反复确认方案（可选）
### （7）对架构设计进行概念证明 
### （8）细化架构的部分实施细节 
### （9）结合技术和业务，进行需求排期
### 对于不同项目来说，上述步骤都会有所不同（有的可以直接忽略一些步骤，有的则会包含更多的步骤）
### 在这个过程中，最重要的是收集需求
- 有了需求之后，才能进行相关的技术决策
- 每个项目的需求不同，技术方案也略有差异

## 1.2.1 收集架构需求（需求分析）
### 如何明确架构需要解决的问题？
#### 了解相关者的利益
##### 互联网软件的生命周期中的角色有哪些？每种角色的目标、任务、责任是什么？参考：[[软件生命周期中的角色]]
##### 各方的利益诉求不一致，需某一方做出一定的妥协

#### 寻找架构关注点
##### 架构设计中的关注点：
###### 性能：需达到怎样的性能指标、实现多少用户的并发
###### 安全：如何保障用户数据安全、如何应对客户端服务端的攻击
###### 用户体验：用户体验是否比其他几个维度更重要
###### 平台化：应用是否需作为一个承载其他系统的平台 
###### 代码维护：是否稍有经验的开发人员都能快速上手 

##### 不同项目不同需求，关注点的优先级不一样
##### 决策时和相关者讨论，得到关注点的优先级顺序（**优先级，对于后续工作非常有帮助，可减少设计上出现的返工**）

#### 明确跨功能需求
按功能性来划分
##### 功能性需求：一个软件系统或组件的功能，也是一个系统需提供的功能及服务

##### 非功能性需求（跨功能性需求）：也是需求的重要组成部分，依靠一些条件，判断系统运作的情形或其特性，而不是针对系统特定行为的需求
###### 运行质量（Execution Qualities）：系统运行时观察到的质量，例如安全性、易用性等

###### 演进质量（Evolution Qualities）：它们体现在系统的静态结构中，例如软件*可测试性、可维护性、可扩展性、可伸缩性*等
###### 可用性：指在一段时间内，系统能够正常运行的概率。如何保证这样的可用性？
###### 容错性：系统中可能会出现哪些故障？如何确保这些故障不会让系统无法运行？ 

###### 可变性：在未来，应用的哪些地方会发生变化？是否需要提前做好准备？ 
###### 可维护性：指标是，在接到修改后，可以在相应的时间内（如小功能1～3天）修改完成

###### 可伸缩性：当更大规模的用户使用系统时，哪些服务会出现问题？ 
多数时候，对于后端服务来说，它们只会间接影响架构的决策。但是对于*前端应用*来说，它们往往会影响应用的架构——部分相关的内容是一些**兼容性、跨平台**相关的需求，举例如下。 

- 浏览器的支持范围：明确指出要针对哪些浏览器，以及浏览器的哪些版本做兼容。 
- 移动端设备支持的版本：常见的设备如Android和iOS，设备最低的支持版本，以及支持哪些设备制造商。 
- 它会严重影响前端系统的架构
 
###### 部分跨功能性需求可能是由产品经理提出来的，对这些问题**不是非常了解**
- 要坚持**以数据来说服人**：
	- 要么提供不同浏览器、系统的占比
	- 要么提供支持向下兼容的成本估算（真实的估算）

###### 在设计架构过程中，需详细列出实现跨功能需求的计划

#### 罗列技术风险点
##### 设计架构过程中，需寻找系统中的一系列技术风险点，并努力降低它们带来的风险
##### 为什么？**风险最影响应用开发**，不确定性带来的风险是**未知的**
##### 常见的风险类型：
###### **技术风险**：如果在应用中某一个功能的*实现比较复杂*，或者团队*缺乏某一领域的经验*，如AI，那么在实践的时候可能会影响系统的架构
###### **第三方系统集成**：在大中型公司内部，这是一个令人头痛的问题。如果集成后端服务，那么只需要确认对方的API能否按时上线，并按照我们的规范编写即可。如果*集成客户端的SDK或者组件*，那么第三方要以Web或原生代码的形式集成到系统中。不论哪种方式，都需要**提前进行技术方面的评审**，并在上线前安排联调。
###### **受限制的线上运行环境**：在开发人员和运维人员部门**分离**的组织里，往往会在内部限制某些语言，如选定Java等语言，限制其他语言的使用。如果选定的是其他语言，如JavaScript+Node.js，那么运维人员便难以维护，需要进行培训或者招聘新的运维人员
###### **需求带来额外的技术膨胀，不能按时完成开发带来风险**：比如，想要实现一个*复杂的前端动画效果*，经过评估可能需要两星期的开发时间，如果实现这个动画效果将*无法按时上线*。这时，要么努力去说服业务人员修改需求——适当地降低交互效果，要么将相应的功能排期靠后

## 1.2.2 架构模式
### 常见的架构风格有：
#### **分层风格**：最常见的架构风格，它将系统按照水平切分的方式分成多个层。一个系统由多层组成，每层由多个模块组成。每一层为上层提供服务，并使用下层提供的功能

#### **MVC架构风格**：将软件系统分为三部分：模型（Model）、视图（View）和控制器（Controller）。在涉及图形界面时，往往都有它的身影，如前端应用、移动端应用等

#### **发布-订阅风格**：基于事件的架构风格，是**一种一对多的关系**，一个对象状态改变时，所有订阅它的对象都会得到通知。**它的最大好处是代码上的解耦**，发布者不关心事件的订阅者，只在适当时发布相应的事件即可；而订阅者则依赖于事件。前端中，**为了解耦不同的UI组件的依赖**，经常采用

#### **管理和过滤器**：这是一种**适合于处理数据流**的架构模式，它将每个步骤都封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。它**也适用于相关的数据处理场景**，如前端框架Angular，直接内置了管理（Pipe）系统

## 1.2.3 架构设计方法
### 架构的开发方法和开发流程，与架构开发的模式有关。由于这些设计方法往往是为了解决复杂的问题而存在的，**因而对于一般的项目来说，充满大量冗余的步骤，并不很实用**

### 简单地介绍4+1视图法、TOGAF。这两种方式，**侧重于从系统的角度来考虑问题，若只是从前端的角度来考虑，未免有些大材小用**

### 架构开发方法：4+1视图法

#### 系统架构图：
##### 包含了系统内的主要层级之间的关系、与第三方系统之间的关系
##### 包含了系统的软件架构部分、部署内容

#### 4+1视图法的构成：
##### **逻辑视图**（Logical View）：在设计期的**模块、接口**划分，职责及协作方式等。 
##### **流程视图**（Process View）：在运行期运行的数据同步，如在微前端中的**数据流、控制流**等。 
##### **开发视图**（Development View）：在开发期的**框架、库、技术选型、编译**。 
##### **部署视图/物理视图**（Physical View）：在部署期与持续交付相关的技术决策。 
##### **用例视图/场景**（Scenarios）：它使用一组用例或场景来说明架构
![](_posts/architect/_教程/前端架构：从入门到微前端/images/ch01/4+1.jpg)

#### 4+1视图法的设计流程：
##### （1）架构人员根据需求创建相应的逻辑架构，开发人员进行详细设计。 
##### （2）架构人员和开发人员根据需求设计物理架构，再由开发人员根据物理架构进行对应的详细设计

#### **这种烦琐的设计方式，既不适合于互联网应用，又不适合于前端应用**

#### **可作为借鉴，即从四个不同的维度（逻辑架构、开发流程、部署架构、运行时）来考虑软件技术的设计**

### 架构开发方法：TOGAF及ADM



## 1.2.4 生成架构产出物
### 架构图：它包含了系统的整体架构，如何构成整个系统的，每个部分之间的关系，第三方系统与该系统之间的关系

### 迭代计划：按时间顺序排列出项目的实施计划。包含上线时间，可从上线时间往前推算出迭代时间。开发流程：敏捷或瀑布、源码流程（GitFlow）
### 技术栈及选型：确定项目中使用的语言、框架、库、依赖等技术栈
### 示例代码：在这些代码中展示架构的风格、设计规范
### 测试策略：明确项目的测试类型、测试流程，相应的人员在哪些层级进行测试
### 部署方式：定义应用的部署方式、部署方案
 
### 持续集成方案：描述系统的各个模块之间（如前后端）如何集成，采用怎样的时间和频率来集成相关的模块
 

# 1.3 架构设计原则
## 作者总结的三个设计原则：
### 不多也不少：不做多余的设计，也不缺少关键的部分
### 演进式：不断地演进以使架构适应当前的环境
### 持续性：长期的架构改进比什么都重要

## 1.3.1 不多也不少
## 1.3.2 演进式
## 1.3.3 持续性 
# 1.4 前端架构发展史
最初，前端是没有架构的，因为功能简单的代码没有架构可言。通过操作DOM就能完成的工作，不需要复杂的设计模式和代码管理机制，也就不需要架构来支撑起应用。

### 前端开发的发展历史分为以下几个阶段： 
#### 古典时期：由后端渲染出前端HTML，用Table布局，用CSS进行简单的辅助
#### 动效时期：前端开始编写一些简单的JavaScript脚本来做动画效果，如轮播广告
#### Ajax异步通信时期：2005年，Google使用了异步通信技术（如Google地图），开启了Web前端的一个新时代
 一旦前端应用需要从后端获取数据，就意味着前端应用在运行时是动态地渲染内容的，这便是Model（模型）UI层解耦。jQuery能够提供DOM操作方法和模板引擎等。**这时的开发人员需要做下面两个事情：** 
##### 动态生成HTML：由后端返回前端所需要的HTML，再动态替换页面的DOM元素

##### 模板分离：由后端用API返回前端所需的JSON数据，再由前端来计算生成这些HTML。前端不使用HTML，而使用如Mustache这样的模板引擎来渲染HTML
 
 由于HTML的动态生成、模板的独立与分离，前端应用开始变得复杂。**后端的MVC架构进一步影响了前端开发，便诞生了一系列早期的MVC框架**，如Backbone，Knockout，等等。 
 
#### Node.js之后：
##### 更好的构建工具：诞生了诸如Grunt和Gulp等构建工具。 
##### 包管理：产生了用于前端的包管理工具Bower和NPM。 
##### 模块管理：出现了AMD、Common.js等不同的模块管理方案

随着单页面应用的流行，前后端分离架构也成为行业内的标准实践。由此，前端进入了一个新的时代，要考虑的内容也越来越多： 

##### API管理：采用了如Swagger的API管理工具，各式的Mock Server也成为标准实践。 
##### 大前端：由前端来开发跨平台移动应用框架，采用诸如Ionic、React Native、Flutter等框架。 
##### 组件化：前端应用从此由一个个细小的组件结合而成，而不再是一个大的页面组件。 

**系统变得越来越复杂，架构在前端的作用也变得越来越重要**。MVC满足不了开发人员的需求，于是采用了*组件化架构*。而组件化+MV\*也无法应对大型的前端应用，*微前端*便又出现在我们的面前，它解决了以下问题： 
##### 微前端：它解决了以下问题： 
###### 跨框架。在一个页面上运行，可以同时使用多个前端框架。 
###### 应用拆分。将一个复杂的应用拆解为多个微小的应用，类似于微服务。
###### 遗留系统迁移。让旧的前端框架，可以直接嵌入现有的应用运行。


# 1.5 前端架构设计：层次设计
## 架构设计的四个层级：
![](_posts/architect/_教程/前端架构：从入门到微前端/images/ch01/architecture-level.jpg)

### 系统级：即应用在**整个系统内的关系**，如与后台服务如何通信，与第三方系统如何集成。 
### 应用级：即应用外部(？)的整体架构，如多个应用之间如何共享组件、如何通信等。
### 模块级：即应用内部的模块架构，如代码的模块化、数据和状态的管理等。 
### 代码级：即从基础设施来保障架构实施。 
 在设计的时候，既要**用自上而下的方式来设计架构**，又要**用自下而上的方式来完善（完成）架构**。从演进式设计的角度来看，我们需要在***前期设计的时候*，对所有*系统级架构*及部分*应用级架构*进行技术决策**，而***其余部分的架构*则可以*在实施的过程中*考虑**。

## 1.5.1 系统内架构
~~设计前端架构时，首先考虑的是前端应用在整个系统中的位置——它与系统中的其他子系统的关系，如架构、业务上的关系，它们之间的协作机制。其他子系统：~~ 
 ~~◎　其他前端应用。关注如何与这些应用进行交互、通信等。~~ 
 ~~◎　对接的后台服务。关注如何与后台服务进行通信，诸如权限、授权、API管理等。~~ 
 ~~如果是**系统间的数据通信**（如与后台服务之间的交互），那么只需要规定数据通信、数据传递的机制即可。这一类的通信机制，不仅包含了前后端分离架构的API设计，还包含了各类的数据传递，如OAuth跳转的Token验证等。此外，对于传统的多页面应用来说，也需要关注其中的数据传递，如将Cookie作为用户凭据等。~~

### 设计前端架构时，首先考虑的是前端应用与系统中的其他子系统的关系
#### 其他子系统： 
##### 其他前端应用：如何与这些应用进行交互、通信等。 
##### 后台服务：如何与后台服务进行通信，如权限、授权、API管理等。 

#### 系统间的数据通信：
需规定数据通信、数据传递的机制

##### API设计（前后端分离架构）
##### 各类的数据传递（如OAuth跳转的Token验证）
##### 多页面应用的数据传递（如将Cookie作为用户凭据）

#### 前端与后端的关系（主要是前后端分离架构的设计）

##### 前后端分离架构（笼统的概念）：是指前后端分离如何实施的技术决策

##### 前后端分离架构，包含了一系列的决策、用户鉴权、API接口管理与设计、API（契约）文档管理、Mock Server使用、BFF（服务于前端的后端）、是否需要服务端渲染等
##### 与后端团队沟通（与后端一起设计出整个前后端分离的方案）

### 微前端架构

微前端是将多个前端子应用以某种形式结合到一起，当系统中存在多个前端应用（或者单个前端应用的模块较大）时，就需要考虑使用微前端的方式来拆分

### 考虑前端的客户端形式

#### PC Web应用、移动Web应用、混合移动应用（结合Cordova构架）、混合桌面应用（结合Electron框架）、原生移动应用（结合React Native）等
#### 具体选择哪一种技术，取决于我们先前调查的利益相关者的需求

### 部署架构
当我们做完上述三个核心的架构决策之后，就需要考虑应用的**部署架构**了。有的客户端形式可能**需要服务端渲染**，会在某种程度上影响到前端应用的部署，但是总的影响并不大，往往只需要通过反向代理的配置就可以完成部署的配置。如果**与后台服务不在一个域**，则需要考虑支持跨域请求，或者让后台做一层代码


## 1.5.2 应用级架构
### 应用级架构：单个应用与外部应用的关系（如，一个团队下的多个前端子应用、一个组织内的前端应用）

### 与系统级架构的关系：系统级架构的进一步细化（如，系统架构中定义了微前端架构，具体实施细则会放在各个应用中实现）
至于应用间的数据如何交换，不同的应用有不同的实现方式，通常是通过在相应的层级里定义相应的接口来实现。 


由于各应用之间需要**通过复用代码、共享组件库、统一设计等减少工作量**，因此，我们**要考虑以下几方面内容：**

### 脚手架
#### 作用：用于快速生成、搭建前端应用
#### 生成内容：一个前端项目所需要的要素、规范和模式（如部署模板、构建脚本、CLI工具）

### 模式库：一系列可复用代码的合集（如前端组件、通用的工具函数等）
#### 作用：在多个应用之间共享代码
#### 将模式库作为一层代理来封装外部API，降低外部API变更的修改成本（如React-Router）
在设计架构的时候，如果考虑内建相应的UI组件库，就需要考虑结合装饰器模式，将模式库作为一层代理来封装外部的API，以降低后期的修改成本。模式库还包含了用于多个前端应用通信的数据通信库。 

### 设计系统：更高级别的UI组件库
在这个层级里，我们关注抽象通用的UI模式，用于在多个系统之间共享设计。与模式库/组件库不同，设计系统偏向于设计人员的模式，而非开发人员的视角。 
 
### 在应用级架构中，进行相关的技术选型（如前端框架）

## 1.5.3 模块级架构
### 模块级架构：深入单个应用内部，更细致地**设计应用内部的架构**
### 在开始业务编码之前进行设计
### 在敏捷软件开发中，被称为`迭代0/Sprint 0/Iteration 0`

### 它所涉及的内容是我们在日常开发中经常接触的：
其相关的内容有以下两个方面： 
#### 模块化：包含了CSS、JavaScript、HTML/模板的模块化
对于JavaScript或者模板而言，其模块化的设计受框架的影响比较深。对于CSS来说，我们也需要设计一个合理的方式来进行管理，既需要考虑全局样式以用于样式复用、局部样式以用于隔离变化、通用变量以方便修改，又需要考虑相应的工具来辅助设计。此外，还需要定义相应的CSS、JavaScript、模块的代码组织方式。 

#### 组件化：主要考虑的是，在应用内如何对组件进行封闭，以及相应的原则和粒度。 

### 特定框架的架构设计
#### React框架中，需设计状态、数据流的管理方式，即需要诸如Flux或者Redux这样的状态管理方案
#### Angular框架中，不需要关心相关的模式，只需掌握框架定义的规范即可，如使用Service来保存应用的状态、使用Pipe来处理数据等

## 1.5.4 代码级：规范与原则
当我们真正编码的时候，考虑的架构因素是更低层级的内容，这部分架构设计被称为代码级的架构设计，它关注于实践过程中的相关规范和原则。这部分内容相当多并且烦琐，包含但不限于下述内容： 
 
开发流程。它包含了开发一个功能所需要的完整流程——从源码管理方式、代码合并方式、代码提交信息规范、代码规范自动化，到测试编写等一系列的过程。编写开发流程的目的是，保证编写、创建出来的代码能够符合项目的要求。 
 
代码质量及改善。在实施过程中不仅要注重代码整洁，还要注重TDD（测试驱动开发）等相关的实践，并且遵守SOLID原则，以保证代码的质量。此外，还需要制定代码的测试策略，测试的目的并非减少bug，而是用测试来保证现有的功能是正确的。 
 
规范而非默契。在整个架构中，我们会更关注规范化。小的团队可以依赖于默契，大的团队则需要规范。它需要我们关注几个方面：代码风格的统一，如统一化编辑器、IDE等的配置、使用几个空格；代码的命名；如何保持一致性等。 

此外，在日常的开发中，还需要注重代码的可维护性——简单的代码更容易被读懂和维护。笔者在维护一个Scala项目的过程中，就深有体会——越是写得抽象的代码，越难以维护。诸如函数式编程是一个好东西，但是好的东西也容易被滥用，导致人们不喜欢这个东西。

# 1.6 小结
