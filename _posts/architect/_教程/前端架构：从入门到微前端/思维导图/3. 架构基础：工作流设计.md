从**代码的角度**出发，展示**前端架构的基础内容**：**基础规范**、**文档**化、通过流程化**提高代码质量**和**测试策略**。

---
# **基础架构**：一系列工具与流程的集合，一系列规范和规划。启动项目时需制定

# 不同时期的项目启动，会有不同的看法，和团队规模密切相关
## 1.0时期的迭代0：是选定一个前端框架。要进行一堆细致的分析才能决定使用哪一个，需搭建一个持续集成环境，需编写构建脚本
## 2.0时期的迭代0：是选定前端框架+完整的构建脚本和构建系统。适合一个小团队的架构。小团队的规范可口头约定，大团队的规范一定是自动化的

## 3.0时期的迭代0：是选定前端框架+完整的构建脚本和构建系统+流程规范化。更大规模的团队，要开发自己的前端框架、Design System、脚手架、开发工具、协作工具。**于是，少数码农的工作重心便从业务转向了构建工具**。
## **为了保障团队能顺利合作开发**，需制定一系列的**开发流程**，创建**开发规范**

# 流程与规范的过去、现在对比：
技术在不断演进，帮助我们不断地提高生产力、使流程规范化。随着我们不断地优化开发流程，这些工作越来越自动化。这些流程通过规范代码，来提升代码的可阅读性，减少代码中可能出现的bug。这些流程与规范，就是在本章中讨论的内容。

## 过去手动下载依赖，现在一键安装依赖
## 过去需单独进行测试，现在可在提交代码后自动测试
## 过去只有规范，期盼成员能遵循。现在规范被硬编码到流程中，操作由程序来进行检测（如，使用Lint工具、使用测试覆盖率检测测试是否测试过等）


# 3.1 代码之旅：基础规范（可读性）
## **为什么要有基础规范？** 设计架构时，要考虑由下而上的模式，**底层的实践最终会影响整个系统的架构**（再好的架构，若没有好的工程实践，最终得到的只是一个空有其表的架构方案）

## **为了提升代码的可读性**：

### **规范代码组织结构**（**反映了架构的模式**，可真真切切地感受到它与系统架构的相似之处）

### 统一代码风格（即源代码的书写风格）

### 命名规范（组件、函数等）

### 开发工具规范

# 3.2 应用架构决定代码结构
## 如何读懂代码结构
### 打开README了解应该阅读哪些相关的资料。

### 阅读package.json了解系统的基础设施、使用了哪些组件库，以及配置了哪些构建脚本。

### 浏览主目录下的一个个文件，了解系统的一些插件的配置。

### 进入项目代码中阅读和了解。

## 例子，Angular应用的主目录下的结构：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/203183889cc3238cbfc8cd8d9207fb5a_MD5.jpeg]]

通过上面的文件名信息，我们可以快速地了解系统的一些基础组成。这对于其他前端框架也是相似的，这些配置文件实则是定义了一系列的规范。对于不同的开发者，它们可以起到规范的作用。

在src目录的app文件夹下，有如下一些文件：
![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/8ce69be7564337b0deb1bce53f10ddae_MD5.jpeg]]

### 从代码组织形式来看，它更像基于组件的架构，非MVC架构
从这里的代码组织形式来看，它更像是基于组件的架构，而不再是类似于MVC形式的架构。对于其他前端框架比如React，如果我们通过状态来管理应用，那么从组织构建上看，它像MVC架构。

从文件名上就可以了解这是一个组件（Component），而由于CSS、HTML、TypeScript的分离，我们又可以快速地在修改代码时找到对应的文件。这种特性对于庞大工程的项目来说相当有帮助，但是对于简单的业务，比如加载（Loading）组件时，使用与React、Vue相似的结构会更简洁，即一个文件包含CSS、HTML、JavaScript代码。

## **确定了应用架构后，按照架构编写代码结构（目录、文件的结构）**

## **参考：**[[设计可扩展的代码结构（前端领域驱动设计(DDD)实战）]]

# 3.3 统一代码风格，避免架构腐烂 
代码是写给人看的，给计算机执行的是二进制码。
## 代码风格：即源代码的书写风格（比如，缩进使用两个空格而不是4个）


# 3.4 使用Lint规范代码 
## TSLint、CSSLint代码扫描工具：对代码风格进行检测，语法验证
## 代码风格的规范：
对于代码风格来说，有太多需要规范的地方，比如下面这些事项：

### 是否以分号（；）结束语句。

### 缩进四个空格，还是两个空格。

### 判断是否相等的时候，使用\=\=\=，以避免类型转换。

### 函数大括号是否换行。

## Lint配置选项：生成自己的，使用其他团队创建好的风格配置（如，Airbnb创建的eslint-config-airbnb规范，可在它的基础上修改）


# 3.5 规范化命名，提升可读性 
我们开始进一步了解业务逻辑、阅读项目的代码和函数。于是，我们又进一步将注意力放到命名上。

这个头疼的问题不是我们使用规范能解决的，但是我们可以通过制定命名规则来统一命名方法。

## 3.5.1 命名法 
### 函数名、变量名应是容易阅读的
### 常用的命名规则：

#### 驼峰命名法，译自CamelCase，类似于骆驼的后背形状一样高低起伏。如“getTypeById”。在前端开发中，这种命名规则较为常见。

#### 下画线命名法，即通过下画线来分割单词，如“get_type_by_id”就是采用这种命名方法。

#### 匈牙利命名法，最初是由一个匈牙利程序员Charles Simonyi发明的，其命名规则是：属性+类型+对象描述。如“strFirstName”便是这样的形式，变量中的“str”表示这个变量的类型是string，再比如“iAge”中的“i”表示这个变量的类型是int。


## 3.5.2 CSS及其预处理器命名规则 
### 对CSS进行命名规范的主要原因，是不同页面、组件中的样式易发生冲突

### 统一的编码规范：比如“Airbnb CSS/Sass指南”
![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/5f359184c20d5220ebb1dfd66c63ff4d_MD5.jpeg]]

下面是一些对应的解释：

#### .ListingCard是一个块（Block），表示高层次的组件。
#### .ListingCard__title是一个元素（Element），它属于.ListingCard的一部分，因此块是由元素组成的。
#### .ListingCard--featured是一个修饰符（Modifier），表示这个块与.ListingCard有着不同的状态。

需要注意的是，原版的Airbnb写法中，“ListingCard”采用全小写的形式，“listing-card”在使用React的JSX语法的时候，变成了驼峰式写法。

## 3.5.3 组件命名规则、规范
同样，对于团队而言，组件的命名规则也需要规范，特别是对于使用组件化框架的项目而言，有如下几种不同的命名方式：

### 按照功能来命名：如，SideBar就是一个侧边栏功能的组件。

### 按页面来切分组件：如，NewsItem就是用于展示新闻的组件，它既用于列表页，又用于相关新闻页。

### 按上下文来命名组件：如，NewsChildItem就是按需要将上一个组件的某个共用元素拆分出来。

### 这些命名方式并不是对立的，它们可能同时存在于一个项目中。

# 3.6 规范开发工具，提升开发效率 

下面是一些适合在项目中使用的插件：

## EditorConfig：它可以让我们读取项目中的.editorconfig配置，以遵循统一的编辑器规范，诸如两个空格的缩进。

## Lint插件：如ESLint、HTMLHint，帮助IDE显示Lint问题。

## 单词拼写检测：直接在代码中显示拼错的单词，可以帮助其他人阅读代码。

## 路径补全（Path Intellisense）：能自动提醒我们可以引用的资源、库路径。

## 代码自动补全：包含不同语言的代码补全。

## Emmet插件：帮助我们快速编写HTML、CSS等。

## 代码格式化：可以帮助我们格式化代码。


# 3.7 项目的文档化：README搭建指南 
现在，我们已经大致了解了前端项目的一些基础规范，但是仍然可能错过一些关键的信息。这时，我们就需要通过文档来深入了解细节。在讨论文档时，有可能说的是需求文档、设计文档、测试文档、用户手册等，而这里特指的是与项目相关的技术文档。

## 为什么需要文档？
### 文档对于项目来说，是一个重中之重的存在，是**每个代码库的必做工作**，原因如下
### 当团队进来一个新人时，需要提供一份**快速上手指南**
### 当我们**想要了解当前的系统架构时**，需要一份能方便查阅的文档
### **当我们对过去的技术决策表示怀疑时**，需要查看文档了解原因，并查看架构演进设计

## README文档
### README的好处：存在于项目的代码中，复制代码到本地时，就**可以直接查看**
### README的搭建指南：
一份好的搭建指南，应该和我们在GitHub上看到的开源项目是相似的，具有如下特点：

#### 支持运行的环境。

#### 说明必要的依赖、如何搭建。

#### 项目的安装指南。

#### 线上的示例或最后的运行环境。

#### 相关的文档链接。

#### 相关人员的联系方式，讨论群。

在大部分项目里，这些必要的资源放在README中，能大大地提高开发人员的效率。

# 3.8 绘制架构图：减少沟通成本 
## **架构图**：
### 架构图能让一个团队中的新成员**快速地了解现有系统的各个组成部分**

### 简单系统的架构图：可以是由项目的技术栈组成的
在简单的前端项目里，架构图可能只表现不同框架之间的关系，以及不同层级的组件库之间的使用关系。即使不看架构图，我们也可以清晰地了解项目的架构。

### **复杂系统的架构图**：一般展示的是各个子系统之间如何通信
对于复杂的前端项目来说，我们可能**采用微前端**的方式来设计应用架构。**各个应用之间**可能存在一定的关联性，以及**底层的一些共用依赖**等。**在微前端方案里，架构图的作用更多是描述项目的构建过程**。

### 架构图的绘制方式：
#### 使用代码生成
#### 使用专业工具绘制
#### 也可以是某次会议上的讨论结果，然后将拍照记录到文档中
总之，我们需要为后来者建立一个有效的文档机制，以方便未来的开发者能够在需要的时候，找到原有的系统设计和现在架构之间的一些差异。

## 3.8.1 代码生成 
**对于可能不断变化的事物而言，能使用版本工具记录**是最好的选择。对于架构图的记录也是如此，因此我们要考虑的第一种方式就是：代码生成架构图。

在笔者的工具箱里，`Graphviz`就是一个不错的工具。它是一个由AT&T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。它也提供了可供其他软件使用的库，比如Darge.js是一个可以直接在浏览器渲染Graphviz的库。

**Graphviz之所以方便是因为语法特别简单**——和我们平时表达的方式是一样的，即：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/7c5d19fe0667d4654b838fb51dcb7a16_MD5.jpeg]]


我们**只需要关注如何编写它们之间的关系，就能快速地绘制出流程图**。

Graphviz也有**一些明显的缺点**，比如它的自动化生成连线，容易导致线条间重叠；它生成的UI图，看上去不是那么美观。因此，它更适合在开发者之间使用，当我们有一些更高级的需求时，则可以考虑使用其他工具。

## 3.8.2 专业工具 
与代码生成相比，使用专业的工具来绘制架构图是一种更方便的选择。但是因为它们专业，所以在价格上也体现了一定的专业性。比如**Windows系统的Visio、macOS上的OmniGraffle**都是一些非常不错的软件，只是它们**价格昂贵**。当然，除了架构图，这些专业的软件*还能做出更丰富的与项目管理相关的软件图*。

除了这些专有的闭源软件，还可以选择使用**开源软件，比如Dia**。它是**开源的流程图软件**，是GNU开源计划中的一部分，作者是Alexander Larsson。它可以将多种需求*以模块化的方式进行设计*，如流程图、网络图、电路图等。

## 3.8.3 软件附带工具 
专业的绘图软件都是相当昂贵的，并且不是很好用。笔者有时会使用*macOS上自带的Keynote*来绘制层级架构图。对于不复杂的架构来说，它相当方便，并且快速有效。macOSKeynote的示例如图3-3所示。

![](macos-keynote.png)

由于写作需要，笔者购买了Office 365套装。其中的Word和Powerpoint是自带的，*SmartArt也适用于架构图的绘制*。SmartArt自带一系列的模板，可以帮助我们快速地画出系统架构，如图3-4所示。
![](powerpoint-smart.png)

仔细探索，也许就会发现正在使用的编辑器可能也可以直接生成架构图，而不需要专门绘制。

## 3.8.4 在线工具 
除了使用上述离线工具，我们还可以使用在线工具来绘制架构及流程图。由于篇幅限制，这里就不展开讨论了。

值得注意的是，如果不是会员，这些在线工具会在超出容量限制之后，将超出容量的图直接发布到互联网上。

# 3.9 可编辑文档库：提升协作性 
# 3.10 记录架构决策：轻量级架构决策记录
# 3.11 可视化文档：注重代码的可读性
# 3.12 看板工具：统一管理业务知识 
# 3.13 提交信息：每次代码提交文档化
## 3.13.1 项目方式 
## 3.13.2 开源项目方式 
## 3.13.3 对比不同文档方式 
# 3.14 通过流程化提高代码质量 
## 质量-速度-需求的关系
### 为了交付更符合用户需求的产品，就不得不经常做一些需求变更
### 而这些变更，往往会影响代码质量、开发速度
### 实现一个需求的时间越短，测试的时间就越短，Bug出现的可能性就越高
### 如，今晚上线，下午临时改需求

在这个时候，持续集成只能显式地告诉我们，测试挂了，某些功能失效了，我们不应该部署这个新版本。然而并不是持续集成出问题了，我们就不能部署，仍然还是能部署的。

## 3.14.1 使用Lint+Git Hooks自动化检测代码问题（代码预处理 ）

### **代码提交前的操作**：

#### 静态代码分析（Lint）：进行静态代码分析，如TSLint（类型检查）、ESLint（语法检查）、Lint4j

#### 运行测试：为了不影响持续集成，需在代码提交之前进行测试

现在的编辑器（使用相应插件）、IDE可以提高技术手段，**在开发的过程中分析静态代码，并随时提供建议**。如Intellij IDEA和WebStorm就会根据TSLint来提醒开发者注意关于TypeScript代码的一些规范问题。

### 分析工具进行代码分析，进行如下的风格检测：
#### 规范函数名及变量。

#### 代码格式规范。

#### 限制语言特性。

#### 函数行数限制。

#### 多重嵌套限制。

#### 未使用代码。

### **使用Git Hooks**执行提交前的操作
这些规范如果没有强制就是一个游戏，于是我们通常会**依赖于Git Hooks来做这样的事**。对于一个使用Git来管理源码的项目来说，Git Hooks可以做这样一些事情，即在.git/hooks目录下查看一些内容，相应的命令如下。

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/c3bd05dc87ff27c2b41a6423ec195368_MD5.jpeg]]

一般而言，我们只会在两个阶段做相应的事情：

#### pre-commit：本地预提交。在该提交之前**进行一些语法和Lint的检测**。

#### pre-push：远程预提交。在该提交之前**运行一些测试**。

于是，在我们的这个前端项目里又写了两个scripts，代码如下：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/f0424bdc56eff6ace302d670c548dacf_MD5.jpeg]]

在执行pre-commit时，我们配合lint-staged和prettier来进行代码格式化：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/5ada8185fc6c3a6b27fd05bf45aaa6ab_MD5.jpeg]]

事实上，使用ng lint --fix也是一种不错的方式。

我们在push代码之前进行测试及Angular的构建。*单元测试运行得相当快，它可以在几分钟内完成*，快速地对问题做出响应，*而不是等到持续集成出问题时再去修复*。

#### Git提供了一个--no-verify参数，可让开发者不需要进行上面的验证就能提交代码。

Git提供了一个--no-verify参数，可以让开发者不需要进行上面的验证就能提交代码。我们往往无法阻止别人做这样的事情，特别是在多个团队协作的时候。


## 3.14.2 手动检视代码（**Code Review**）
### 手动检视代码的**好处**：
#### 代码检视是难以发现代码中的Bug的，但是它**能督促其他成员认真写代码**。
#### **保证代码规范得以实施**。
#### **提高代码的质量**。
#### 提高新成员的编程水平。
#### 每个人对项目的业务都会很熟悉。
#### 帮助成员熟悉工具和快捷键的使用。

### 代码检视的常见的方式：

#### 1.**常规代码检视**

`常规代码检视（Code Review）`，**即团队成员聚在一起，听其他成员讲述自己最近（通常是今天）写的代码**。**一个完整的代码检视**是**从讲述相关的业务功能、技术功能开始的，而非打开IDE直接讲代码的实现**。项目中的成员对代码有了上下文的了解之后，才能更明确地知道代码为什么需要这么写。

除了上面的基本规范，**常规代码检视通常还需要规定一个固定的时间**。比如在笔者的公司里，**通常从每天下午5点开始。写了一天的代码，这个时候大概也累了，可以讨论一些技术问题**。固定时间还有一个好处是，在进入每天的检视环节之前，可以提前回顾一下自己写的代码。

值得注意的是，**下午下班前可能是一天最累的时候，代码检视不一定有显著的效果**，因此适时地调整代码检视的时间，也可以取得不错的效果。**我们曾将代码检视的时间定为下午两点**，一方面是因为午休后需要缓冲，另一方面是因为在代码检视完后要立即修改代码。

#### 2.阻塞式代码检视

`阻塞式代码检视`，是**由代码提交者通知项目中的其他人，代码需要检视才能合并入代码库**。上面谈到的常规代码检视是一种非阻塞式代码检视，即代码可以直接提交到主分支上。

**在阻塞式代码检视里，代码提交通常是一个Pull Request**，即要求其他人把代码拉到主分支，这就**要求项目中的其他开发者来帮助我们检视代码**。当代码没有问题的时候，通过这个代码Pull Request请求，代码便会合并到主分支上。它通常与`功能（Feature）分支工作流`、`GitFlow工作流`或`Fork工作流`一起使用。

作为一个喜欢自由的开发者，**笔者不是很推荐这种方式，它会影响持续集成的构建**。即我们的主（Master）分支上应该包含所有的代码，而不是将代码分散在功能（Feature）分支上。但是**它仍然有相当多的适用场合，当项目中的代码质量真的不好时，就可以采用这种方式**——*前提是，其他检视者能够带责任感地去检视代码*。

#### 3.技术负责人，检视成员代码

此外，**对于技术负责人来说，平时还需要经常检视团队成员写的代码**。*比如*，每天在提交代码的时候，我们都需要从远程获取最新的代码。在这个时候，或者运行测试的时候，我们可以顺便阅读一下其他人写的代码，如果从中发现问题，可以直接展开讨论，以免影响其他开发者的开发。


# 3.15 使用工具提升代码质量 
## 3.15.1 代码扫描工具 
## 3.15.2 IDE 快速重构 
# 3.16 测试策略 
## 3.16.1 单元测试 
## 3.16.2 组件测试 
## 3.16.3 契约/接口测试 
# 3.17 小结 