从**代码的角度**出发，展示**前端架构的基础内容**：**基础规范**、**文档**化、通过流程化**提高代码质量**和**测试策略**。

---
# 基础架构：一系列工具与流程的集合，一系列规范和规划（启动一个项目时需制定）

# 不同时期的项目启动，会有不同的看法，和团队规模密切相关
## 1.0时期的迭代0：是选定一个前端框架。要进行一堆细致的分析才能决定使用哪一个，需搭建一个持续集成环境，需编写构建脚本
## 2.0时期的迭代0：是选定前端框架+完整的构建脚本和构建系统。适合一个小团队的架构。小团队的规范可口头约定，大团队的规范一定是自动化的

## 3.0时期的迭代0：是选定前端框架+完整的构建脚本和构建系统+流程规范化。更大规模的团队，要开发自己的前端框架、Design System、脚手架、开发工具、协作工具。**于是，少数码农的工作重心便从业务转向了构建工具**。
## **为了保障团队能顺利合作开发**，需制定一系列的**开发流程**，创建**开发规范**

# 流程与规范的过去、现在对比：
技术在不断演进，帮助我们不断地提高生产力、使流程规范化。随着我们不断地优化开发流程，这些工作越来越自动化。这些流程通过规范代码，来提升代码的可阅读性，减少代码中可能出现的bug。这些流程与规范，就是在本章中讨论的内容。

## 过去手动下载依赖，现在一键安装依赖
## 过去需单独进行测试，现在可在提交代码后自动测试
## 过去只有规范，期盼成员能遵循。现在规范被硬编码到流程中，操作由程序来进行检测（如，使用Lint工具、使用测试覆盖率检测测试是否测试过等）


# 3.1 代码之旅：基础规范
## **为什么要有基础规范？** 设计架构时，要考虑由下而上的模式，**底层的实践最终会影响整个系统的架构**（再好的架构，若没有好的工程实践，最终得到的只是一个空有其表的架构方案）


代码本身是一种难以衡量的实践，同一个业务功能有不同的代码实现。想象一个场景，我们对外提供了一个RESTful API，是不是只要我们能以规范的方式提供这个RESTful API接口，代码的实现方式和质量就变得不重要了？

从短期来看，如果一个API能快速地提供功能以驱动业务增长，那么它就是一个成功的API。不论其设计多么丑陋，代码质量多差，只要不影响性能，未来就有改进的空间。可是从长期来看，API是要能够面向变化而快速扩展的，如果我们不能方便地在API中扩展功能，那么它就真的会影响业务了。尽管重构旧的代码可以帮助我们走向更好的架构，但是在业务进度不合理的情况下，我们只能在旧的、丑陋的代码上不断堆砌功能。直至有一天，我们愉快地选择重写系统。

在本节里，我们将讨论代码中的一些基础规范，它们更多地关注代码的可读性，而不是代码的质量，我们会在后面的章节里关注代码质量。为了提升代码的可读性，我们需要做到以下几方面：

◎　规范代码组织结构。

◎　统一代码风格，即源代码的书写风格。

◎　组件、函数等命名规范。

◎　开发工具规范。

光看这几点要求，总觉得似乎多了很多条条框框。尽管这种统一性会扼杀团队的多样性，但是对于代码层次的风格统一是相当有必要的。

在这些实践中，有些并不仅仅是实践，它还反映了架构的模式，如代码组织结构——从代码的组织构建上，我们可以真真切切地感受到它与系统架构的相似之处。由于应用内的代码复用采用组件化的架构，所以我们应该隔离不同的组件。比如，在Angular生成的组件（component）中，我们就可以看到一种组件完全独立的存在形式。


# 3.2 代码组织决定应用架构
# 3.3 统一代码风格，避免架构腐烂 
# 3.4 使用Lint规范代码 
# 3.5 规范化命名，提升可读性 
## 3.5.1 命名法 
## 3.5.2 CSS及其预处理器命名规则 
## 3.5.3 组件命名规则 
# 3.6 规范开发工具，提升开发效率 
# 3.7 项目的文档化：README搭建指南 
# 3.8 绘制架构图：减少沟通成本 
## 3.8.1 代码生成 
## 3.8.2 专业工具 
## 3.8.3 软件附带工具 
## 3.8.4 在线工具 
# 3.9 可编辑文档库：提升协作性 
# 3.10 记录架构决策：轻量级架构决策记录
# 3.11 可视化文档：注重代码的可读性
# 3.12 看板工具：统一管理业务知识 
# 3.13 提交信息：每次代码提交文档化
## 3.13.1 项目方式 
## 3.13.2 开源项目方式 
## 3.13.3 对比不同文档方式 
# 3.14 通过流程化提高代码质量 
## 3.14.1 代码预处理 
## 3.14.2 手动检视代码 
# 3.15 使用工具提升代码质量 
## 3.15.1 代码扫描工具 
## 3.15.2 IDE 快速重构 
# 3.16 测试策略 
## 3.16.1 单元测试 
## 3.16.2 组件测试 
## 3.16.3 契约/接口测试 
# 3.17 小结 