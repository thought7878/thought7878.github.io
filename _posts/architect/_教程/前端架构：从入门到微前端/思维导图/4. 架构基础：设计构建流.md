在第3章中讲述了如何去搭建和熟悉开发环境这样的工作，作为一个资深的前端开发人员，我们要有能力去设计一个完整的应用开发流程。而这个流程实际上就是要设计一个构建系统，通过它将第3章中设计的流程以代码、工具的形式来加以规范。

# 构建系统
## 核心用途是，帮助开发者从源代码开发开始，构建出最后可用的目标软件
## 前端应用中，构建系统：
### 依赖管理及安装。

### 优化开发环境。

### 代码质量检测。

### 编译及打包。

### 测试及部署。

与过去相比，前端应用的构建已经变得相当复杂。前端应用需要管理依赖版本，以防止在不同的开发机器上因依赖版本不一致而出错；**需要编译代码，而不再是直接合并代码、导致混淆；需要编译SCSS为CSS，而不是直接使用CSS**。对于一个现代的前端应用而言，通常需要做一些步骤，如图4-1所示。

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/db7de0c452ad75b1000dc92aa1dfc7f2_MD5.jpeg]]


尽管现有的前端框架提供了一些工具，帮我们屏蔽了底层构建的复杂度，但是在实际开发的过程中会遇到一些问题，使得我们不得不去优化底层的构建系统。下面是混合应用框架Ionic，其命令行工具执行ionic serve时的启动日志如下：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/8cb6a760013a6fb3e5c17bad1edbbc10_MD5.jpeg]]

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/2512b3c2666a00a4105fb9c5d95b9493_MD5.jpeg]]

在这个过程中，它会完成如下工作：

（1）启动“代码修改监测”服务。

（2）开始构建Dev（开发）版本的代码。

（3）清除上次构建的代码。

（4）将TypeScript转译（或称编译）为JavaScript，以便于直接在浏览器上调试。

（5）对DeepLinks（在iOS上称为通用链接（Universal Links））进行预处理。

（6）复制资源文件到对应的目录中。

（7）将Sass编译为CSS，以便于直接在浏览器上调试。

（8）执行一些构建后的处理。

（9）开始执行Lint。

与早期的前端应用相比，这样的一个Web应用构建流程相当复杂。如果是自己从头编写这样一个构建流程，那么它可能比完成项目的时间还长。从上面的日志来看，这个框架的构建工具是webpack。**它帮助我们自动完成了大量的底层细节，使得我们只需要编写相应的配置就可以实现构建流**。

那么，接下来让我们探索一下其中比较重要的几部分内容。


# 4.1 依赖管理工具
## 为什么？
### **依赖管理工具**，使代码在项目的各开发机器、持续集成服务器上快速地搭建、运行、发布，**而不需要确认依赖版本等额外的工作**
### **早期没有依赖管理软件时**，项目的依赖放在代码库中——每次更新依赖的时候，均需向项目的代码库提交一个新的版本，这导致项目的代码库越来越大，对新成员越来越不友好
### **有了依赖管理之后**，只要执行安装命令，如npm install，再运行服务就可以进行开发了

## （1）不同的模块化方案
### AMD、CommonJS和UMD：是不同的JavaScript**模块化方案，在一定程度上影响着项目的依赖管理**

### AMD（Asynchronous Module Definition）异步模块定义
AMD（Asynchronous Module Definition）即异步模块定义，其典型的表现形式是通过构建好的JavaScript库文件，直接在浏览器中引入依赖，典型的框架有jQuery。为了引用这些采用AMD方式的库，我们还需要使用诸如require.js这样的AMD 管理库来管理依赖。如果这些AMD库是在浏览器上通过script直接引入并运行的，那么它们就可以使用bower来进行管理。

### CommonJS
CommonJS最初被用于**在非浏览器端使用JavaScript来管理模块**，比如使用Node.js来开发服务器应用。设计的**目的**是避免模块定义全局对象，即JavaScript的作用域问题。在CommonJS库里，**每个文件就是一个模块**。开始时，CommonJS在Node.js服务端运行，**随着Browserify和webpack能将这些CommonJS编译为浏览器能运行的JavaScript，越来越多的前端框架直接使用CommonJS来管理模块**。

### UMD（Universal Module Definition，通用模块定义）
随着AMD和CommonJS的流行，又产生了UMD（Universal Module Definition，通用模块定义），**它是AMD和CommonJS的糅合**，它会判断是否是Node.js的模块。下面是一个UMD库的示例代码：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/e95267aa99dc21d4fe9c942741cff60e_MD5.jpeg]]

**这段代码中的typeof exports \=\=\='object'就是用于判断Node.js中的模块（Exports）是否存在**。如果不存在，则使用AMD的方式来加载模块。

那么，让我们从AMD方式讲起。

## （2）AMD方式：通过Bower进行管理

谈到AMD库的管理，一般会有两种方式，一种是直接下载对应的库，另一种是可以由后来的Bower进行管理。

过去前端的基础设施不完善，没有统一的软件包中心，开发者需要在搜索引擎或者GitHub上找到代码库，然后下载解压，再从中复制出代码文件、资源文件等。

在有了Bower之后，开发者只需要在bower.json文件中添加所需要的依赖，就可以由Bower自动下载这个依赖的相关内容——该库打包到bower的服务器上（Bower是一个包管理工具），它可以管理包含HTML、CSS、JavaScript、字体甚至图像文件的组件。Bower的工作原理是，从各个地方获取安装包，并搜索、查找、下载和保存正在寻找的内容。因此，Bower在过去的某段时间里非常流行。

值得注意的是，由于现今的大部分新的前端应用都是通过CommonJS及AMD的方式来引入依赖的，所以Bower的使用场景越来越少。

## （3）CommonJS方式：通过NPM/Yarn管理

由于CommonJS早先是用在Node.js项目上的，所以其包管理工具NPM也与CommonJS有了更多的交集。

`NPM（Node Package Manager，Node包管理器）`是JavaScript世界的包管理工具，并且是Node.js平台的默认包管理工具。开发人员通过NPM可以安装、共享、分发代码，并管理项目依赖关系。此外，这些包会分发到NPM的官方网站npmjs.org上，以便对NPM包进行更好的管理。

除了NPM，还可以使用Yarn来管理依赖。Yarn是由Facebook推出的一款新的JavaScript包管理工具，其特色是Yarn会缓存它下载的每个包，因此不用重复下载就可以加快安装速度。随着Yarn提出缓存包的功能，NPM也提供了相似的功能。

目前主流的前端应用框架（React、Angular、Vue）支持并采用的方式主要以编译构建为主，大都采用NPM+CommonJS的形式来管理依赖。


# 4.2 软件包源管理
## 软件包源有以下几种方式：

### 公有/私有软件包源服务器

#### npmjs.org的官方源。它可以提供最新的软件包，但是国内开发者使用的时候会受到影响。

#### 淘宝的cnpm源。它可以为国内的开发者提供更快速的下载服务。

#### 搭建私有的NPM服务器，提供更为安全快速的Node.js环境。

### 基于源码版本管理服务器，比如直接使用Git服务器来管理和分布库的版本。

### 本地的软件包，使用相对路径导入本地仓库。
## 不同公司的使用情况：

### 小型组织，软件包通常来源于公有软件包源服务器
### 大中型企业，**建立私有包源服务器**，除了放置那些不适合公开的库，它还可保证应用的构建不受外部的干扰（如外部软件包中心宕机）


## 1.基于源码版本管理服务器

对于一些内部的前端库，除了自己搭建NPM服务器，还可以通过Git服务器及Git Tag的方式进行管理。下面是一个新版本的发布代码：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/58c4b716732a2be9f45724b89a688a34_MD5.jpeg]]

在依赖package.json中安装对应的版本：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/ff9c9bf3e67e8bbc0227d4bceb560b51_MD5.jpeg]]

需要注意的是，使用这种方式管理的包，需要将构建完的源码提交到代码库。比如，使用TypeScript/ES6编写的库，需要提供最后编译生成的目标文件（通常位于dist或者build目录下），并将其提交到代码库中，这会使得源码库由于版本越来越多而变得越来越臃肿。

因此，在这种情况下，可以创建一个新的代码库来管理构建后的包，将源码与目标代码进行隔离。

## 2.本地的软件依赖包

本地的软件依赖包是指，把应用的依赖放置在本地。它通过包管理工具来支持file协议并引入依赖，即在package.json中通过"aofe":"file:aofe"的形式来引入依赖。

在拥有Git服务器的环境下，这种方式已经不多见，其使用场景如下：

◎　构建的包过大，不适合使用Git下载。

◎　在开发应用的同时开发依赖。在开发一个前端库的时候，我们会在这个库里包含相应的Demo，方便对该库的调试。但是当用户的应用、第三方库与我们的库冲突时，就不得不通过下载代码来进行调试。这时需要通过相对文件夹路径的方式来引入库，以方便我们进行调试。

在前端不断扩张的未来，这种本地的管理方式不会消失。

## 3.前端应用的编译

获取软件依赖，并在本地安装依赖之后，我们就可以尝试进行编译和打包。按照惯例，我们执行npm build就能构建出这个项目的目标应用。在安装依赖后，构建应用的目的是确保依赖是正确安装的。在笔者的搭建经验里，这一步并不总是成功的——其他人提交的未经测试的代码可能是有问题的，它会影响我们的构建。

在进行构建的过程中，除了与钩子相关的操作，很大一部分是在编译相关的源码。

浏览器在渲染页面的时候使用HTML+JavaScript+CSS的形式。不论我们在编写代码的时候采用什么形式，最后都需要以这种形式来运行。于是，我们就需要将应用编译成JavaScript、CSS，以及对应的HTML DOM。

## 4.JavaScript的编译

JavaScript是一门重要的语言，尽管它最初是在10天内设计出来的。它具有各种神奇的语法，它像魔法一样不时地让我们发现一些“惊喜”。由于JavaScript中糟粕的比重超出了预料，以至于大量的使用者在吐槽其设计。正是因为JavaScript的流行，使得人们越来越正视这个问题。不满足现状的开发人员，开始创建一门又一门基于JavaScript的语言，以获得更好的开发体验。这些行动使得原先可以直接在浏览器上运行的JavaScript，改为编译后再运行。

CoffeeScript是早期较为流行的JavaScript语言，现在使用的人已经越来越少，人们可以运行越来越好的ES x（ES6、ES2015、ES2016、ES2017）或者是TypeScript。过去受限于JavaScript语言的各种问题，有大量的应用是用CoffeeScript来编写的。因此，CoffeeScript让喜欢“造轮子”的开发者意识到这么做也是相当合适的——先使用其他语言编写，再将其编译到JavaScript——通过coffee命令来编译，就能到浏览器上解释运行。即我们可以使用一个更完备的语言来编写应用，而不是受限于语言本身。

ES6，即ECMAScript 6，尽管是下一代的正统JavaScript，受限于浏览器的支持，它仍然需要编译为ECMAScript 5才能在大部分浏览器上运行。主流的前端框架都支持使用ES6来开发，只需要配合编译器Babel的CLI，就可以使用babel来编译代码，比如babel src-d lib就可以将ES6代码编译成ES5代码。因此，ES6与TypeScript都是目前主流的框架。

Typescript是JavaScript的一个严格超集，它除具有ECMAScript的特性外，还带来前端大规模应用中最需要的静态类型检查和基于类的面向对象编程。TypeScript使用自己的TypeScript编译器，通过tsc将TypeScript代码转换为ES5或者ES6的代码，配合tsconfig.json就可以大规模地应用于前端应用开发。同样地，现有的主流框架也可以支持TypeScript。

此外，还有ClojureScript等不同的语言。我们唯一需要做的就是：找一个喜欢的JavaScript语言版本。不同的语言有自己的适用场景，作为一个习惯规范的开发者，笔者更喜欢TypeScript这门语言。它烦琐，但是规范性很强。

选择语言，也会在一定程度上影响我们引入包的方式。不过，现今的大部分应用都使用NPM来管理依赖。代码在编译的过程中，会自动导入所需要的依赖，然后构建出对应的目标文件。

## 5.CSS的编译

在现在的前端应用里，CSS的展现方式不再像过去那么简单，出现了一些新的方式。架构上的差异，也决定了我们使用哪种方式来对CSS进行编译。

传统方式是指，通过<link>标签加载，在全局中使用上CSS的方式。我们只需要按自己的偏好，选定一个CSS预处理器（如Sass、LESS、Stylus），在构建的时候将其编译为CSS，就可以引入使用了。

对于小型项目来说，全局化的CSS并没有问题。但是当项目的规模越来越大时，全局的CSS就变得越来越难以使用。在这种时候，使用哪个CSS预处理器就不再重要了。CSS与生俱来的继承与覆盖，会导致我们在CSS代码中写入大量的“!imporntant”。

![img](blob:file:///b8d0dd59-cb13-4dfd-ac79-82d9a73d2dba)

## 6.CSS In JavaScript

为了进一步避免这种问题的发生，就有了CSS in JavaScript——即CSS在JavaScript代码中。实际上，CSS in JavaScript是组件化架构不断发展的一个产物，它可以解决CSS全局作用域的问题。传统的CSS加载方式是，将所有的样式写在CSS文件里；而CSS in JavaScript则是通过JavaScript将CSS样式附加到元素上。这意味着，组件的样式可以独立运行，并且能在JavaScript和CSS之间共享函数和变量。

下面是Angular框架生成的CSS in JavaScript代码示例：

![img](blob:file:///8586ad38-4ad7-4d81-b96a-10d1ea928374)

从代码中，我们可以清晰地看到styles对象中绑定的p［_ngcontent-%COMP%］{word-break:break-all}。它在浏览器运行的时候会被解析为：

![img](blob:file:///41ca3ad2-3076-4cb6-8303-cb01595690b6)

对比之后，会发现这里的%COMP%是一个变量模板。在运行时，对应的组件会绑定新的属性，对应的属性也会动态添加CSS。具体实现代码如图4-2所示：

![img](blob:file:///4b621734-7fff-41dd-b45f-3ca88a25d81a)

图4-2

因此，当我们选择组件化架构的时候，更多地会考虑使用这种方式来实现。尽管如此，两种方式之间并不是对立的，我们也需要通过传统的CSS方式来实现一些全局的样式，比如颜色、字体等的设置。我们使用CSS in JavaScript是为了更好地控制组件中的样式。

## 7.模板编译

HTML是网页结构的一个重要支撑，在经典的网页里，HTML都是由静态的HTML代码或工具生成的。与JavaScript和CSS不同的是，多数的HTML并不是直接编译生成的，而是间接地通过模板来生成HTML DOM节点的。

早先我们并不会直接编译模板为JavaScript代码，而是在运行时由模板引擎来实时编译模板。由于模板在网页运行的时候，还需要将其解释为JavaScript可以处理的数据，所以会进一步导致一定的性能问题。

进一步地，在构建的过程中，直接将相应的模板编译到源码中。当应用程序在线上运行的时候，直接调用相应的方法来更新数据或者触发对应的方法。我们编写的模板文件与之前相比并没有太大的区别。

下面是Angular编译后的模板：

![img](blob:file:///1931ca1d-34eb-40d0-b7e3-2beecb83431e)

其原先的HTML模板如下：

![img](blob:file:///be8edda4-ade0-49d0-8d55-4748dd6814aa)

从编译并minify后的代码里，我们可以清晰地看到与DOM节点相关的内容——如数组中的“href”，“tel:987654321”，即对应的HTML中的href属性。

相似地，对于React、Vue这一类框架也是如此，将模板编译为JavaScript可以提高运行效率。因此在今天看来，尽管我们依然在编写HTML，但是实际上它们只是像模板一样，相应的细节都交给前端框架的脚手架来完成了。

# 4.3 前端代码的打包
# 4.4 设计构建流
# 4.5 持续交付问题
# 4.6 小结 
