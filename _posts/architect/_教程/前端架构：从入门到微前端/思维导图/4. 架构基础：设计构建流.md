在第3章中讲述了如何去搭建和熟悉开发环境这样的工作，作为一个资深的前端开发人员，我们要有能力去设计一个完整的应用开发流程。而这个流程实际上就是要设计一个构建系统，通过它将第3章中设计的流程以代码、工具的形式来加以规范。

# 构建系统
## 核心用途是，帮助开发者从源代码开发开始，构建出最后可用的目标软件
## 前端应用中，构建系统：
### 依赖管理及安装。

### 优化开发环境。

### 代码质量检测。

### 编译及打包。

### 测试及部署。

与过去相比，前端应用的构建已经变得相当复杂。前端应用需要管理依赖版本，以防止在不同的开发机器上因依赖版本不一致而出错；**需要编译代码，而不再是直接合并代码、导致混淆；需要编译SCSS为CSS，而不是直接使用CSS**。对于一个现代的前端应用而言，通常需要做一些步骤，如图4-1所示。

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/db7de0c452ad75b1000dc92aa1dfc7f2_MD5.jpeg]]


尽管现有的前端框架提供了一些工具，帮我们屏蔽了底层构建的复杂度，但是在实际开发的过程中会遇到一些问题，使得我们不得不去优化底层的构建系统。下面是混合应用框架Ionic，其命令行工具执行ionic serve时的启动日志如下：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/8cb6a760013a6fb3e5c17bad1edbbc10_MD5.jpeg]]

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/2512b3c2666a00a4105fb9c5d95b9493_MD5.jpeg]]

在这个过程中，它会完成如下工作：

（1）启动“代码修改监测”服务。

（2）开始构建Dev（开发）版本的代码。

（3）清除上次构建的代码。

（4）将TypeScript转译（或称编译）为JavaScript，以便于直接在浏览器上调试。

（5）对DeepLinks（在iOS上称为通用链接（Universal Links））进行预处理。

（6）复制资源文件到对应的目录中。

（7）将Sass编译为CSS，以便于直接在浏览器上调试。

（8）执行一些构建后的处理。

（9）开始执行Lint。

与早期的前端应用相比，这样的一个Web应用构建流程相当复杂。如果是自己从头编写这样一个构建流程，那么它可能比完成项目的时间还长。从上面的日志来看，这个框架的构建工具是webpack。**它帮助我们自动完成了大量的底层细节，使得我们只需要编写相应的配置就可以实现构建流**。

那么，接下来让我们探索一下其中比较重要的几部分内容。


# 4.1 依赖管理工具
## 为什么？
### **依赖管理工具**，使代码在项目的各开发机器、持续集成服务器上快速地搭建、运行、发布，**而不需要确认依赖版本等额外的工作**
### **早期没有依赖管理软件时**，项目的依赖放在代码库中——每次更新依赖的时候，均需向项目的代码库提交一个新的版本，这导致项目的代码库越来越大，对新成员越来越不友好
### **有了依赖管理之后**，只要执行安装命令，如npm install，再运行服务就可以进行开发了

## （1）不同的模块化方案
### AMD、CommonJS和UMD：是不同的JavaScript**模块化方案，在一定程度上影响着项目的依赖管理**

### AMD（Asynchronous Module Definition）异步模块定义
AMD（Asynchronous Module Definition）即异步模块定义，其典型的表现形式是通过构建好的JavaScript库文件，直接在浏览器中引入依赖，典型的框架有jQuery。为了引用这些采用AMD方式的库，我们还需要使用诸如require.js这样的AMD 管理库来管理依赖。如果这些AMD库是在浏览器上通过script直接引入并运行的，那么它们就可以使用bower来进行管理。

### CommonJS
CommonJS最初被用于**在非浏览器端使用JavaScript来管理模块**，比如使用Node.js来开发服务器应用。设计的**目的**是避免模块定义全局对象，即JavaScript的作用域问题。在CommonJS库里，**每个文件就是一个模块**。开始时，CommonJS在Node.js服务端运行，**随着Browserify和webpack能将这些CommonJS编译为浏览器能运行的JavaScript，越来越多的前端框架直接使用CommonJS来管理模块**。

### UMD（Universal Module Definition，通用模块定义）
随着AMD和CommonJS的流行，又产生了UMD（Universal Module Definition，通用模块定义），**它是AMD和CommonJS的糅合**，它会判断是否是Node.js的模块。下面是一个UMD库的示例代码：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/e95267aa99dc21d4fe9c942741cff60e_MD5.jpeg]]

**这段代码中的typeof exports \=\=\='object'就是用于判断Node.js中的模块（Exports）是否存在**。如果不存在，则使用AMD的方式来加载模块。

那么，让我们从AMD方式讲起。

## （2）AMD方式：通过Bower进行管理

谈到AMD库的管理，一般会有两种方式，一种是直接下载对应的库，另一种是可以由后来的Bower进行管理。

过去前端的基础设施不完善，没有统一的软件包中心，开发者需要在搜索引擎或者GitHub上找到代码库，然后下载解压，再从中复制出代码文件、资源文件等。

在有了Bower之后，开发者只需要在bower.json文件中添加所需要的依赖，就可以由Bower自动下载这个依赖的相关内容——该库打包到bower的服务器上（Bower是一个包管理工具），它可以管理包含HTML、CSS、JavaScript、字体甚至图像文件的组件。Bower的工作原理是，从各个地方获取安装包，并搜索、查找、下载和保存正在寻找的内容。因此，Bower在过去的某段时间里非常流行。

值得注意的是，由于现今的大部分新的前端应用都是通过CommonJS及AMD的方式来引入依赖的，所以Bower的使用场景越来越少。

## （3）CommonJS方式：通过NPM/Yarn管理

由于CommonJS早先是用在Node.js项目上的，所以其包管理工具NPM也与CommonJS有了更多的交集。

`NPM（Node Package Manager，Node包管理器）`是JavaScript世界的包管理工具，并且是Node.js平台的默认包管理工具。开发人员通过NPM可以安装、共享、分发代码，并管理项目依赖关系。此外，这些包会分发到NPM的官方网站npmjs.org上，以便对NPM包进行更好的管理。

除了NPM，还可以使用Yarn来管理依赖。Yarn是由Facebook推出的一款新的JavaScript包管理工具，其特色是Yarn会缓存它下载的每个包，因此不用重复下载就可以加快安装速度。随着Yarn提出缓存包的功能，NPM也提供了相似的功能。

目前主流的前端应用框架（React、Angular、Vue）支持并采用的方式主要以编译构建为主，大都采用NPM+CommonJS的形式来管理依赖。


# 4.2 软件包源管理
## 软件包源有以下几种方式：

### 公有/私有软件包源服务器

#### npmjs.org的官方源。它可以提供最新的软件包，但是国内开发者使用的时候会受到影响。

#### 淘宝的cnpm源。它可以为国内的开发者提供更快速的下载服务。

#### 搭建私有的NPM服务器，提供更为安全快速的Node.js环境。

### 基于源码版本管理服务器，比如直接使用Git服务器来管理和分布库的版本。

### 本地的软件包，使用相对路径导入本地仓库。
## 不同公司的使用情况：

### 小型组织，软件包通常来源于公有软件包源服务器
### 大中型企业，**建立私有包源服务器**，除了放置那些不适合公开的库，它还可保证应用的构建不受外部的干扰（如外部软件包中心宕机）


## 1.基于源码版本管理服务器

对于一些内部的前端库，除了自己搭建NPM服务器，还可以通过Git服务器及Git Tag的方式进行管理。

下面是一个**新版本的发布代码：**

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/58c4b716732a2be9f45724b89a688a34_MD5.jpeg]]

**在依赖package.json中安装对应的版本：**

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/ff9c9bf3e67e8bbc0227d4bceb560b51_MD5.jpeg]]

需要注意的是，**使用这种方式管理的包，需要将构建完的源码提交到代码库**。*比如*，使用TypeScript/ES6编写的库，需要提供最后编译生成的目标文件（通常位于dist或者build目录下），并将其提交到代码库中，这会使得源码库由于版本越来越多而变得越来越臃肿。

因此，在这种情况下，可以创建一个新的代码库来管理构建后的包，将源码与目标代码进行隔离。

## 2.本地的软件依赖包

`本地的软件依赖包`是指，把应用的依赖放置在本地。它通过包管理工具来支持file协议并引入依赖，即在package.json中通过 `"aofe":"file:aofe"` 的形式来引入依赖。

在拥有Git服务器的环境下，这种方式已经不多见，**其使用场景如下：**

◎　构建的包过大，不适合使用Git下载。

◎　在开发应用的同时开发依赖。在开发一个前端库的时候，我们会在这个库里包含相应的Demo，方便对该库的调试。但是当用户的应用、第三方库与我们的库冲突时，就不得不通过下载代码来进行调试。这时需要通过相对文件夹路径的方式来引入库，以方便我们进行调试。

在前端不断扩张的未来，这种本地的管理方式不会消失。

## 3.前端应用的编译

获取软件依赖，并在本地安装依赖之后，我们就可以尝试进行编译和打包。按照惯例，我们执行npm build就能构建出这个项目的目标应用。在安装依赖后，构建应用的目的是确保依赖是正确安装的。在笔者的搭建经验里，这一步并不总是成功的——其他人提交的未经测试的代码可能是有问题的，它会影响我们的构建。

在进行构建的过程中，除了与钩子相关的操作，很大一部分是在编译相关的源码。

浏览器在渲染页面的时候使用HTML+JavaScript+CSS的形式。不论我们在编写代码的时候采用什么形式，最后都需要以这种形式来运行。于是，我们就需要将应用编译成JavaScript、CSS，以及对应的HTML DOM。

## 4.JavaScript的编译

JavaScript是一门重要的语言，尽管它最初是在10天内设计出来的。它具有各种神奇的语法，它像魔法一样不时地让我们发现一些“惊喜”。由于JavaScript中糟粕的比重超出了预料，以至于大量的使用者在吐槽其设计。正是因为JavaScript的流行，使得人们越来越正视这个问题。不满足现状的开发人员，开始创建一门又一门基于JavaScript的语言，以获得更好的开发体验。这些行动使得原先可以直接在浏览器上运行的JavaScript，改为编译后再运行。

`CoffeeScript`是早期较为流行的JavaScript语言，现在使用的人已经越来越少，人们可以运行越来越好的ES x（ES6、ES2015、ES2016、ES2017）或者是TypeScript。过去受限于JavaScript语言的各种问题，有大量的应用是用CoffeeScript来编写的。因此，CoffeeScript让喜欢“造轮子”的开发者意识到这么做也是相当合适的——**先使用其他语言编写，再将其编译到JavaScript**——通过coffee命令来编译，就能到浏览器上解释运行。即我们可以使用一个更完备的语言来编写应用，而不是受限于语言本身。

`ES6`，即ECMAScript 6，尽管是下一代的正统JavaScript，受限于浏览器的支持，它仍然需要编译为ECMAScript 5才能在大部分浏览器上运行。主流的前端框架都支持使用ES6来开发，只需要配合`编译器Babel`的CLI，就可以使用babel来编译代码，比如babel src-d lib就可以**将ES6代码编译成ES5代码**。因此，ES6与TypeScript都是目前主流的框架。

`Typescript`是JavaScript的一个严格超集，它除具有ECMAScript的特性外，还带来前端大规模应用中**最需要的静态类型检查**和基于类的面向对象编程。TypeScript使用自己的*TypeScript编译器*，**通过tsc将TypeScript代码转换为ES5或者ES6的代码**，配合*tsconfig.json*就可以大规模地应用于前端应用开发。同样地，现有的主流框架也可以支持TypeScript。

此外，还有ClojureScript等不同的语言。我们唯一需要做的就是：找一个喜欢的JavaScript语言版本。不同的语言有自己的适用场景，作为一个习惯规范的开发者，笔者更喜欢TypeScript这门语言。它烦琐，但是规范性很强。

选择语言，也会在一定程度上影响我们引入包的方式。不过，现今的大部分应用都使用NPM来管理依赖。代码在编译的过程中，会自动导入所需要的依赖，然后构建出对应的目标文件。

## 5.CSS的编译

在现在的前端应用里，CSS的展现方式不再像过去那么简单，出现了一些新的方式。架构上的差异，也决定了我们使用哪种方式来对CSS进行编译。

`传统方式`是指，通过<link>标签加载，在全局中使用上CSS的方式。我们只需要按自己的偏好，选定一个CSS预处理器（如Sass、LESS、Stylus），*在构建的时候将其编译为CSS*，就可以引入使用了。

*对于小型项目来说*，全局化的CSS并没有问题。但是*当项目的规模越来越大时*，全局的CSS就变得越来越难以使用。在这种时候，使用哪个CSS预处理器就不再重要了。*CSS与生俱来的继承与覆盖，会导致我们在CSS代码中写入大量的“!imporntant”*。

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/c445e313ab1318974334a3c28b0b92e7_MD5.jpeg]]

## 6.CSS In JavaScript

为了进一步避免这种问题的发生，就有了CSS in JavaScript——即CSS在JavaScript代码中。实际上，CSS in JavaScript是组件化架构不断发展的一个产物，**它可以解决CSS全局作用域的问题**。传统的CSS加载方式是，将所有的样式写在CSS文件里；而CSS in JavaScript则是通过JavaScript将CSS样式附加到元素上。这意味着，组件的样式可以独立运行，并且能在JavaScript和CSS之间共享函数和变量。

下面是Angular框架生成的CSS in JavaScript代码示例：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/b6b48897139a0e4e1f8382d3d596af62_MD5.jpeg]]

从代码中，我们可以清晰地看到styles对象中绑定的p［\_ngcontent-%COMP%］{word-break:break-all}。它在浏览器运行的时候会被解析为：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/4194794c44cbbd2bbaee9f45cfeb94f0_MD5.jpeg]]

对比之后，会发现这里的%COMP%是一个变量模板。在运行时，对应的组件会绑定新的属性，对应的属性也会动态添加CSS。具体实现代码如图4-2所示：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/4ac2f10c4c9e4e42fc9d123caa76b297_MD5.jpeg]]

因此，当我们选择组件化架构的时候，更多地会考虑使用这种方式来实现。尽管如此，**两种方式之间并不是对立的，我们也需要通过传统的CSS方式来实现一些全局的样式**，比如颜色、字体等的设置。我们使用CSS in JavaScript是为了更好地控制组件中的样式。

## 7.模板编译

HTML是网页结构的一个重要支撑，在经典的网页里，HTML都是由静态的HTML代码或工具生成的。与JavaScript和CSS不同的是，多数的HTML并不是直接编译生成的，而是间接地通过模板来生成HTML DOM节点的。

早先我们并不会直接编译模板为JavaScript代码，而是在运行时由模板引擎来实时编译模板。由于模板在网页运行的时候，还需要将其解释为JavaScript可以处理的数据，*所以会进一步导致一定的性能问题*。

进一步地，**在构建的过程中，直接将相应的模板编译到源码中**。*当应用程序在线上运行的时候，直接调用相应的方法来更新数据或者触发对应的方法*。我们编写的模板文件与之前相比并没有太大的区别。

下面是Angular编译后的模板：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/e183c0a47e9edd327acc360d2a2325f2_MD5.jpeg]]

其原先的HTML模板如下：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/709ccd884891c4d58ce87ee36e990de7_MD5.jpeg]]

从编译并minify后的代码里，我们可以清晰地看到与DOM节点相关的内容——如数组中的“href”，“tel:987654321”，即对应的HTML中的href属性。

**相似地，对于React、Vue这一类框架也是如此，将模板编译为JavaScript可以提高运行效率**。因此在今天看来，尽管我们依然在编写HTML，但是实际上它们只是像模板一样，相应的细节都交给前端框架的脚手架来完成了。

# 4.3 前端代码的打包
在主流的前端框架里，编译及打包的工作都已经交给对应框架的CLI（Command-Line Interface，命令行界面）来完成了，例如Angular的CLI、Vue的CLI，以及Facebook推出的Create-React-App。在这些工具里，只有Angular可以真正地实现开箱即用，这和Anguar本身大而全的设计有关。因此，当我们选择使用Vue、React等其他框架时，或多或少地需要进行一些定制，这就要求我们对应用本身的打包有一定了解。

**代码打包的最后一步就是，一一将代码“拼接”到一起，压缩并混淆代码，最后构建出目标代码文件**。期间，还会进行可选的`摇树优化`（Tree Shaking，顾名思义就是去掉不需要用到的代码），其主要依赖于ES6模板及其带来的静态分析。这个目标文件是按我们的需要而产生的，如下是Angular项目构建出来的代码相关文件（通过ng build--prod生成）：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/dac6714ded74639fbccf20df81d9e561_MD5.jpeg]]

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/05dc2a43dd5cccef02a7bc338c922b09_MD5.jpeg]]

上面的代码中涉及我们需要的几个目标文件：

◎　用于管理运行时（如路由懒加载）的runtime.js文件（在Angular 6.0之前的版本里是inline.js）。

◎　样式相关的styles.css。

◎　解决JavaScript在不同浏览器兼容问题的polyfills.js。

◎　程序相关逻辑的main.js。

上面这段代码，除了进行代码编译、打包，还对CSS和JS等静态资源文件进行了重命名。

# 4.4 设计构建流
## 构建流的设计是**逐步演进的，很难在项目初始时便设计出完整的构建流**
### 对于复杂的应用，在开发应用的过程中会不断地完善。
### 对于简单的应用，事先设计好的流程可能用不上。

## 构建流通常来源于：
### 过去的开发经验。
### 前端框架提供的命令。
### 应用脚手架提供的功能。

不管哪种形式提供的构建流，多数时候都需要经过一定的改造才能满足我们的需求。

## 1.如何设计构建流？
### 需要思考的问题：
摆在我们面前的第一个考验是，如何设计应用的构建流？我们需要进一步了解如下内容：

#### （1）我们需要做的任务有哪些？

#### （2）每个任务具体的步骤拆解有哪些？

#### （3）部署时，其对应的形式是怎样的？

#### （4）有没有现成的插件可使用？

### 任务。应用的多数流程都是通用的，对应的任务也是通用的。这些命令都是我们耳熟能详的，比如用于安装依赖的命令 npm install，用于测试的命令npm test，等等。稍有区别的是，其背后对应的细节处理不一致，也就是对于这些任务的拆解。

### 步骤拆解。任务本身的区别并不大，其背后的步骤往往差异甚大，尤其是常见的build命令。build命令一方面受前端框架的影响，另一方面则受项目复杂度的影响。越是复杂的项目，其背后的构建流越复杂，比如其需要依赖于不同的子模块、定义度过高的自定义脚本。尽管build命令只有一个，我们还是需要将其拆解为多个子命令，如build:icon、build:lib，等等。

### 展现形式。虽然多数的应用都是以Web应用的形式部署的，但是并非所有的应用都是需要部署的。当我们提供底层库时，提供的是一个库和相应的文档；当我们提供一套UI框架时，构建的是一个库+UI组件的演示库。不同类型创建的应用，其展现形式都有所不同。

### 插件。在设计构建流程的过程中，不得不考虑插件对我们的影响。比如，我们要打包图标字体（Icon Font），如果没有现成的工具，则可能不会考虑这种形式——多数时候，我们并不会自己来编写这样的插件。当我们只能找到一个对应的插件时，如果它与所需的构建流程不符合，那么我们要修改与插件相应的代码，或重新设计流程。当且仅当有多个插件时，我们才能打造更流畅的构建流。

在实施的过程中，我们还需要一个构建工具，它可以是Grunt、Gulp、webpack等中的一个，或者直接使用NPM来完成。这些工具并没有太大的区别，要做的事情的复杂性决定了使用的工具。

## 2.构建工具：自动化任务

构建工具，相当于是一个自动化任务工具，也可以称之为任务管理器。我们通过这个构建工具和其提供的接口来提供应用程序的构建服务。有的构建工具如NPM或者make只是简单地帮助我们运行命令，它不能提供一些可编程的接口。有的工具如gulp和grunt，会提供流（Pipe）以帮助我们更好地设计构建流。

过去，受到后端项目的影响，在Node.js还没有成熟之前，我们可能会使用Gradle（构建脚本以build.gradle文件的形式存在于项目中）和Make（构建脚本以makefile文件的形式存在于项目中）等工具进行构建。而现在，基本上以下面的三种形式存在：

◎　NPM脚本，适用于脚本简单的应用构建。

◎　Gulp/Grunt，适用于复杂的项目工作流构建。

◎　webpack，进行项目的模块化打包。

每个工具都有一定的适用场景。

## 3.使用包管理工具构建NPM

我们可以通过NPM脚本来执行构建工作。这些脚本存在于package.json中的scripts部分中。它们可以通过执行npm run［任务］来运行，如npm run build。

如果只是简单的构建，如Angular框架中的ng build外加一些参数，那么直接使用NPM自带的package.json就可以完成相应的配置，代码如下：

![img](blob:file:///ebffd751-77f0-4cbc-a686-f8e9b1a20f06)

比如在上面的示例中，我们定义了5个任务：build、build:app、watch、lint、start，其对应的值便是命令执行的详细内容。

然而，对于构建稍微复杂一点的项目来说，它相当难维护。如上面的build:app任务，实际上是一段字符串。当字符串越来越长时，它本身就难以阅读，更不用说添加更多的任务。我们使用JSON文件来管理任务，而JSON文件本身不能编写注释，所以任务很难在代码中文档化。

当脚本越来越复杂时，我们就考虑使用脚本文件的形式来管理，如node build.js。既然这么复杂，我们就可以考虑更实用的方式，找一些现成的工具来管理。

尽管如此，在实现的时候，我们一般都会结合NPM脚本与webpack或Gulp/Grunt使用，代码如下：

![img](blob:file:///225da653-0bcf-41e9-b577-4183f25e0807)

这样做的好处是：第一，使用一致的命令行接口能提供友好的开发体验；第二，未来在替换webpack的时候，对于其他开发者来说是无感知的。

## 4.使用构建工具构建Grunt/Gulp

对于复杂的构建流，我们就可以考虑使用Grunt或者是Gulp来完成构建。

◎　Grunt是最早的前端构建和原生构建工具之一，只需要找到适当的插件，加上适当的配置，就可以完成构建。作为早期的构建工具，它拥有大量的插件，因为配置简单，所以相当受欢迎。

◎　Gulp是一个基于流的构建工具，适当的插件外加适量的流操作代码，可以管理复杂的任务。由于使用流编程的方式，它更能胜任复杂的构建项目。

两者都是相当流行的构建工具，只是稍有区别。Grunt通过Gruntfile进行配置，而Gulp则通过Gulpfile进行编程。随着项目变得越来越复杂，开发人员发现通过配置的构建脚本，越来越难以使用——有相当多的任务是不能简单地通过配置来完成的。尽管使用流编程稍微复杂一些，但是它能带来更灵活的自定义任务。

下面是一个Grunt用于编译Sass为CSS的任务示例：

![img](blob:file:///e83aa437-378c-431f-8ed5-5bef637ab6ea)

![img](blob:file:///a708ea22-91f8-4ade-91e9-290566fbd99b)

在代码中的initConfig函数中传入的参数，就是我们的配置。在这个配置中，主要由编译Sass为CSS的Sass对象和将CSS压缩为cssmin对象来完成。在这两个对象里，我们还配置了源文件，目标文件等内容。loadNpmTasks函数则是用于加载对应的Grunt插件。registerTask函数，则是用于配置默认的任务，它依赖于两个子任务Sass和cssmin。

在这个流程中，我们先将src/styles.scss文件进行编译，并输出形成dist/css/styles.css文件。然后，再将这个文件压缩成dist/css/styles.min.css。

而Gulp写出的构建任务则是以代码为主。下面是一个gulpfile的相应任务的示例：

![img](blob:file:///b6be4a09-5b7e-4d58-ac60-8e7e89ec59cc)

![img](blob:file:///a8a01f11-a893-4701-99bc-15494b4b1de0)

Gulp借鉴了UNIX操作系统的管道（Pipe）思想，所以在上面代码中的Sass任务里，也是以多个JSON为主的链式调用。在任务开始的时候，通过src方法配置了输入文件，然后像流水线一样往下执行：

（1）进行sass()编译。

（2）输出一个目标文件到dist/css目录下。

（3）使用minifyCss进行代码压缩。

（4）通过rename将文件的扩展名取为.min.css。

（5）再输出这个文件到dist/css目录下。

（6）结束任务和工作流。

通过这个过程我们可以看到，编程的方式比配置的方式更能提高可管理性。这也是Gulp与Grunt越来越流行的原因。在早期，选择哪个构建工具，还会有一个决定因素，那就是构建工具中是否有对应的插件。但是，现在这个因素已经越来越不重要了，因为两个构建工具都有我们所需要的大部分插件。从npmjs.org的下载情况来看（2019年04月），Gulp的每周下载量（近120万次）接近Grunt（60余万次）的两倍。

然而，构建工具的故事到这里并没有结束。随着前端工程的模块化，webpack也在某种程度上成为一个构建工具。

## 5.使用打包工具构建webpack

在了解webpack之前，不得不提到一点：webpack并不是一个构建任务运行器，但是它提供了灵活的配置，可以进行一些与任务相关的操作，如其官网介绍的那样：

webpack是一个现代JavaScript应用程序的静态模块打包器（Static Module Bundler）。在webpack处理应用程序时，它会在内部创建一个依赖图（Dependency Graph），并映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle中。

当前主要的前端框架（Angular、React、Vue等）都使用webpack来打包应用，除了承担打包的工作，它还负责一部分常见的构建任务。然而对于webpack而言，它仍然是一个以配置方式为主的构建过程。下面是同上面的Gulp和Grunt类似的用于编译Sass成CSS的步骤：

![img](blob:file:///191b5b0d-8064-4267-a010-77007eba7e6a)

上述配置脚本，看上去和Grunt更加相似，而未采用Gulp式的流编程。因为其主要作用仍然是代码编译，而非构建。对于复杂的构建来说，还是结合Gulp更加合理。

对于前端框架来说，他们倾向于在底层屏蔽这些复杂的配置。例如使用create-react-app脚本生成的应用，需要执行npm run eject才能生成对应的webpack配置。

## 6.实现构建流

尽管应用的构建相当重要，但是在编写前端应用的时候，我们往往不会自己从头去编写构建代码。第一，它需要花费大量的时间；第二，现成的构建代码可以使用。这些代码及配置的来源，可能是前端框架自带的，也可能是前端应用的脚手架提供的。在需要编写某些功能的时候，还可以直接找到现成的插件来实现。

## 7.插件定义构建流

在框架自带构建的情况下，只需要执行build命令就可以生成项目所需要的JavaScript、CSS、HTML等文件。但是总会有一些意外，有时需要一些额外的静态资源。比如，当我们使用的图标源自图标字体（Icon Fonts）时，每次都需要通过SVG重新生成。此时，我们就需要在构建脚本里编写一些相应的代码来实现这个功能。

我们遇到的这些构建问题，多是其他人曾经遇到过的，可以尝试通过以下方式来解决问题：

（1）查找是否有对应的插件。

（2）对比不同的插件区别。

（3）创建插件的适配层。

（4）验证插件是否有效。

（5）重复（2）～（4）步。

（6）如果插件都不适用，那么就编写新插件或改写原有的插件。

针对第3章中提到的与模板相应的编译，我们要做的内容有，编译HTML、JavaScript和CSS，对应的task就是：gulp.task('default'，［'html'，'css'，'js' ］)。

我们可以在具体的编译任务中处理相应的编译工作，此外，我们还要做的事情有：

（1）确认源文件类型、输出文件内容及格式。

（2）根据源文件输出查找相应的插件。

（3）编写对应的配置或者代码。

一般而言，如果输入文件夹是src目录，那么输出文件则是build或者dist。按照这个基础模式，我们只需要找到相应的插件，编写处理的工作流即可。

下面是一个前端项目编译的相关示例：

![img](blob:file:///83463669-f24d-4ece-8046-627abd8a2d6f)

![img](blob:file:///04c6913b-bcbf-4b19-9ada-3140c2e8d890)

在这个代码示例中，我们设计了编译JavaScript、CSS和HTML三个任务，每个任务都依赖于相应的插件来编译代码：

◎　在HTML任务里，使用gulp-pug插件来编译pug，模板为HTML。

◎　在CSS任务里，使用gulp-less插件来编译less，代码为CSS代码，并使用gulp-csso来压缩CSS代码。

◎　在JavaScript任务里，使用gulp-concat插件来合并JavaScript代码文件，并使用'gulp-sourcemaps插件来输出代码映射的SourceMap文件。

构建完成后在build目录下会生成相应的配置：

![img](blob:file:///a2a491a4-a798-40e7-bf12-4dbb4dc61fe3)

![img](blob:file:///c49e2110-3e77-45bf-8785-c7aaa8c1caf8)

在这几个不同的任务中，我们可以清晰地看到插件起到了关键性的作用。插件所能做的事情决定了工作流的设计效果。

## 8.框架定义构建流

前端应用的构建离不开基本的三要素HTML、CSS和JavaScript。不论我们选用哪一个前端框架，最后输出的内容是一样的。随着前端应用变得越来越复杂，越来越多的前端框架提供了完整的应用脚手架，脚手架中也提供了完整的构建流。对于多数应用来说，使用官方提供的脚手架提供的构建流就可以了，完全不需要自己编写。

让我们来看一个React的示例。首先，使用React官方的create-react-app来创建应用。

对于npm 5.2+（执行npm --version查看）的用户来说，可以直接使用npx create-reactapp react-webpack-demo来创建应用。

对于NPM 5.2以下的用户，则使用以下的命令来创建：

![img](blob:file:///f002339e-d10d-49c9-bced-36d016274138)

安装完成后，执行npm run eject或yarn eject来生成对应的脚本文件和配置文件：

![img](blob:file:///f4dc31c4-7200-4b8d-9131-81d454495470)

从代码中我们可以看到，React是以webpack打包为主的构建方式。这里有几个不同的webpack配置文件，分别对应不同的使用环境。以webpack.config.dev.js为例，下面的代码是其JavaScript编译的核心逻辑：

![img](blob:file:///cbdfc900-1b98-4bf6-b3f4-e6dca03505d6)

在这段代码中，entry指明了进入编译的文件入口，output对象则是输出的路径，即相应的配置。

然而，在这个过程中发生了一个巨大的变化——这个脚手架本身提供了构建流，在执行npm run eject之前，我们是看不到构建脚本的。当然，我们也不需要看到这些代码，框架本身已经提供了这个功能。只有在应用和构建变得复杂时，我们才需要去了解它是如何构建的，才需要去修改构建脚本。也就是说，框架已经定义了构建流。

# 4.5 持续交付问题
如果应用构建成功，那么就可以着手部署应用了。大部分前端应用的部署并不复杂，只需要将最后构建生成的目标文件，安装或者复制到指定的线上目录即可——如HTTP服务器指向的固定路径。由于其部署简单，有一定Linux使用经验的开发者都可以独立完成部署。在笔者经历的多数项目里，尽管身为前端的技术主管，但都不需要半夜去上线，而是交由后端开发人员来完成。

## 1.部署方式

对于前端应用来说，其部署方式和后端的区别不大，从方式上可以分为如下三种。

（1）持续部署。构建完成即部署，常见于测试环境。

（2）自动化部署。在持续部署的基础上稍微弱化，即需要人为的介入才能自动化部署。

（3）手动部署。即全程需要人为操作的部署流程。

对于第一种持续部署方式，它不需要有一个上线计划，任何时间都在上线。持续部署更类似于GitHub Pages的形式，提交代码后就自动上线了。

在笔者经历的项目里，基本上都具备Dev环境的自动化部署，部署的成功也就意味着持续集成是成功的。对于其他测试环境如ST、UAT来说，也往往具备这种持续部署的可能性，只是出于流程考虑，通常采用手动触发的自动化部署方式。对于生产环境来说，这种持续部署更加少见。在笔者经历的某个项目里，前端部署采用持续部署的模式，任何修改都可以直接部署到生产环境中。它的实践依赖于成体系的代码质量控制，项目的单元测试覆盖率要在90%以上，并且拥有大量的自动化UI测试。

不论是自动化部署还是手动部署，都需要一个确定的发布策略——不论是敏捷模式还是瀑布模式。敏捷模式的上线发布计划是一个分布迭代（通常两周一次），随后不断地发布；而瀑布模式则是一次上线就完成大部分主要功能。

持续不断地发布应用的优点在于，让团队成员适应快速变化和发布的节奏，并有能力快速解决应用发布过程中出现的问题，而不是在一次上线之后匆忙地应对各种可能发生的情况。对于大型组织下的项目而言，受限于组织内部的上线策略，并不是所有的敏捷项目都可以按迭代上线，但是我们都可以在内部发布，并在过程中持续地改进发布流程。

## 2.设计持续集成

在ThoughtWorks里完成本地的“hello，world”编写之后，下一步要设计持续集成。这种模式有如下优点：

◎　拥有一个随时可发布的应用软件。

◎　方便测试人员进行测试。

◎　及时地展示项目的代码集成情况。

与之相对应的是：我们要采用第3章中提到的何种代码管理方式，越是能持续集成代码，那么后期我们要面对的风险也就越小。在选择代码管理方式时，要选择那种能够持续集成代码的方式，以降低风险。前端项目持续集成的主要内容如下：

◎　对应用进行构建。

◎　进行应用的测试，利用代码来完成测试有助于减少bug。

◎　部署应用到对应的环境，以提供一个联调和测试环境。

我们需要做的事情有：

（1）找到相应的工具。

（2）进行相应的配置。

（3）运行本章中完成的构建脚本。

（4）编写部署脚本。

相应地，我们需要选择一个合适的持续集成工具——专业的收费工具有Bamboo；开源的工具有Jenkins、GoCD；用于开源软件的工具有Travis CI。对于这一类工具来说，Jenkins往往是最好的选择，开源、免费又拥有大量的中文文档。在进行配置的时候，我们可以采用流水线即代码（Pipeline as Code）方式进行，将构建流水线的代码编写在代码库中。再次声明一下，我们推荐把一切与代码相关的东西，都放在代码库中管理，如一些与项目相关的文档、架构决策记录，等等。比如Jenkins的配置文件，以及Jenkinsfile和Travis CI的.travis.yml配置文件，都是用来运行相应的构建的。

如下是一个Jenkins的流水线即代码（Pipeline as Code）方式的Jenkinsfile配置：

![img](blob:file:///1b64150e-da1f-492d-9086-65d73f7cab90)

![img](blob:file:///cf0eacaf-ed5c-4d07-b4cf-050bea6e3804)

注意：在运行上面的测试脚本时，可以使用Docker运行一个Jenkins应用，在Docker官方提供的Kitematic中可以找到对应的镜像，再配合代码：chapter04/react-webpack-demo即可使用。

该配置与构建脚本类似，定义了持续集成所要做的基本事项：安装依赖、执行构建、运行测试，它们分别对应不同的步骤，也对应于前端的构建任务中的几个核心任务。只是现在执行者变了，由开发者变为持续集成服务器，由手动变为全自动执行。

与构建脚本保持基本一致，可以上前端构建与持续集成平台进行解耦，以便向不同的平台迁移。关于持续集成的好处，这里不再赘述。如果读者还没有使用过持续集成，那么可以从现在开始构建一个更好的开发体验。事实上，在完成上面的步骤后，我们还需要编写对应的部署脚本。

## 3.自动化部署

相比于后端，自动化部署对于前端来说是一件特别容易的事。我们通过npm run build就可以构建出一个前端项目：

![img](blob:file:///dfdb9ae7-e059-48ee-81b9-d04bf120c086)

![img](blob:file:///a217fb87-96df-43f5-b4b0-9760fb0168be)

首先，将这些静态文件部署到服务器上，使用Nginx配置域名及相应后台服务的地址即可，代码如下：

![img](blob:file:///88a3a1c7-c1c6-48ce-ae28-36c017d48d8a)

然后，搭配Docker，编写Dockerfile就能完成快速的应用部署。

再编写一个对应的NPM脚本，配置到Jenkinsfile中，就完成了整个持续部署的流程。

使用Puppet、Chef这样的工具也可以直接在本地运行脚本，将应用部署到线上环境。然而，事情往往并不是这么简单的，只有当我们拥有服务器的直接操作权时，才可以轻松地运行我们所需要的服务。

尽管前端部署很简单，还要适当地考虑“回滚机制、蓝绿部署、灰度发布”等因素。并在应用部署后，使用UI自动化测试来测试部分功能是否正常，以及测试对应的后端服务连接。这里不推荐人工测试，考虑到前端的部署比较简单，就不详细地进行说明了。

## 4.环境配置

不同的环境拥有不同的功能、代码及配置事项。当我们编写构建脚本的时候，还需要针对不同的环境（开发、线上）编写构建脚本。

## 5.开发环境配置

对于开发配置而言，有如下不同环境的考虑因素：

（1）在本地环境开发时，我们需要将HTTP请求指向本地的Mock Server。

（2）在本地集成后端服务时，需要将HTTP请求直接指向开发环境的后台服务。

（3）针对不同环境的构建配置来配置不同的构建脚本，以用于部署或者调试。

（4）在运行时，针对不同环境的产品进行相关服务的配置。

我们需要考虑如下配置：

构建配置。在前面的webpack部分，我们介绍了针对不同环境的构建脚本。这个功能是构建工具本身所支持的，不需要我们操心——当然，通过一些额外的配置和参数，也可以实现同样的功能。因此，只需要在编写构建脚本时，将这些因素考虑进去。

代码配置。多数前端框架都提供了环境变量的功能，如Angular可以通过不同的environment.*.ts文件来区分不同的环境。代码中的配置主要用于运行时的环境配置，比如用于不同环境（开发、测试、线上）的第三方服务配置，以及广告、第三方登录授权服务配置等。这些配置可能是硬编码在项目中的，也有可能是动态地从后台获取的。两种方式都有各自的优缺点，使用哪种方式要看需求、配置的变更程度，以及部署是否便利。

代理配置。对于遵循流程的ST、UAT环境来说，由于其可能拥有半年前、一年前的线上数据，因此这些环境和线上的环境更加相似。在这个环境里更容易发现一些Bug，这时需要将HTTP请求指向这些不同环境的服务器。因此，我们几乎需要对所有的环境编写相应的配置。

下面是一个Angular应用针对不同环境的配置示例：

![img](blob:file:///15340d8f-c348-4605-903d-fa31695d43b9)

此外，我们还有一些线上运行时与调试相关的配置。

## 6.线上调试

对于项目开发而言，我们经常要写一些调试代码。为了捕获难以察觉的bug，有时需要在对应的环境上运行代码，有时则需要在线上的环境中运行代码。

为了在线上运行和调试代码，通常需要有一些额外的“开关”（toggle），如：

◎　在URL中添加一些参数，前端代码在运行的过程中去读取这个参数。

◎　在LocalStorage中根据某些值是否存在来运行和调试代码。

◎　对特定的账号进行权限处理，以获取调试功能。

具体采用哪种方式，取决于不同项目的需要。对于一些特殊的应用来说，我们还可能需要通过输入参数来获取后台返回的相应的Debug用的JavaScript代码。

有意思的是，另外一个重要的开关功能：功能开关（Feature Toggles），也使用了类似的注入变量的调试方式。

功能开关是一种强大的技术，允许团队在不更改代码的情况下修改系统行为。比如，我们想在月底的上线中添加一个重要的A功能。但是A功能不太稳定，我们想在发布的过程中控制A功能的使用。这个时候，我们就需要使用功能开关来控制，当我们打开A功能开关的时候，就运行带A功能的部分的代码；当我们关闭A功能开关的时候，就运行原始的代码。在代码中，我们通过某一个变量来控制，而变量的管理则可以通过上述的方式来实现。

# 4.6 小结 
