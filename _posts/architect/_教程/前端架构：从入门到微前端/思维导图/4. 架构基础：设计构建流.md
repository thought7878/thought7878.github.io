在第3章中讲述了如何去搭建和熟悉开发环境这样的工作，作为一个资深的前端开发人员，我们要有能力去设计一个完整的应用开发流程。而这个流程实际上就是要设计一个构建系统，通过它将第3章中设计的流程以代码、工具的形式来加以规范。

# 构建系统
## 核心用途是，帮助开发者从源代码开发开始，构建出最后可用的目标软件
## 前端应用中，构建系统：
### 依赖管理及安装。

### 优化开发环境。

### 代码质量检测。

### 编译及打包。

### 测试及部署。

与过去相比，前端应用的构建已经变得相当复杂。前端应用需要管理依赖版本，以防止在不同的开发机器上因依赖版本不一致而出错；**需要编译代码，而不再是直接合并代码、导致混淆；需要编译SCSS为CSS，而不是直接使用CSS**。对于一个现代的前端应用而言，通常需要做一些步骤，如图4-1所示。

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/db7de0c452ad75b1000dc92aa1dfc7f2_MD5.jpeg]]


尽管现有的前端框架提供了一些工具，帮我们屏蔽了底层构建的复杂度，但是在实际开发的过程中会遇到一些问题，使得我们不得不去优化底层的构建系统。下面是混合应用框架Ionic，其命令行工具执行ionic serve时的启动日志如下：

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/8cb6a760013a6fb3e5c17bad1edbbc10_MD5.jpeg]]

![[_posts/architect/_教程/前端架构：从入门到微前端/思维导图/media/2512b3c2666a00a4105fb9c5d95b9493_MD5.jpeg]]

在这个过程中，它会完成如下工作：

（1）启动“代码修改监测”服务。

（2）开始构建Dev（开发）版本的代码。

（3）清除上次构建的代码。

（4）将TypeScript转译（或称编译）为JavaScript，以便于直接在浏览器上调试。

（5）对DeepLinks（在iOS上称为通用链接（Universal Links））进行预处理。

（6）复制资源文件到对应的目录中。

（7）将Sass编译为CSS，以便于直接在浏览器上调试。

（8）执行一些构建后的处理。

（9）开始执行Lint。

与早期的前端应用相比，这样的一个Web应用构建流程相当复杂。如果是自己从头编写这样一个构建流程，那么它可能比完成项目的时间还长。从上面的日志来看，这个框架的构建工具是webpack。**它帮助我们自动完成了大量的底层细节，使得我们只需要编写相应的配置就可以实现构建流**。

那么，接下来让我们探索一下其中比较重要的几部分内容。


# 4.1 依赖管理工具
在项目的源码管理中，依赖的管理是相当重要的一部分。它可以使代码在项目的各个开发机器、持续集成服务器上快速地搭建、运行、发布，而不需要确认依赖版本等额外的工作。早期没有依赖管理软件时，项目的依赖放在代码库中——每次更新依赖的时候，均需向项目的代码库提交一个新的版本，这导致项目的代码库越来越大，对新成员越来越不友好。在有了依赖管理之后，我们只要执行安装命令，如npm install，再执行运行服务就可以进行开发了。

（1）不同的模块化方案

在继续讨论依赖管理之前，我们不得不再次提及AMD、CommonJS和UMD，它们是三种不同的JavaScript模块化方案。这些模块化方案，在一定程度上影响着项目的依赖管理。

AMD（Asynchronous Module Definition）即异步模块定义，其典型的表现形式是通过构建好的JavaScript库文件，直接在浏览器中引入依赖，典型的框架有jQuery。为了引用这些采用AMD方式的库，我们还需要使用诸如require.jsjs这样的AMD 管理库来管理依赖。如果这些AMD库是在浏览器上通过script直接引入并运行的，那么它们就可以使用bower来进行管理。

CommonJS最初被用于在非浏览器端使用JavaScript来管理模块，比如使用Node.js来开发服务器应用。设计的目的是避免模块定义全局对象，即JavaScript的作用域问题。在CommonJS库里，每个文件就是一个模块。开始时，CommonJS在Node.js服务端运行，随着Browserify和webpack能将这些CommonJS编译为浏览器能运行的JavaScript，越来越多的前端框架直接使用CommonJS来管理模块。

随着AMD和CommonJS的流行，又产生了UMD（Universal Module Definition，通用模块定义），它是AMD和CommonJS的糅合，它会判断是否是Node.js的模块。下面是一个UMD库的示例代码：

![img](blob:file:///ca399cdc-9f4a-40a9-a988-e38d75309c1f)

这段代码中的typeof exports ==='object'就是用于判断Node.js中的模块（Exports）是否存在。如果不存在，则使用AMD的方式来加载模块。

那么，让我们从AMD方式讲起。

（2）AMD方式：通过Bower进行管理

谈到AMD库的管理，一般会有两种方式，一种是直接下载对应的库，另一种是可以由后来的Bower进行管理。

过去前端的基础设施不完善，没有统一的软件包中心，开发者需要在搜索引擎或者GitHub上找到代码库，然后下载解压，再从中复制出代码文件、资源文件等。

在有了Bower之后，开发者只需要在bower.json文件中添加所需要的依赖，就可以由Bower自动下载这个依赖的相关内容——该库打包到bower的服务器上（Bower是一个包管理工具），它可以管理包含HTML、CSS、JavaScript、字体甚至图像文件的组件。Bower的工作原理是，从各个地方获取安装包，并搜索、查找、下载和保存正在寻找的内容。因此，Bower在过去的某段时间里非常流行。

值得注意的是，由于现今的大部分新的前端应用都是通过CommonJS及AMD的方式来引入依赖的，所以Bower的使用场景越来越少。

（3）CommonJS方式：通过NPM/Yarn管理

由于CommonJS早先是用在Node.js项目上的，所以其包管理工具NPM也与CommonJS有了更多的交集。

NPM（Node Package Manager，Node包管理器）是JavaScript世界的包管理工具，并且是Node.js平台的默认包管理工具。开发人员通过NPM可以安装、共享、分发代码，并管理项目依赖关系。此外，这些包会分发到NPM的官方网站npmjs.org上，以便对NPM包进行更好的管理。

除了NPM，还可以使用Yarn来管理依赖。Yarn是由Facebook推出的一款新的JavaScript包管理工具，其特色是Yarn会缓存它下载的每个包，因此不用重复下载就可以加快安装速度。随着Yarn提出缓存包的功能，NPM也提供了相似的功能。

目前主流的前端应用框架（React、Angular、Vue）支持并采用的方式主要以编译构建为主，大都采用NPM+CommonJS的形式来管理依赖。


# 4.2 软件包源管理
# 4.3 前端代码的打包
# 4.4 设计构建流
# 4.5 持续交付问题
# 4.6 小结 
