---
title: "III. Layers | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/client-side-architecture/layers/"
author:
  - "[[Khalil Stemmler]]"
published: 2020-06-24
created: 2025-10-07
description: "Advanced TypeScript & Node.js guides for large-scale applications. Learn to write flexible, maintainable TypeScript."
tags:
  - "clippings"
---
[Welcome](https://khalilstemmler.com/articles/client-side-architecture/introduction) [I. Architecture](https://khalilstemmler.com/articles/client-side-architecture/architecture) [II. Principles](https://khalilstemmler.com/articles/client-side-architecture/principles) [III. Layers](https://khalilstemmler.com/articles/client-side-architecture/layers) [IV. Conclusion](https://khalilstemmler.com/articles/client-side-architecture/conclusion)  
æ¬¢è¿ I. æ¶æ„ II. åŸåˆ™ III. å±‚çº§ IV. ç»“è®º

  
å±•ç¤ºç»„ä»¶ UI é€»è¾‘ å®¹å™¨/æ§åˆ¶å™¨ç»„ä»¶ äº¤äº’å±‚ ç½‘ç»œä¸æ•°æ®è·å–

Last updated Jun 24th, 2020  
æœ€åæ›´æ–°äº 2020 å¹´ 6 æœˆ 24 æ—¥

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/7a6cfed60379bca03b1f4d0912259531_MD5.png]]

> This is page three of a guide on Client-Side Architecture basics. Start at [page one](https://khalilstemmler.com/articles/client-side-architecture/introduction).  
> è¿™æ˜¯å…³äºå®¢æˆ·ç«¯æ¶æ„åŸºç¡€æŒ‡å—çš„ç¬¬ä¸‰é¡µã€‚ä»ç¬¬ä¸€é¡µå¼€å§‹ã€‚

## åˆ†å±‚ä¸å…³æ³¨ç‚¹
Layers and concerns 

We're finally ready to decompose each part of Model-View-Presenter, especially the *model* part.  
æˆ‘ä»¬ç»ˆäºå‡†å¤‡å¥½åˆ†è§£ Model-View-Presenter çš„æ¯ä¸ªéƒ¨åˆ†ï¼Œå°¤å…¶æ˜¯æ¨¡å‹éƒ¨åˆ†ã€‚

Here's a graphic to illustrate that decomposition into something more concrete.  
è¿™æ˜¯ä¸€å¼ å›¾ï¼Œç”¨æ¥è¯´æ˜åˆ†è§£ä¸ºæ›´å…·ä½“çš„ä¸œè¥¿ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/e5138906bb8c7d37898dc6f6ab45197b_MD5.png]]

Can you see both CQS and SoC in here?  
ä½ èƒ½åœ¨è¿™é‡Œçœ‹åˆ° CQS å’Œ SoC å—ï¼Ÿ

Let's examine it from the top.  
è®©æˆ‘ä»¬ä»é¡¶éƒ¨å¼€å§‹åˆ†æã€‚

## å±•ç¤ºç»„ä»¶
Presentation components 

> Render the UI and create user events  
> æ¸²æŸ“ UI å¹¶åˆ›å»ºç”¨æˆ·äº‹ä»¶

If you read the title and feel like closing the tab because of *[this article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)* by Dan Abramov, hang in there. Just wait until we get to container components to decide if you want to bounce ğŸ€.  
å¦‚æœä½ çœ‹äº†æ ‡é¢˜ï¼Œå› ä¸º Dan Abramov çš„æ–‡ç« å°±æƒ³å…³é—­æ ‡ç­¾é¡µï¼Œè¯·å†ç­‰ç­‰ã€‚ç­‰åˆ°æˆ‘ä»¬è®²åˆ°å®¹å™¨ç»„ä»¶æ—¶ï¼Œå†å†³å®šä½ æ˜¯å¦æƒ³è·³æŠ•ğŸ€ã€‚

Presentation components live within the boundaries of the *View* portion of Model-View-Presenter. Their entire purpose is to:  
å±•ç¤ºç»„ä»¶å­˜åœ¨äº Model-View-Presenter çš„ View éƒ¨åˆ†è¾¹ç•Œå†…ã€‚å®ƒä»¬å…¨éƒ¨çš„ç›®çš„æ˜¯ï¼š

- Display data in the UI  
	åœ¨ UI ä¸­æ˜¾ç¤ºæ•°æ®
- Generate user events (from keypresses, button clicks, hover states, etc)  
	ç”Ÿæˆç”¨æˆ·äº‹ä»¶ï¼ˆæ¥è‡ªæŒ‰é”®ã€æŒ‰é’®ç‚¹å‡»ã€æ‚¬åœçŠ¶æ€ç­‰ï¼‰

### å±•ç¤ºç»„ä»¶æ˜¯å®ç°ç»†èŠ‚
Presentation components are an implementation detail

An implementation detail is a low-level detail that helps us accomplish our *main* goal. But they're not our *main* goal. If our *main* goal is to hook up the *Add Todo* feature, the buttons, styling, and text in the UI is an implementation detail in realizing the feature.  
å®ç°ç»†èŠ‚æ˜¯å¸®åŠ©æˆ‘ä»¬å®ç°ä¸»è¦ç›®æ ‡çš„ä½çº§ç»†èŠ‚ã€‚ä½†å®ƒä»¬ä¸æ˜¯æˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡ã€‚å¦‚æœæˆ‘ä»¬ä¸»è¦ç›®æ ‡æ˜¯è¿æ¥æ·»åŠ å¾…åŠäº‹é¡¹åŠŸèƒ½ï¼Œé‚£ä¹ˆç•Œé¢ä¸­çš„æŒ‰é’®ã€æ ·å¼å’Œæ–‡æœ¬æ˜¯å®ç°è¯¥åŠŸèƒ½æ—¶çš„å®ç°ç»†èŠ‚ã€‚

### å±•ç¤ºç»„ä»¶å¯èƒ½æ˜¯æ˜“å˜çš„
Presentation components can be volatile

Anything subject to frequent change is said to be *volatile*. Us constantly changing the look and feel of components is what makes them so.  
ä»»ä½•ç»å¸¸å‘ç”Ÿå˜åŒ–çš„äº‹ç‰©éƒ½è¢«è®¤ä¸ºæ˜¯æ˜“å˜çš„ã€‚æˆ‘ä»¬ä¸æ–­æ”¹å˜ç»„ä»¶çš„å¤–è§‚å’Œæ„Ÿè§‰ï¼Œæ­£æ˜¯ä½¿å®ƒä»¬å¦‚æ­¤çš„åŸå› ã€‚

One way to accommodate this phenomenon is to decide on a **[stable](https://khalilstemmler.com/wiki/stable-dependency-principle/)** set of reusable components (that either you wrote or grabbed from a component library), then create your views from those.  
åº”å¯¹è¿™ç§ç°è±¡çš„ä¸€ç§æ–¹æ³•æ˜¯ç¡®å®šä¸€å¥—ç¨³å®šçš„å¯é‡ç”¨ç»„ä»¶ï¼ˆè¿™äº›ç»„ä»¶è¦ä¹ˆæ˜¯ä½ è‡ªå·±ç¼–å†™çš„ï¼Œè¦ä¹ˆæ˜¯ä»ç»„ä»¶åº“ä¸­è·å–çš„ï¼‰ï¼Œç„¶åä»è¿™äº›ç»„ä»¶åˆ›å»ºä½ çš„è§†å›¾ã€‚

Even though we could use reusable components, data requirements change frequently.  
å°½ç®¡æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¯é‡ç”¨ç»„ä»¶ï¼Œä½†æ•°æ®éœ€æ±‚ç»å¸¸å˜åŒ–ã€‚

Take this simple `CardDescription` component that uses a GraphQL query to describe a card.  
ä»¥è¿™ä¸ªç®€å•çš„ `CardDescription` ç»„ä»¶ä¸ºä¾‹ï¼Œå®ƒä½¿ç”¨ GraphQL æŸ¥è¯¢æ¥æè¿°ä¸€ä¸ªå¡ç‰‡ã€‚

```tsx
const CARD_DESCRIPTION_QUERY = gql\`
  query CardDescription($cardId: ID!) {
    card(id: $cardId) {
      description
    }
  }
\`;

const CardDescription = ({ cardId }) => {
  const { data, loading } = useQuery({ 
    query: CARD_DESCRIPTION_QUERY, 
    variables: { cardId }
  });

  if (loading) {
    return null;
  }

  return <span>{data.card.description}</span>
}
```

How likely is it that we'd need to change the styling? What about displaying something like a `lastChanged` date beside it? Chances are we pretty likely.  
æˆ‘ä»¬å¯èƒ½éœ€è¦æ›´æ”¹æ ·å¼å—ï¼Ÿæ¯”å¦‚åœ¨æ—è¾¹æ˜¾ç¤ºä¸€ä¸ª `lastChanged` æ—¥æœŸï¼Ÿå¯èƒ½æ€§å¾ˆå¤§ã€‚

### åº”è¯¥åœ¨å±•ç¤ºç»„ä»¶ä¸­åŒ…å« GraphQL æŸ¥è¯¢å—ï¼Ÿ
Should we include GraphQL queries in our presentation components?

It's good to have GraphQL queries **as close to the presentational component as possible**. Queries define the data requirements. And since they'll likely need to be changed together if the requirements change, having them close together reduces unnecessary cognitive load accrued by flipping back and forth between files.  
å°† GraphQL æŸ¥è¯¢å°½å¯èƒ½é è¿‘å±•ç¤ºç»„ä»¶æ˜¯ä»¶å¥½äº‹ã€‚æŸ¥è¯¢å®šä¹‰äº†æ•°æ®éœ€æ±‚ã€‚è€Œä¸”ï¼Œå¦‚æœéœ€æ±‚å‘ç”Ÿå˜åŒ–ï¼Œå®ƒä»¬å¾ˆå¯èƒ½éœ€è¦ä¸€èµ·ä¿®æ”¹ï¼Œå°†å®ƒä»¬æ”¾åœ¨ä¸€èµ·å¯ä»¥å‡å°‘åœ¨æ–‡ä»¶ä¹‹é—´æ¥å›åˆ‡æ¢æ‰€ç´¯ç§¯çš„ä¸å¿…è¦çš„è®¤çŸ¥è´Ÿæ‹…ã€‚

One potential *downside* to putting your queries in your components is that now, if you ever wanted to switch away from GraphQL, your components aren't pureâ€” they're coupled to GraphQL. If you wanted to switch transport-layer technologies, you'd have to refactor every component.  
å°†ä½ çš„æŸ¥è¯¢æ”¾åœ¨ç»„ä»¶ä¸­çš„ä¸€ä¸ªæ½œåœ¨ç¼ºç‚¹æ˜¯ï¼Œç°åœ¨å¦‚æœä½ æƒ³è¦ä» GraphQL åˆ‡æ¢ï¼Œä½ çš„ç»„ä»¶å°±ä¸æ˜¯çº¯å‡€çš„â€”â€”å®ƒä»¬ä¸ GraphQL è€¦åˆäº†ã€‚å¦‚æœä½ æƒ³è¦åˆ‡æ¢ä¼ è¾“å±‚æŠ€æœ¯ï¼Œä½ å°†ä¸å¾—ä¸é‡æ„æ¯ä¸ªç»„ä»¶ã€‚

Another potential downside is that to test these components, you'd need to make sure they're wrapped in a [mocked Apollo Client provider](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider).  
å¦ä¸€ä¸ªæ½œåœ¨çš„ç¼ºç‚¹æ˜¯ï¼Œä¸ºäº†æµ‹è¯•è¿™äº›ç»„ä»¶ï¼Œä½ éœ€è¦ç¡®ä¿å®ƒä»¬è¢«åŒ…è£¹åœ¨ä¸€ä¸ªæ¨¡æ‹Ÿçš„ Apollo Client æä¾›è€…ä¸­ã€‚

My recommendation is to couple the queries to the components anyways. What you gain in an incredible developer experience is, in my opinion, worth the risk of going fully in with GraphQL and deciding you want to change later down the road.  
æˆ‘ä»ç„¶å»ºè®®å°†æŸ¥è¯¢ä¸ç»„ä»¶ç»“åˆèµ·æ¥ã€‚åœ¨æˆ‘çœ‹æ¥ï¼Œè·å¾—å“è¶Šçš„å¼€å‘ä½“éªŒæ˜¯å€¼å¾—å†’é™©çš„ï¼Œå³å®Œå…¨é‡‡ç”¨ GraphQLï¼Œå¹¶åœ¨æœªæ¥å†³å®šæƒ³è¦æ”¹å˜ã€‚

**Note on query performance**: It's ok to have lots of queries for super-specific chunks of data like shown above. Using Apollo Client, Apollo handles that complicated logic of checking whether the data is cached already, and if not â€” it makes a request to get it.  
å…³äºæŸ¥è¯¢æ€§èƒ½çš„è¯´æ˜ï¼šå¯¹äºåƒä¸Šé¢å±•ç¤ºçš„è¿™æ ·å¤§é‡é’ˆå¯¹è¶…çº§ç‰¹å®šæ•°æ®å—çš„æŸ¥è¯¢æ˜¯æ²¡é—®é¢˜çš„ã€‚ä½¿ç”¨ Apollo Client æ—¶ï¼ŒApollo ä¼šå¤„ç†æ£€æŸ¥æ•°æ®æ˜¯å¦å·²ç»è¢«ç¼“å­˜çš„å¤æ‚é€»è¾‘ï¼Œå¦‚æœæ²¡æœ‰ç¼“å­˜â€”â€”å®ƒä¼šå‘èµ·è¯·æ±‚æ¥è·å–æ•°æ®ã€‚

### åœ¨å±•ç¤ºç»„ä»¶ä¸­è¦æµ‹è¯•ä»€ä¹ˆ
What to test in presentation components

Unit testing implementation details is typically fruitless â€” especially for volatile things. It doesn't do us much good testing to see if a button is blue or green. Instead, when testing presentation components, we want to test against UI logic.  
å•å…ƒæµ‹è¯•å®ç°ç»†èŠ‚é€šå¸¸æ˜¯å¾’åŠ³çš„â€”â€”å°¤å…¶æ˜¯å¯¹äºæ˜“å˜çš„äº‹ç‰©ã€‚æµ‹è¯•ä¸€ä¸ªæŒ‰é’®æ˜¯è“è‰²è¿˜æ˜¯ç»¿è‰²å¯¹æˆ‘ä»¬å¹¶æ²¡æœ‰å¤ªå¤šå¥½å¤„ã€‚ç›¸åï¼Œåœ¨æµ‹è¯•å±•ç¤ºç»„ä»¶æ—¶ï¼Œæˆ‘ä»¬æƒ³è¦é’ˆå¯¹ UI é€»è¾‘è¿›è¡Œæµ‹è¯•ã€‚

To demonstrate what I mean, here's a bland, basic presentation component.  
ä¸ºäº†è¯´æ˜æˆ‘çš„æ„æ€ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå¹³æ·¡æ— å¥‡çš„åŸºç¡€å±•ç¤ºç»„ä»¶ã€‚

/components/Todo.tsx

```tsx
export const Todo = (props) => (
  <div className="todo">
    <div class="todo-text">{props.text}</div>
    <button onClick={props.onDeleteTodo}>Delete</button>
  </div>
)
```

There's no UI logic involved here. It merely takes in props, hooks up callbacks, and renders some HTML.  
è¿™é‡Œæ²¡æœ‰æ¶‰åŠ UI é€»è¾‘ã€‚å®ƒåªæ˜¯æ¥æ”¶ propsï¼Œè¿æ¥å›è°ƒå‡½æ•°ï¼Œå¹¶æ¸²æŸ“ä¸€äº› HTMLã€‚

Here's *another* example of the same component, but this time, as a class-based component with **UI logic*.***  
è¿™é‡Œåˆæ˜¯åŒä¸€ä¸ªç»„ä»¶çš„å¦ä¸€ä¸ªä¾‹å­ï¼Œä½†è¿™æ¬¡æ˜¯ä»¥åŸºäºç±»çš„ç»„ä»¶å½¢å¼ï¼Œå¹¶åŒ…å« UI é€»è¾‘ã€‚

/components/Todo.tsx

```tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'

type Props = any;

export default class Todo extends Component<Props, Props> {
  static propTypes = {
    todo: PropTypes.object.isRequired,
    editTodo: PropTypes.func.isRequired,
    deleteTodo: PropTypes.func.isRequired,
    completeTodo: PropTypes.func.isRequired
  }

  state = {
    editing: false
  }

  handleDoubleClick = () => {
    this.setState({ editing: true })
  }

  handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      this.props.deleteTodo(id)
    } else {
      this.props.editTodo(id, text)
    }
    this.setState({ editing: false })
  }

  render() {
    const { todo, completeTodo, deleteTodo } = this.props

    return this.state.editing ? (
      <TodoTextInput 
          text={todo.text}
          editing={this.state.editing}
          onSave={(text: string) => this.handleSave(todo.id, text)} />
    ) : (
      <div className="view">
        <input 
           className="toggle"
           type="checkbox"
           checked={todo.completed}
           onChange={() => completeTodo(todo.id)} />
        <label onDoubleClick={this.handleDoubleClick}>
          {todo.text}
        </label>
        <button 
          className="destroy"
          onClick={() => deleteTodo(todo.id)} />
      </div>
    )
  }
}
```

## UI é€»è¾‘
UI logic 

> View behavior & local component state  
> æŸ¥çœ‹è¡Œä¸ºä¸æœ¬åœ°ç»„ä»¶çŠ¶æ€

The main difference between the two previously shown `Todo` components is that the second `Todo` component contained UI logic where the first did not.  
ä¹‹å‰å±•ç¤ºçš„ä¸¤ä¸ª `Todo` ç»„ä»¶ä¹‹é—´çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œç¬¬äºŒä¸ª `Todo` ç»„ä»¶åŒ…å«äº† UI é€»è¾‘ï¼Œè€Œç¬¬ä¸€ä¸ªåˆ™æ²¡æœ‰ã€‚

### UI é€»è¾‘å°±æ˜¯è§†å›¾è¡Œä¸º
UI logic is view behavior

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/58c6dfdefd8c3d968ceea2fd157f1518_MD5.png]]

"If you're logged in, show *this* â€” otherwise, show *this."*  
å¦‚æœä½ å·²ç™»å½•ï¼Œæ˜¾ç¤ºè¿™ä¸ª â€” å¦åˆ™ï¼Œæ˜¾ç¤ºè¿™ä¸ªã€‚

"If you're this type of user, show *this* â€” otherwise, show *this."*  
å¦‚æœä½ æ˜¯è¿™ç§ç±»å‹çš„ç”¨æˆ·ï¼Œæ˜¾ç¤ºè¿™ä¸ª â€” å¦åˆ™ï¼Œæ˜¾ç¤ºè¿™ä¸ªã€‚

"Depending on which page you're on in the signup process, show the correct form".  
"æ ¹æ®ä½ åœ¨æ³¨å†Œè¿‡ç¨‹ä¸­æ‰€åœ¨çš„é¡µé¢ï¼Œæ˜¾ç¤ºæ­£ç¡®çš„è¡¨å•"ã€‚

A component has UI logic when it exudes behavior. Conditionals that determine *what to show*, or *when certain user events get called over others* **are a form of view behavior (UI logic)**.  
ä¸€ä¸ªç»„ä»¶å…·æœ‰ UI é€»è¾‘ï¼Œå½“å®ƒè¡¨ç°å‡ºè¡Œä¸ºæ—¶ã€‚å†³å®šæ˜¾ç¤ºä»€ä¹ˆå†…å®¹çš„æ¡ä»¶ï¼Œæˆ–æŸäº›ç”¨æˆ·äº‹ä»¶ä½•æ—¶è¢«è°ƒç”¨ä¼˜å…ˆäºå…¶ä»–äº‹ä»¶ï¼Œæ˜¯ä¸€ç§è§†å›¾è¡Œä¸ºï¼ˆUI é€»è¾‘ï¼‰ã€‚

Here's a conditional example from the previous code sample **determining what to show**.  
è¿™æ˜¯æ¥è‡ªä¸Šä¸€ä¸ªä»£ç ç¤ºä¾‹çš„ä¸€ä¸ªæ¡ä»¶æ€§ç¤ºä¾‹ï¼Œç”¨äºç¡®å®šè¦æ˜¾ç¤ºä»€ä¹ˆå†…å®¹ã€‚

```tsx
return this.state.editing ? (
    <TodoTextInput 
        text={todo.text}
        editing={this.state.editing}
        onSave={(text: string) => this.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
         className="toggle"
         type="checkbox"
         checked={todo.completed}
         onChange={() => completeTodo(todo.id)} />
      <label onDoubleClick={this.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => deleteTodo(todo.id)} />
    </div>
  )
```

Here's a conditional **determining which user event to create**.  
è¿™é‡Œæ˜¯ä¸€ä¸ªå†³å®šåˆ›å»ºå“ªä¸ªç”¨æˆ·äº‹ä»¶çš„æ¡ä»¶ã€‚

```tsx
handleSave = (id: number, text: string) => {
  if (text.length === 0) {
    this.props.deleteTodo(id)
  } else {
    this.props.editTodo(id, text)
  }
  this.setState({ editing: false })
}
```

### ç»„ä»¶ / æœ¬åœ°çŠ¶æ€
Component / local state

This is where the *first* type of state we might encounter: `local (component)` state.  
è¿™å°±æ˜¯æˆ‘ä»¬å¯èƒ½é‡åˆ°çš„ç¬¬ä¸€ç§çŠ¶æ€ï¼š `local (component)` çŠ¶æ€ã€‚

In [Jed Watson](https://twitter.com/JedWatson) 's talk from GraphQL Summit 2019 titled, " [A Treatise on State](https://www.youtube.com/watch?v=tBz3UmZG_bk&feature=emb_title) ", he describes five different types of state when building web apps: `local (component)`, `shared (global)`, `remote (global)`, `meta`, and `router`.  
åœ¨ Jed Watson äº 2019 å¹´ GraphQL Summit ä¸Šçš„æ¼”è®²ã€Šå…³äºçŠ¶æ€çš„å°å†Œå­ã€‹ä¸­ï¼Œä»–æè¿°äº†åœ¨æ„å»º Web åº”ç”¨æ—¶æ¶‰åŠåˆ°çš„äº”ç§ä¸åŒç±»å‹çš„çŠ¶æ€ï¼š `local (component)` ã€ `shared (global)` ã€ `remote (global)` ã€ `meta` å’Œ `router` ã€‚

- **Explanations of the five types of state  
	äº”ç§çŠ¶æ€ç±»å‹çš„è§£é‡Š**
	- `local (component)`: State that belongs to a single component. Can also be thought about as UI state. UI state can be extracted from a presentation component into a React hook. **Note: we're about to do this**.  
		`local (component)`: å±äºå•ä¸ªç»„ä»¶çš„çŠ¶æ€ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸º UI çŠ¶æ€ã€‚UI çŠ¶æ€å¯ä»¥ä»å±•ç¤ºç»„ä»¶ä¸­æå–åˆ° React é’©å­ä¸­ã€‚æ³¨æ„ï¼šæˆ‘ä»¬å³å°†è¿™æ ·åšã€‚
	- `shared (global)`: As soon as some state belongs to more than one component, it's *shared* global state. Components shouldn't need to know about each other (a header shouldn't need to know about a todo).  
		`shared (global)`: å½“æŸä¸ªçŠ¶æ€å±äºå¤šä¸ªç»„ä»¶æ—¶ï¼Œå®ƒå°±æ˜¯å…±äº«çš„å…¨å±€çŠ¶æ€ã€‚ç»„ä»¶ä¹‹é—´ä¸éœ€è¦ç›¸äº’äº†è§£ï¼ˆå¤´éƒ¨ç»„ä»¶ä¸éœ€è¦äº†è§£å¾…åŠäº‹é¡¹ç»„ä»¶ï¼‰ã€‚
	- `remote (global)`: The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
		`remote (global)`: æœåŠ¡ä¸­ API èƒŒåå­˜åœ¨çš„çŠ¶æ€ã€‚å½“æˆ‘ä»¬ä¸ºè¿œç¨‹çŠ¶æ€åˆ›å»º `queries` æ—¶ï¼Œæˆ‘ä»¬ä¼šä¿ç•™ä¸€ä¸ªå¯åœ¨å…¨å±€èŒƒå›´å†…è®¿é—®çš„æœ¬åœ°å‰¯æœ¬ã€‚
	- `meta`: Meta state refers to state *about* state. The best example of this is the `loading` async states that tell us the progress of our network requests.  
		`meta`: å…ƒçŠ¶æ€æŒ‡çš„æ˜¯å…³äºçŠ¶æ€çš„çŠ¶æ€ã€‚æœ€å¥½çš„ä¾‹å­å°±æ˜¯ `loading` å¼‚æ­¥çŠ¶æ€ï¼Œå®ƒä»¬å‘Šè¯‰æˆ‘ä»¬ç½‘ç»œè¯·æ±‚çš„è¿›åº¦ã€‚
	- and `router` state: The current URL of the browser.  
		å¹¶ä¸” `router` çŠ¶æ€ï¼šæµè§ˆå™¨å½“å‰çš„ URLã€‚

This state, `local (component)` state, belongs to a single component. You can call this UI state. It's meant to hold onto data that helps a single component do its job.  
è¿™ä¸ªçŠ¶æ€ï¼Œ `local (component)` çŠ¶æ€ï¼Œå±äºå•ä¸ªç»„ä»¶ã€‚ä½ å¯ä»¥ç§°è¿™ä¸ªä¸º UI çŠ¶æ€ã€‚å®ƒçš„ç›®çš„æ˜¯ä¿å­˜å¸®åŠ©å•ä¸ªç»„ä»¶å®Œæˆå…¶å·¥ä½œçš„æ•°æ®ã€‚

To better see what it looks like, let's extract all UI state from this class-based component and refactor to a functional component and a React hook.  
ä¸ºäº†æ›´å¥½åœ°æŸ¥çœ‹å…¶å¤–è§‚ï¼Œè®©æˆ‘ä»¬ä»è¿™ä¸ªåŸºäºç±»çš„ç»„ä»¶ä¸­æå–æ‰€æœ‰ UI çŠ¶æ€ï¼Œå¹¶å°†å…¶é‡æ„ä¸ºä¸€ä¸ªå‡½æ•°å¼ç»„ä»¶å’Œä¸€ä¸ª React é’©å­ã€‚

/components/Todo.tsx

```tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'
import { useState } from 'react'

/**
 * Decompose the UI logic from the presentational component
 * and store it in a React hook.
 *
 * All data and operations in this hook are UI logic for the
 * component - we've just separated concerns, that's all.
 */

function useTodoComponent (actions) {
  // "editing" is a form of local (component) state
  const [editing, setEditing] = useState(false);

  const handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      actions.deleteTodo(id)
    } else {
      actions.editTodo(id, text)
    }
    setEditing(true);
  }

  const handleDoubleClick = () => {
    setEditing(true);
  }

  return { 
    models: { editing }, 
    operations: { handleSave, handleDoubleClick } 
  }
}

/**
 * This component relies on some local state, but none of 
 * it lives within the component, which is purely 
 * presentational.
 */

export function Todo (props) {
  const { todo, actions } = props;
  
  // Grab our local (component) state and access to other UI logic
  const { models, operations } = useTodoComponent(actions);
  
  // Conditional UI logic
  return models.editing ? (
    <TodoTextInput 
      text={todo.text}
      editing={models.editing}
      onSave={(text: string) => operations.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
        className="toggle"
        type="checkbox"
        checked={todo.completed}
        onChange={() => actions.completeTodo(todo.id)} />
      <label onDoubleClick={operations.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => actions.deleteTodo(todo.id)} />
    </div>
  )
}
```

### UI é€»è¾‘æ˜¯æˆ‘ä»¬å®é™…ä¸Šåœ¨ç»„ä»¶ä¸­å°è¯•æµ‹è¯•çš„å†…å®¹
UI logic is what we actually try to test within components

Since UI logic is behavior, *this* is actually what we want to test against in our integration tests. The behavior. You *could* write unit tests as well, but it might be trivial if component logic is straightforward. It could be more worthwhile and give you more confidence that the feature is working correctly to integration test both the component and the UI logic together.  
ç”±äº UI é€»è¾‘æ˜¯è¡Œä¸ºï¼Œå®é™…ä¸Šè¿™æ˜¯æˆ‘ä»¬å¸Œæœ›åœ¨é›†æˆæµ‹è¯•ä¸­æµ‹è¯•çš„å†…å®¹ã€‚è¡Œä¸ºã€‚ä½ ä¹Ÿå¯ä»¥ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œä½†å¦‚æœç»„ä»¶é€»è¾‘å¾ˆç®€å•ï¼Œè¿™å¯èƒ½å°±æ²¡ä»€ä¹ˆæ„ä¹‰äº†ã€‚å°†ç»„ä»¶å’Œ UI é€»è¾‘ä¸€èµ·è¿›è¡Œé›†æˆæµ‹è¯•å¯èƒ½æ›´æœ‰ä»·å€¼ï¼Œå¹¶ä¸”èƒ½è®©ä½ æ›´æœ‰ä¿¡å¿ƒåœ°ç¡®ä¿¡åŠŸèƒ½è¿è¡Œæ­£å¸¸ã€‚

## å®¹å™¨/æ§åˆ¶å™¨
Container/controller 

> The glue layer (pages)  
> ç²˜åˆå±‚ï¼ˆé¡µé¢ï¼‰

Traditionally, the responsibilities of a container component were to:  
ä¼ ç»Ÿä¸Šï¼Œå®¹å™¨ç»„ä»¶çš„èŒè´£æ˜¯ï¼š

- Consume user events & pass them to the model  
	æ¶ˆè´¹ç”¨æˆ·äº‹ä»¶å¹¶å°†å…¶ä¼ é€’ç»™æ¨¡å‹
- Subscribe to data changes (reactivity) and keep the view updated  
	è®¢é˜…æ•°æ®å˜åŒ–ï¼ˆå“åº”æ€§ï¼‰å¹¶ä¿æŒè§†å›¾æ›´æ–°

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/b2b86e61c87686226d1945c0400cc986_MD5.png]]

This isn't new. The definition of a *controller/presenter,* all the way back from the *Model-View-Presenter* pattern, made this distinction.  
è¿™å¹¶éæ–°äº‹ç‰©ã€‚æ§åˆ¶å™¨/å‘ˆç°è€…çš„å®šä¹‰ï¼Œä»æ¨¡å‹-è§†å›¾-å‘ˆç°è€…æ¨¡å¼å¼€å§‹ï¼Œå°±åšå‡ºäº†è¿™ç§åŒºåˆ†ã€‚

### æˆ‘ä»¬çœŸçš„éœ€è¦å®¹å™¨ç»„ä»¶å—ï¼Ÿ
Do we really need container components?

In 2019, with the advent of React hooks, [Dan said we don't](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).  
2019 å¹´ï¼Œéšç€ React hooks çš„æ¨å‡ºï¼ŒDan è¯´è¿‡æˆ‘ä»¬ä¸éœ€è¦ã€‚

> The main reason I found \[container components\] useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division.  
> æˆ‘å‘ç°\[å®¹å™¨ç»„ä»¶\]æœ‰ç”¨çš„ä¸»è¦åŸå› æ˜¯å®ƒè®©æˆ‘èƒ½å°†å¤æ‚çš„å¸¦çŠ¶æ€é€»è¾‘ä¸å…¶ä»–ç»„ä»¶æ–¹é¢åˆ†ç¦»ã€‚Hooks è®©æˆ‘èƒ½ä¸é€šè¿‡ä»»æ„åˆ’åˆ†å®ç°åŒæ ·çš„äº‹æƒ…ã€‚

Here are my thoughts.  
ä»¥ä¸‹æ˜¯æˆ‘çš„æƒ³æ³•ã€‚

I fully agree that complex stateful logic **shouldn't live within presentation components**. When we do that, we don't get the ability to reuse logic across different components.  
æˆ‘å®Œå…¨åŒæ„å¤æ‚çš„çŠ¶æ€é€»è¾‘ä¸åº”è¯¥å­˜åœ¨äºå±•ç¤ºç»„ä»¶ä¸­ã€‚å½“æˆ‘ä»¬é‚£æ ·åšæ—¶ï¼Œæˆ‘ä»¬å°±æ— æ³•åœ¨ä¸åŒçš„ç»„ä»¶ä¹‹é—´é‡ç”¨é€»è¾‘ã€‚

Now, as for stateful logic in *container components*? I don't believe it *ever should have been in 'em.*  
ç°åœ¨ï¼Œå…³äºå®¹å™¨ç»„ä»¶ä¸­çš„æœ‰çŠ¶æ€é€»è¾‘ï¼Ÿæˆ‘ä¸è®¤ä¸ºå®ƒæœ¬è¯¥æ”¾åœ¨é‡Œé¢ã€‚

Previously, React developers were advised to put data and behavior in container components and write code that determined "how things work". That breaks the rules of what was said to be the responsibility of a container/presenter.  
æ­¤å‰ï¼ŒReact å¼€å‘è€…è¢«å»ºè®®å°†æ•°æ®å’Œé€»è¾‘æ”¾åœ¨å®¹å™¨ç»„ä»¶ä¸­ï¼Œå¹¶ç¼–å†™å†³å®š"äº‹ç‰©å¦‚ä½•è¿ä½œ"çš„ä»£ç ã€‚ä½†è¿™è¿åäº†å®¹å™¨/å±•ç¤ºå™¨è¢«æŒ‡å‡ºçš„è´£ä»»è§„åˆ™ã€‚

Just because we know to put stateful data and behavior in React Hooks, it **doesn't mean we removed the problems a container component solves**.  
ä»…ä»…å› ä¸ºæˆ‘ä»¬çŸ¥é“åœ¨ React Hooks ä¸­æ”¾ç½®æœ‰çŠ¶æ€æ•°æ®å’Œè¡Œä¸ºï¼Œå¹¶ä¸æ„å‘³ç€æˆ‘ä»¬ç§»é™¤äº†å®¹å™¨ç»„ä»¶æ‰€è§£å†³çš„é—®é¢˜ã€‚

We *still* need to configure *reactivity*, sometimes using Redux, sometimes using Apollo Client or something else, and we *still* need some construct to **act as the glue, knowing which components to load up for the features we enable on a page**.  
æˆ‘ä»¬ä»ç„¶éœ€è¦é…ç½®å“åº”æ€§ï¼Œæœ‰æ—¶ä½¿ç”¨ Reduxï¼Œæœ‰æ—¶ä½¿ç”¨ Apollo Client æˆ–å…¶ä»–å·¥å…·ï¼Œå¹¶ä¸”æˆ‘ä»¬ä»ç„¶éœ€è¦ä¸€ä¸ªç»“æ„ä½œä¸ºç²˜åˆå‰‚ï¼ŒçŸ¥é“è¦ä¸ºé¡µé¢å¯ç”¨çš„åŠŸèƒ½åŠ è½½å“ªäº›ç»„ä»¶ã€‚

### å®¹å™¨ç»„ä»¶æ˜¯é¡µé¢
Container components are pages

In the following React Router example, we have three main *pages:* home, about, and dashboard.  
åœ¨ä»¥ä¸‹ React Router ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸‰ä¸ªä¸»è¦é¡µé¢ï¼šä¸»é¡µã€å…³äºé¡µå’Œä»ªè¡¨ç›˜é¡µã€‚

src/App.js

```tsx
export default function App () {
  return (
    <Router>
        <Switch>
          <Route exact path="/"> 
            <Home />
          </Route>
          <Route path="/about">
            <About />
          </Route>
          <Route path="/dashboard">
            <Dashboard />
          </Route>
        </Switch>
    </Router>
  );
}
```

Each page:æ¯é¡µï¼š

- is responsible for enable a variable number of features (remember, a feature is a `command` or `query`)  
	è´Ÿè´£å¯ç”¨ä¸€ä¸ªå¯å˜æ•°é‡çš„åŠŸèƒ½ï¼ˆè®°ä½ï¼Œä¸€ä¸ªåŠŸèƒ½æ˜¯ä¸€ä¸ª `command` æˆ– `query` ï¼‰
- has a variable number of presentational components within it, and  
	åŒ…å«ä¸€ä¸ªå¯å˜æ•°é‡çš„è¡¨ç°ç»„ä»¶
- knows about `shared` reactive state, and *sometimes* connects it to presentational components that need it  
	çŸ¥é“ `shared` ååº”å¼çŠ¶æ€ï¼Œæœ‰æ—¶ä¼šå°†å…¶è¿æ¥åˆ°éœ€è¦å®ƒçš„å±•ç¤ºç»„ä»¶

Container components are the top-level modules that turn on all the features for a particular page. In Gatsby.js, we call them *Page components*. Since all client architectures naturally evolve from this Model-View-Presenter pattern, it's unlikely we'll **get rid of the presenter (container) entirely**.  
å®¹å™¨ç»„ä»¶æ˜¯ç‰¹å®šé¡µé¢çš„é¡¶å±‚æ¨¡å—ï¼Œç”¨äºå¯ç”¨æ‰€æœ‰åŠŸèƒ½ã€‚åœ¨ Gatsby.js ä¸­ï¼Œæˆ‘ä»¬ç§°å®ƒä»¬ä¸ºé¡µé¢ç»„ä»¶ã€‚ç”±äºæ‰€æœ‰å®¢æˆ·ç«¯æ¶æ„éƒ½è‡ªç„¶åœ°éµå¾ªæ¨¡å‹-è§†å›¾-å‘ˆç°è€…æ¨¡å¼ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¤ªå¯èƒ½å®Œå…¨åºŸé™¤å‘ˆç°è€…ï¼ˆå®¹å™¨ï¼‰ã€‚

To demonstrate my point, here's a *container component* in a React hooks world. It might not look like much, but notice that **it fulfills the two responsibilities of a container component**.  
ä¸ºäº†è¯æ˜æˆ‘çš„è§‚ç‚¹ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªåœ¨ React hooks ä¸–ç•Œä¸­çš„å®¹å™¨ç»„ä»¶ã€‚å®ƒçœ‹èµ·æ¥å¯èƒ½ä¸èµ·çœ¼ï¼Œä½†è¯·æ³¨æ„å®ƒæ‰¿æ‹…äº†å®¹å™¨ç»„ä»¶çš„ä¸¤ä¸ªèŒè´£ã€‚

/modules/home/Home.container.tsx

```tsx
import React from 'react'
import MainSection from '../components/MainSection'
import { useQuery } from '@apollo/client'
import { VisiblityFilter } from '../models/VisibilityFilter'
import { Todos } from '../models/Todos'
import { GET_ALL_TODOS } from '../operations/queries/getAllTodos'
import { GET_VISIBILITY_FILTER } from '../operations/queries/getVisibilityFilter'
import { todoMutations } from '../operations/mutations'

const todosAPI = new TodosAPI();

export default function Home () {
  // Shared (global) or remote (global) state.
  const { operations, models } = useTodos(todosAPI);
  const { 
    completeAllTodos, 
    setVisibilityFilter, 
    clearCompletedTodos 
  } = operations;

  return (
    <Layout>
      <MainSection
        // Pass data to components
        activeVisibilityFilter={visibilityFilter}
        todosCount={models.todos.length}
        completedCount={models.todos.filter(t => t.completed).length}
        
        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
      />
      <ReportSection 
        // Pass data to components
        todos={models.todos}

        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
       />
    </Layout>
  );
};
```

***Something* is responsible for knowing how to connect to a reactive model, and knowing what to do with events that come from presentation components. That's a container.  
æœ‰æŸç‰©è´Ÿè´£çŸ¥é“å¦‚ä½•è¿æ¥åˆ°å“åº”å¼æ¨¡å‹ï¼Œä»¥åŠå¦‚ä½•å¤„ç†æ¥è‡ªå±•ç¤ºç»„ä»¶çš„äº‹ä»¶ã€‚è¿™å°±æ˜¯å®¹å™¨ã€‚**

Of course, you could call everything a *component,* but then the explicit communication and delineation of responsibilities we're fighting for is lost.  
å½“ç„¶ï¼Œä½ å¯ä»¥å°†æ‰€æœ‰ä¸œè¥¿éƒ½ç§°ä¸ºç»„ä»¶ï¼Œä½†é‚£æ ·æˆ‘ä»¬ä¸ºä¹‹å¥‹æ–—çš„æ˜ç¡®æ²Ÿé€šå’Œè´£ä»»ç•Œå®šå°±ä¼šä¸¢å¤±ã€‚

### å®¹å™¨ç»„ä»¶ä¸åŒ…å«ä»»ä½•åŠŸèƒ½
Container components contain no functionality

The container component is pretty bare. That's a good thing. They're not supposed to contain any functionality. They're not worthy of unit testing. They're just meant to stitch things together. However, if you want to do an integration test all features of a page, just load up the container component and have at 'er.  
å®¹å™¨ç»„ä»¶ç›¸å½“ç®€å•ã€‚è¿™æ˜¯ä¸ªå¥½äº‹ã€‚å®ƒä»¬ä¸åº”è¯¥åŒ…å«ä»»ä½•åŠŸèƒ½ã€‚å®ƒä»¬ä¸å€¼å¾—è¿›è¡Œå•å…ƒæµ‹è¯•ã€‚å®ƒä»¬åªæ˜¯ç”¨æ¥å°†ä¸œè¥¿ç»„åˆåœ¨ä¸€èµ·ã€‚ç„¶è€Œï¼Œå¦‚æœä½ æƒ³å¯¹é¡µé¢çš„æ‰€æœ‰åŠŸèƒ½è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œåªéœ€åŠ è½½å®¹å™¨ç»„ä»¶å¹¶å¼€å§‹æµ‹è¯•å³å¯ã€‚

> Model behavior æ¨¡å‹è¡Œä¸º

We're finally in the most challenging part of a client-side architecture: the *model*.  
æˆ‘ä»¬ç»ˆäºæ¥åˆ°äº†å®¢æˆ·ç«¯æ¶æ„ä¸­æœ€å…·æŒ‘æˆ˜æ€§çš„éƒ¨åˆ†ï¼šæ¨¡å‹ã€‚

The first layer of the model, which is what gets called from the container component, is the **interaction layer**.  
æ¨¡å‹çš„ç¬¬ä¸€ä¸ªå±‚æ¬¡ï¼Œå³ä»å®¹å™¨ç»„ä»¶è°ƒç”¨çš„å±‚æ¬¡ï¼Œæ˜¯äº¤äº’å±‚ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

When you click submit to " *add a todo"*, do you jump straight to the GraphQL `mutation` right away? Do you perform any validation logic? Are there any rules to enforce?  
å½“ä½ ç‚¹å‡»æäº¤æ¥â€œæ·»åŠ å¾…åŠäº‹é¡¹â€æ—¶ï¼Œä½ ä¼šç›´æ¥è·³è½¬åˆ° GraphQL `mutation` å—ï¼Ÿä½ ä¼šæ‰§è¡Œä»»ä½•éªŒè¯é€»è¾‘å—ï¼Ÿæ˜¯å¦æœ‰ä»»ä½•è§„åˆ™éœ€è¦å¼ºåˆ¶æ‰§è¡Œï¼Ÿ

A lot of times, there *aren't* any rules. Sometimes we can't be bothered and we leave validation logic as something the *server* handles. This is particularly common on simple dashboard apps. These apps have pretty much **no rules to enforce**, so an interaction layer doesn't exist.  
å¾ˆå¤šæ—¶å€™ï¼Œå¹¶æ²¡æœ‰è§„åˆ™ã€‚æœ‰æ—¶æˆ‘ä»¬æ‡’å¾—å¤„ç†ï¼Œå°±æŠŠéªŒè¯é€»è¾‘äº¤ç»™æœåŠ¡å™¨æ¥å¤„ç†ã€‚è¿™åœ¨ç®€å•çš„ä»ªè¡¨ç›˜åº”ç”¨ä¸­å°¤å…¶å¸¸è§ã€‚è¿™äº›åº”ç”¨å‡ ä¹æ²¡æœ‰ä»€ä¹ˆè§„åˆ™éœ€è¦å¼ºåˆ¶æ‰§è¡Œï¼Œæ‰€ä»¥äº¤äº’å±‚å°±ä¸å­˜åœ¨ã€‚

It goes controller â†’ network request.  
å®ƒä»æ§åˆ¶å™¨æµå‘ç½‘ç»œè¯·æ±‚ã€‚

Or as we've been doing for a long time, presentation component â†’ network request.  
æˆ–è€…ï¼Œå°±åƒæˆ‘ä»¬é•¿æœŸä»¥æ¥æ‰€åšçš„é‚£æ ·ï¼Œå±•ç¤ºç»„ä»¶â†’ç½‘ç»œè¯·æ±‚ã€‚

When there **is** policy to enforce, it's time to think about carving out an interaction layer.  
å½“æœ‰æ”¿ç­–éœ€è¦æ‰§è¡Œæ—¶ï¼Œå°±æ˜¯è€ƒè™‘æ„å»ºäº¤äº’å±‚çš„æ—¶å€™äº†ã€‚

**Application (or interaction) logic** is the logic that makes a decision as to what happens next.  
åº”ç”¨ï¼ˆæˆ–äº¤äº’ï¼‰é€»è¾‘æ˜¯å†³å®šæ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆçš„é€»è¾‘ã€‚

Let's say you have a `command` called `createTodoIfNotExists`. Whatever construct is responsible for the interaction layer contains the code that helps you decide, "should we follow through with this"?  
å‡è®¾ä½ æœ‰ä¸€ä¸ªåä¸º `createTodoIfNotExists` çš„ `command` ã€‚è´Ÿè´£äº¤äº’å±‚çš„ä»»ä½•ç»“æ„éƒ½åŒ…å«å¸®åŠ©ä½ å†³å®šâ€œæ˜¯å¦ç»§ç»­æ‰§è¡Œè¿™ä¸ªæ“ä½œâ€çš„ä»£ç ã€‚

Here's a [Redux Thunk](https://github.com/reduxjs/redux-thunk) example, where sometimes, we need to reach into some form of `global` state (maybe cached in a store) to make a decision.  
è¿™é‡Œæœ‰ä¸€ä¸ª Redux Thunk çš„ä¾‹å­ï¼Œæœ‰æ—¶æˆ‘ä»¬éœ€è¦ä»æŸç§ `global` çŠ¶æ€ï¼ˆå¯èƒ½å­˜å‚¨åœ¨æŸä¸ª store ä¸­ï¼‰ä¸­è·å–ä¿¡æ¯æ¥åšå‡ºå†³ç­–ã€‚

/todos/redux/thunks/createTodoIfNotExists.tsx

```tsx
// Interaction example
export function createTodoIfNotExists (text: string) {
  return (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }

    ...
    // Validate
    // Request
  }
}
```

Alternatively, here's a React Hooks & Apollo Client example.  
æˆ–è€…ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ª React Hooks & Apollo Client çš„ç¤ºä¾‹ã€‚

/models/useTodos.tsx

```tsx
function useTodos (todos) {

  const createTodoIfNotExists = (text: string) => {
    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
    
    ...
    // Validate
    // Request
  }

  return { createTodoIfNotExists }
}

// Container
function Main () {
  const { data: todos } = useQuery(GET_ALL_TODOS);
  const { createTodoIfNotExists } = useTodos(todos);

  ...
}
```

### å®ƒåŒ…å«æ‚¨åº”ç”¨ç¨‹åºçš„æ“ä½œ
It contains your application's operations

Some refer to this layer as **app logic**, which works as well because these are all of the *operations* of your app. The interaction layer contains the discrete set of `commands` and `queries` that your users will carry out. These are the *use cases*.  
æœ‰äº›äººå°†è¿™ä¸€å±‚ç§°ä¸ºåº”ç”¨é€»è¾‘ï¼Œè¿™æ ·ç§°å‘¼ä¹Ÿæ˜¯åˆé€‚çš„ï¼Œå› ä¸ºè¿™äº›æ­£æ˜¯ä½ çš„åº”ç”¨çš„æ‰€æœ‰æ“ä½œã€‚äº¤äº’å±‚åŒ…å«äº†ç”¨æˆ·å°†æ‰§è¡Œçš„ä¸€ç³»åˆ—ç¦»æ•£çš„ `commands` å’Œ `queries` ï¼Œè¿™å°±æ˜¯ç”¨ä¾‹ã€‚

Having great visibility into these [use cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) enables us to get pretty structured with our integration testing as well. We can functionally test every use case with edge cases using Given-When-Then style tests.  
æ·±å…¥äº†è§£è¿™äº›ç”¨ä¾‹ä½¿æˆ‘ä»¬èƒ½å¤Ÿéå¸¸ç³»ç»Ÿåœ°å¼€å±•é›†æˆæµ‹è¯•ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Given-When-Then é£æ ¼çš„æµ‹è¯•æ¥å¯¹æ¯ä¸ªç”¨ä¾‹è¿›è¡ŒåŠŸèƒ½æµ‹è¯•ï¼ŒåŒ…æ‹¬è¾¹ç¼˜æƒ…å†µã€‚

For example:ä¾‹å¦‚ï¼š

- *Given* no todos exist, *when* I perform `CreateTodo`, *then* I should see one todo.  
	å¦‚æœæ²¡æœ‰å¾…åŠäº‹é¡¹ï¼Œå½“æˆ‘æ‰§è¡Œ `CreateTodo` æ—¶ï¼Œæˆ‘åº”è¯¥çœ‹åˆ°ä¸€æ¡å¾…åŠäº‹é¡¹ã€‚
- *Given* I have 3 completed todos and 1 uncompleted one, *when* I perform `CompleteAllTodos`, *then* I should have 4 completed todos.  
	æ—¢ç„¶æˆ‘æœ‰ 3 ä¸ªå·²å®Œæˆçš„å¾…åŠäº‹é¡¹å’Œ 1 ä¸ªæœªå®Œæˆçš„ï¼Œå½“æˆ‘æ‰§è¡Œ `CompleteAllTodos` æ—¶ï¼Œæˆ‘åº”è¯¥æœ‰ 4 ä¸ªå·²å®Œæˆçš„å¾…åŠäº‹é¡¹ã€‚

If you're familiar with [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) concepts, this is the [Application Service](https://khalilstemmler.com/articles/software-design-architecture/domain-driven-design-vs-clean-architecture/#Application-Services) equivalent.  
å¦‚æœä½ ç†Ÿæ‚‰é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDomain-Driven Designï¼‰çš„æ¦‚å¿µï¼Œé‚£ä¹ˆè¿™å°±æ˜¯åº”ç”¨æœåŠ¡ï¼ˆApplication Serviceï¼‰çš„å¯¹åº”æ¦‚å¿µã€‚

### å…±äº«è¡Œä¸º
Shared behavior 

This behavior is written to be used by any component. It contains the rules for how shared state is allowed to change.  
æ­¤è¡Œä¸ºè¢«è®¾è®¡ä¸ºå¯ä¾›ä»»ä½•ç»„ä»¶ä½¿ç”¨ã€‚å®ƒåŒ…å«äº†å…±äº«çŠ¶æ€å…è®¸å¦‚ä½•å˜åŒ–çš„è§„åˆ™ã€‚

At this level, we're often handling concerns like `auth`, `logging`, or even more *domain-specific* things like `todos`, `users`, `calendar`, or even `chess`.  
åœ¨è¿™ä¸ªå±‚æ¬¡ä¸Šï¼Œæˆ‘ä»¬ç»å¸¸å¤„ç†åƒ `auth` ã€ `logging` è¿™æ ·çš„é—®é¢˜ï¼Œç”šè‡³æ›´ç‰¹å®šäºé¢†åŸŸçš„äº‹æƒ…ï¼Œæ¯”å¦‚ `todos` ã€ `users` ã€ `calendar` ï¼Œç”šè‡³ `chess` ã€‚

Consider an interaction-layer React hook that contained all your chess game logic.  
è€ƒè™‘ä¸€ä¸ªåŒ…å«æ‰€æœ‰æ£‹ç›˜æ¸¸æˆé€»è¾‘çš„äº¤äº’å±‚ React é’©å­ã€‚

/hooks/useChess.tsx

```jsx
function useChess (todosAPI: ITodosAPI) {
  ...
  return { 
   operations: { makeMove, isValidMove, ... },
   models: { board, players, currentTurn }
  }
}
```

Read " [Domain-Driven GraphQL Schema Design](https://khalilstemmler.com/articles/graphql/ddd/schema-design/) " for the principles and practices for how to use event Storming to discover the subdomains within your app.  
é˜…è¯»ã€Šé¢†åŸŸé©±åŠ¨ GraphQL æ–¹æ¡ˆè®¾è®¡ã€‹äº†è§£ä½¿ç”¨äº‹ä»¶é£æš´å‘ç°åº”ç”¨ä¸­å­åŸŸçš„åŸåˆ™å’Œå®è·µã€‚

### å®ç°æ¨¡å‹çš„å…¶å®ƒæ–¹æ³•
Other ways to implement the model

Though most React developers will be comfortable writing their application/interaction layer logic using something like React Hooks, there's tons of other ways to implement the model.  
å°½ç®¡å¤§å¤šæ•° React å¼€å‘è€…ä¼šä½¿ç”¨ React Hooks ä¹‹ç±»çš„å·¥å…·æ¥ç¼–å†™ä»–ä»¬çš„åº”ç”¨å±‚/äº¤äº’å±‚é€»è¾‘ï¼Œä½†å®ç°æ¨¡å‹çš„æ–¹æ³•è¿˜æœ‰å¾ˆå¤šã€‚

- If you like to think of your model as a state machine, the [xState library](https://xstate.js.org/docs/recipes/react.html#hooks) does this exceptionally well and provides capabilities for you to plug your model instance into a React hook.  
	å¦‚æœä½ æƒ³æŠŠä½ çš„æ¨¡å‹çœ‹ä½œæ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼ŒxState åº“åœ¨è¿™æ–¹é¢è¡¨ç°å¾—éå¸¸å‡ºè‰²ï¼Œå¹¶æä¾›äº†ä¸€ç§å°†ä½ çš„æ¨¡å‹å®ä¾‹æ¥å…¥ React é’©å­çš„èƒ½åŠ›ã€‚
- For those who want to try to model their interaction layer using plain vanilla JavaScript, the [pojo-observer library](https://github.com/xolvio/pojo-observer) takes advantage of the fact that every client-app is an implementation of the observer pattern. Separating your model code from React hooks, it also provides a way to notify React that the model changed so a re-render is necessary.  
	å¯¹äºé‚£äº›æƒ³è¦å°è¯•ä½¿ç”¨çº¯ JavaScript æ¥å»ºæ¨¡äº¤äº’å±‚çš„äººæ¥è¯´ï¼Œpojo-observer åº“åˆ©ç”¨äº†æ¯ä¸ªå®¢æˆ·ç«¯åº”ç”¨éƒ½æ˜¯è§‚å¯Ÿè€…æ¨¡å¼å®ç°è¿™ä¸€äº‹å®ã€‚å®ƒå°†ä½ çš„æ¨¡å‹ä»£ç ä¸ React é’©å­åˆ†ç¦»ï¼ŒåŒæ—¶ä¹Ÿæä¾›äº†ä¸€ç§é€šçŸ¥ React æ¨¡å‹å·²æ›´æ”¹çš„æ–¹å¼ï¼Œä»è€Œç¡®ä¿å¿…è¦çš„é‡æ–°æ¸²æŸ“ã€‚

Someone once asked me [if it's possible to do DDD in the front-end](https://khalilstemmler.com/articles/typescript-domain-driven-design/ddd-frontend/). Initially, I said *no*, but after sometime thinking about it, it *totally is*. While the true high-level policy will always live on the backend, the interaction layer is comparable to the Application and *possibly* Domain layer in DDD.  
æœ‰äººæ›¾é—®æˆ‘æ˜¯å¦å¯ä»¥åœ¨å‰ç«¯åš DDDã€‚èµ·åˆæˆ‘è¯´ä¸è¡Œï¼Œä½†ç»è¿‡ä¸€æ®µæ—¶é—´æ€è€ƒåï¼Œå®Œå…¨å¯ä»¥ã€‚è™½ç„¶çœŸæ­£çš„é«˜å±‚ç­–ç•¥å§‹ç»ˆå­˜åœ¨äºåç«¯ï¼Œä½†äº¤äº’å±‚ç›¸å½“äº DDD ä¸­çš„åº”ç”¨å±‚ï¼Œç”šè‡³å¯èƒ½æ˜¯é¢†åŸŸå±‚ã€‚

### é€šå¸¸æœ‰å‡ ä¸ªå±‚
There are usually several layers

Most of the time, your app will have several of these **application / interaction** layers.  
é€šå¸¸æƒ…å†µä¸‹ï¼Œä½ çš„åº”ç”¨å°†åŒ…å«å¤šä¸ªè¿™äº›åº”ç”¨/äº¤äº’å±‚ã€‚

Here are some more examples of interaction layers that are commonly built out.  
è¿™é‡Œæ˜¯ä¸€äº›å¸¸è§çš„äº¤äº’å±‚æ„å»ºç¤ºä¾‹ã€‚

- **Examples of other interaction layers  
	å…¶ä»–äº¤äº’å±‚ç¤ºä¾‹**
	- Auth layer â€” Extremely common. Check out the [useAuth](https://github.com/Swizec/useAuth) library which implements Auth0 authentication and authorization as a React hook.  
		è®¤è¯å±‚ â€” éå¸¸å¸¸è§ã€‚å¯ä»¥æŸ¥çœ‹ useAuth åº“ï¼Œå®ƒå°† Auth0 è®¤è¯å’Œæˆæƒå®ç°ä¸º React é’©å­ã€‚
	- Logging â€” Sometimes it's important to. Luckily, there are many tools out there that can do this for you, but if you needed to build one yourself, it would exist as an entirely separate layer within your model.  
		æ—¥å¿—è®°å½• â€” æœ‰æ—¶è¿™å¾ˆé‡è¦ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰è®¸å¤šå·¥å…·å¯ä»¥ä¸ºä½ å®Œæˆè¿™é¡¹å·¥ä½œï¼Œä½†å¦‚æœä½ éœ€è¦è‡ªå·±æ„å»ºä¸€ä¸ªï¼Œå®ƒå°†ä½œä¸ºæ¨¡å‹ä¸­çš„ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„å±‚å­˜åœ¨ã€‚
	- Real-time subscriptions â€” Let's say you're subscribed to a stream of data. When a chunk comes in, you need to process it, and perhaps act on a `switch` statement to figure out if you should invoke a `command`. Keep your code clean by delegating this responsibility to a layer.  
		å®æ—¶è®¢é˜… â€” å‡è®¾ä½ è®¢é˜…äº†ä¸€ä¸ªæ•°æ®æµã€‚å½“æ•°æ®å—åˆ°è¾¾æ—¶ï¼Œä½ éœ€è¦å¤„ç†å®ƒï¼Œå¹¶å¯èƒ½æ ¹æ® `switch` è¯­å¥å†³å®šæ˜¯å¦è°ƒç”¨ `command` ã€‚é€šè¿‡å°†è¿™ä¸€è´£ä»»å§”æ‰˜ç»™ä¸€ä¸ªå±‚ï¼Œæ¥ä¿æŒä½ çš„ä»£ç æ•´æ´ã€‚
	- Complex rendering logic â€” I once worked on a project that built out really complex call flows for call centers using Angular and D3. Hundreds of different node types could be dragged and dropped onto a surface. When dropped, the way they connected to each other and how they could be used depended on the rendering and application logic, each decoupled from each other.  
		å¤æ‚çš„æ¸²æŸ“é€»è¾‘â€”â€”æˆ‘æ›¾ç»å‚ä¸è¿‡ä¸€ä¸ªé¡¹ç›®ï¼Œè¯¥é¡¹ç›®ä½¿ç”¨ Angular å’Œ D3 ä¸ºå‘¼å«ä¸­å¿ƒæ„å»ºäº†éå¸¸å¤æ‚çš„å‘¼å«æµç¨‹ã€‚æ•°ç™¾ç§ä¸åŒçš„èŠ‚ç‚¹ç±»å‹å¯ä»¥è¢«æ‹–æ”¾åˆ°ä¸€ä¸ªè¡¨é¢ä¸Šã€‚å½“å®ƒä»¬è¢«æ”¾ç½®æ—¶ï¼Œå®ƒä»¬å½¼æ­¤è¿æ¥çš„æ–¹å¼ä»¥åŠå®ƒä»¬å¦‚ä½•è¢«ä½¿ç”¨å–å†³äºæ¸²æŸ“å’Œåº”ç”¨é€»è¾‘ï¼Œæ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯ç›¸äº’è§£è€¦çš„ã€‚
	- Metadata layer â€” Imagine building a multiplayer video game where new prizes and weapons come out every week. How can we prevent hard-coding weapons and prizes?  
		å…ƒæ•°æ®å±‚ â€” æƒ³è±¡ä¸€ä¸‹ï¼Œæ­£åœ¨å¼€å‘ä¸€æ¬¾å¤šäººè§†é¢‘æ¸¸æˆï¼Œæ¯å‘¨éƒ½ä¼šæ¨å‡ºæ–°çš„å¥–å“å’Œæ­¦å™¨ã€‚æˆ‘ä»¬å¦‚ä½•æ‰èƒ½é¿å…ç¡¬ç¼–ç æ­¦å™¨å’Œå¥–å“å‘¢ï¼Ÿ

If you're curious about what a large-scale version of this looks like, check out [Twilio's video-app example](https://github.com/twilio/twilio-video-app-react) built with React hooks and context for global state.  
å¦‚æœä½ æƒ³çŸ¥é“è¿™ä¸ªå¤§å‹ç‰ˆæœ¬çš„æ ·å­ï¼Œå¯ä»¥çœ‹çœ‹ Twilio ç”¨ React hooks å’Œä¸Šä¸‹æ–‡æ„å»ºçš„å…¨å±€çŠ¶æ€è§†é¢‘åº”ç”¨ç¤ºä¾‹ã€‚

## ç½‘ç»œä¸æ•°æ®è·å–ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
Networking & data fetching (infrastructure)

> Performing API calls and reporting metadata state  
> æ‰§è¡Œ API è°ƒç”¨å’ŒæŠ¥å‘Šå…ƒæ•°æ®çŠ¶æ€

The responsibilities of a networking and data fetching layer are to:  
ç½‘ç»œå’Œæ•°æ®è·å–å±‚çš„èŒè´£æ˜¯ï¼š

- Know where the backend service(s) are  
	çŸ¥é“åç«¯æœåŠ¡åœ¨å“ªé‡Œ
- Formulate responses åˆ¶å®šå›åº”
- Marshal response data or errors  
	å“åº”æ•°æ®æˆ–é”™è¯¯
- Report async statuses (isLoading)  
	æŠ¥å‘Šå¼‚æ­¥çŠ¶æ€ï¼ˆisLoadingï¼‰

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

Jed Watson describes the async states that tell you about the status of a network request as **meta state** â€” state *about* state.  
æ°å¾·Â·æ²ƒæ£®å°†æè¿°ç½‘ç»œè¯·æ±‚çŠ¶æ€çš„å¼‚æ­¥çŠ¶æ€ç§°ä¸ºå…ƒçŠ¶æ€â€”â€”å…³äºçŠ¶æ€çš„çŠ¶æ€ã€‚

For example, in Apollo Client, the `loading` variable we deconstruct from the query response is a form of meta state.  
ä¾‹å¦‚ï¼Œåœ¨ Apollo Client ä¸­ï¼Œæˆ‘ä»¬ä»æŸ¥è¯¢å“åº”ä¸­è§£æ„çš„ `loading` å˜é‡æ˜¯ä¸€ç§å…ƒçŠ¶æ€ã€‚

```tsx
const { data, loading, error } = useQuery(GET_ALL_TODOS);
```

With Apollo Client, that's handled for us. Though if we were to use a more barebones approach, like Axios and Redux, we'd have to write this signaling code ourselves within a Thunk.  
ä½¿ç”¨ Apollo Clientï¼Œè¿™äº›éƒ½è¢«æˆ‘ä»¬å¤„ç†äº†ã€‚ä½†å¦‚æœæˆ‘ä»¬è¦ä½¿ç”¨æ›´ç²¾ç®€çš„æ–¹æ³•ï¼Œæ¯”å¦‚ Axios å’Œ Reduxï¼Œæˆ‘ä»¬å°±å¿…é¡»åœ¨ Thunk ä¸­è‡ªå·±ç¼–å†™è¿™ä¸ªä¿¡ä»¤ä»£ç ã€‚

```tsx
export function createTodoIfNotExists (text: string) {
  return async (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
     
    // Signaling start
    dispatch({ type: actions.CREATING_TODO })

    try {
      const result = await todoAPI.create(...)
      
      // Signaling success
      dispatch({ type: actions.CREATING_TODO_SUCCESS, todo: result.data.todo })
    } catch (err) {
  
      // Signaling Failure
      dispatch({ type: actions.CREATING_TODO_FAILURE, error: err })
    }

  }
}
```

**Note**: The code example above is a demonstration of doing a little too much. Recall that a Redux Thunk is an interaction layer concern? That means it should *only* be responsible for the decision-making logic, and no *signalling* logic, since request signalling is a concern of the networking & data-fetching layer. It can be hard to establish these concrete boundaries sometimes. Especially if the library or framework wasn't designed with separation of concerns in mind.  
æ³¨æ„ï¼šä¸Šè¿°ä»£ç ç¤ºä¾‹æœ‰ç‚¹è¿‡äºå¤æ‚ã€‚å›æƒ³ä¸€ä¸‹ï¼ŒRedux Thunk æ˜¯ä¸€ä¸ªäº¤äº’å±‚çš„é—®é¢˜å—ï¼Ÿè¿™æ„å‘³ç€å®ƒåªåº”è¯¥è´Ÿè´£å†³ç­–é€»è¾‘ï¼Œè€Œä¸åº”åŒ…å«ä¿¡å·é€»è¾‘ï¼Œå› ä¸ºè¯·æ±‚ä¿¡å·æ˜¯ç½‘ç»œä¸æ•°æ®è·å–å±‚çš„é—®é¢˜ã€‚æœ‰æ—¶å€™å¾ˆéš¾æ˜ç¡®è¿™äº›å…·ä½“è¾¹ç•Œã€‚ç‰¹åˆ«æ˜¯å¦‚æœåº“æˆ–æ¡†æ¶åœ¨è®¾è®¡æ—¶æ²¡æœ‰è€ƒè™‘å…³æ³¨ç‚¹åˆ†ç¦»ã€‚

## çŠ¶æ€ç®¡ç† & å­˜å‚¨ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
State management & storage (infrastructure)

> Storage, updating data, reactivity  
> å­˜å‚¨ï¼Œæ›´æ–°æ•°æ®ï¼Œå“åº”æ€§

A state management library has *three* responsibilities:  
ä¸€ä¸ªçŠ¶æ€ç®¡ç†åº“æœ‰ä¸‰ä¸ªèŒè´£ï¼š

- **Storage** â€” Hold onto global state somewhere, usually in a store / client-side cache.  
	å­˜å‚¨ â€” å°†å…¨å±€çŠ¶æ€ä¿å­˜åœ¨æŸä¸ªåœ°æ–¹ï¼Œé€šå¸¸ä¿å­˜åœ¨ä¸€ä¸ªå­˜å‚¨åº“/å®¢æˆ·ç«¯ç¼“å­˜ä¸­ã€‚
- **Updating data** â€” Make changes to the data in the cache.  
	æ›´æ–°æ•°æ® â€” ä¿®æ”¹ç¼“å­˜ä¸­çš„æ•°æ®ã€‚
- **Reactivity** â€” Provide a way for view-layer presentation components to subscribe to data, and then re-render when data changes.  
	å“åº”æ€§ â€” æä¾›ä¸€ç§æ–¹å¼ï¼Œè®©è§†å›¾å±‚çš„å±•ç¤ºç»„ä»¶è®¢é˜…æ•°æ®ï¼Œå¹¶åœ¨æ•°æ®å˜åŒ–æ—¶é‡æ–°æ¸²æŸ“ã€‚

### çŠ¶æ€ç®¡ç†å’Œç½‘ç»œé€šå¸¸ä¸€èµ·è§£å†³
State management and networking are often solved together

State management is complex.  
çŠ¶æ€ç®¡ç†å¾ˆå¤æ‚ã€‚

Because it's complex, there are libraries out there to make life a little bit easier. Two of those libraries, Apollo Client and react-query, actually handle the *networking* part for you.  
å› ä¸ºå®ƒå¾ˆå¤æ‚ï¼Œæ‰€ä»¥æœ‰ä¸€äº›åº“å¯ä»¥ç®€åŒ–ç”Ÿæ´»ã€‚å…¶ä¸­ä¸¤ä¸ªåº“ï¼ŒApollo Client å’Œ react-queryï¼Œå®é™…ä¸Šä¼šä¸ºä½ å¤„ç†ç½‘ç»œéƒ¨åˆ†ã€‚

It can be preferable to choose a library instead of building out the state management machinery and *networking* layer manually.  
é€‰æ‹©ä¸€ä¸ªåº“è€Œä¸æ˜¯æ‰‹åŠ¨æ„å»ºçŠ¶æ€ç®¡ç†æœºåˆ¶å’Œç½‘ç»œå±‚å¯èƒ½æ›´å¯å–ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/f3bc522726fde79b7d01ed2718b52a9c_MD5.png]]

Apollo Client handles both the state management and data fetching concerns.  
Apollo Client å¤„ç†çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–çš„é—®é¢˜ã€‚

### å…±äº«å…¨å±€çŠ¶æ€
Shared global state 

Two types of state exist at this layer. They are:  
è¿™ä¸€å±‚å­˜åœ¨ä¸¤ç§çŠ¶æ€ã€‚å®ƒä»¬æ˜¯ï¼š

- `remote (global)` state â€” The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
	`remote (global)` çŠ¶æ€ â€” å­˜åœ¨äºæœåŠ¡ API èƒŒåçš„çŠ¶æ€ã€‚å½“æˆ‘ä»¬åˆ›å»º `queries` è¿œç¨‹çŠ¶æ€æ—¶ï¼Œæˆ‘ä»¬æŒæœ‰å…¶æœ¬åœ°å‰¯æœ¬ï¼Œå¯ä»¥ä»å…¨å±€èŒƒå›´å†…è®¿é—®ã€‚
- `shared (global)`: We said earlier, "as soon as some state belongs to more than one component, it's *shared* global state". And you'll know you need this when **two components that rely on the same state don't need to know about each other**. To be clear, this type of state can be live in the interaction layer (via hooks and context, for example). Though sometimes, when working with `remote(global) state`, it's preferable to have something act as a single source of truth, especially if you need to mix remote and local state.  
	`shared (global)`: æˆ‘ä»¬ä¹‹å‰è¯´è¿‡ï¼Œâ€œä¸€æ—¦æŸä¸ªçŠ¶æ€å±äºå¤šä¸ªç»„ä»¶ï¼Œå®ƒå°±æ˜¯å…±äº«çš„å…¨å±€çŠ¶æ€â€ã€‚å½“ä½ å‘ç°ä¾èµ–ç›¸åŒçŠ¶æ€çš„ä¸¤ä¸ªç»„ä»¶ä¸éœ€è¦ç›¸äº’äº†è§£æ—¶ï¼Œä½ å°±ä¼šçŸ¥é“éœ€è¦ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚ä¸ºäº†æ˜ç¡®èµ·è§ï¼Œè¿™ç§çŠ¶æ€å¯ä»¥å­˜åœ¨äºäº¤äº’å±‚ï¼ˆä¾‹å¦‚é€šè¿‡é’©å­å’Œä¸Šä¸‹æ–‡ï¼‰ã€‚ä¸è¿‡ï¼Œåœ¨å¤„ç† `remote(global) state` æ—¶ï¼Œæœ‰æ—¶æœ€å¥½æœ‰ä¸€ä¸ªå•ä¸€çš„äº‹å®æ¥æºï¼Œç‰¹åˆ«æ˜¯å½“ä½ éœ€è¦æ··åˆè¿œç¨‹å’Œæœ¬åœ°çŠ¶æ€æ—¶ã€‚

### è¿œç¨‹å’Œæœ¬åœ°çŠ¶æ€çš„æ··åˆ
Mixture of remote and local state

We often cache remote state in a client-side cache or store. Since we do that, it's reasonable to try to use the store as a single source of truth. Often, we'd like to add some client-only local variables or pieces of state to the store as well.  
æˆ‘ä»¬ç»å¸¸å°†è¿œç¨‹çŠ¶æ€ç¼“å­˜åˆ°å®¢æˆ·ç«¯ç¼“å­˜æˆ–å­˜å‚¨ä¸­ã€‚æ—¢ç„¶æˆ‘ä»¬å·²ç»è¿™æ ·åšäº†ï¼Œé‚£ä¹ˆå°†å­˜å‚¨ç”¨ä½œå•ä¸€äº‹å®æ¥æºæ˜¯åˆç†çš„ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬è¿˜æƒ³å°†ä¸€äº›ä»…å®¢æˆ·ç«¯çš„æœ¬åœ°å˜é‡æˆ–çŠ¶æ€ç‰‡æ®µæ·»åŠ åˆ°å­˜å‚¨ä¸­ã€‚

Here's a Redux example of adding an `isSelected` attribute to each of the `todos` before merging to the store.  
è¿™é‡Œæœ‰ä¸€ä¸ª Redux ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•åœ¨åˆå¹¶åˆ°å­˜å‚¨ä¹‹å‰ï¼Œä¸ºæ¯ä¸ª `todos` æ·»åŠ ä¸€ä¸ª `isSelected` å±æ€§ã€‚

```tsx
switch (action.type) {
  ...
  case actions.GET_TODOS_SUCCESS:
    return {
      ...state,
      // Add some local state to the remote state before merging it
      // to the store
      todos: action.todos.map((t) => { ...t, isSelected: false })
    }
}
```

And in Apollo Client 3, here's the equivalent with cache policies and reactive variables.  
åœ¨ Apollo Client 3 ä¸­ï¼Œä»¥ä¸‹æ˜¯ä½¿ç”¨ç¼“å­˜ç­–ç•¥å’Œå“åº”å¼å˜é‡çš„ç­‰æ•ˆæ–¹æ³•ã€‚

```jsx
import { InMemoryCache } from "@apollo/client";

export const cache: InMemoryCache = new InMemoryCache({
  typePolicies: {
    Todo: {
      fields: {
        isSelected: {
          read (value, opts) {
            const todoId = opts.readField('id');
            const isSelected = !!currentSelectedTodoIds()
              .find((id) => id === todoId)
              
            return isSelected;
          }
        }
      }
    }
  }
});

export const currentSelectedTodoIds = cache.makeVar<number[]>([]);
```

We can configure a way to request `remote` state and *client-only* `shared` local state in the same query.  
æˆ‘ä»¬å¯ä»¥é…ç½®ä¸€ç§æ–¹å¼ï¼Œåœ¨åŒä¸€æŸ¥è¯¢ä¸­è¯·æ±‚ `remote` çŠ¶æ€å’Œå®¢æˆ·ç«¯ä¸“ç”¨çš„ `shared` æœ¬åœ°çŠ¶æ€ã€‚

```tsx
export const GET_ALL_TODOS = gql\`
  query GetAllTodos {
    todos { 
      id  
      text  
      completed
      isSelected @client
    }
  }
\`
```

### å­˜å‚¨ç«‹é¢
Storage facades 

Most of the time we don't provide direct access to whats stored within the *store*. Usually, there's some *facade*, an API, that sits in-front of the data and provides ways for us to interact with it.  
å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬ä¸ä¼šç›´æ¥æä¾›å¯¹å­˜å‚¨åœ¨å­˜å‚¨ä¸­çš„å†…å®¹çš„è®¿é—®ã€‚é€šå¸¸ï¼Œä¼šæœ‰ä¸€ä¸ªå¤–è§‚æ¨¡å¼ï¼ˆfacadeï¼‰ï¼Œå³ APIï¼Œå®ƒä½äºæ•°æ®å‰é¢ï¼Œä¸ºæˆ‘ä»¬æä¾›ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ã€‚

In Redux, this is `dispatch` (for updates) and connect (for reactivity).  
åœ¨ Redux ä¸­ï¼Œè¿™æ˜¯ `dispatch` ï¼ˆç”¨äºæ›´æ–°ï¼‰å’Œ connectï¼ˆç”¨äºå“åº”å¼ï¼‰ã€‚

In Apollo Client, this is `useMutation` (for updates) and `useQuery` (for reactivity).  
åœ¨ Apollo Client ä¸­ï¼Œè¿™æ˜¯ `useMutation` ï¼ˆç”¨äºæ›´æ–°ï¼‰å’Œ `useQuery` ï¼ˆç”¨äºå“åº”å¼ï¼‰ã€‚

Even SQL is a form of a storage facade. It's a powerful pattern.  
å³ä½¿æ˜¯ SQL ä¹Ÿæ˜¯ä¸€ç§å­˜å‚¨å¤–è§‚æ¨¡å¼ã€‚è¿™æ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ¨¡å¼ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/f986e1537c231dfadb646c93c6acf8b9_MD5.png]]

---

