---
title: "III. Layers | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/client-side-architecture/layers/"
author:
  - "[[Khalil Stemmler]]"
published: 2020-06-24
created: 2025-10-07
description: "Advanced TypeScript & Node.js guides for large-scale applications. Learn to write flexible, maintainable TypeScript."
tags:
  - "clippings"
---
[Welcome](https://khalilstemmler.com/articles/client-side-architecture/introduction) [I. Architecture](https://khalilstemmler.com/articles/client-side-architecture/architecture) [II. Principles](https://khalilstemmler.com/articles/client-side-architecture/principles) [III. Layers](https://khalilstemmler.com/articles/client-side-architecture/layers) [IV. Conclusion](https://khalilstemmler.com/articles/client-side-architecture/conclusion)  
欢迎 I. 架构 II. 原则 III. 层级 IV. 结论

  
展示组件 UI 逻辑 容器/控制器组件 交互层 网络与数据获取

Last updated Jun 24th, 2020  
最后更新于 2020 年 6 月 24 日

![[_posts/architect/_教程/Client-Side Architecture Basics/media/7a6cfed60379bca03b1f4d0912259531_MD5.png]]

> This is page three of a guide on Client-Side Architecture basics. Start at [page one](https://khalilstemmler.com/articles/client-side-architecture/introduction).  
> 这是关于客户端架构基础指南的第三页。从第一页开始。

## 分层与关注点
Layers and concerns 

We're finally ready to decompose each part of Model-View-Presenter, especially the *model* part.  
我们终于准备好*分解 Model-View-Presenter 的每个部分，尤其是模型部分*。

Here's a graphic to illustrate that decomposition into something more concrete.  
这是一张图，用来说明分解为更具体的东西。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/e5138906bb8c7d37898dc6f6ab45197b_MD5.png]]

Can you see both CQS and SoC in here?  
你能在这里看到 CQS 和 SoC 吗？

Let's examine it from the top.  
让我们*从顶部开始分析*。

## 展示组件
Presentation components 

> Render the UI and create user events  
> 渲染 UI 并创建用户事件

If you read the title and feel like closing the tab because of *[this article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)* by Dan Abramov, hang in there. Just wait until we get to container components to decide if you want to bounce 🏀.  
如果你看了标题，因为 Dan Abramov 的文章就想关闭标签页，请再等等。等到我们讲到容器组件时，再决定你是否想跳投🏀。

Presentation components live within the boundaries of the *View* portion of Model-View-Presenter. Their entire purpose is to:  
*展示组件存在于 Model-View-Presenter 的 View 部分*边界内。它们全部的目的是：

- Display data in the UI  
	**在 UI 中显示数据**
- Generate user events (from keypresses, button clicks, hover states, etc)  
	**生成用户事件**（来自按键、按钮点击、悬停状态等）

### 展示组件是实现细节
Presentation components are an implementation detail

An implementation detail is a low-level detail that helps us accomplish our *main* goal. But they're not our *main* goal. If our *main* goal is to hook up the *Add Todo* feature, the buttons, styling, and text in the UI is an implementation detail in realizing the feature.  
实现细节是帮助我们达成主要目标的低级细节。但它们并非我们的主要目标。*如果我们的主要目标是实现“添加待办事项”功能，那么用户界面中的按钮、样式和文本就是实现该功能时的实现细节*。

### 展示组件可能是易变的
Presentation components can be volatile

Anything subject to frequent change is said to be *volatile*. Us constantly changing the look and feel of components is what makes them so.  
任何容易频繁变化的事物都被称为“易变的”。我们*不断改变组件的外观和风格，这正是导致它们易变的原因*。

One way to accommodate this phenomenon is to decide on a **[stable](https://khalilstemmler.com/wiki/stable-dependency-principle/)** set of reusable components (that either you wrote or grabbed from a component library), then create your views from those.  
*应对这种现象的一种方法是确定一套稳定的可重用组件*（这些组件要么是你自己编写的，要么是从组件库中获取的），*然后用这些组件创建你的视图*。

Even though we could use reusable components, data requirements change frequently.  
*尽管我们可以使用可重用组件，但数据需求经常变化*。

Take this simple `CardDescription` component that uses a GraphQL query to describe a card.  
以这个简单的 `CardDescription` 组件为例，它使用 GraphQL 查询来描述一个卡片。

```tsx
const CARD_DESCRIPTION_QUERY = gql\`
  query CardDescription($cardId: ID!) {
    card(id: $cardId) {
      description
    }
  }
\`;

const CardDescription = ({ cardId }) => {
  const { data, loading } = useQuery({ 
    query: CARD_DESCRIPTION_QUERY, 
    variables: { cardId }
  });

  if (loading) {
    return null;
  }

  return <span>{data.card.description}</span>
}
```

How likely is it that we'd need to change the styling? What about displaying something like a `lastChanged` date beside it? Chances are we pretty likely.  
我们可能需要更改样式吗？比如在旁边显示一个 `lastChanged` 日期？可能性很大。

### 应该在展示组件中包含 GraphQL 查询吗？
Should we include GraphQL queries in our presentation components?

It's good to have GraphQL queries **as close to the presentational component as possible**. Queries define the data requirements. And since they'll likely need to be changed together if the requirements change, having them close together reduces unnecessary cognitive load accrued by flipping back and forth between files.
让GraphQL查询尽可能靠近展示组件是很好的做法。查询定义了数据需求。而且，由于如果需求发生变化，它们很可能需要一起修改，将它们放在一起可以减少在文件之间来回切换所带来的不必要的认知负担。

One potential _downside_ to putting your queries in your components is that now, if you ever wanted to switch away from GraphQL, your components aren't pure— they're coupled to GraphQL. If you wanted to switch transport-layer technologies, you'd have to refactor every component.
**在组件中放入查询的一个潜在缺点**是，如果你想不再使用GraphQL，这些组件就不再是纯组件了——*它们与GraphQL耦合在一起*。如果你想更换传输层技术，就必须重构每个组件。

Another potential downside is that to test these components, you'd need to make sure they're wrapped in a [mocked Apollo Client provider](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider).
**另一个潜在的缺点**是，要测试这些组件，你需要确保它们被包裹在一个[模拟的Apollo Client提供程序](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider)中。

My recommendation is to couple the queries to the components anyways. What you gain in an incredible developer experience is, in my opinion, worth the risk of going fully in with GraphQL and deciding you want to change later down the road.
我的建议是无论如何都要将查询与组件关联起来。在我看来，你在卓越的开发者体验方面所获得的收益，值得冒完全采用GraphQL的风险，即便之后你可能会决定做出改变。

**Note on query performance**: It's ok to have lots of queries for super-specific chunks of data like shown above. Using Apollo Client, Apollo handles that complicated logic of checking whether the data is cached already, and if not — it makes a request to get it.
**关于查询性能的说明**：像上面所示的那样，对超特定的数据块进行大量查询是没问题的。使用Apollo Client时，Apollo会处理复杂的逻辑，检查数据是否已被缓存，如果没有，则会发出请求来获取数据。

### 在展示组件中要测试什么
What to test in presentation components

Unit testing implementation details is typically fruitless — especially for volatile things. It doesn't do us much good testing to see if a button is blue or green. Instead, when testing presentation components, we want to test against UI logic.
*对实现细节进行单元测试通常是徒劳的*——尤其是对于易变的内容。测试按钮是蓝色还是绿色对我们没什么帮助。相反，在测试展示组件时，我们希望*针对UI逻辑进行测试*。

To demonstrate what I mean, here's a bland, basic presentation component.
为了说明我的意思，这里有一个平淡、基础的展示组件。

```tsx
// /components/Todo.tsx
export const Todo = (props) => (
  <div className="todo">
    <div class="todo-text">{props.text}</div>
    <button onClick={props.onDeleteTodo}>Delete</button>
  </div>
)
```

There's no UI logic involved here. It merely takes in props, hooks up callbacks, and renders some HTML.这里*不涉及任何用户界面逻辑*。它只是接收属性、连接回调函数并渲染一些HTML。

Here's _another_ example of the same component, but this time, as a class-based component with **UI logic.**
这是同一个组件的另一个示例，但这次是作为*带有UI逻辑的基于类的组件*。

```tsx
// /components/Todo.tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'

type Props = any;

export default class Todo extends Component<Props, Props> {
  static propTypes = {
    todo: PropTypes.object.isRequired,
    editTodo: PropTypes.func.isRequired,
    deleteTodo: PropTypes.func.isRequired,
    completeTodo: PropTypes.func.isRequired
  }

  state = {
    editing: false
  }

  handleDoubleClick = () => {
    this.setState({ editing: true })
  }

  handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      this.props.deleteTodo(id)
    } else {
      this.props.editTodo(id, text)
    }
    this.setState({ editing: false })
  }

  render() {
    const { todo, completeTodo, deleteTodo } = this.props

    return this.state.editing ? (
      <TodoTextInput 
          text={todo.text}
          editing={this.state.editing}
          onSave={(text: string) => this.handleSave(todo.id, text)} />
    ) : (
      <div className="view">
        <input 
           className="toggle"
           type="checkbox"
           checked={todo.completed}
           onChange={() => completeTodo(todo.id)} />
        <label onDoubleClick={this.handleDoubleClick}>
          {todo.text}
        </label>
        <button 
          className="destroy"
          onClick={() => deleteTodo(todo.id)} />
      </div>
    )
  }
}
```

## UI 逻辑
UI logic 

> View behavior & local component state  
> View行为与本地组件状态

The main difference between the two previously shown `Todo` components is that the second `Todo` component contained UI logic where the first did not.  
之前展示的两个`Todo`组件之间的主要区别在于，*第二个`Todo`组件包含了UI逻辑，而第一个则没有*。
### UI 逻辑就是视图行为（事件处理函数、条件渲染）
UI logic is view behavior

![[_posts/architect/_教程/Client-Side Architecture Basics/media/58c6dfdefd8c3d968ceea2fd157f1518_MD5.png]]

"If you're logged in, show _this_ — otherwise, show _this_."
“如果已登录，显示_这个_——否则，显示_这个_。”

"If you're this type of user, show _this_ — otherwise, show _this_."
“如果你是这类用户，就显示_这个_——否则，就显示_这个_。”

"Depending on which page you're on in the signup process, show the correct form".
“根据你在注册流程中所处的页面，显示正确的表单。”

A component has UI logic when it exudes behavior. Conditionals that determine _what to show_, or _when certain user events get called over others_ **are a form of view behavior (UI logic)**.
组件在展现行为时具有UI逻辑。决定要显示什么的**条件判断**，或者某些用户事件优先于其他事件被调用的情况，**都是视图行为（UI逻辑）的一种形式**。

Here's a conditional example from the previous code sample **determining what to show**.
以下是前一个代码示例中的条件示例，用于**确定要显示的内容**。

```tsx
return this.state.editing ? (
    <TodoTextInput 
        text={todo.text}
        editing={this.state.editing}
        onSave={(text: string) => this.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
         className="toggle"
         type="checkbox"
         checked={todo.completed}
         onChange={() => completeTodo(todo.id)} />
      <label onDoubleClick={this.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => deleteTodo(todo.id)} />
    </div>
  )
```

Here's a conditional **determining which user event to create**.  
这里是一个**决定创建哪个用户事件的条件**。

```tsx
handleSave = (id: number, text: string) => {
  if (text.length === 0) {
    this.props.deleteTodo(id)
  } else {
    this.props.editTodo(id, text)
  }
  this.setState({ editing: false })
}
```

### 组件 / 本地状态
Component / local state

This is where the *first* type of state we might encounter: `local (component)` state.  
这就是我们可能遇到的**第一种状态**： `local (component)` 状态。

In [Jed Watson](https://twitter.com/JedWatson) 's talk from GraphQL Summit 2019 titled, " [A Treatise on State](https://www.youtube.com/watch?v=tBz3UmZG_bk&feature=emb_title) ", he describes five different types of state when building web apps: `local (component)`, `shared (global)`, `remote (global)`, `meta`, and `router`.  
在 Jed Watson 于 2019 年 GraphQL Summit 上的演讲《关于状态的小册子》中，他描述了在构建 Web 应用时涉及到的**五种不同类型的状态**： `local (component)` 、 `shared (global)` 、 `remote (global)` 、 `meta 元数据` 和 `router 路由` 。

- **Explanations of the five types of state  
	五种状态类型的解释**
	- `local (component)`: State that belongs to a single component. Can also be thought about as UI state. UI state can be extracted from a presentation component into a React hook. **Note: we're about to do this**.  
		`local (component)`: 属于**单个组件的状态**。也可以看作是`UI状态`。UI状态可以**从展示组件中提取到React钩子中**。注意：我们即将这样做。
	- `shared (global)`: As soon as some state belongs to more than one component, it's *shared* global state. Components shouldn't need to know about each other (a header shouldn't need to know about a todo).  
		`shared (global)`: 一旦某些状态**属于多个组件**，它就是*共享的全局状态*。组件之间无需相互了解（header无需了解待办事项）。
	- `remote (global)`: The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
		`remote (global)`: **存在于服务中API背后的状态**。*当我们对远程状态进行`queries`时，我们会保留其本地副本，该副本可从全局作用域访问*。
	- `meta`: Meta state refers to state *about* state. The best example of this is the `loading` async states that tell us the progress of our network requests.  
		`meta`: 元状态指的是**关于状态的状态**。最好的例子是 *`loading`的异步状态，它会告诉我们网络请求的进度*。
	- and `router` state: The current URL of the browser.  
		并且 `router` 状态：**浏览器当前的 URL**。

This state, `local (component)` state, belongs to a single component. You can call this UI state. It's meant to hold onto data that helps a single component do its job.
这种状态，即`local (component)`状态，属于单个组件。你可以称其为`UI状态`。它旨在**保存有助于单个组件完成其工作的*数据***。

To better see what it looks like, let's extract all UI state from this class-based component and refactor to a functional component and a React hook.
为了更清楚地了解它的样子，让我们*从这个基于类的组件中提取所有UI状态，并重构为一个函数组件和一个React钩子*。

```tsx
// /components/Todo.tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'
import { useState } from 'react'

/**
 * Decompose the UI logic from the presentational component
 * and store it in a React hook.
 *
 * All data and operations in this hook are UI logic for the
 * component - we've just separated concerns, that's all.
 */

function useTodoComponent (actions) {
  // "editing" is a form of local (component) state
  const [editing, setEditing] = useState(false);

  const handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      actions.deleteTodo(id)
    } else {
      actions.editTodo(id, text)
    }
    setEditing(true);
  }

  const handleDoubleClick = () => {
    setEditing(true);
  }

  return { 
    models: { editing }, 
    operations: { handleSave, handleDoubleClick } 
  }
}

/**
 * This component relies on some local state, but none of 
 * it lives within the component, which is purely 
 * presentational.
 */

export function Todo (props) {
  const { todo, actions } = props;
  
  // Grab our local (component) state and access to other UI logic
  const { models, operations } = useTodoComponent(actions);
  
  // Conditional UI logic
  return models.editing ? (
    <TodoTextInput 
      text={todo.text}
      editing={models.editing}
      onSave={(text: string) => operations.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
        className="toggle"
        type="checkbox"
        checked={todo.completed}
        onChange={() => actions.completeTodo(todo.id)} />
      <label onDoubleClick={operations.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => actions.deleteTodo(todo.id)} />
    </div>
  )
}
```

### UI逻辑是我们在组件中实际要测试的内容
UI logic is what we actually try to test within components

Since UI logic is behavior, _this_ is actually what we want to test against in our integration tests. The behavior. You _could_ write unit tests as well, but it might be trivial if component logic is straightforward. It could be more worthwhile and give you more confidence that the feature is working correctly to integration test both the component and the UI logic together.
由于用户界面逻辑属于行为范畴，*这实际上正是我们在集成测试中想要测试的内容——即行为*。你也可以编写单元测试，但如果组件逻辑简单直接，单元测试可能就没什么必要了。*将组件和用户界面逻辑一起进行集成测试，可能更有价值，也能让你更有信心确定该功能运行正常*。

## 容器/控制器
Container/controller 

> The glue layer (pages)  
> 粘合层（页面）

Traditionally, the responsibilities of a container component were to:  
**传统上，容器组件的职责**是：

- Consume user events & pass them to the model  
	接收用户事件并将其传递给模型
- Subscribe to data changes (reactivity) and keep the view updated  
	订阅数据变化（响应性）并保持视图更新

![[_posts/architect/_教程/Client-Side Architecture Basics/media/b2b86e61c87686226d1945c0400cc986_MD5.png]]

This isn't new. The definition of a *controller/presenter,* all the way back from the *Model-View-Presenter* pattern, made this distinction.  
这并非新鲜事。早在“模型-视图-呈现器”（Model-View-Presenter）模式中，“控制器/呈现器”（controller/presenter）的定义就已经做了这种区分。

### 我们真的需要容器组件吗？
Do we really need container components?

In 2019, with the advent of React hooks, [Dan said we don't](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).  
2019 年，随着 React hooks 的推出，*Dan 说过我们不需要*。

> The main reason I found \[container components\] useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division.  
> 我发现【容器组件】有用的主要原因是，它能让我*将复杂的有状态逻辑与组件的其他方面分离开来*。而*Hooks让我无需进行这种随意的划分就能实现同样的效果*。

Here are my thoughts. 
以下是我的想法。

I fully agree that complex stateful logic **shouldn't live within presentation components**. When we do that, we don't get the ability to reuse logic across different components.
我完全同意，**复杂的有状态逻辑不应该存在于展示组件中**。如果我们那样做，**就无法在不同组件之间复用逻辑**。

Now, as for stateful logic in _container components_? I don't believe it _ever should have been in 'em._
至于容器组件中的有状态逻辑，我认为它根本就不应该存在于其中。

Previously, React developers were advised to put data and behavior in container components and write code that determined "how things work". That breaks the rules of what was said to be the responsibility of a container/presenter.
*以前，React开发者被建议将数据和行为放在容器组件中*，并编写用于确定“事物如何运作”的代码。这违背了所谓的容器/展示组件的职责规则。

Just because we know to put stateful data and behavior in React Hooks, it **doesn't mean we removed the problems a container component solves**.
仅仅因为我们知道要将有状态数据和行为放入React Hooks中，这**并不意味着我们消除了容器组件所能解决的问题**。

We _still_ need to configure _reactivity_, sometimes using Redux, sometimes using Apollo Client or something else, and we _still_ need some construct to **act as the glue, knowing which components to load up for the features we enable on a page**.
我们仍然需要配置响应性，有时使用Redux，有时使用Apollo Client或其他工具，而且我们仍然需要一些结构来起到粘合作用，知晓为页面上启用的功能加载哪些组件。

### 容器组件是页面组件
Container components are pages

In the following React Router example, we have three main *pages:* home, about, and dashboard.  
在以下 React Router 示例中，我们有*三个主要页面*：主页、关于页和仪表盘页。

```tsx
// src/App.js
export default function App () {
  return (
    <Router>
        <Switch>
          <Route exact path="/"> 
            <Home />
          </Route>
          <Route path="/about">
            <About />
          </Route>
          <Route path="/dashboard">
            <Dashboard />
          </Route>
        </Switch>
    </Router>
  );
}
```

Each page:每页：

- is responsible for enable a variable number of features (remember, a feature is a `command` or `query`)  
	*负责启用数量可变的功能*（请记住，功能是指`command`或`query`）
- has a variable number of presentational components within it, and  
	其中*包含数量不定的展示组件*，并且
- knows about `shared` reactive state, and *sometimes* connects it to presentational components that need it  
	了解`shared`响应式状态，并且_有时_会将其连接到需要它的展示组件

Container components are the top-level modules that turn on all the features for a particular page. In Gatsby.js, we call them _Page components_. Since all client architectures naturally evolve from this Model-View-Presenter pattern, it's unlikely we'll **get rid of the presenter (container) entirely**.
`容器组件`是*启用特定页面所有功能的顶级模块*。在Gatsby.js中，我们称它们为`页面组件`。*由于所有客户端架构自然都从这种模型-视图-呈现器模式演变而来*，因此我们不太可能**完全摒弃呈现器（容器）**。

To demonstrate my point, here's a _container component_ in a React hooks world. It might not look like much, but notice that **it fulfills the two responsibilities of a container component**.
为了说明我的观点，*以下是React Hooks环境中的一个_容器组件_*。它可能看起来没什么特别，但请注意，**它履行了容器组件的两项职责**。
```tsx
// /modules/home/Home.container.tsx
import React from 'react'
import MainSection from '../components/MainSection'
import { useQuery } from '@apollo/client'
import { VisiblityFilter } from '../models/VisibilityFilter'
import { Todos } from '../models/Todos'
import { GET_ALL_TODOS } from '../operations/queries/getAllTodos'
import { GET_VISIBILITY_FILTER } from '../operations/queries/getVisibilityFilter'
import { todoMutations } from '../operations/mutations'

const todosAPI = new TodosAPI();

export default function Home () {
  // Shared (global) or remote (global) state.
  const { operations, models } = useTodos(todosAPI);
  const { 
    completeAllTodos, 
    setVisibilityFilter, 
    clearCompletedTodos 
  } = operations;

  return (
    <Layout>
      <MainSection
        // Pass data to components
        activeVisibilityFilter={visibilityFilter}
        todosCount={models.todos.length}
        completedCount={models.todos.filter(t => t.completed).length}
        
        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
      />
      <ReportSection 
        // Pass data to components
        todos={models.todos}

        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
       />
    </Layout>
  );
};
```

**_Something_ is responsible for knowing how to connect to a reactive model, and knowing what to do with events that come from presentation components. That's a container.
某个事物负责了解如何连接到反应式模型，以及知道如何处理来自展示组件的事件。这就是容器。**

Of course, you could call everything a _component,_ but then the explicit communication and delineation of responsibilities we're fighting for is lost.
当然，你可以把所有东西都称为_组件_，但这样一来，我们所追求的通信和责任划分就不复存在了。

### 容器组件不包含任何功能
Container components contain no functionality

The container component is pretty bare. That's a good thing. They're not supposed to contain any functionality. They're not worthy of unit testing. They're just meant to stitch things together. However, if you want to do an integration test all features of a page, just load up the container component and have at 'er.
容器组件相当简洁。这是件好事。它们本*不应包含任何功能*。它们*不值得进行单元测试*。**它们只是用来将各种东西组合在一起的**。不过，如果你想对一个页面的所有功能进行集成测试，只需加载容器组件并对其进行测试即可。

## 交互层
Interaction layer 

> Model behavior 模型行为

We're finally in the most challenging part of a client-side architecture: the _model_.
我们终于来到了客户端**架构中最具挑战性的部分**：_模型_。

The first layer of the model, which is what gets called from the container component, is the **interaction layer**.
模型的第一层是交互层，它是从容器组件中调用的部分。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

### 交互层是模型的行为
The interaction layer is the behavior of the model

When you click submit to "_add a todo"_, do you jump straight to the GraphQL `mutation` right away? Do you perform any validation logic? Are there any rules to enforce?
当你点击提交以“_添加待办事项_”时，是否会直接跳转到GraphQL `mutation`？你会执行任何验证逻辑吗？有任何需要执行的规则吗？

A lot of times, there _aren't_ any rules. Sometimes we can't be bothered and we leave validation logic as something the _server_ handles. This is particularly common on simple dashboard apps. These apps have pretty much **no rules to enforce**, so an interaction layer doesn't exist.
很多时候，并没有什么规则可言。有时我们懒得去管，*会把验证逻辑留给服务器处理*。这在简单的仪表盘应用中尤为常见。*这些应用几乎没有什么规则需要执行，因此也就不存在交互层*。

It goes controller → network request.
Or as we've been doing for a long time, presentation component → network request.
When there **is** policy to enforce, it's time to think about carving out an interaction layer.
*流程是控制器→网络请求（不存在交互层）*
或者就像我们长期以来所做的那样，展示组件→网络请求。
*当有策略需要执行时，就该考虑构建一个交互层了*。

### 交互层是决策层
The interaction layer is the decision-making layer

**Application (or interaction) logic** is the logic that makes a decision as to what happens next.
**应用（或交互）逻辑**是决定接下来会发生什么的逻辑。

Let's say you have a `command` called `createTodoIfNotExists`. Whatever construct is responsible for the interaction layer contains the code that helps you decide, "should we follow through with this"?假设你有一个名为`createTodoIfNotExists`的`command`。负责交互层的任何结构都包含有助于你决定“我们是否应该执行这个操作”的代码。

Here's a [Redux Thunk](https://github.com/reduxjs/redux-thunk) example, where sometimes, we need to reach into some form of `global` state (maybe cached in a store) to make a decision.以下是一个[Redux Thunk](https://github.com/reduxjs/redux-thunk)示例，在这个示例中，我们有时需要访问某种形式的`global`状态（可能缓存在存储中）来做出决策。

```tsx
// /todos/redux/thunks/createTodoIfNotExists.tsx

// Interaction example
export function createTodoIfNotExists (text: string) {
  return (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }

    ...
    // Validate
    // Request
  }
}
```

Alternatively, here's a React Hooks & Apollo Client example.  
或者，这里有一个 React Hooks & Apollo Client 的示例。

/models/useTodos.tsx

```tsx
function useTodos (todos) {

  const createTodoIfNotExists = (text: string) => {
    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
    
    ...
    // Validate
    // Request
  }

  return { createTodoIfNotExists }
}

// Container
function Main () {
  const { data: todos } = useQuery(GET_ALL_TODOS);
  const { createTodoIfNotExists } = useTodos(todos);

  ...
}
```

### 它包含您应用程序的操作
It contains your application's operations

Some refer to this layer as **app logic**, which works as well because these are all of the *operations* of your app. The interaction layer contains the discrete set of `commands` and `queries` that your users will carry out. These are the *use cases*.  
有些人将这一层称为应用逻辑，这样称呼也是合适的，因为这些正是你的应用的所有操作。交互层包含了用户将执行的一系列离散的 `commands` 和 `queries` ，这就是用例。

Having great visibility into these [use cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) enables us to get pretty structured with our integration testing as well. We can functionally test every use case with edge cases using Given-When-Then style tests.  
深入了解这些用例使我们能够非常系统地开展集成测试。我们可以使用 Given-When-Then 风格的测试来对每个用例进行功能测试，包括边缘情况。

For example:例如：

- *Given* no todos exist, *when* I perform `CreateTodo`, *then* I should see one todo.  
	如果没有待办事项，当我执行 `CreateTodo` 时，我应该看到一条待办事项。
- *Given* I have 3 completed todos and 1 uncompleted one, *when* I perform `CompleteAllTodos`, *then* I should have 4 completed todos.  
	既然我有 3 个已完成的待办事项和 1 个未完成的，当我执行 `CompleteAllTodos` 时，我应该有 4 个已完成的待办事项。

If you're familiar with [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) concepts, this is the [Application Service](https://khalilstemmler.com/articles/software-design-architecture/domain-driven-design-vs-clean-architecture/#Application-Services) equivalent.  
如果你熟悉领域驱动设计（Domain-Driven Design）的概念，那么这就是应用服务（Application Service）的对应概念。

### 共享行为
Shared behavior 

This behavior is written to be used by any component. It contains the rules for how shared state is allowed to change.  
此行为被设计为可供任何组件使用。它包含了共享状态允许如何变化的规则。

At this level, we're often handling concerns like `auth`, `logging`, or even more *domain-specific* things like `todos`, `users`, `calendar`, or even `chess`.  
在这个层次上，我们经常处理像 `auth` 、 `logging` 这样的问题，甚至更特定于领域的事情，比如 `todos` 、 `users` 、 `calendar` ，甚至 `chess` 。

Consider an interaction-layer React hook that contained all your chess game logic.  
考虑一个包含所有棋盘游戏逻辑的交互层 React 钩子。

/hooks/useChess.tsx

```jsx
function useChess (todosAPI: ITodosAPI) {
  ...
  return { 
   operations: { makeMove, isValidMove, ... },
   models: { board, players, currentTurn }
  }
}
```

Read " [Domain-Driven GraphQL Schema Design](https://khalilstemmler.com/articles/graphql/ddd/schema-design/) " for the principles and practices for how to use event Storming to discover the subdomains within your app.  
阅读《领域驱动 GraphQL 方案设计》了解使用事件风暴发现应用中子域的原则和实践。

### 实现模型的其它方法
Other ways to implement the model

Though most React developers will be comfortable writing their application/interaction layer logic using something like React Hooks, there's tons of other ways to implement the model.  
尽管大多数 React 开发者会使用 React Hooks 之类的工具来编写他们的应用层/交互层逻辑，但实现模型的方法还有很多。

- If you like to think of your model as a state machine, the [xState library](https://xstate.js.org/docs/recipes/react.html#hooks) does this exceptionally well and provides capabilities for you to plug your model instance into a React hook.  
	如果你想把你的模型看作是一个状态机，xState 库在这方面表现得非常出色，并提供了一种将你的模型实例接入 React 钩子的能力。
- For those who want to try to model their interaction layer using plain vanilla JavaScript, the [pojo-observer library](https://github.com/xolvio/pojo-observer) takes advantage of the fact that every client-app is an implementation of the observer pattern. Separating your model code from React hooks, it also provides a way to notify React that the model changed so a re-render is necessary.  
	对于那些想要尝试使用纯 JavaScript 来建模交互层的人来说，pojo-observer 库利用了每个客户端应用都是观察者模式实现这一事实。它将你的模型代码与 React 钩子分离，同时也提供了一种通知 React 模型已更改的方式，从而确保必要的重新渲染。

Someone once asked me [if it's possible to do DDD in the front-end](https://khalilstemmler.com/articles/typescript-domain-driven-design/ddd-frontend/). Initially, I said *no*, but after sometime thinking about it, it *totally is*. While the true high-level policy will always live on the backend, the interaction layer is comparable to the Application and *possibly* Domain layer in DDD.  
有人曾问我是否可以在前端做 DDD。起初我说不行，但经过一段时间思考后，完全可以。虽然真正的高层策略始终存在于后端，但交互层相当于 DDD 中的应用层，甚至可能是领域层。

### 通常有几个层
There are usually several layers

Most of the time, your app will have several of these **application / interaction** layers.  
通常情况下，你的应用将包含多个这些应用/交互层。

Here are some more examples of interaction layers that are commonly built out.  
这里是一些常见的交互层构建示例。

- **Examples of other interaction layers  
	其他交互层示例**
	- Auth layer — Extremely common. Check out the [useAuth](https://github.com/Swizec/useAuth) library which implements Auth0 authentication and authorization as a React hook.  
		认证层 — 非常常见。可以查看 useAuth 库，它将 Auth0 认证和授权实现为 React 钩子。
	- Logging — Sometimes it's important to. Luckily, there are many tools out there that can do this for you, but if you needed to build one yourself, it would exist as an entirely separate layer within your model.  
		日志记录 — 有时这很重要。幸运的是，有许多工具可以为你完成这项工作，但如果你需要自己构建一个，它将作为模型中的一个完全独立的层存在。
	- Real-time subscriptions — Let's say you're subscribed to a stream of data. When a chunk comes in, you need to process it, and perhaps act on a `switch` statement to figure out if you should invoke a `command`. Keep your code clean by delegating this responsibility to a layer.  
		实时订阅 — 假设你订阅了一个数据流。当数据块到达时，你需要处理它，并可能根据 `switch` 语句决定是否调用 `command` 。通过将这一责任委托给一个层，来保持你的代码整洁。
	- Complex rendering logic — I once worked on a project that built out really complex call flows for call centers using Angular and D3. Hundreds of different node types could be dragged and dropped onto a surface. When dropped, the way they connected to each other and how they could be used depended on the rendering and application logic, each decoupled from each other.  
		复杂的渲染逻辑——我曾经参与过一个项目，该项目使用 Angular 和 D3 为呼叫中心构建了非常复杂的呼叫流程。数百种不同的节点类型可以被拖放到一个表面上。当它们被放置时，它们彼此连接的方式以及它们如何被使用取决于渲染和应用逻辑，每个部分都是相互解耦的。
	- Metadata layer — Imagine building a multiplayer video game where new prizes and weapons come out every week. How can we prevent hard-coding weapons and prizes?  
		元数据层 — 想象一下，正在开发一款多人视频游戏，每周都会推出新的奖品和武器。我们如何才能避免硬编码武器和奖品呢？

If you're curious about what a large-scale version of this looks like, check out [Twilio's video-app example](https://github.com/twilio/twilio-video-app-react) built with React hooks and context for global state.  
如果你想知道这个大型版本的样子，可以看看 Twilio 用 React hooks 和上下文构建的全局状态视频应用示例。

## 网络与数据获取（基础设施）
Networking & data fetching (infrastructure)

> Performing API calls and reporting metadata state  
> 执行 API 调用和报告元数据状态

The responsibilities of a networking and data fetching layer are to:  
网络和数据获取层的职责是：

- Know where the backend service(s) are  
	知道后端服务在哪里
- Formulate responses 制定回应
- Marshal response data or errors  
	响应数据或错误
- Report async statuses (isLoading)  
	报告异步状态（isLoading）

![[_posts/architect/_教程/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

Jed Watson describes the async states that tell you about the status of a network request as **meta state** — state *about* state.  
杰德·沃森将描述网络请求状态的异步状态称为元状态——关于状态的状态。

For example, in Apollo Client, the `loading` variable we deconstruct from the query response is a form of meta state.  
例如，在 Apollo Client 中，我们从查询响应中解构的 `loading` 变量是一种元状态。

```tsx
const { data, loading, error } = useQuery(GET_ALL_TODOS);
```

With Apollo Client, that's handled for us. Though if we were to use a more barebones approach, like Axios and Redux, we'd have to write this signaling code ourselves within a Thunk.  
使用 Apollo Client，这些都被我们处理了。但如果我们要使用更精简的方法，比如 Axios 和 Redux，我们就必须在 Thunk 中自己编写这个信令代码。

```tsx
export function createTodoIfNotExists (text: string) {
  return async (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
     
    // Signaling start
    dispatch({ type: actions.CREATING_TODO })

    try {
      const result = await todoAPI.create(...)
      
      // Signaling success
      dispatch({ type: actions.CREATING_TODO_SUCCESS, todo: result.data.todo })
    } catch (err) {
  
      // Signaling Failure
      dispatch({ type: actions.CREATING_TODO_FAILURE, error: err })
    }

  }
}
```

**Note**: The code example above is a demonstration of doing a little too much. Recall that a Redux Thunk is an interaction layer concern? That means it should *only* be responsible for the decision-making logic, and no *signalling* logic, since request signalling is a concern of the networking & data-fetching layer. It can be hard to establish these concrete boundaries sometimes. Especially if the library or framework wasn't designed with separation of concerns in mind.  
注意：上述代码示例有点过于复杂。回想一下，Redux Thunk 是一个交互层的问题吗？这意味着它只应该负责决策逻辑，而不应包含信号逻辑，因为请求信号是网络与数据获取层的问题。有时候很难明确这些具体边界。特别是如果库或框架在设计时没有考虑关注点分离。

## 状态管理 & 存储（基础设施）
State management & storage (infrastructure)

> Storage, updating data, reactivity  
> 存储，更新数据，响应性

A state management library has *three* responsibilities:  
一个状态管理库有三个职责：

- **Storage** — Hold onto global state somewhere, usually in a store / client-side cache.  
	存储 — 将全局状态保存在某个地方，通常保存在一个存储库/客户端缓存中。
- **Updating data** — Make changes to the data in the cache.  
	更新数据 — 修改缓存中的数据。
- **Reactivity** — Provide a way for view-layer presentation components to subscribe to data, and then re-render when data changes.  
	响应性 — 提供一种方式，让视图层的展示组件订阅数据，并在数据变化时重新渲染。

### 状态管理和网络通常一起解决
State management and networking are often solved together

State management is complex.  
状态管理很复杂。

Because it's complex, there are libraries out there to make life a little bit easier. Two of those libraries, Apollo Client and react-query, actually handle the *networking* part for you.  
因为它很复杂，所以有一些库可以简化生活。其中两个库，Apollo Client 和 react-query，实际上会为你处理网络部分。

It can be preferable to choose a library instead of building out the state management machinery and *networking* layer manually.  
选择一个库而不是手动构建状态管理机制和网络层可能更可取。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/f3bc522726fde79b7d01ed2718b52a9c_MD5.png]]

Apollo Client handles both the state management and data fetching concerns.  
Apollo Client 处理状态管理和数据获取的问题。

### 共享全局状态
Shared global state 

Two types of state exist at this layer. They are:  
这一层存在两种状态。它们是：

- `remote (global)` state — The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
	`remote (global)` 状态 — 存在于服务 API 背后的状态。当我们创建 `queries` 远程状态时，我们持有其本地副本，可以从全局范围内访问。
- `shared (global)`: We said earlier, "as soon as some state belongs to more than one component, it's *shared* global state". And you'll know you need this when **two components that rely on the same state don't need to know about each other**. To be clear, this type of state can be live in the interaction layer (via hooks and context, for example). Though sometimes, when working with `remote(global) state`, it's preferable to have something act as a single source of truth, especially if you need to mix remote and local state.  
	`shared (global)`: 我们之前说过，“一旦某个状态属于多个组件，它就是共享的全局状态”。当你发现依赖相同状态的两个组件不需要相互了解时，你就会知道需要使用这种方式。为了明确起见，这种状态可以存在于交互层（例如通过钩子和上下文）。不过，在处理 `remote(global) state` 时，有时最好有一个单一的事实来源，特别是当你需要混合远程和本地状态时。

### 远程和本地状态的混合
Mixture of remote and local state

We often cache remote state in a client-side cache or store. Since we do that, it's reasonable to try to use the store as a single source of truth. Often, we'd like to add some client-only local variables or pieces of state to the store as well.  
我们经常将远程状态缓存到客户端缓存或存储中。既然我们已经这样做了，那么将存储用作单一事实来源是合理的。通常，我们还想将一些仅客户端的本地变量或状态片段添加到存储中。

Here's a Redux example of adding an `isSelected` attribute to each of the `todos` before merging to the store.  
这里有一个 Redux 示例，展示如何在合并到存储之前，为每个 `todos` 添加一个 `isSelected` 属性。

```tsx
switch (action.type) {
  ...
  case actions.GET_TODOS_SUCCESS:
    return {
      ...state,
      // Add some local state to the remote state before merging it
      // to the store
      todos: action.todos.map((t) => { ...t, isSelected: false })
    }
}
```

And in Apollo Client 3, here's the equivalent with cache policies and reactive variables.  
在 Apollo Client 3 中，以下是使用缓存策略和响应式变量的等效方法。

```jsx
import { InMemoryCache } from "@apollo/client";

export const cache: InMemoryCache = new InMemoryCache({
  typePolicies: {
    Todo: {
      fields: {
        isSelected: {
          read (value, opts) {
            const todoId = opts.readField('id');
            const isSelected = !!currentSelectedTodoIds()
              .find((id) => id === todoId)
              
            return isSelected;
          }
        }
      }
    }
  }
});

export const currentSelectedTodoIds = cache.makeVar<number[]>([]);
```

We can configure a way to request `remote` state and *client-only* `shared` local state in the same query.  
我们可以配置一种方式，在同一查询中请求 `remote` 状态和客户端专用的 `shared` 本地状态。

```tsx
export const GET_ALL_TODOS = gql\`
  query GetAllTodos {
    todos { 
      id  
      text  
      completed
      isSelected @client
    }
  }
\`
```

### 存储立面
Storage facades 

Most of the time we don't provide direct access to whats stored within the *store*. Usually, there's some *facade*, an API, that sits in-front of the data and provides ways for us to interact with it.  
大多数时候，我们不会直接提供对存储在存储中的内容的访问。通常，会有一个外观模式（facade），即 API，它位于数据前面，为我们提供与数据交互的方式。

In Redux, this is `dispatch` (for updates) and connect (for reactivity).  
在 Redux 中，这是 `dispatch` （用于更新）和 connect（用于响应式）。

In Apollo Client, this is `useMutation` (for updates) and `useQuery` (for reactivity).  
在 Apollo Client 中，这是 `useMutation` （用于更新）和 `useQuery` （用于响应式）。

Even SQL is a form of a storage facade. It's a powerful pattern.  
即使是 SQL 也是一种存储外观模式。这是一个强大的模式。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/f986e1537c231dfadb646c93c6acf8b9_MD5.png]]

---

