---
title: "III. Layers | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/client-side-architecture/layers/"
author:
  - "[[Khalil Stemmler]]"
published: 2020-06-24
created: 2025-10-07
description: "Advanced TypeScript & Node.js guides for large-scale applications. Learn to write flexible, maintainable TypeScript."
tags:
  - "clippings"
---
[Welcome](https://khalilstemmler.com/articles/client-side-architecture/introduction) [I. Architecture](https://khalilstemmler.com/articles/client-side-architecture/architecture) [II. Principles](https://khalilstemmler.com/articles/client-side-architecture/principles) [III. Layers](https://khalilstemmler.com/articles/client-side-architecture/layers) [IV. Conclusion](https://khalilstemmler.com/articles/client-side-architecture/conclusion)  
æ¬¢è¿ I. æ¶æ„ II. åŸåˆ™ III. å±‚çº§ IV. ç»“è®º

  
å±•ç¤ºç»„ä»¶ UI é€»è¾‘ å®¹å™¨/æ§åˆ¶å™¨ç»„ä»¶ äº¤äº’å±‚ ç½‘ç»œä¸æ•°æ®è·å–

Last updated Jun 24th, 2020  
æœ€åæ›´æ–°äº 2020 å¹´ 6 æœˆ 24 æ—¥

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/7a6cfed60379bca03b1f4d0912259531_MD5.png]]

> This is page three of a guide on Client-Side Architecture basics. Start at [page one](https://khalilstemmler.com/articles/client-side-architecture/introduction).  
> è¿™æ˜¯å…³äºå®¢æˆ·ç«¯æ¶æ„åŸºç¡€æŒ‡å—çš„ç¬¬ä¸‰é¡µã€‚ä»ç¬¬ä¸€é¡µå¼€å§‹ã€‚

## åˆ†å±‚ä¸å…³æ³¨ç‚¹
Layers and concerns 

We're finally ready to decompose each part of Model-View-Presenter, especially the *model* part.  
æˆ‘ä»¬ç»ˆäºå‡†å¤‡å¥½*åˆ†è§£ Model-View-Presenter çš„æ¯ä¸ªéƒ¨åˆ†ï¼Œå°¤å…¶æ˜¯æ¨¡å‹éƒ¨åˆ†*ã€‚

Here's a graphic to illustrate that decomposition into something more concrete.  
è¿™æ˜¯ä¸€å¼ å›¾ï¼Œç”¨æ¥è¯´æ˜åˆ†è§£ä¸ºæ›´å…·ä½“çš„ä¸œè¥¿ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/e5138906bb8c7d37898dc6f6ab45197b_MD5.png]]

Can you see both CQS and SoC in here?  
ä½ èƒ½åœ¨è¿™é‡Œçœ‹åˆ° CQS å’Œ SoC å—ï¼Ÿ

Let's examine it from the top.  
è®©æˆ‘ä»¬*ä»é¡¶éƒ¨å¼€å§‹åˆ†æ*ã€‚

## å±•ç¤ºç»„ä»¶
Presentation components 

> Render the UI and create user events  
> æ¸²æŸ“ UI å¹¶åˆ›å»ºç”¨æˆ·äº‹ä»¶

If you read the title and feel like closing the tab because of *[this article](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)* by Dan Abramov, hang in there. Just wait until we get to container components to decide if you want to bounce ğŸ€.  
å¦‚æœä½ çœ‹äº†æ ‡é¢˜ï¼Œå› ä¸º Dan Abramov çš„æ–‡ç« å°±æƒ³å…³é—­æ ‡ç­¾é¡µï¼Œè¯·å†ç­‰ç­‰ã€‚ç­‰åˆ°æˆ‘ä»¬è®²åˆ°å®¹å™¨ç»„ä»¶æ—¶ï¼Œå†å†³å®šä½ æ˜¯å¦æƒ³è·³æŠ•ğŸ€ã€‚

Presentation components live within the boundaries of the *View* portion of Model-View-Presenter. Their entire purpose is to:  
*å±•ç¤ºç»„ä»¶å­˜åœ¨äº Model-View-Presenter çš„ View éƒ¨åˆ†*è¾¹ç•Œå†…ã€‚å®ƒä»¬å…¨éƒ¨çš„ç›®çš„æ˜¯ï¼š

- Display data in the UI  
	**åœ¨ UI ä¸­æ˜¾ç¤ºæ•°æ®**
- Generate user events (from keypresses, button clicks, hover states, etc)  
	**ç”Ÿæˆç”¨æˆ·äº‹ä»¶**ï¼ˆæ¥è‡ªæŒ‰é”®ã€æŒ‰é’®ç‚¹å‡»ã€æ‚¬åœçŠ¶æ€ç­‰ï¼‰

### å±•ç¤ºç»„ä»¶æ˜¯å®ç°ç»†èŠ‚
Presentation components are an implementation detail

An implementation detail is a low-level detail that helps us accomplish our *main* goal. But they're not our *main* goal. If our *main* goal is to hook up the *Add Todo* feature, the buttons, styling, and text in the UI is an implementation detail in realizing the feature.  
å®ç°ç»†èŠ‚æ˜¯å¸®åŠ©æˆ‘ä»¬è¾¾æˆä¸»è¦ç›®æ ‡çš„ä½çº§ç»†èŠ‚ã€‚ä½†å®ƒä»¬å¹¶éæˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡ã€‚*å¦‚æœæˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡æ˜¯å®ç°â€œæ·»åŠ å¾…åŠäº‹é¡¹â€åŠŸèƒ½ï¼Œé‚£ä¹ˆç”¨æˆ·ç•Œé¢ä¸­çš„æŒ‰é’®ã€æ ·å¼å’Œæ–‡æœ¬å°±æ˜¯å®ç°è¯¥åŠŸèƒ½æ—¶çš„å®ç°ç»†èŠ‚*ã€‚

### å±•ç¤ºç»„ä»¶å¯èƒ½æ˜¯æ˜“å˜çš„
Presentation components can be volatile

Anything subject to frequent change is said to be *volatile*. Us constantly changing the look and feel of components is what makes them so.  
ä»»ä½•å®¹æ˜“é¢‘ç¹å˜åŒ–çš„äº‹ç‰©éƒ½è¢«ç§°ä¸ºâ€œæ˜“å˜çš„â€ã€‚æˆ‘ä»¬*ä¸æ–­æ”¹å˜ç»„ä»¶çš„å¤–è§‚å’Œé£æ ¼ï¼Œè¿™æ­£æ˜¯å¯¼è‡´å®ƒä»¬æ˜“å˜çš„åŸå› *ã€‚

One way to accommodate this phenomenon is to decide on a **[stable](https://khalilstemmler.com/wiki/stable-dependency-principle/)** set of reusable components (that either you wrote or grabbed from a component library), then create your views from those.  
*åº”å¯¹è¿™ç§ç°è±¡çš„ä¸€ç§æ–¹æ³•æ˜¯ç¡®å®šä¸€å¥—ç¨³å®šçš„å¯é‡ç”¨ç»„ä»¶*ï¼ˆè¿™äº›ç»„ä»¶è¦ä¹ˆæ˜¯ä½ è‡ªå·±ç¼–å†™çš„ï¼Œè¦ä¹ˆæ˜¯ä»ç»„ä»¶åº“ä¸­è·å–çš„ï¼‰ï¼Œ*ç„¶åç”¨è¿™äº›ç»„ä»¶åˆ›å»ºä½ çš„è§†å›¾*ã€‚

Even though we could use reusable components, data requirements change frequently.  
*å°½ç®¡æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¯é‡ç”¨ç»„ä»¶ï¼Œä½†æ•°æ®éœ€æ±‚ç»å¸¸å˜åŒ–*ã€‚

Take this simple `CardDescription` component that uses a GraphQL query to describe a card.  
ä»¥è¿™ä¸ªç®€å•çš„ `CardDescription` ç»„ä»¶ä¸ºä¾‹ï¼Œå®ƒä½¿ç”¨ GraphQL æŸ¥è¯¢æ¥æè¿°ä¸€ä¸ªå¡ç‰‡ã€‚

```tsx
const CARD_DESCRIPTION_QUERY = gql\`
  query CardDescription($cardId: ID!) {
    card(id: $cardId) {
      description
    }
  }
\`;

const CardDescription = ({ cardId }) => {
  const { data, loading } = useQuery({ 
    query: CARD_DESCRIPTION_QUERY, 
    variables: { cardId }
  });

  if (loading) {
    return null;
  }

  return <span>{data.card.description}</span>
}
```

How likely is it that we'd need to change the styling? What about displaying something like a `lastChanged` date beside it? Chances are we pretty likely.  
æˆ‘ä»¬å¯èƒ½éœ€è¦æ›´æ”¹æ ·å¼å—ï¼Ÿæ¯”å¦‚åœ¨æ—è¾¹æ˜¾ç¤ºä¸€ä¸ª `lastChanged` æ—¥æœŸï¼Ÿå¯èƒ½æ€§å¾ˆå¤§ã€‚

### åº”è¯¥åœ¨å±•ç¤ºç»„ä»¶ä¸­åŒ…å« GraphQL æŸ¥è¯¢å—ï¼Ÿ
Should we include GraphQL queries in our presentation components?

It's good to have GraphQL queriesÂ **as close to the presentational component as possible**. Queries define the data requirements. And since they'll likely need to be changed together if the requirements change, having them close together reduces unnecessary cognitive load accrued by flipping back and forth between files.
è®©GraphQLæŸ¥è¯¢å°½å¯èƒ½é è¿‘å±•ç¤ºç»„ä»¶æ˜¯å¾ˆå¥½çš„åšæ³•ã€‚æŸ¥è¯¢å®šä¹‰äº†æ•°æ®éœ€æ±‚ã€‚è€Œä¸”ï¼Œç”±äºå¦‚æœéœ€æ±‚å‘ç”Ÿå˜åŒ–ï¼Œå®ƒä»¬å¾ˆå¯èƒ½éœ€è¦ä¸€èµ·ä¿®æ”¹ï¼Œå°†å®ƒä»¬æ”¾åœ¨ä¸€èµ·å¯ä»¥å‡å°‘åœ¨æ–‡ä»¶ä¹‹é—´æ¥å›åˆ‡æ¢æ‰€å¸¦æ¥çš„ä¸å¿…è¦çš„è®¤çŸ¥è´Ÿæ‹…ã€‚

One potentialÂ _downside_Â to putting your queries in your components is that now, if you ever wanted to switch away from GraphQL, your components aren't pureâ€” they're coupled to GraphQL. If you wanted to switch transport-layer technologies, you'd have to refactor every component.
**åœ¨ç»„ä»¶ä¸­æ”¾å…¥æŸ¥è¯¢çš„ä¸€ä¸ªæ½œåœ¨ç¼ºç‚¹**æ˜¯ï¼Œå¦‚æœä½ æƒ³ä¸å†ä½¿ç”¨GraphQLï¼Œè¿™äº›ç»„ä»¶å°±ä¸å†æ˜¯çº¯ç»„ä»¶äº†â€”â€”*å®ƒä»¬ä¸GraphQLè€¦åˆåœ¨ä¸€èµ·*ã€‚å¦‚æœä½ æƒ³æ›´æ¢ä¼ è¾“å±‚æŠ€æœ¯ï¼Œå°±å¿…é¡»é‡æ„æ¯ä¸ªç»„ä»¶ã€‚

Another potential downside is that to test these components, you'd need to make sure they're wrapped in aÂ [mocked Apollo Client provider](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider).
**å¦ä¸€ä¸ªæ½œåœ¨çš„ç¼ºç‚¹**æ˜¯ï¼Œè¦æµ‹è¯•è¿™äº›ç»„ä»¶ï¼Œä½ éœ€è¦ç¡®ä¿å®ƒä»¬è¢«åŒ…è£¹åœ¨ä¸€ä¸ª[æ¨¡æ‹Ÿçš„Apollo Clientæä¾›ç¨‹åº](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider)ä¸­ã€‚

My recommendation is to couple the queries to the components anyways. What you gain in an incredible developer experience is, in my opinion, worth the risk of going fully in with GraphQL and deciding you want to change later down the road.
æˆ‘çš„å»ºè®®æ˜¯æ— è®ºå¦‚ä½•éƒ½è¦å°†æŸ¥è¯¢ä¸ç»„ä»¶å…³è”èµ·æ¥ã€‚åœ¨æˆ‘çœ‹æ¥ï¼Œä½ åœ¨å“è¶Šçš„å¼€å‘è€…ä½“éªŒæ–¹é¢æ‰€è·å¾—çš„æ”¶ç›Šï¼Œå€¼å¾—å†’å®Œå…¨é‡‡ç”¨GraphQLçš„é£é™©ï¼Œå³ä¾¿ä¹‹åä½ å¯èƒ½ä¼šå†³å®šåšå‡ºæ”¹å˜ã€‚

**Note on query performance**: It's ok to have lots of queries for super-specific chunks of data like shown above. Using Apollo Client, Apollo handles that complicated logic of checking whether the data is cached already, and if not â€” it makes a request to get it.
**å…³äºæŸ¥è¯¢æ€§èƒ½çš„è¯´æ˜**ï¼šåƒä¸Šé¢æ‰€ç¤ºçš„é‚£æ ·ï¼Œå¯¹è¶…ç‰¹å®šçš„æ•°æ®å—è¿›è¡Œå¤§é‡æŸ¥è¯¢æ˜¯æ²¡é—®é¢˜çš„ã€‚ä½¿ç”¨Apollo Clientæ—¶ï¼ŒApolloä¼šå¤„ç†å¤æ‚çš„é€»è¾‘ï¼Œæ£€æŸ¥æ•°æ®æ˜¯å¦å·²è¢«ç¼“å­˜ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ä¼šå‘å‡ºè¯·æ±‚æ¥è·å–æ•°æ®ã€‚

### åœ¨å±•ç¤ºç»„ä»¶ä¸­è¦æµ‹è¯•ä»€ä¹ˆ
What to test in presentation components

Unit testing implementation details is typically fruitless â€” especially for volatile things. It doesn't do us much good testing to see if a button is blue or green. Instead, when testing presentation components, we want to test against UI logic.
*å¯¹å®ç°ç»†èŠ‚è¿›è¡Œå•å…ƒæµ‹è¯•é€šå¸¸æ˜¯å¾’åŠ³çš„*â€”â€”å°¤å…¶æ˜¯å¯¹äºæ˜“å˜çš„å†…å®¹ã€‚æµ‹è¯•æŒ‰é’®æ˜¯è“è‰²è¿˜æ˜¯ç»¿è‰²å¯¹æˆ‘ä»¬æ²¡ä»€ä¹ˆå¸®åŠ©ã€‚ç›¸åï¼Œåœ¨æµ‹è¯•å±•ç¤ºç»„ä»¶æ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›*é’ˆå¯¹UIé€»è¾‘è¿›è¡Œæµ‹è¯•*ã€‚

To demonstrate what I mean, here's a bland, basic presentation component.
ä¸ºäº†è¯´æ˜æˆ‘çš„æ„æ€ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå¹³æ·¡ã€åŸºç¡€çš„å±•ç¤ºç»„ä»¶ã€‚

```tsx
// /components/Todo.tsx
export const Todo = (props) => (
  <div className="todo">
    <div class="todo-text">{props.text}</div>
    <button onClick={props.onDeleteTodo}>Delete</button>
  </div>
)
```

There's no UI logic involved here. It merely takes in props, hooks up callbacks, and renders some HTML.è¿™é‡Œ*ä¸æ¶‰åŠä»»ä½•ç”¨æˆ·ç•Œé¢é€»è¾‘*ã€‚å®ƒåªæ˜¯æ¥æ”¶å±æ€§ã€è¿æ¥å›è°ƒå‡½æ•°å¹¶æ¸²æŸ“ä¸€äº›HTMLã€‚

Here'sÂ _another_Â example of the same component, but this time, as a class-based component withÂ **UI logic.**
è¿™æ˜¯åŒä¸€ä¸ªç»„ä»¶çš„å¦ä¸€ä¸ªç¤ºä¾‹ï¼Œä½†è¿™æ¬¡æ˜¯ä½œä¸º*å¸¦æœ‰UIé€»è¾‘çš„åŸºäºç±»çš„ç»„ä»¶*ã€‚

```tsx
// /components/Todo.tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'

type Props = any;

export default class Todo extends Component<Props, Props> {
  static propTypes = {
    todo: PropTypes.object.isRequired,
    editTodo: PropTypes.func.isRequired,
    deleteTodo: PropTypes.func.isRequired,
    completeTodo: PropTypes.func.isRequired
  }

  state = {
    editing: false
  }

  handleDoubleClick = () => {
    this.setState({ editing: true })
  }

  handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      this.props.deleteTodo(id)
    } else {
      this.props.editTodo(id, text)
    }
    this.setState({ editing: false })
  }

  render() {
    const { todo, completeTodo, deleteTodo } = this.props

    return this.state.editing ? (
      <TodoTextInput 
          text={todo.text}
          editing={this.state.editing}
          onSave={(text: string) => this.handleSave(todo.id, text)} />
    ) : (
      <div className="view">
        <input 
           className="toggle"
           type="checkbox"
           checked={todo.completed}
           onChange={() => completeTodo(todo.id)} />
        <label onDoubleClick={this.handleDoubleClick}>
          {todo.text}
        </label>
        <button 
          className="destroy"
          onClick={() => deleteTodo(todo.id)} />
      </div>
    )
  }
}
```

## UI é€»è¾‘
UI logic 

> View behavior & local component state  
> Viewè¡Œä¸ºä¸æœ¬åœ°ç»„ä»¶çŠ¶æ€

The main difference between the two previously shown `Todo` components is that the second `Todo` component contained UI logic where the first did not.  
ä¹‹å‰å±•ç¤ºçš„ä¸¤ä¸ª`Todo`ç»„ä»¶ä¹‹é—´çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œ*ç¬¬äºŒä¸ª`Todo`ç»„ä»¶åŒ…å«äº†UIé€»è¾‘ï¼Œè€Œç¬¬ä¸€ä¸ªåˆ™æ²¡æœ‰*ã€‚
### UI é€»è¾‘å°±æ˜¯è§†å›¾è¡Œä¸ºï¼ˆäº‹ä»¶å¤„ç†å‡½æ•°ã€æ¡ä»¶æ¸²æŸ“ï¼‰
UI logic is view behavior

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/58c6dfdefd8c3d968ceea2fd157f1518_MD5.png]]

"If you're logged in, showÂ _this_Â â€” otherwise, showÂ _this_."
â€œå¦‚æœå·²ç™»å½•ï¼Œæ˜¾ç¤º_è¿™ä¸ª_â€”â€”å¦åˆ™ï¼Œæ˜¾ç¤º_è¿™ä¸ª_ã€‚â€

"If you're this type of user, showÂ _this_Â â€” otherwise, showÂ _this_."
â€œå¦‚æœä½ æ˜¯è¿™ç±»ç”¨æˆ·ï¼Œå°±æ˜¾ç¤º_è¿™ä¸ª_â€”â€”å¦åˆ™ï¼Œå°±æ˜¾ç¤º_è¿™ä¸ª_ã€‚â€

"Depending on which page you're on in the signup process, show the correct form".
â€œæ ¹æ®ä½ åœ¨æ³¨å†Œæµç¨‹ä¸­æ‰€å¤„çš„é¡µé¢ï¼Œæ˜¾ç¤ºæ­£ç¡®çš„è¡¨å•ã€‚â€

A component has UI logic when it exudes behavior. Conditionals that determineÂ _what to show_, orÂ _when certain user events get called over others_Â **are a form of view behavior (UI logic)**.
ç»„ä»¶åœ¨å±•ç°è¡Œä¸ºæ—¶å…·æœ‰UIé€»è¾‘ã€‚å†³å®šè¦æ˜¾ç¤ºä»€ä¹ˆçš„**æ¡ä»¶åˆ¤æ–­**ï¼Œæˆ–è€…æŸäº›ç”¨æˆ·äº‹ä»¶ä¼˜å…ˆäºå…¶ä»–äº‹ä»¶è¢«è°ƒç”¨çš„æƒ…å†µï¼Œ**éƒ½æ˜¯è§†å›¾è¡Œä¸ºï¼ˆUIé€»è¾‘ï¼‰çš„ä¸€ç§å½¢å¼**ã€‚

Here's a conditional example from the previous code sampleÂ **determining what to show**.
ä»¥ä¸‹æ˜¯å‰ä¸€ä¸ªä»£ç ç¤ºä¾‹ä¸­çš„æ¡ä»¶ç¤ºä¾‹ï¼Œç”¨äº**ç¡®å®šè¦æ˜¾ç¤ºçš„å†…å®¹**ã€‚

```tsx
return this.state.editing ? (
    <TodoTextInput 
        text={todo.text}
        editing={this.state.editing}
        onSave={(text: string) => this.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
         className="toggle"
         type="checkbox"
         checked={todo.completed}
         onChange={() => completeTodo(todo.id)} />
      <label onDoubleClick={this.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => deleteTodo(todo.id)} />
    </div>
  )
```

Here's a conditional **determining which user event to create**.  
è¿™é‡Œæ˜¯ä¸€ä¸ª**å†³å®šåˆ›å»ºå“ªä¸ªç”¨æˆ·äº‹ä»¶çš„æ¡ä»¶**ã€‚

```tsx
handleSave = (id: number, text: string) => {
  if (text.length === 0) {
    this.props.deleteTodo(id)
  } else {
    this.props.editTodo(id, text)
  }
  this.setState({ editing: false })
}
```

### ç»„ä»¶ / æœ¬åœ°çŠ¶æ€
Component / local state

This is where the *first* type of state we might encounter: `local (component)` state.  
è¿™å°±æ˜¯æˆ‘ä»¬å¯èƒ½é‡åˆ°çš„**ç¬¬ä¸€ç§çŠ¶æ€**ï¼š `local (component)` çŠ¶æ€ã€‚

In [Jed Watson](https://twitter.com/JedWatson) 's talk from GraphQL Summit 2019 titled, " [A Treatise on State](https://www.youtube.com/watch?v=tBz3UmZG_bk&feature=emb_title) ", he describes five different types of state when building web apps: `local (component)`, `shared (global)`, `remote (global)`, `meta`, and `router`.  
åœ¨ Jed Watson äº 2019 å¹´ GraphQL Summit ä¸Šçš„æ¼”è®²ã€Šå…³äºçŠ¶æ€çš„å°å†Œå­ã€‹ä¸­ï¼Œä»–æè¿°äº†åœ¨æ„å»º Web åº”ç”¨æ—¶æ¶‰åŠåˆ°çš„**äº”ç§ä¸åŒç±»å‹çš„çŠ¶æ€**ï¼š `local (component)` ã€ `shared (global)` ã€ `remote (global)` ã€ `meta å…ƒæ•°æ®` å’Œ `router è·¯ç”±` ã€‚

- **Explanations of the five types of state  
	äº”ç§çŠ¶æ€ç±»å‹çš„è§£é‡Š**
	- `local (component)`: State that belongs to a single component. Can also be thought about as UI state. UI state can be extracted from a presentation component into a React hook. **Note: we're about to do this**.  
		`local (component)`: å±äº**å•ä¸ªç»„ä»¶çš„çŠ¶æ€**ã€‚ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯`UIçŠ¶æ€`ã€‚UIçŠ¶æ€å¯ä»¥**ä»å±•ç¤ºç»„ä»¶ä¸­æå–åˆ°Reacté’©å­ä¸­**ã€‚æ³¨æ„ï¼šæˆ‘ä»¬å³å°†è¿™æ ·åšã€‚
	- `shared (global)`: As soon as some state belongs to more than one component, it's *shared* global state. Components shouldn't need to know about each other (a header shouldn't need to know about a todo).  
		`shared (global)`: ä¸€æ—¦æŸäº›çŠ¶æ€**å±äºå¤šä¸ªç»„ä»¶**ï¼Œå®ƒå°±æ˜¯*å…±äº«çš„å…¨å±€çŠ¶æ€*ã€‚ç»„ä»¶ä¹‹é—´æ— éœ€ç›¸äº’äº†è§£ï¼ˆheaderæ— éœ€äº†è§£å¾…åŠäº‹é¡¹ï¼‰ã€‚
	- `remote (global)`: The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
		`remote (global)`: **å­˜åœ¨äºæœåŠ¡ä¸­APIèƒŒåçš„çŠ¶æ€**ã€‚*å½“æˆ‘ä»¬å¯¹è¿œç¨‹çŠ¶æ€è¿›è¡Œ`queries`æ—¶ï¼Œæˆ‘ä»¬ä¼šä¿ç•™å…¶æœ¬åœ°å‰¯æœ¬ï¼Œè¯¥å‰¯æœ¬å¯ä»å…¨å±€ä½œç”¨åŸŸè®¿é—®*ã€‚
	- `meta`: Meta state refers to state *about* state. The best example of this is the `loading` async states that tell us the progress of our network requests.  
		`meta`: å…ƒçŠ¶æ€æŒ‡çš„æ˜¯**å…³äºçŠ¶æ€çš„çŠ¶æ€**ã€‚æœ€å¥½çš„ä¾‹å­æ˜¯ *`loading`çš„å¼‚æ­¥çŠ¶æ€ï¼Œå®ƒä¼šå‘Šè¯‰æˆ‘ä»¬ç½‘ç»œè¯·æ±‚çš„è¿›åº¦*ã€‚
	- and `router` state: The current URL of the browser.  
		å¹¶ä¸” `router` çŠ¶æ€ï¼š**æµè§ˆå™¨å½“å‰çš„ URL**ã€‚

This state,Â `local (component)`Â state, belongs to a single component. You can call this UI state. It's meant to hold onto data that helps a single component do its job.
è¿™ç§çŠ¶æ€ï¼Œå³`local (component)`çŠ¶æ€ï¼Œå±äºå•ä¸ªç»„ä»¶ã€‚ä½ å¯ä»¥ç§°å…¶ä¸º`UIçŠ¶æ€`ã€‚å®ƒæ—¨åœ¨**ä¿å­˜æœ‰åŠ©äºå•ä¸ªç»„ä»¶å®Œæˆå…¶å·¥ä½œçš„*æ•°æ®***ã€‚

To better see what it looks like, let's extract all UI state from this class-based component and refactor to a functional component and a React hook.
ä¸ºäº†æ›´æ¸…æ¥šåœ°äº†è§£å®ƒçš„æ ·å­ï¼Œè®©æˆ‘ä»¬*ä»è¿™ä¸ªåŸºäºç±»çš„ç»„ä»¶ä¸­æå–æ‰€æœ‰UIçŠ¶æ€ï¼Œå¹¶é‡æ„ä¸ºä¸€ä¸ªå‡½æ•°ç»„ä»¶å’Œä¸€ä¸ªReacté’©å­*ã€‚

```tsx
// /components/Todo.tsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import classnames from 'classnames'
import TodoTextInput from './TodoTextInput'
import { useState } from 'react'

/**
 * Decompose the UI logic from the presentational component
 * and store it in a React hook.
 *
 * All data and operations in this hook are UI logic for the
 * component - we've just separated concerns, that's all.
 */

function useTodoComponent (actions) {
  // "editing" is a form of local (component) state
  const [editing, setEditing] = useState(false);

  const handleSave = (id: number, text: string) => {
    if (text.length === 0) {
      actions.deleteTodo(id)
    } else {
      actions.editTodo(id, text)
    }
    setEditing(true);
  }

  const handleDoubleClick = () => {
    setEditing(true);
  }

  return { 
    models: { editing }, 
    operations: { handleSave, handleDoubleClick } 
  }
}

/**
 * This component relies on some local state, but none of 
 * it lives within the component, which is purely 
 * presentational.
 */

export function Todo (props) {
  const { todo, actions } = props;
  
  // Grab our local (component) state and access to other UI logic
  const { models, operations } = useTodoComponent(actions);
  
  // Conditional UI logic
  return models.editing ? (
    <TodoTextInput 
      text={todo.text}
      editing={models.editing}
      onSave={(text: string) => operations.handleSave(todo.id, text)} />
  ) : (
    <div className="view">
      <input 
        className="toggle"
        type="checkbox"
        checked={todo.completed}
        onChange={() => actions.completeTodo(todo.id)} />
      <label onDoubleClick={operations.handleDoubleClick}>
        {todo.text}
      </label>
      <button 
        className="destroy"
        onClick={() => actions.deleteTodo(todo.id)} />
    </div>
  )
}
```

### UIé€»è¾‘æ˜¯æˆ‘ä»¬åœ¨ç»„ä»¶ä¸­å®é™…è¦æµ‹è¯•çš„å†…å®¹
UI logic is what we actually try to test within components

Since UI logic is behavior,Â _this_Â is actually what we want to test against in our integration tests. The behavior. YouÂ _could_Â write unit tests as well, but it might be trivial if component logic is straightforward. It could be more worthwhile and give you more confidence that the feature is working correctly to integration test both the component and the UI logic together.
ç”±äºç”¨æˆ·ç•Œé¢é€»è¾‘å±äºè¡Œä¸ºèŒƒç•´ï¼Œ*è¿™å®é™…ä¸Šæ­£æ˜¯æˆ‘ä»¬åœ¨é›†æˆæµ‹è¯•ä¸­æƒ³è¦æµ‹è¯•çš„å†…å®¹â€”â€”å³è¡Œä¸º*ã€‚ä½ ä¹Ÿå¯ä»¥ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œä½†å¦‚æœç»„ä»¶é€»è¾‘ç®€å•ç›´æ¥ï¼Œå•å…ƒæµ‹è¯•å¯èƒ½å°±æ²¡ä»€ä¹ˆå¿…è¦äº†ã€‚*å°†ç»„ä»¶å’Œç”¨æˆ·ç•Œé¢é€»è¾‘ä¸€èµ·è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œå¯èƒ½æ›´æœ‰ä»·å€¼ï¼Œä¹Ÿèƒ½è®©ä½ æ›´æœ‰ä¿¡å¿ƒç¡®å®šè¯¥åŠŸèƒ½è¿è¡Œæ­£å¸¸*ã€‚

## å®¹å™¨/æ§åˆ¶å™¨
Container/controller 

> The glue layer (pages)  
> ç²˜åˆå±‚ï¼ˆé¡µé¢ï¼‰

Traditionally, the responsibilities of a container component were to:  
**ä¼ ç»Ÿä¸Šï¼Œå®¹å™¨ç»„ä»¶çš„èŒè´£**æ˜¯ï¼š

- Consume user events & pass them to the model  
	æ¥æ”¶ç”¨æˆ·äº‹ä»¶å¹¶å°†å…¶ä¼ é€’ç»™æ¨¡å‹
- Subscribe to data changes (reactivity) and keep the view updated  
	è®¢é˜…æ•°æ®å˜åŒ–ï¼ˆå“åº”æ€§ï¼‰å¹¶ä¿æŒè§†å›¾æ›´æ–°

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/b2b86e61c87686226d1945c0400cc986_MD5.png]]

This isn't new. The definition of a *controller/presenter,* all the way back from the *Model-View-Presenter* pattern, made this distinction.  
è¿™å¹¶éæ–°é²œäº‹ã€‚æ—©åœ¨â€œæ¨¡å‹-è§†å›¾-å‘ˆç°å™¨â€ï¼ˆModel-View-Presenterï¼‰æ¨¡å¼ä¸­ï¼Œâ€œæ§åˆ¶å™¨/å‘ˆç°å™¨â€ï¼ˆcontroller/presenterï¼‰çš„å®šä¹‰å°±å·²ç»åšäº†è¿™ç§åŒºåˆ†ã€‚

### æˆ‘ä»¬çœŸçš„éœ€è¦å®¹å™¨ç»„ä»¶å—ï¼Ÿ
Do we really need container components?

In 2019, with the advent of React hooks, [Dan said we don't](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).  
2019 å¹´ï¼Œéšç€ React hooks çš„æ¨å‡ºï¼Œ*Dan è¯´è¿‡æˆ‘ä»¬ä¸éœ€è¦*ã€‚

> The main reason I found \[container components\] useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division.  
> æˆ‘å‘ç°ã€å®¹å™¨ç»„ä»¶ã€‘æœ‰ç”¨çš„ä¸»è¦åŸå› æ˜¯ï¼Œå®ƒèƒ½è®©æˆ‘*å°†å¤æ‚çš„æœ‰çŠ¶æ€é€»è¾‘ä¸ç»„ä»¶çš„å…¶ä»–æ–¹é¢åˆ†ç¦»å¼€æ¥*ã€‚è€Œ*Hooksè®©æˆ‘æ— éœ€è¿›è¡Œè¿™ç§éšæ„çš„åˆ’åˆ†å°±èƒ½å®ç°åŒæ ·çš„æ•ˆæœ*ã€‚

Here are my thoughts.Â 
ä»¥ä¸‹æ˜¯æˆ‘çš„æƒ³æ³•ã€‚

I fully agree that complex stateful logicÂ **shouldn't live within presentation components**. When we do that, we don't get the ability to reuse logic across different components.
æˆ‘å®Œå…¨åŒæ„ï¼Œ**å¤æ‚çš„æœ‰çŠ¶æ€é€»è¾‘ä¸åº”è¯¥å­˜åœ¨äºå±•ç¤ºç»„ä»¶ä¸­**ã€‚å¦‚æœæˆ‘ä»¬é‚£æ ·åšï¼Œ**å°±æ— æ³•åœ¨ä¸åŒç»„ä»¶ä¹‹é—´å¤ç”¨é€»è¾‘**ã€‚

Now, as for stateful logic inÂ _container components_? I don't believe itÂ _ever should have been in 'em._
è‡³äºå®¹å™¨ç»„ä»¶ä¸­çš„æœ‰çŠ¶æ€é€»è¾‘ï¼Œæˆ‘è®¤ä¸ºå®ƒæ ¹æœ¬å°±ä¸åº”è¯¥å­˜åœ¨äºå…¶ä¸­ã€‚

Previously, React developers were advised to put data and behavior in container components and write code that determined "how things work". That breaks the rules of what was said to be the responsibility of a container/presenter.
*ä»¥å‰ï¼ŒReactå¼€å‘è€…è¢«å»ºè®®å°†æ•°æ®å’Œè¡Œä¸ºæ”¾åœ¨å®¹å™¨ç»„ä»¶ä¸­*ï¼Œå¹¶ç¼–å†™ç”¨äºç¡®å®šâ€œäº‹ç‰©å¦‚ä½•è¿ä½œâ€çš„ä»£ç ã€‚è¿™è¿èƒŒäº†æ‰€è°“çš„å®¹å™¨/å±•ç¤ºç»„ä»¶çš„èŒè´£è§„åˆ™ã€‚

Just because we know to put stateful data and behavior in React Hooks, itÂ **doesn't mean we removed the problems a container component solves**.
ä»…ä»…å› ä¸ºæˆ‘ä»¬çŸ¥é“è¦å°†æœ‰çŠ¶æ€æ•°æ®å’Œè¡Œä¸ºæ”¾å…¥React Hooksä¸­ï¼Œè¿™**å¹¶ä¸æ„å‘³ç€æˆ‘ä»¬æ¶ˆé™¤äº†å®¹å™¨ç»„ä»¶æ‰€èƒ½è§£å†³çš„é—®é¢˜**ã€‚

WeÂ _still_Â need to configureÂ _reactivity_, sometimes using Redux, sometimes using Apollo Client or something else, and weÂ _still_Â need some construct toÂ **act as the glue, knowing which components to load up for the features we enable on a page**.
æˆ‘ä»¬ä»ç„¶éœ€è¦é…ç½®å“åº”æ€§ï¼Œæœ‰æ—¶ä½¿ç”¨Reduxï¼Œæœ‰æ—¶ä½¿ç”¨Apollo Clientæˆ–å…¶ä»–å·¥å…·ï¼Œè€Œä¸”æˆ‘ä»¬ä»ç„¶éœ€è¦ä¸€äº›ç»“æ„æ¥èµ·åˆ°ç²˜åˆä½œç”¨ï¼ŒçŸ¥æ™“ä¸ºé¡µé¢ä¸Šå¯ç”¨çš„åŠŸèƒ½åŠ è½½å“ªäº›ç»„ä»¶ã€‚

### å®¹å™¨ç»„ä»¶æ˜¯é¡µé¢ç»„ä»¶
Container components are pages

In the following React Router example, we have three main *pages:* home, about, and dashboard.  
åœ¨ä»¥ä¸‹ React Router ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰*ä¸‰ä¸ªä¸»è¦é¡µé¢*ï¼šä¸»é¡µã€å…³äºé¡µå’Œä»ªè¡¨ç›˜é¡µã€‚

```tsx
// src/App.js
export default function App () {
  return (
    <Router>
        <Switch>
          <Route exact path="/"> 
            <Home />
          </Route>
          <Route path="/about">
            <About />
          </Route>
          <Route path="/dashboard">
            <Dashboard />
          </Route>
        </Switch>
    </Router>
  );
}
```

Each page:æ¯é¡µï¼š

- is responsible for enable a variable number of features (remember, a feature is a `command` or `query`)  
	*è´Ÿè´£å¯ç”¨æ•°é‡å¯å˜çš„åŠŸèƒ½*ï¼ˆè¯·è®°ä½ï¼ŒåŠŸèƒ½æ˜¯æŒ‡`command`æˆ–`query`ï¼‰
- has a variable number of presentational components within it, and  
	å…¶ä¸­*åŒ…å«æ•°é‡ä¸å®šçš„å±•ç¤ºç»„ä»¶*ï¼Œå¹¶ä¸”
- knows about `shared` reactive state, and *sometimes* connects it to presentational components that need it  
	äº†è§£`shared`å“åº”å¼çŠ¶æ€ï¼Œå¹¶ä¸”_æœ‰æ—¶_ä¼šå°†å…¶è¿æ¥åˆ°éœ€è¦å®ƒçš„å±•ç¤ºç»„ä»¶

Container components are the top-level modules that turn on all the features for a particular page. In Gatsby.js, we call themÂ _Page components_. Since all client architectures naturally evolve from this Model-View-Presenter pattern, it's unlikely we'llÂ **get rid of the presenter (container) entirely**.
`å®¹å™¨ç»„ä»¶`æ˜¯*å¯ç”¨ç‰¹å®šé¡µé¢æ‰€æœ‰åŠŸèƒ½çš„é¡¶çº§æ¨¡å—*ã€‚åœ¨Gatsby.jsä¸­ï¼Œæˆ‘ä»¬ç§°å®ƒä»¬ä¸º`é¡µé¢ç»„ä»¶`ã€‚*ç”±äºæ‰€æœ‰å®¢æˆ·ç«¯æ¶æ„è‡ªç„¶éƒ½ä»è¿™ç§æ¨¡å‹-è§†å›¾-å‘ˆç°å™¨æ¨¡å¼æ¼”å˜è€Œæ¥*ï¼Œå› æ­¤æˆ‘ä»¬ä¸å¤ªå¯èƒ½**å®Œå…¨æ‘’å¼ƒå‘ˆç°å™¨ï¼ˆå®¹å™¨ï¼‰**ã€‚

To demonstrate my point, here's aÂ _container component_Â in a React hooks world. It might not look like much, but notice thatÂ **it fulfills the two responsibilities of a container component**.
ä¸ºäº†è¯´æ˜æˆ‘çš„è§‚ç‚¹ï¼Œ*ä»¥ä¸‹æ˜¯React Hooksç¯å¢ƒä¸­çš„ä¸€ä¸ª_å®¹å™¨ç»„ä»¶_*ã€‚å®ƒå¯èƒ½çœ‹èµ·æ¥æ²¡ä»€ä¹ˆç‰¹åˆ«ï¼Œä½†è¯·æ³¨æ„ï¼Œ**å®ƒå±¥è¡Œäº†å®¹å™¨ç»„ä»¶çš„ä¸¤é¡¹èŒè´£**ã€‚
```tsx
// /modules/home/Home.container.tsx
import React from 'react'
import MainSection from '../components/MainSection'
import { useQuery } from '@apollo/client'
import { VisiblityFilter } from '../models/VisibilityFilter'
import { Todos } from '../models/Todos'
import { GET_ALL_TODOS } from '../operations/queries/getAllTodos'
import { GET_VISIBILITY_FILTER } from '../operations/queries/getVisibilityFilter'
import { todoMutations } from '../operations/mutations'

const todosAPI = new TodosAPI();

export default function Home () {
  // Shared (global) or remote (global) state.
  const { operations, models } = useTodos(todosAPI);
  const { 
    completeAllTodos, 
    setVisibilityFilter, 
    clearCompletedTodos 
  } = operations;

  return (
    <Layout>
      <MainSection
        // Pass data to components
        activeVisibilityFilter={visibilityFilter}
        todosCount={models.todos.length}
        completedCount={models.todos.filter(t => t.completed).length}
        
        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
      />
      <ReportSection 
        // Pass data to components
        todos={models.todos}

        // Delegate operations to the model
        actions={{
          completeAllTodos,
          setVisibilityFilter,
          clearCompletedTodos
        }}
       />
    </Layout>
  );
};
```

**_Something_Â is responsible for knowing how to connect to a reactive model, and knowing what to do with events that come from presentation components. That's a container.
æŸä¸ªäº‹ç‰©è´Ÿè´£äº†è§£å¦‚ä½•è¿æ¥åˆ°ååº”å¼æ¨¡å‹ï¼Œä»¥åŠçŸ¥é“å¦‚ä½•å¤„ç†æ¥è‡ªå±•ç¤ºç»„ä»¶çš„äº‹ä»¶ã€‚è¿™å°±æ˜¯å®¹å™¨ã€‚**

Of course, you could call everything aÂ _component,_Â but then the explicit communication and delineation of responsibilities we're fighting for is lost.
å½“ç„¶ï¼Œä½ å¯ä»¥æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½ç§°ä¸º_ç»„ä»¶_ï¼Œä½†è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬æ‰€è¿½æ±‚çš„é€šä¿¡å’Œè´£ä»»åˆ’åˆ†å°±ä¸å¤å­˜åœ¨äº†ã€‚

### å®¹å™¨ç»„ä»¶ä¸åŒ…å«ä»»ä½•åŠŸèƒ½
Container components contain no functionality

The container component is pretty bare. That's a good thing. They're not supposed to contain any functionality. They're not worthy of unit testing. They're just meant to stitch things together. However, if you want to do an integration test all features of a page, just load up the container component and have at 'er.
å®¹å™¨ç»„ä»¶ç›¸å½“ç®€æ´ã€‚è¿™æ˜¯ä»¶å¥½äº‹ã€‚å®ƒä»¬æœ¬*ä¸åº”åŒ…å«ä»»ä½•åŠŸèƒ½*ã€‚å®ƒä»¬*ä¸å€¼å¾—è¿›è¡Œå•å…ƒæµ‹è¯•*ã€‚**å®ƒä»¬åªæ˜¯ç”¨æ¥å°†å„ç§ä¸œè¥¿ç»„åˆåœ¨ä¸€èµ·çš„**ã€‚ä¸è¿‡ï¼Œå¦‚æœä½ æƒ³å¯¹ä¸€ä¸ªé¡µé¢çš„æ‰€æœ‰åŠŸèƒ½è¿›è¡Œé›†æˆæµ‹è¯•ï¼Œåªéœ€åŠ è½½å®¹å™¨ç»„ä»¶å¹¶å¯¹å…¶è¿›è¡Œæµ‹è¯•å³å¯ã€‚

## äº¤äº’å±‚
Interaction layer 

> Model behaviorÂ æ¨¡å‹è¡Œä¸º

We're finally in the most challenging part of a client-side architecture: theÂ _model_.
æˆ‘ä»¬ç»ˆäºæ¥åˆ°äº†å®¢æˆ·ç«¯**æ¶æ„ä¸­æœ€å…·æŒ‘æˆ˜æ€§çš„éƒ¨åˆ†**ï¼š_æ¨¡å‹_ã€‚

The first layer of the model, which is what gets called from the container component, is theÂ **interaction layer**.
æ¨¡å‹çš„ç¬¬ä¸€å±‚æ˜¯äº¤äº’å±‚ï¼Œå®ƒæ˜¯ä»å®¹å™¨ç»„ä»¶ä¸­è°ƒç”¨çš„éƒ¨åˆ†ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

### äº¤äº’å±‚æ˜¯æ¨¡å‹çš„è¡Œä¸º
The interaction layer is the behavior of the model

When you click submit to "_add a todo"_, do you jump straight to the GraphQLÂ `mutation`Â right away? Do you perform any validation logic? Are there any rules to enforce?
å½“ä½ ç‚¹å‡»æäº¤ä»¥â€œ_æ·»åŠ å¾…åŠäº‹é¡¹_â€æ—¶ï¼Œæ˜¯å¦ä¼šç›´æ¥è·³è½¬åˆ°GraphQLÂ `mutation`ï¼Ÿä½ ä¼šæ‰§è¡Œä»»ä½•éªŒè¯é€»è¾‘å—ï¼Ÿæœ‰ä»»ä½•éœ€è¦æ‰§è¡Œçš„è§„åˆ™å—ï¼Ÿ

A lot of times, thereÂ _aren't_Â any rules. Sometimes we can't be bothered and we leave validation logic as something theÂ _server_Â handles. This is particularly common on simple dashboard apps. These apps have pretty muchÂ **no rules to enforce**, so an interaction layer doesn't exist.
å¾ˆå¤šæ—¶å€™ï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆè§„åˆ™å¯è¨€ã€‚æœ‰æ—¶æˆ‘ä»¬æ‡’å¾—å»ç®¡ï¼Œ*ä¼šæŠŠéªŒè¯é€»è¾‘ç•™ç»™æœåŠ¡å™¨å¤„ç†*ã€‚è¿™åœ¨ç®€å•çš„ä»ªè¡¨ç›˜åº”ç”¨ä¸­å°¤ä¸ºå¸¸è§ã€‚*è¿™äº›åº”ç”¨å‡ ä¹æ²¡æœ‰ä»€ä¹ˆè§„åˆ™éœ€è¦æ‰§è¡Œï¼Œå› æ­¤ä¹Ÿå°±ä¸å­˜åœ¨äº¤äº’å±‚*ã€‚

It goes controller â†’ network request.
Or as we've been doing for a long time, presentation component â†’ network request.
When thereÂ **is**Â policy to enforce, it's time to think about carving out an interaction layer.
*æµç¨‹æ˜¯æ§åˆ¶å™¨â†’ç½‘ç»œè¯·æ±‚ï¼ˆä¸å­˜åœ¨äº¤äº’å±‚ï¼‰*
æˆ–è€…å°±åƒæˆ‘ä»¬é•¿æœŸä»¥æ¥æ‰€åšçš„é‚£æ ·ï¼Œå±•ç¤ºç»„ä»¶â†’ç½‘ç»œè¯·æ±‚ã€‚
*å½“æœ‰ç­–ç•¥éœ€è¦æ‰§è¡Œæ—¶ï¼Œå°±è¯¥è€ƒè™‘æ„å»ºä¸€ä¸ªäº¤äº’å±‚äº†*ã€‚

### äº¤äº’å±‚æ˜¯å†³ç­–å±‚
The interaction layer is the decision-making layer

**Application (or interaction) logic**Â is the logic that makes a decision as to what happens next.
**åº”ç”¨ï¼ˆæˆ–äº¤äº’ï¼‰é€»è¾‘**æ˜¯å†³å®šæ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆçš„é€»è¾‘ã€‚

Let's say you have aÂ `command`Â calledÂ `createTodoIfNotExists`. Whatever construct is responsible for the interaction layer contains the code that helps you decide, "should we follow through with this"?å‡è®¾ä½ æœ‰ä¸€ä¸ªåä¸º`createTodoIfNotExists`çš„`command`ã€‚è´Ÿè´£äº¤äº’å±‚çš„ä»»ä½•ç»“æ„éƒ½åŒ…å«æœ‰åŠ©äºä½ å†³å®šâ€œæˆ‘ä»¬æ˜¯å¦åº”è¯¥æ‰§è¡Œè¿™ä¸ªæ“ä½œâ€çš„ä»£ç ã€‚

Here's aÂ [Redux Thunk](https://github.com/reduxjs/redux-thunk)Â example, where sometimes, we need to reach into some form ofÂ `global`Â state (maybe cached in a store) to make a decision.ä»¥ä¸‹æ˜¯ä¸€ä¸ª[Redux Thunk](https://github.com/reduxjs/redux-thunk)ç¤ºä¾‹ï¼Œåœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰æ—¶éœ€è¦è®¿é—®æŸç§å½¢å¼çš„`global`çŠ¶æ€ï¼ˆå¯èƒ½ç¼“å­˜åœ¨å­˜å‚¨ä¸­ï¼‰æ¥åšå‡ºå†³ç­–ã€‚

```tsx
// /todos/redux/thunks/createTodoIfNotExists.tsx

// Interaction example
export function createTodoIfNotExists (text: string) {
  return (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }

    ...
    // Validate
    // Request
  }
}
```

Alternatively, here's a React Hooks & Apollo Client example.  
æˆ–è€…ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ª React Hooks & Apollo Client çš„ç¤ºä¾‹ã€‚

/models/useTodos.tsx

```tsx
function useTodos (todos) {

  const createTodoIfNotExists = (text: string) => {
    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
    
    ...
    // Validate
    // Request
  }

  return { createTodoIfNotExists }
}

// Container
function Main () {
  const { data: todos } = useQuery(GET_ALL_TODOS);
  const { createTodoIfNotExists } = useTodos(todos);

  ...
}
```

### å®ƒåŒ…å«æ‚¨åº”ç”¨ç¨‹åºçš„æ“ä½œ
It contains your application's operations

Some refer to this layer as **app logic**, which works as well because these are all of the *operations* of your app. The interaction layer contains the discrete set of `commands` and `queries` that your users will carry out. These are the *use cases*.  
æœ‰äº›äººå°†è¿™ä¸€å±‚ç§°ä¸ºåº”ç”¨é€»è¾‘ï¼Œè¿™æ ·ç§°å‘¼ä¹Ÿæ˜¯åˆé€‚çš„ï¼Œå› ä¸ºè¿™äº›æ­£æ˜¯ä½ çš„åº”ç”¨çš„æ‰€æœ‰æ“ä½œã€‚äº¤äº’å±‚åŒ…å«äº†ç”¨æˆ·å°†æ‰§è¡Œçš„ä¸€ç³»åˆ—ç¦»æ•£çš„ `commands` å’Œ `queries` ï¼Œè¿™å°±æ˜¯ç”¨ä¾‹ã€‚

Having great visibility into these [use cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) enables us to get pretty structured with our integration testing as well. We can functionally test every use case with edge cases using Given-When-Then style tests.  
æ·±å…¥äº†è§£è¿™äº›ç”¨ä¾‹ä½¿æˆ‘ä»¬èƒ½å¤Ÿéå¸¸ç³»ç»Ÿåœ°å¼€å±•é›†æˆæµ‹è¯•ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Given-When-Then é£æ ¼çš„æµ‹è¯•æ¥å¯¹æ¯ä¸ªç”¨ä¾‹è¿›è¡ŒåŠŸèƒ½æµ‹è¯•ï¼ŒåŒ…æ‹¬è¾¹ç¼˜æƒ…å†µã€‚

For example:ä¾‹å¦‚ï¼š

- *Given* no todos exist, *when* I perform `CreateTodo`, *then* I should see one todo.  
	å¦‚æœæ²¡æœ‰å¾…åŠäº‹é¡¹ï¼Œå½“æˆ‘æ‰§è¡Œ `CreateTodo` æ—¶ï¼Œæˆ‘åº”è¯¥çœ‹åˆ°ä¸€æ¡å¾…åŠäº‹é¡¹ã€‚
- *Given* I have 3 completed todos and 1 uncompleted one, *when* I perform `CompleteAllTodos`, *then* I should have 4 completed todos.  
	æ—¢ç„¶æˆ‘æœ‰ 3 ä¸ªå·²å®Œæˆçš„å¾…åŠäº‹é¡¹å’Œ 1 ä¸ªæœªå®Œæˆçš„ï¼Œå½“æˆ‘æ‰§è¡Œ `CompleteAllTodos` æ—¶ï¼Œæˆ‘åº”è¯¥æœ‰ 4 ä¸ªå·²å®Œæˆçš„å¾…åŠäº‹é¡¹ã€‚

If you're familiar with [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) concepts, this is the [Application Service](https://khalilstemmler.com/articles/software-design-architecture/domain-driven-design-vs-clean-architecture/#Application-Services) equivalent.  
å¦‚æœä½ ç†Ÿæ‚‰é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDomain-Driven Designï¼‰çš„æ¦‚å¿µï¼Œé‚£ä¹ˆè¿™å°±æ˜¯åº”ç”¨æœåŠ¡ï¼ˆApplication Serviceï¼‰çš„å¯¹åº”æ¦‚å¿µã€‚

### å…±äº«è¡Œä¸º
Shared behavior 

This behavior is written to be used by any component. It contains the rules for how shared state is allowed to change.  
æ­¤è¡Œä¸ºè¢«è®¾è®¡ä¸ºå¯ä¾›ä»»ä½•ç»„ä»¶ä½¿ç”¨ã€‚å®ƒåŒ…å«äº†å…±äº«çŠ¶æ€å…è®¸å¦‚ä½•å˜åŒ–çš„è§„åˆ™ã€‚

At this level, we're often handling concerns like `auth`, `logging`, or even more *domain-specific* things like `todos`, `users`, `calendar`, or even `chess`.  
åœ¨è¿™ä¸ªå±‚æ¬¡ä¸Šï¼Œæˆ‘ä»¬ç»å¸¸å¤„ç†åƒ `auth` ã€ `logging` è¿™æ ·çš„é—®é¢˜ï¼Œç”šè‡³æ›´ç‰¹å®šäºé¢†åŸŸçš„äº‹æƒ…ï¼Œæ¯”å¦‚ `todos` ã€ `users` ã€ `calendar` ï¼Œç”šè‡³ `chess` ã€‚

Consider an interaction-layer React hook that contained all your chess game logic.  
è€ƒè™‘ä¸€ä¸ªåŒ…å«æ‰€æœ‰æ£‹ç›˜æ¸¸æˆé€»è¾‘çš„äº¤äº’å±‚ React é’©å­ã€‚

/hooks/useChess.tsx

```jsx
function useChess (todosAPI: ITodosAPI) {
  ...
  return { 
   operations: { makeMove, isValidMove, ... },
   models: { board, players, currentTurn }
  }
}
```

Read " [Domain-Driven GraphQL Schema Design](https://khalilstemmler.com/articles/graphql/ddd/schema-design/) " for the principles and practices for how to use event Storming to discover the subdomains within your app.  
é˜…è¯»ã€Šé¢†åŸŸé©±åŠ¨ GraphQL æ–¹æ¡ˆè®¾è®¡ã€‹äº†è§£ä½¿ç”¨äº‹ä»¶é£æš´å‘ç°åº”ç”¨ä¸­å­åŸŸçš„åŸåˆ™å’Œå®è·µã€‚

### å®ç°æ¨¡å‹çš„å…¶å®ƒæ–¹æ³•
Other ways to implement the model

Though most React developers will be comfortable writing their application/interaction layer logic using something like React Hooks, there's tons of other ways to implement the model.  
å°½ç®¡å¤§å¤šæ•° React å¼€å‘è€…ä¼šä½¿ç”¨ React Hooks ä¹‹ç±»çš„å·¥å…·æ¥ç¼–å†™ä»–ä»¬çš„åº”ç”¨å±‚/äº¤äº’å±‚é€»è¾‘ï¼Œä½†å®ç°æ¨¡å‹çš„æ–¹æ³•è¿˜æœ‰å¾ˆå¤šã€‚

- If you like to think of your model as a state machine, the [xState library](https://xstate.js.org/docs/recipes/react.html#hooks) does this exceptionally well and provides capabilities for you to plug your model instance into a React hook.  
	å¦‚æœä½ æƒ³æŠŠä½ çš„æ¨¡å‹çœ‹ä½œæ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼ŒxState åº“åœ¨è¿™æ–¹é¢è¡¨ç°å¾—éå¸¸å‡ºè‰²ï¼Œå¹¶æä¾›äº†ä¸€ç§å°†ä½ çš„æ¨¡å‹å®ä¾‹æ¥å…¥ React é’©å­çš„èƒ½åŠ›ã€‚
- For those who want to try to model their interaction layer using plain vanilla JavaScript, the [pojo-observer library](https://github.com/xolvio/pojo-observer) takes advantage of the fact that every client-app is an implementation of the observer pattern. Separating your model code from React hooks, it also provides a way to notify React that the model changed so a re-render is necessary.  
	å¯¹äºé‚£äº›æƒ³è¦å°è¯•ä½¿ç”¨çº¯ JavaScript æ¥å»ºæ¨¡äº¤äº’å±‚çš„äººæ¥è¯´ï¼Œpojo-observer åº“åˆ©ç”¨äº†æ¯ä¸ªå®¢æˆ·ç«¯åº”ç”¨éƒ½æ˜¯è§‚å¯Ÿè€…æ¨¡å¼å®ç°è¿™ä¸€äº‹å®ã€‚å®ƒå°†ä½ çš„æ¨¡å‹ä»£ç ä¸ React é’©å­åˆ†ç¦»ï¼ŒåŒæ—¶ä¹Ÿæä¾›äº†ä¸€ç§é€šçŸ¥ React æ¨¡å‹å·²æ›´æ”¹çš„æ–¹å¼ï¼Œä»è€Œç¡®ä¿å¿…è¦çš„é‡æ–°æ¸²æŸ“ã€‚

Someone once asked me [if it's possible to do DDD in the front-end](https://khalilstemmler.com/articles/typescript-domain-driven-design/ddd-frontend/). Initially, I said *no*, but after sometime thinking about it, it *totally is*. While the true high-level policy will always live on the backend, the interaction layer is comparable to the Application and *possibly* Domain layer in DDD.  
æœ‰äººæ›¾é—®æˆ‘æ˜¯å¦å¯ä»¥åœ¨å‰ç«¯åš DDDã€‚èµ·åˆæˆ‘è¯´ä¸è¡Œï¼Œä½†ç»è¿‡ä¸€æ®µæ—¶é—´æ€è€ƒåï¼Œå®Œå…¨å¯ä»¥ã€‚è™½ç„¶çœŸæ­£çš„é«˜å±‚ç­–ç•¥å§‹ç»ˆå­˜åœ¨äºåç«¯ï¼Œä½†äº¤äº’å±‚ç›¸å½“äº DDD ä¸­çš„åº”ç”¨å±‚ï¼Œç”šè‡³å¯èƒ½æ˜¯é¢†åŸŸå±‚ã€‚

### é€šå¸¸æœ‰å‡ ä¸ªå±‚
There are usually several layers

Most of the time, your app will have several of these **application / interaction** layers.  
é€šå¸¸æƒ…å†µä¸‹ï¼Œä½ çš„åº”ç”¨å°†åŒ…å«å¤šä¸ªè¿™äº›åº”ç”¨/äº¤äº’å±‚ã€‚

Here are some more examples of interaction layers that are commonly built out.  
è¿™é‡Œæ˜¯ä¸€äº›å¸¸è§çš„äº¤äº’å±‚æ„å»ºç¤ºä¾‹ã€‚

- **Examples of other interaction layers  
	å…¶ä»–äº¤äº’å±‚ç¤ºä¾‹**
	- Auth layer â€” Extremely common. Check out the [useAuth](https://github.com/Swizec/useAuth) library which implements Auth0 authentication and authorization as a React hook.  
		è®¤è¯å±‚ â€” éå¸¸å¸¸è§ã€‚å¯ä»¥æŸ¥çœ‹ useAuth åº“ï¼Œå®ƒå°† Auth0 è®¤è¯å’Œæˆæƒå®ç°ä¸º React é’©å­ã€‚
	- Logging â€” Sometimes it's important to. Luckily, there are many tools out there that can do this for you, but if you needed to build one yourself, it would exist as an entirely separate layer within your model.  
		æ—¥å¿—è®°å½• â€” æœ‰æ—¶è¿™å¾ˆé‡è¦ã€‚å¹¸è¿çš„æ˜¯ï¼Œæœ‰è®¸å¤šå·¥å…·å¯ä»¥ä¸ºä½ å®Œæˆè¿™é¡¹å·¥ä½œï¼Œä½†å¦‚æœä½ éœ€è¦è‡ªå·±æ„å»ºä¸€ä¸ªï¼Œå®ƒå°†ä½œä¸ºæ¨¡å‹ä¸­çš„ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„å±‚å­˜åœ¨ã€‚
	- Real-time subscriptions â€” Let's say you're subscribed to a stream of data. When a chunk comes in, you need to process it, and perhaps act on a `switch` statement to figure out if you should invoke a `command`. Keep your code clean by delegating this responsibility to a layer.  
		å®æ—¶è®¢é˜… â€” å‡è®¾ä½ è®¢é˜…äº†ä¸€ä¸ªæ•°æ®æµã€‚å½“æ•°æ®å—åˆ°è¾¾æ—¶ï¼Œä½ éœ€è¦å¤„ç†å®ƒï¼Œå¹¶å¯èƒ½æ ¹æ® `switch` è¯­å¥å†³å®šæ˜¯å¦è°ƒç”¨ `command` ã€‚é€šè¿‡å°†è¿™ä¸€è´£ä»»å§”æ‰˜ç»™ä¸€ä¸ªå±‚ï¼Œæ¥ä¿æŒä½ çš„ä»£ç æ•´æ´ã€‚
	- Complex rendering logic â€” I once worked on a project that built out really complex call flows for call centers using Angular and D3. Hundreds of different node types could be dragged and dropped onto a surface. When dropped, the way they connected to each other and how they could be used depended on the rendering and application logic, each decoupled from each other.  
		å¤æ‚çš„æ¸²æŸ“é€»è¾‘â€”â€”æˆ‘æ›¾ç»å‚ä¸è¿‡ä¸€ä¸ªé¡¹ç›®ï¼Œè¯¥é¡¹ç›®ä½¿ç”¨ Angular å’Œ D3 ä¸ºå‘¼å«ä¸­å¿ƒæ„å»ºäº†éå¸¸å¤æ‚çš„å‘¼å«æµç¨‹ã€‚æ•°ç™¾ç§ä¸åŒçš„èŠ‚ç‚¹ç±»å‹å¯ä»¥è¢«æ‹–æ”¾åˆ°ä¸€ä¸ªè¡¨é¢ä¸Šã€‚å½“å®ƒä»¬è¢«æ”¾ç½®æ—¶ï¼Œå®ƒä»¬å½¼æ­¤è¿æ¥çš„æ–¹å¼ä»¥åŠå®ƒä»¬å¦‚ä½•è¢«ä½¿ç”¨å–å†³äºæ¸²æŸ“å’Œåº”ç”¨é€»è¾‘ï¼Œæ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯ç›¸äº’è§£è€¦çš„ã€‚
	- Metadata layer â€” Imagine building a multiplayer video game where new prizes and weapons come out every week. How can we prevent hard-coding weapons and prizes?  
		å…ƒæ•°æ®å±‚ â€” æƒ³è±¡ä¸€ä¸‹ï¼Œæ­£åœ¨å¼€å‘ä¸€æ¬¾å¤šäººè§†é¢‘æ¸¸æˆï¼Œæ¯å‘¨éƒ½ä¼šæ¨å‡ºæ–°çš„å¥–å“å’Œæ­¦å™¨ã€‚æˆ‘ä»¬å¦‚ä½•æ‰èƒ½é¿å…ç¡¬ç¼–ç æ­¦å™¨å’Œå¥–å“å‘¢ï¼Ÿ

If you're curious about what a large-scale version of this looks like, check out [Twilio's video-app example](https://github.com/twilio/twilio-video-app-react) built with React hooks and context for global state.  
å¦‚æœä½ æƒ³çŸ¥é“è¿™ä¸ªå¤§å‹ç‰ˆæœ¬çš„æ ·å­ï¼Œå¯ä»¥çœ‹çœ‹ Twilio ç”¨ React hooks å’Œä¸Šä¸‹æ–‡æ„å»ºçš„å…¨å±€çŠ¶æ€è§†é¢‘åº”ç”¨ç¤ºä¾‹ã€‚

## ç½‘ç»œä¸æ•°æ®è·å–ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
Networking & data fetching (infrastructure)

> Performing API calls and reporting metadata state  
> æ‰§è¡Œ API è°ƒç”¨å’ŒæŠ¥å‘Šå…ƒæ•°æ®çŠ¶æ€

The responsibilities of a networking and data fetching layer are to:  
ç½‘ç»œå’Œæ•°æ®è·å–å±‚çš„èŒè´£æ˜¯ï¼š

- Know where the backend service(s) are  
	çŸ¥é“åç«¯æœåŠ¡åœ¨å“ªé‡Œ
- Formulate responses åˆ¶å®šå›åº”
- Marshal response data or errors  
	å“åº”æ•°æ®æˆ–é”™è¯¯
- Report async statuses (isLoading)  
	æŠ¥å‘Šå¼‚æ­¥çŠ¶æ€ï¼ˆisLoadingï¼‰

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/6a23ca46ddca9660ecbbb3f1c0e674e6_MD5.png]]

Jed Watson describes the async states that tell you about the status of a network request as **meta state** â€” state *about* state.  
æ°å¾·Â·æ²ƒæ£®å°†æè¿°ç½‘ç»œè¯·æ±‚çŠ¶æ€çš„å¼‚æ­¥çŠ¶æ€ç§°ä¸ºå…ƒçŠ¶æ€â€”â€”å…³äºçŠ¶æ€çš„çŠ¶æ€ã€‚

For example, in Apollo Client, the `loading` variable we deconstruct from the query response is a form of meta state.  
ä¾‹å¦‚ï¼Œåœ¨ Apollo Client ä¸­ï¼Œæˆ‘ä»¬ä»æŸ¥è¯¢å“åº”ä¸­è§£æ„çš„ `loading` å˜é‡æ˜¯ä¸€ç§å…ƒçŠ¶æ€ã€‚

```tsx
const { data, loading, error } = useQuery(GET_ALL_TODOS);
```

With Apollo Client, that's handled for us. Though if we were to use a more barebones approach, like Axios and Redux, we'd have to write this signaling code ourselves within a Thunk.  
ä½¿ç”¨ Apollo Clientï¼Œè¿™äº›éƒ½è¢«æˆ‘ä»¬å¤„ç†äº†ã€‚ä½†å¦‚æœæˆ‘ä»¬è¦ä½¿ç”¨æ›´ç²¾ç®€çš„æ–¹æ³•ï¼Œæ¯”å¦‚ Axios å’Œ Reduxï¼Œæˆ‘ä»¬å°±å¿…é¡»åœ¨ Thunk ä¸­è‡ªå·±ç¼–å†™è¿™ä¸ªä¿¡ä»¤ä»£ç ã€‚

```tsx
export function createTodoIfNotExists (text: string) {
  return async (dispatch, getState) => {
    const { todos } = getState();

    const alreadyExists = todos.find((t) => t === text);
    
    if (alreadyExists) {
      return;
    }
     
    // Signaling start
    dispatch({ type: actions.CREATING_TODO })

    try {
      const result = await todoAPI.create(...)
      
      // Signaling success
      dispatch({ type: actions.CREATING_TODO_SUCCESS, todo: result.data.todo })
    } catch (err) {
  
      // Signaling Failure
      dispatch({ type: actions.CREATING_TODO_FAILURE, error: err })
    }

  }
}
```

**Note**: The code example above is a demonstration of doing a little too much. Recall that a Redux Thunk is an interaction layer concern? That means it should *only* be responsible for the decision-making logic, and no *signalling* logic, since request signalling is a concern of the networking & data-fetching layer. It can be hard to establish these concrete boundaries sometimes. Especially if the library or framework wasn't designed with separation of concerns in mind.  
æ³¨æ„ï¼šä¸Šè¿°ä»£ç ç¤ºä¾‹æœ‰ç‚¹è¿‡äºå¤æ‚ã€‚å›æƒ³ä¸€ä¸‹ï¼ŒRedux Thunk æ˜¯ä¸€ä¸ªäº¤äº’å±‚çš„é—®é¢˜å—ï¼Ÿè¿™æ„å‘³ç€å®ƒåªåº”è¯¥è´Ÿè´£å†³ç­–é€»è¾‘ï¼Œè€Œä¸åº”åŒ…å«ä¿¡å·é€»è¾‘ï¼Œå› ä¸ºè¯·æ±‚ä¿¡å·æ˜¯ç½‘ç»œä¸æ•°æ®è·å–å±‚çš„é—®é¢˜ã€‚æœ‰æ—¶å€™å¾ˆéš¾æ˜ç¡®è¿™äº›å…·ä½“è¾¹ç•Œã€‚ç‰¹åˆ«æ˜¯å¦‚æœåº“æˆ–æ¡†æ¶åœ¨è®¾è®¡æ—¶æ²¡æœ‰è€ƒè™‘å…³æ³¨ç‚¹åˆ†ç¦»ã€‚

## çŠ¶æ€ç®¡ç† & å­˜å‚¨ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
State management & storage (infrastructure)

> Storage, updating data, reactivity  
> å­˜å‚¨ï¼Œæ›´æ–°æ•°æ®ï¼Œå“åº”æ€§

A state management library has *three* responsibilities:  
ä¸€ä¸ªçŠ¶æ€ç®¡ç†åº“æœ‰ä¸‰ä¸ªèŒè´£ï¼š

- **Storage** â€” Hold onto global state somewhere, usually in a store / client-side cache.  
	å­˜å‚¨ â€” å°†å…¨å±€çŠ¶æ€ä¿å­˜åœ¨æŸä¸ªåœ°æ–¹ï¼Œé€šå¸¸ä¿å­˜åœ¨ä¸€ä¸ªå­˜å‚¨åº“/å®¢æˆ·ç«¯ç¼“å­˜ä¸­ã€‚
- **Updating data** â€” Make changes to the data in the cache.  
	æ›´æ–°æ•°æ® â€” ä¿®æ”¹ç¼“å­˜ä¸­çš„æ•°æ®ã€‚
- **Reactivity** â€” Provide a way for view-layer presentation components to subscribe to data, and then re-render when data changes.  
	å“åº”æ€§ â€” æä¾›ä¸€ç§æ–¹å¼ï¼Œè®©è§†å›¾å±‚çš„å±•ç¤ºç»„ä»¶è®¢é˜…æ•°æ®ï¼Œå¹¶åœ¨æ•°æ®å˜åŒ–æ—¶é‡æ–°æ¸²æŸ“ã€‚

### çŠ¶æ€ç®¡ç†å’Œç½‘ç»œé€šå¸¸ä¸€èµ·è§£å†³
State management and networking are often solved together

State management is complex.  
çŠ¶æ€ç®¡ç†å¾ˆå¤æ‚ã€‚

Because it's complex, there are libraries out there to make life a little bit easier. Two of those libraries, Apollo Client and react-query, actually handle the *networking* part for you.  
å› ä¸ºå®ƒå¾ˆå¤æ‚ï¼Œæ‰€ä»¥æœ‰ä¸€äº›åº“å¯ä»¥ç®€åŒ–ç”Ÿæ´»ã€‚å…¶ä¸­ä¸¤ä¸ªåº“ï¼ŒApollo Client å’Œ react-queryï¼Œå®é™…ä¸Šä¼šä¸ºä½ å¤„ç†ç½‘ç»œéƒ¨åˆ†ã€‚

It can be preferable to choose a library instead of building out the state management machinery and *networking* layer manually.  
é€‰æ‹©ä¸€ä¸ªåº“è€Œä¸æ˜¯æ‰‹åŠ¨æ„å»ºçŠ¶æ€ç®¡ç†æœºåˆ¶å’Œç½‘ç»œå±‚å¯èƒ½æ›´å¯å–ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/f3bc522726fde79b7d01ed2718b52a9c_MD5.png]]

Apollo Client handles both the state management and data fetching concerns.  
Apollo Client å¤„ç†çŠ¶æ€ç®¡ç†å’Œæ•°æ®è·å–çš„é—®é¢˜ã€‚

### å…±äº«å…¨å±€çŠ¶æ€
Shared global state 

Two types of state exist at this layer. They are:  
è¿™ä¸€å±‚å­˜åœ¨ä¸¤ç§çŠ¶æ€ã€‚å®ƒä»¬æ˜¯ï¼š

- `remote (global)` state â€” The state that exists behind APIs in services. When we make `queries` for remote state, we hold onto a local copy of it accessible from a global scope.  
	`remote (global)` çŠ¶æ€ â€” å­˜åœ¨äºæœåŠ¡ API èƒŒåçš„çŠ¶æ€ã€‚å½“æˆ‘ä»¬åˆ›å»º `queries` è¿œç¨‹çŠ¶æ€æ—¶ï¼Œæˆ‘ä»¬æŒæœ‰å…¶æœ¬åœ°å‰¯æœ¬ï¼Œå¯ä»¥ä»å…¨å±€èŒƒå›´å†…è®¿é—®ã€‚
- `shared (global)`: We said earlier, "as soon as some state belongs to more than one component, it's *shared* global state". And you'll know you need this when **two components that rely on the same state don't need to know about each other**. To be clear, this type of state can be live in the interaction layer (via hooks and context, for example). Though sometimes, when working with `remote(global) state`, it's preferable to have something act as a single source of truth, especially if you need to mix remote and local state.  
	`shared (global)`: æˆ‘ä»¬ä¹‹å‰è¯´è¿‡ï¼Œâ€œä¸€æ—¦æŸä¸ªçŠ¶æ€å±äºå¤šä¸ªç»„ä»¶ï¼Œå®ƒå°±æ˜¯å…±äº«çš„å…¨å±€çŠ¶æ€â€ã€‚å½“ä½ å‘ç°ä¾èµ–ç›¸åŒçŠ¶æ€çš„ä¸¤ä¸ªç»„ä»¶ä¸éœ€è¦ç›¸äº’äº†è§£æ—¶ï¼Œä½ å°±ä¼šçŸ¥é“éœ€è¦ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚ä¸ºäº†æ˜ç¡®èµ·è§ï¼Œè¿™ç§çŠ¶æ€å¯ä»¥å­˜åœ¨äºäº¤äº’å±‚ï¼ˆä¾‹å¦‚é€šè¿‡é’©å­å’Œä¸Šä¸‹æ–‡ï¼‰ã€‚ä¸è¿‡ï¼Œåœ¨å¤„ç† `remote(global) state` æ—¶ï¼Œæœ‰æ—¶æœ€å¥½æœ‰ä¸€ä¸ªå•ä¸€çš„äº‹å®æ¥æºï¼Œç‰¹åˆ«æ˜¯å½“ä½ éœ€è¦æ··åˆè¿œç¨‹å’Œæœ¬åœ°çŠ¶æ€æ—¶ã€‚

### è¿œç¨‹å’Œæœ¬åœ°çŠ¶æ€çš„æ··åˆ
Mixture of remote and local state

We often cache remote state in a client-side cache or store. Since we do that, it's reasonable to try to use the store as a single source of truth. Often, we'd like to add some client-only local variables or pieces of state to the store as well.  
æˆ‘ä»¬ç»å¸¸å°†è¿œç¨‹çŠ¶æ€ç¼“å­˜åˆ°å®¢æˆ·ç«¯ç¼“å­˜æˆ–å­˜å‚¨ä¸­ã€‚æ—¢ç„¶æˆ‘ä»¬å·²ç»è¿™æ ·åšäº†ï¼Œé‚£ä¹ˆå°†å­˜å‚¨ç”¨ä½œå•ä¸€äº‹å®æ¥æºæ˜¯åˆç†çš„ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬è¿˜æƒ³å°†ä¸€äº›ä»…å®¢æˆ·ç«¯çš„æœ¬åœ°å˜é‡æˆ–çŠ¶æ€ç‰‡æ®µæ·»åŠ åˆ°å­˜å‚¨ä¸­ã€‚

Here's a Redux example of adding an `isSelected` attribute to each of the `todos` before merging to the store.  
è¿™é‡Œæœ‰ä¸€ä¸ª Redux ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•åœ¨åˆå¹¶åˆ°å­˜å‚¨ä¹‹å‰ï¼Œä¸ºæ¯ä¸ª `todos` æ·»åŠ ä¸€ä¸ª `isSelected` å±æ€§ã€‚

```tsx
switch (action.type) {
  ...
  case actions.GET_TODOS_SUCCESS:
    return {
      ...state,
      // Add some local state to the remote state before merging it
      // to the store
      todos: action.todos.map((t) => { ...t, isSelected: false })
    }
}
```

And in Apollo Client 3, here's the equivalent with cache policies and reactive variables.  
åœ¨ Apollo Client 3 ä¸­ï¼Œä»¥ä¸‹æ˜¯ä½¿ç”¨ç¼“å­˜ç­–ç•¥å’Œå“åº”å¼å˜é‡çš„ç­‰æ•ˆæ–¹æ³•ã€‚

```jsx
import { InMemoryCache } from "@apollo/client";

export const cache: InMemoryCache = new InMemoryCache({
  typePolicies: {
    Todo: {
      fields: {
        isSelected: {
          read (value, opts) {
            const todoId = opts.readField('id');
            const isSelected = !!currentSelectedTodoIds()
              .find((id) => id === todoId)
              
            return isSelected;
          }
        }
      }
    }
  }
});

export const currentSelectedTodoIds = cache.makeVar<number[]>([]);
```

We can configure a way to request `remote` state and *client-only* `shared` local state in the same query.  
æˆ‘ä»¬å¯ä»¥é…ç½®ä¸€ç§æ–¹å¼ï¼Œåœ¨åŒä¸€æŸ¥è¯¢ä¸­è¯·æ±‚ `remote` çŠ¶æ€å’Œå®¢æˆ·ç«¯ä¸“ç”¨çš„ `shared` æœ¬åœ°çŠ¶æ€ã€‚

```tsx
export const GET_ALL_TODOS = gql\`
  query GetAllTodos {
    todos { 
      id  
      text  
      completed
      isSelected @client
    }
  }
\`
```

### å­˜å‚¨ç«‹é¢
Storage facades 

Most of the time we don't provide direct access to whats stored within the *store*. Usually, there's some *facade*, an API, that sits in-front of the data and provides ways for us to interact with it.  
å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬ä¸ä¼šç›´æ¥æä¾›å¯¹å­˜å‚¨åœ¨å­˜å‚¨ä¸­çš„å†…å®¹çš„è®¿é—®ã€‚é€šå¸¸ï¼Œä¼šæœ‰ä¸€ä¸ªå¤–è§‚æ¨¡å¼ï¼ˆfacadeï¼‰ï¼Œå³ APIï¼Œå®ƒä½äºæ•°æ®å‰é¢ï¼Œä¸ºæˆ‘ä»¬æä¾›ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ã€‚

In Redux, this is `dispatch` (for updates) and connect (for reactivity).  
åœ¨ Redux ä¸­ï¼Œè¿™æ˜¯ `dispatch` ï¼ˆç”¨äºæ›´æ–°ï¼‰å’Œ connectï¼ˆç”¨äºå“åº”å¼ï¼‰ã€‚

In Apollo Client, this is `useMutation` (for updates) and `useQuery` (for reactivity).  
åœ¨ Apollo Client ä¸­ï¼Œè¿™æ˜¯ `useMutation` ï¼ˆç”¨äºæ›´æ–°ï¼‰å’Œ `useQuery` ï¼ˆç”¨äºå“åº”å¼ï¼‰ã€‚

Even SQL is a form of a storage facade. It's a powerful pattern.  
å³ä½¿æ˜¯ SQL ä¹Ÿæ˜¯ä¸€ç§å­˜å‚¨å¤–è§‚æ¨¡å¼ã€‚è¿™æ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ¨¡å¼ã€‚

![[_posts/architect/_æ•™ç¨‹/Client-Side Architecture Basics/media/f986e1537c231dfadb646c93c6acf8b9_MD5.png]]

---

