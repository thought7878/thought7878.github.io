---
title: "I. Architecture | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/client-side-architecture/architecture/"
author:
  - "[[Khalil Stemmler]]"
published: 2020-06-24
created: 2025-10-06
description: "Advanced TypeScript & Node.js guides for large-scale applications. Learn to write flexible, maintainable TypeScript."
tags:
  - "clippings"
---
[Welcome](https://khalilstemmler.com/articles/client-side-architecture/introduction) [I. Architecture](https://khalilstemmler.com/articles/client-side-architecture/architecture) [II. Principles](https://khalilstemmler.com/articles/client-side-architecture/principles) [III. Layers](https://khalilstemmler.com/articles/client-side-architecture/layers) [IV. Conclusion](https://khalilstemmler.com/articles/client-side-architecture/conclusion)  
欢迎 I. 架构 II. 原则 III. 层级 IV. 结论

Last updated Jun 24th, 2020  
最后更新于 2020 年 6 月 24 日

![[_posts/architect/_教程/Client-Side Architecture Basics/media/67d14cf25c4dc6b294b8fbe8451e6cb0_MD5.png]]

> This is page one of a guide on Client-Side Architecture basics.  
> 这是关于客户端架构基础指南的第一页。

## 我们需要客户端架构标准的原因
Why we need a client-side architecture standard

Allow me to paint the picture of why we need a better client-side architecture. To start, let's look at the foundation we're all currently working on top of.  
让我描绘一下我们需要更好的客户端架构的原因。首先，让我们看看我们目前都在其上工作的基础。

### Model-View controller 
模型-视图-控制器

You've probably heard of **[Model-View-Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)**, the architectural pattern that describes how to design apps involving user interfaces.  
你很可能听说过模型-视图-控制器，这是一种描述涉及用户界面的应用程序如何设计的架构模式。

**MVC** says that we should split our application into *model*, *view*, and *controller* layers. This is so each layer can focus on their own respective responsibilities.  
MVC 认为我们应该将应用程序分为模型、视图和控制器层。这样每一层都可以专注于各自的责任。

- The model handles data and logic  
	模型处理数据和逻辑
- The view handles presentation  
	视图处理展示
- and the controller turns user events into changes to the model  
	控制器将用户事件转换为对模型的更改

![[_posts/architect/_教程/Client-Side Architecture Basics/media/a0cf746175dba3d05d65c596cab30605_MD5.png]]

Model-view-controller architectural pattern. Used to separate the concerns between a client-side web app and backend services.  
模型-视图-控制器架构模式。用于分离客户端网页应用和后端服务之间的关注点。

Most full-stack apps are comprised of a **client-side portion,** utterly separate from **backend services**. When users ask to make a change from the UI, it makes things happen by interacting with the backend through some API: in MVC, the API is the *controller*.  
大多数全栈应用由一个与后端服务完全分离的客户端部分组成。当用户从界面请求进行更改时，它通过与后端通过某个 API 交互来实现：在 MVC 中，API 就是控制器。

This works! And we like it. At least, we *must* — it's one of the first architectural patterns we teach to new developers learning how to build full-stack apps.  
这有效！而且我们喜欢它。至少，我们必须喜欢——它是我们教新开发者如何构建全栈应用时最早介绍的一种架构模式。

### Model-View presenter 
模型-视图-呈现者

Where *Model-View-Controller* explained how to separate the concerns of a **full-stack web application**, [Model-View Presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter), a derivation of MVC, told us how to separate the concerns of **the client part**.  
模型-视图-控制器解释了如何分离全栈 Web 应用的关注点，而模型-视图-呈现者作为 MVC 的衍生，告诉我们如何分离客户端部分的关注点。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/627f3599f3956086c53b8b1353f51839_MD5.png]]

Model-View-Presenter is the architectural pattern typically used within client applications. It's a derivation of the MVC pattern.  
模型-视图-呈现者是通常在客户端应用中使用的架构模式。它是 MVC 模式的一种衍生。

In *Model-View-Presenter*, the **view** creates user events.  
在模型-视图-呈现器模式中，视图创建用户事件。

Those user events get turned into **updates** or **changes** to the model.  
这些用户事件会被转换为对模型的更新或变更。

When the **model** changes, the **view** is updated with the new data.  
当模型发生变化时，视图会使用新数据更新。

It's heartening to realize that **every client app uses some form of the model-view presenter pattern**.  
令人欣慰的是，每个客户端应用程序都使用某种形式的模型-视图-呈现器模式。

### MVC 和 MVP 过于泛化
MVC & MVP are too generic

MVC and MVP are great starters. They give you a *good enough* understanding of the communication pathways from a 5000-ft view.  
MVC 和 MVP 是非常好的入门选择。它们让你从 5000 英尺的高度对通信路径有一个足够清晰的理解。

Unfortunately, they both suffer from the same problem: being *too generic*.  
不幸的是，它们都存在同一个问题：过于泛化。

In both MVC and MVP, **the biggest challenge is that the `M` is responsible for way too much**.  
在 MVC 和 MVP 中，最大的挑战是 `M` 承担了太多责任。

As a result, developers don't know *which tools* are responsible for *which tasks*.  
因此，开发者不知道哪些工具负责哪些任务。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/43afb088e23d8d680fe383536a5f5822_MD5.png]]

In MVC and MVP, the model is ambiguous. This makes matching the correct tool up to the task feel like a puzzle.  
在 MVC 和 MVP 中，模型是模糊的。这使得将正确的工具与任务相匹配感觉像是一个谜题。

### 模型的任务
Tasks of the model

In the real world, the model portion in most client-side web apps does a lot.  
在现实世界中，大多数客户端 Web 应用中的模型部分做很多事情。

**State management —** Most apps need a way to fetch state, update state, and configure reactivity to when state changes, the *view* can re-render.  
状态管理——大多数应用需要一个方法来获取状态、更新状态，并配置当状态变化时视图可以重新渲染。

**Networking & data fetching —** The actual *data-fetching* concern is sometimes conflated as part of the model. The data fetching and networking aspect of an app need to know about backend services, formulate requests, handle responses, and marshal data, but it also needs to signal request *metadata* (ie: `isLoading`, `error`). What about features like optimistic updates? Is that a concern of the model? I think it is.  
网络与数据获取 — 实际的数据获取问题有时会被混同为模型的一部分。应用的数据获取和网络方面需要了解后端服务、构建请求、处理响应和整理数据，但它还需要传递请求元数据（例如： `isLoading` ， `error` ）。对于乐观更新等特性呢？这是模型的问题吗？我认为是的。

**Model behavior (ie: domain, app, or interaction logic) —** Deciding what happens next when a user clicks *submit*, or wants to interact with something on the page is a form of *[interaction logic](https://khalilstemmler.com/articles/client-side-architecture/layers#Interaction-layer)*. Sometimes there are rules we need to enforce. They can be simple — like validation before sending off an API call. They can be complicated — like deciding if a chess piece can be dropped on the selected square. Some call this *app logic*, which I believe to be sufficient since it describes how our app responds to user events. Alternatively, I call it *interaction logic* because it explains what happens in response to *user interaction*. There's one other kind of logic here, and that's *domain logic*. Domain logic doesn't normally have anything to do with the application itself. Instead, it originates from an understanding of the domain. For example, while displaying a modal *before move a chess piece* might be **application/interaction logic**, enforcing the policy that *a knight can only move in an L-shaped fashion* is a form of **domain logic**. That rule originates from understanding the domain of *chess* where the application-specific logic holds rules about how the user interacts with the app. Usually, domain logic lives behind backend services, and if we break the rules, we can get an error back as a response. Still, sometimes we co-locate it on the client-side, especially for more complex applications.  
模型行为（即：领域、应用或交互逻辑）— 当用户点击提交或想要与页面上的某物交互时，决定接下来会发生什么是一种交互逻辑。有时我们需要执行规则。它们可以是简单的——比如在发送 API 调用之前进行验证。它们也可以是复杂的——比如判断棋子是否可以放在选定的方格上。有些人称之为应用逻辑，我认为这足够了，因为它描述了我们的应用如何响应用户事件。或者，我称之为交互逻辑，因为它解释了在响应用户交互时会发生什么。这里还有另一种逻辑，那就是领域逻辑。领域逻辑通常与应用本身无关。相反，它源于对领域的理解。例如，在移动棋子之前显示一个模态框可能是应用/交互逻辑，而强制执行骑士只能以 L 形移动的政策是一种领域逻辑。这条规则源于对棋类领域的理解，而应用特定的逻辑则包含有关用户如何与应用交互的规则。 通常，领域逻辑存在于后端服务中，如果我们违反规则，可能会收到一个错误作为响应。但有时，我们会将其放在客户端，尤其是对于更复杂的应用程序。

**Authentication & authorization logic (specific type of model behavior) —** This is another specific type of model behavior, but it's common enough to mention. Most of the time, authN & authR finds itself being used from within the view layer (show *Login screen if not authenticated*). Sometimes, it manifests in the **application/interaction** layer as well, preventing access to specific operations.  
认证与授权逻辑（特定类型的模型行为）— 这也是一种特定类型的模型行为，但足够常见，值得提及。大多数情况下，认证与授权逻辑会从视图层使用（如果未认证，则显示登录屏幕）。有时，它也会在应用层或交互层中体现，阻止对特定操作的访问。

### 模型中使用的工具
Tools used within the model

These are all common challenges to solve. In 2020, the developer toolbox for a React developer looks a little something like this:  
这些都是常见的挑战。2020 年，React 开发者的工具箱看起来有点像这样：

- React hooks
- Redux
- Context API
- Apollo Client
- xState
- react-query
- and now, recoil

Each of these are capable of addressing a particular piece of the *ambiguous model* we described, but matching the correct tool to the proper concern can be tricky.  
这些都能解决我们描述的那种模糊模型中的特定部分，但将正确的工具与适当的问题相匹配可能很棘手。

Of course, it's tricky. We don't have a standard language to describe the different concerns. Instead of thinking about the tools right away, I think we need to back up and look at the bigger picture of the problems to be solved.  
当然，这很棘手。我们没有一种标准语言来描述不同的关注点。与其一开始就考虑工具，我认为我们需要退一步，看看要解决的问题的整体情况。

## 我们需要一种共同的语言来讨论客户端架构
We need a shared language to talk about client-side architecture

We need a shared language to describe these architectural concepts upon which we either:  
我们需要一种共同的语言来描述这些架构概念，我们要么：

- Configure a library or a framework to solve  
	配置一个库或框架以解决
- Write the code ourselves for  
	我们自己编写代码

Most React developers know the implementation-specific terminology like hooks, reducers, context, and props, but architectural concerns are sometimes misunderstood.  
大多数 React 开发者都熟悉特定的术语，如 hooks、reducers、context 和 props，但架构问题有时会被误解。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/d9ad71c71a140be7893a6e05447dcc19_MD5.png]]

Having a shared understanding of what constitutes **client-side architecture concerns** enables us to:  
对构成客户端架构问题的共同理解使我们能够：

- Have better design conversations  
	进行更好的设计对话
- Communicate which concerns are addressed by which tool  
	说明哪些工具解决了哪些问题
- Avoid code from concerns creeping too profoundly into another  
	避免代码从某个问题领域过度渗透到另一个领域

If we can, as a community, communicate a shared understanding of the concerns that make up the model (and the other parts), I think we can more easily answer questions like this:  
如果我们能作为一个社区，就构成模型（以及其他部分）的问题领域达成共识，我认为我们能够更轻松地回答这类问题：

- Where do we put *application logic* in a React/Redux app? What about an Apollo Client one? What about a \[insert new library/framework here\] one?  
	在 React/Redux 应用中，我们如何放置应用逻辑？Apollo Client 呢？还有\[插入新的库/框架\]呢？
- Should I use container components?  
	我应该使用容器组件吗？
- Should I put my GraphQL mutations inside of my component?  
	我应该把我的 GraphQL 变异放在组件里面吗？
- Do I need to write tests for Apollo Client? Redux?  
	我需要为 Apollo Client 和 Redux 写测试吗？
- What kind of logic should I put in a React hook?  
	我应该把什么样的逻辑放在 React 钩子里面？

I've got good news for you...  
我有个好消息要告诉你...

## 我们已经解决了这个问题
We've already solved this problem

Let's not discredit the software design and architecture research done over the last 30 years.  
让我们不要贬低过去 30 年里所做的软件设计和架构研究。

While the tools and approaches to web development have changed at a miraculous pace, **software design** **principles and patterns have remarkably, remained the same**.  
虽然网页开发工具和方法以惊人的速度变化，但软件设计原则和模式却显著地保持不变。

**Knowledge drain**: When (domain, trade, scientific) knowledge is lost or forgotten over time.  
知识流失：当（领域、商业、科学）知识随着时间的推移而丢失或被遗忘时。

Let's look at backend development.  
让我们看看后端开发。

How did we solve the *ambiguous model* problem when building out backend services?  
在构建后端服务时，我们是如何解决模糊模型问题的？

Initially, with MVC on the server, we thought the model could be *services*, [ORM](https://sequelize.org/) s, or even the *database* itself*.* Each of these are *part* of the model, but they're not the entire model.  
最初，在服务器上使用 MVC 时，我们认为模型可以是服务、ORM，甚至数据库本身。这些都是模型的一部分，但它们并不是整个模型。

According to [wikipedia](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), the **model** is supposed to represent the **data, logic, and any rules of the application**.  
根据维基百科，模型应该表示数据、逻辑以及应用程序的任何规则。

When backend developers discovered that [MVC doesn't provide enough insight as to how to structure the *model* portion](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/), we used design principles to create more advanced architectures, like the [clean architecture](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/clean-nodejs-architecture/).  
当后端开发人员发现 MVC 无法提供足够的见解来指导模型部分的结构时，我们利用设计原则创建了更高级的架构，例如整洁架构。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/157cbdc64735dbe8b8a5313d21369d55_MD5.png]]

The clean architecture sheds more light on how to structure your backend in a testable and flexible way. It also helps accommodate for more advanced applications containing business logic.  
整洁架构更清晰地阐述了如何以可测试和灵活的方式构建后端。它还有助于适应包含业务逻辑的更高级的应用。

The *clean architecture* (which has many similar variants — see layered, [hexagonal architecture](https://khalilstemmler.com/articles/graphql/graphql-architectural-advantages/), or ports & adapters) provides specifics as to what the `M` in the model is.  
整洁架构（它有许多类似的变体——参见分层架构、六边形架构或端口与适配器）具体说明了模型中的 `M` 是什么。

By splitting the model into **infrastructure,****application,** and **domain** layers, we exercise the **separation of concerns** design principle, and we're left with a much easier to reason about architecture.  
通过将模型分为基础设施层、应用层和领域层，我们实践了关注点分离的设计原则，从而得到一个更容易理解的架构。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/9d9df61c12209120479dccdf3188ac9d_MD5.png]]

The middle layers (domain and application) are the purest. It's the code that *we,* the developers, **have to write from scratch**. And since our app doesn't do much unless we can hook it up to the real-world using things like web servers, databases, APIs, and caches, the *adapter layer* provides a flexible way to integrate those **infrastructural dependencies into our app, while keeping them distanced** from our domain and app layer code.  
中间层（领域和应用层）是最纯粹的。这是我们开发者必须从头编写代码的地方。而且，由于我们的应用程序如果不通过 Web 服务器、数据库、API 和缓存等与现实世界连接，就无法做太多事情，因此适配器层提供了一种灵活的方式来将那些基础设施依赖集成到我们的应用程序中，同时保持它们与我们的领域和应用层代码分离。

To learn more about the clean architecture read [Organizing App Logic with the Clean Architecture \[with Examples\]](https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/).  
要了解更多关于干净架构的内容，请阅读《使用干净架构组织应用逻辑\[带示例\]》。

---

A layered architecture like this comes at the cost of being more *complex* than a simple single-tiered one, but let's be honest — **sometimes we have to solve some *damn* hard problems**.  
这种分层架构的代价是比简单的单层架构更复杂，但说实话——有时候我们不得不解决一些极其棘手的问题。

A *layered* architecture has a lot of benefits:  
分层架构有很多好处：

- It makes it **extremely clear** which tools are needed at which layer of the stack.  
	它使我们需要在堆栈的哪一层使用哪些工具变得极其清晰。
- It keeps concerns separate and enables you to **keep your app and domain layer code unit testable.**  
	它将关注点分离，并使你的应用和领域层代码保持可测试性。
- It allows you to mock out expensive to test things, **and swap libraries and frameworks** (not that you do that too often — but, in case you ever needed to, you can).  
	它允许你模拟出测试成本高的事物，并替换库和框架（虽然你不太经常这么做——但，如果你真的需要，你可以）。

That's hella cool.这太酷了。

Quick question.快速问一下。

> **Where's our *client-side* version of this?  
> 我们这个客户端版本在哪里？**

## 客户端需求——可测试性、灵活性和可维护性
Client-side needs — testability, flexibility, and maintainability

Let's back up a bit.  
让我们稍微后退一步。

Before we discuss an equivalent client-side architecture, let's talk about our needs first.  
在讨论一个等效的客户端架构之前，让我们先谈谈我们的需求。

We don't want to dogmatically copy the clean architecture.  
我们不想教条式地复制干净架构。

What are we *really* looking for when we talk about *architecture* on the client-side? Why does any of this matter? Why don't we just write all of our code in a single file (actually, some of us *do* write single file components)? Is architecture about *file organization*, or is it about something more?  
当我们谈论客户端架构时，我们真正在寻找什么？这一切为什么重要？我们为什么不把所有代码都写在同一个文件里（实际上，有些人确实写单文件组件）？架构是关于文件组织，还是关于更深层的东西？

> **It's about writing testable, flexible, and maintainable code**.  
> 它关乎编写可测试、灵活且可维护的代码。

### 可测试性
Testability 

I've noticed that an alarming amount of developers don't write tests for their front-end code.  
我注意到有大量开发者不为其前端代码编写测试。

It could be a conscious decision of *choosing* not to write tests — which is one thing, but it could also be a lack of education for how to write code so that it can **be tested**.  
这可能是有意选择不编写测试——这本身没什么，但它也可能是缺乏如何编写可测试代码的教育。

I've found that depending on your testing strategy, your needs to separate concerns changes. **If you're only going to be writing integration tests, then separation of concerns matters less**. **If you're going to be writing a lot of unit tests, then mocking is going to be your saving grace, and separation of concerns is paramount**.  
我发现，根据你的测试策略，你分离关注点的需求会变化。如果你只打算编写集成测试，那么分离关注点就不那么重要。如果你打算编写大量单元测试，那么模拟将是你的救命稻草，而分离关注点则是至关重要的。

If you understand the app you're building and the complexity of it, you can kind-of gauge this upfront.  
如果你了解你正在构建的应用及其复杂性，你可以在一开始就大致判断这一点。

### 何时编写单元测试+
When to write unit tests 

Unit testing is the preferred approach for testing your client app if there's a **heavy amount of interaction/app logic**, like a metadata layer in a 3D rendered game, chess game logic, a boating application, or a streaming site like Twitch.  
单元测试是测试客户端应用程序的首选方法，如果存在大量交互/应用逻辑，例如 3D 渲染游戏中的元数据层、国际象棋游戏逻辑、航海应用程序或 Twitch 等流媒体网站。

If the accuracy of the most important use cases cannot be verified by merely observing the side effects in the view, then unit tests are the way to go.  
如果最重要的使用场景的准确性不能仅仅通过观察视图中的副作用来验证，那么单元测试就是最佳选择。

### 何时编写集成测试+
When to write integration tests 

Kent C. Dodds recommends integration tests when 90% of your users' primary use cases can be tested against by observing changes to the view in response to user interaction. In this case, we're talking about basic CRUD apps.  
Kent C. Dodds 建议在 90%的用户主要用例可以通过观察视图对用户交互的响应来进行测试时进行集成测试。在这种情况下，我们指的是基本的 CRUD 应用程序。

The view is an implementation detail, and it's recommended to not test against implementation details. [Testing library](https://testing-library.com/) provides an excellent suite of tools to run integration tests on React apps through the view without focusing on implementation details.  
视图是一个实现细节，不推荐针对实现细节进行测试。测试库提供了一套出色的工具，可以通过视图在 React 应用上运行集成测试，而无需关注实现细节。

### 灵活性
Flexibility 

It's not so often that we need to switch from REST to GraphQL or swap out APIs, but there are a select few cases that we should enable flexibility for.  
我们很少需要从 REST 切换到 GraphQL 或更换 API，但确实有一些特定情况需要我们提供灵活性。

**Swapping out view components —** Keeping app logic out of your presentational components allows you to swap out how the component looks from how it works, as painlessly as humanly possible.  
更换视图组件——将应用逻辑与展示组件分离，可以让你尽可能轻松地更换组件的外观而不影响其功能。

**Changing model behavior —** If your app is the interaction-logic heavy kind of app that needs lots of unit tests, using [dependency inversion](https://khalilstemmler.com/articles/tutorials/dependency-injection-inversion-explained/) to mock out API and framework code enables you to run fast tests against the behavior of the model.  
改变模型行为——如果你的应用是交互逻辑密集型且需要大量单元测试的应用，使用依赖倒置来模拟 API 和框架代码能够让你针对模型的行為运行快速测试。

### 可维护性
Maintainability 

Maintainability is our ability to constantly provide value. If we struggle to change code or add new features, maintainability is low.  
可维护性是我们持续提供价值的能力。如果我们难以更改代码或添加新功能，可维护性就低。

It's worthy to note that if developer experience is low, there's a *chance* maintainability is low as well.  
值得注意的是，如果开发者体验差，可维护性也有可能低。

Here's an argument to challenge everything I've praised about a *clean architecture* so far. Looking at it from another point of view, *too many layers* and *too many rules* traditionally yields low developer experience for newer developers less familiar with the approach.  
这里有一个观点来挑战我之前所赞扬的整洁架构。从一个不同的角度来看，传统上过多的层和过多的规则会为不太熟悉这种方法的新开发者带来较差的开发者体验。

This might be why so many new developers prefer to use React over Angular. Angular is actually quite opinionated and forces you towards a particular style of architecture. React lets you do whatever.  
这可能就是为什么许多新开发者更倾向于使用 React 而不是 Angular。Angular 实际上相当有主见，并迫使你采用特定的架构风格。React 则让你可以随心所欲。

There's a balance to be struck here. We want the structure of architecture, but we want the developer experience of knowing what to do and having the freedom to do it however we want.  
这里需要权衡。我们想要架构的结构，但也想要开发者体验——知道该做什么，并拥有自由选择实现方式的权力。

> **Design** is the balance of conflicting priorities  
> 设计是冲突优先级的平衡

> Office furniture = cost vs. quality  
> 办公家具 = 成本与质量

> Note-taking = context vs. compression  
> 做笔记 = 上下文 vs. 压缩  
> — Tiago Forte

And more relevant to us:  
而且与我们更相关的是：

> Software design = structure vs. developer experience  
> 软件设计 = 结构 vs. 开发者体验

I believe that developers who care not only about getting the job done but also getting it done *right* will push through learning curves.  
我相信那些不仅关心完成任务，而且关心如何正确完成任务的开发者会克服学习曲线。


---

