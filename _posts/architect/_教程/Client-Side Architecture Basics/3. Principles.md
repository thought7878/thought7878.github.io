---
title: "II. Principles | Khalil Stemmler"
source: "https://khalilstemmler.com/articles/client-side-architecture/principles/"
author:
  - "[[Khalil Stemmler]]"
published: 2020-06-24
created: 2025-10-07
description: "Advanced TypeScript & Node.js guides for large-scale applications. Learn to write flexible, maintainable TypeScript."
tags:
  - "clippings"
---
Last updated Jun 24th, 2020  
最后更新于 2020 年 6 月 24 日

![[_posts/architect/_教程/Client-Side Architecture Basics/media/5d1c14d8530bb38da9fdf9442137b346_MD5.png]]

> This is page two of a guide on Client-Side Architecture basics. Start at [page one](https://khalilstemmler.com/articles/client-side-architecture/introduction).  
> 这是关于客户端架构基础指南的第二页。从第一页开始。

## 最具影响力的客户端架构设计原则
The most influential client-side architecture design principles

While the *clean architecture* works, we don't need a copy of it on the client-side. However, I *do* think it's a good idea to look at the same design principles and practices that formed it and apply those to the client.  
*虽然整洁架构有效，但我们不需要在客户端复制它。然而，我认为查看形成它的相同设计原则和实践，并将这些应用于客户端是个好主意。*

You'll notice that each principle, in some way, is about enforcing some structural constraints as to what can be done, and how things are organized.  
你会注意到，*每个原则在某种程度上都是关于强制执行某些结构约束，以决定可以做什么，以及如何组织事物*。

In my opinion, these are the **most crucial** design principles. They influence 90% of what constitutes good client-side architecture.  
在我看来，*这些是最关键的设计原则。它们影响着构成良好客户端架构的 90%。*

- Command-Query Separation  
	**命令-查询分离**
- Separation of Concerns **关注点分离**

## 命令查询分离（读写分离）
Command Query Separation

> Separate methods that change state from those that don't  
> **将改变状态的方法与不改变状态的方法分开**

Command Query Separation is a design principle that states that an operation is either a `command` or a `query`.  
`命令查询分离`是**一种设计原则，它指出一个操作要么是 `command` ，要么是 `query` 。**

- `commands` change state but return no data, and  
	`commands` **改变状态但不返回数据**，和
- `queries` return data but don't change state.  
	`queries` **返回数据但不改变状态**。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/a659572e32e4354ebcdeb2ecfeaa6f04_MD5.png]]

**Operations** are the same thing as *interactions*.  
操作与交互是同一回事。

The primary benefit of this pattern is that it makes code **easier to reason about**. Ultimately, it urges us to carve out two code paths: one for *reads*, and one for *writes*.  
**`这种模式的主要好处`是使代码更易于理解。最终，它促使我们*划分两条代码路径：一条用于读取，一条用于写入*。**

The simplest way to see it in action is at the *method-level.*  
最直观地看到它的方式是*在方法级别*。

### 命令
Commands

Consider the methods `createUser` and `selectTodo`. These are both `command` -like operations.  
考虑 `createUser` 和 `selectTodo` *这两种方法*。它们都是 `command` 类似的操作。

```tsx
function createUser (props: UserDetails): Promise<void> { ... }
function selectTodo (todoId: number): void { ... }
```

Notice that neither of these methods return anything. They're both `void`. That's what a valid `command` is.  
请注意，*这两种方法都不返回任何内容*。它们都是 `void` 。*这就是一个有效的 `command` 的样子*。

That means that the following methods aren't valid commands.  
这意味着*以下方法不是有效的命令*。

```tsx
function createUser (): Promise<User> { ... }
function selectTodo (): Todo { ... }
```

### 查询
Queries

Queries are operations that return data and perform no side-effects. Like these, for example:  
`查询`是*返回数据而不产生副作用的操作*。例如这些：

```tsx
function getCurrentUser (): Promise<User> { ... }
function getUserById (userId: UserId): Promise<User> { ... }
```

### 这有什么关系？
Why does it matter?

- Simplifies the code paths — this is what React hooks does with the accessor/mutator API of `useState`, and what GraphQL does with `queries` and `mutations`.  
	**简化了代码路径**——*这就是 React hooks 通过 `useState` 的访问器/修改器 API 实现的效果*，以及 GraphQL 通过 `queries` 和 `mutations` 实现的效果。
- Operations are easier to reason about — consider how hard (and disastrous) it would be to test a `query` was working properly if it always also performed a side-effect that changed the state of the system.  
	**操作更容易推理**——想想看，*如果 `query` 总是执行一个改变系统状态的副作用，测试它是否正常工作该有多困难（以及多么灾难性）*。
- All *features* can be thought about as operations: `commands` or `queries`. If you want to make sure that all your features have integration tests, ensure a good separation of `commands` and `queries` that the user performs, and test each one. One other interesting discovery: since most **pages/routes** in your app invoke one or more *features,* a potentially maintainable folder structure could be formed by [co-locating](https://kentcdodds.com/blog/colocation) all the concerns and components by features, and then by page/route. The folks behind React Router seem to be on a similar *page* (sorry); their new project, [Remix](https://remix.run/), features file system routes and route layout nesting.  
	**所有功能都可以被视为操作： `commands` 或 `queries`** 。如果你想*确保所有功能都有集成测试*，确保用户执行的操作 `commands` 和 `queries` 之间有良好的分离，并测试每一个。另一个有趣的发现是：由于你的应用中的大多数页面/路由会调用一个或多个功能，*通过按功能集中所有关注点和组件*，然后按页面/路由组织，可能会*形成一种潜在的易维护的文件夹结构*。React Router 的开发者似乎也有类似的想法（抱歉）；他们的新项目 Remix 支持文件系统路由和路由布局嵌套。
- Apparently, cache invalidation is one of the hardest problems in computer science. It's easier with this. Using CQS, we can be sure that when if no new `commands` were executed (against a particular item), we can continue to perform `queries` for directly from the cache. The moment a `command` is executed, we invalidate the item in the cache. Consider how this might be useful for a state management library.  
	显然，缓存失效是计算机科学中最难的问题之一。有了这个方法，就更容易了。*使用 CQS，我们可以确保如果没有执行新的 `commands` （针对特定项目），我们可以直接从缓存中继续执行 `queries` 。一旦执行了 `command` ，我们就使缓存中的项目失效。考虑一下这对状态管理库可能有多有用。*

## 关注点分离
Separation of Concerns 

> Consciously enforcing logical boundaries between each of the architectural concerns of your app  
> 有意识地在你应用的每个架构关注点之间强制逻辑边界

Assume we have a list of todos.  
假设我们有一个待办事项列表。

When a user clicks *delete* on the todo, what happens next?  
当用户点击删除待办事项时，接下来会发生什么？

```tsx
export const Todo = (props) => (
  <div className="todo">
    <div class="todo-text">{props.text}</div>
    <button onClick={props.onDeleteTodo}>Delete</button>
  </div>
)
```

Well, the *view* passes off the event to a container. That could connect the user event to a method from a React Hook or a Redux thunk. From there, we might want to run some logic, decide if we should invoke a network request, update the state stored locally, then somehow notify the UI that it should update.  
好的，*视图将事件传递给一个容器*。这可以*将用户事件与 React Hook 的方法或 Redux 的 thunk 连接起来*。从那里，我们可能想*要运行一些逻辑，决定是否应该发起网络请求，更新本地存储的状态，然后以某种方式通知 UI 应该更新*。

That's a lot. And that's a *simple* app. And when I said we might want to *run some logic* a moment ago, I wasn't clear about **exactly** what kinds of logic it could be. It could be authorization logic, validation logic, interaction/domain logic, etc. Instead of putting five different kinds of logic *wherever*, we can classify it, carve out a place for it to live, and be more structured and conscious about how we connect features together.  
*这逻辑太多了*。而且这是一个很简单的应用。当我之前说我们可能需要运行一些逻辑时，我并没有明确说明这些逻辑具体是什么类型。它可以是授权逻辑、验证逻辑、交互/领域逻辑等。***与其在各个地方放置五种不同类型的逻辑，我们可以对其进行分类，为其划分一个生存空间，并更有结构地、有意识地思考如何将功能连接在一起***。

Separation of concerns is one of my favorite design principles. It's about thinking the jobs to be done, delegating them to a particular layer that handles those concerns, and then ensuring those layers do their jobs, and their jobs *only*.  
`关注点分离`是我最喜欢的设计原则之一。它是指思考需要完成的任务，**将它们委托给专门处理这些关注点的层次，然后确保这些层次只做它们的工作，并且只做它们的工作**。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/e01c8cf447f002c29d09f38d61629da3_MD5.png]]

### 关注点分离和 CQS 如何协同工作
How separation of concerns and CQS work together

CQS said that every *feature* is an operation. It also said that every operation is either a `command` or `query`.  
**`CQS` 表示每个功能都是一个操作。它还表示每个操作要么是 `command` ，要么是 `query` 。**

This means that every *feature* cuts through several concerns to work.  
**这意味着每个功能都贯穿多个关注点来工作。**

I like to think of features as ***vertical slices* that cut through the stack.**  
我喜欢**将功能视为贯穿整个堆栈的*垂直切片***。

### 功能是垂直切片
Features are vertical slices

When we add or change features in an application, we're modifying a part of the vertical slice for that feature.  
当我们在应用程序中添加或更改功能时，我们正在修改该功能的部分垂直切片。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/77e9d2a3d29e9cf11b1e2664caf5dc99_MD5.png]]

Need to change the way the login component looks? No problem, you're going to add some styles to the presentational component in the presentation layer *from the Login feature*.  
需要更改登录组件的外观吗？没问题，你将向登录功能的表现层中的表现组件添加一些样式。

Need to change what happens a when todo open for longer than 30 days was just completed? Want to throw confetti on the screen and say how proud of the user you are? Gotcha. Add some logic to the [xState model](https://xstate.js.org/docs/recipes/react.html#hooks) from the interaction layer for the *Complete Todo* feature.  
需要更改当待办事项打开超过 30 天后被完成时的行为吗？想屏幕上撒些彩带并表达你对用户的骄傲之情吗？没问题。为交互层的完成待办事项功能，在 xState 模型中添加一些逻辑。

![[_posts/architect/_教程/Client-Side Architecture Basics/media/7244ce7c16e57f4450c90680ee75ab37_MD5.png]]

I'm a huge fan of this.  
我非常喜欢这个。

Understanding the responsibilities of each layer enables us to better reason about which tools to use **per feature**.  
理解每一层的责任使我们能够更好地推理每个功能应使用哪些工具。

Using Apollo Client, React Hooks + xState  
使用 Apollo Client，React Hooks + xState

- Application logic: Hooks + xState  
	应用逻辑：Hooks + xState
- State management: Apollo Client (global state)  
	状态管理：Apollo Client（全局状态）
- Data fetching: Apollo Client  
	数据获取：Apollo Client

Using Apollo Client and plain JavaScript  
使用 Apollo Client 和纯 JavaScript

- Interaction logic: Hooks + [pojo-observer](https://github.com/xolvio/pojo-observer)  
	交互逻辑：Hooks + pojo-observer
- State Management: Apollo Client (global state)  
	状态管理：Apollo Client（全局状态）
- Data fetching: Apollo Client  
	数据获取：Apollo Client

Using REST, Redux, and React Hooks  
使用 REST、Redux 和 React Hooks

- Interaction logic: Hooks  
	交互逻辑：Hooks
- State Management: Redux (global state). Connect for observability/reactivity, and Thunks for signaling async states.  
	状态管理：Redux（全局状态）。使用 Connect 实现可观察性/响应性，以及使用 Thunks 表示异步状态。
- Data fetching: Fetch or Axios  
	数据获取：Fetch 或 Axios

I first heard of the term *vertical slices* from [Jimmy Bogard](https://jimmybogard.com/vertical-slice-architecture/). Thinking of features this way reduces the amount of time it takes for developers to figure out where to add or change code.  
我第一次从 Jimmy Bogard 那里听到垂直切片这个术语。以这种方式思考功能可以减少开发人员确定在哪里添加或更改代码所需的时间。

This is where developers get stuck, figuring out what the layers of the stack are, and which tools can be used at each layer of the stack.  
这就是开发人员卡住的地方，他们需要弄清楚堆栈的哪些层，以及可以在堆栈的每一层使用哪些工具。

Vertical slices enables us to keep [Single Responsibility](https://khalilstemmler.com/articles/solid-principles/single-responsibility/) high if we "minimize coupling between slices, and maximize coupling in a slice" — via [Jimmy Bogard](https://jimmybogard.com/vertical-slice-architecture/). Also read Kent C. Dodd's article on " [Co-location](https://kentcdodds.com/blog/colocation) ".  
垂直切片使我们能够在“最小化切片之间的耦合，并在切片内部最大化耦合”的情况下保持单一职责原则——这是 Jimmy Bogard 的观点。也请阅读 Kent C. Dodd 关于“位置相邻”的文章。

### 这有什么关系？
Why does it matter?

- Better visibility as to which tasks need to be done, which layer they belong to, and which tools can be used to address those concerns.  
	更清晰地了解哪些任务需要完成，它们属于哪个层级，以及可以使用哪些工具来处理这些问题。
- Helps to decide whether we want to implement a layer ourselves or use a framework/library. For example, most developers won't build their own view-layer library for presentational components — they'll use React or Vue. But lots of users ***will* build their own state management system from scratch** using Redux and Connect.  
	有助于决定我们是要自己实现一层，还是使用框架/库。例如，大多数开发者不会为展示组件构建自己的视图层库——他们会使用 React 或 Vue。但很多用户会使用 Redux 和 Connect 从零开始构建自己的状态管理系统。

