n this article, you'll learn about the Clean Architecture, why we should separate the concerns of large applications into layers, the 6 most common types of application logic, and which layer they belong to.
在本文中，你将了解到整洁架构、为什么我们要将大型应用程序的关注点分离到不同层、六种最常见的应用程序逻辑类型以及它们分别属于哪一层。

---

![](https://khalilstemmler.com/img/blog/software-architecture-design/logic-types.png)


This topic is taken from Solid Book - The Software Architecture & Design Handbook w/ TypeScript + Node.js. [Check it out](https://solidbook.io/) if you like this post.本主题取自《Solid 指南——TypeScript + Node.js 软件架构与设计手册》。如果你喜欢这篇文章，[可以去看看](https://solidbook.io/)。

How many times have you been working on an application, and in the middle of writing some logic, asked yourself:你在开发应用程序时，有多少次在编写某些逻辑的过程中，会问自己：

> "Is this the right place to put this logic?"“这里是放置这个逻辑的正确位置吗？”

There's a lot that goes into figuring out where something belongs.要弄清楚某物属于哪里，需要考虑很多因素。

First, you have to understand the domain that you're working in. That's how you figure out the [subdomains](https://khalilstemmler.com/articles/domain-driven-design-intro/) in your app.首先，你必须了解自己所从事的领域。这是你弄清楚应用程序中[子领域](https://khalilstemmler.com/articles/domain-driven-design-intro/)的方法。

Then, for each subdomain, you have to identify all the [use cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) and which **actors** are allowed to execute them.然后，对于每个子域，你必须确定所有的[用例](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/)以及允许执行这些用例的**参与者**。

This is [Conway's Law](https://khalilstemmler.com/wiki/conways-law/) **in action**. 这就是[康威定律](https://khalilstemmler.com/wiki/conways-law/)的**实际体现**。

What I've found to be the most challenging part, especially for developers new to [enterprise application development](https://khalilstemmler.com/articles/categories/enterprise-node-type-script/) that have [moved well-past simple CRUD MVC apps](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/), is implementing a **layered architecture** to separate the concerns of app development.我发现最具挑战性的部分，尤其是对于那些刚接触企业应用程序开发</b0、且早已超越简单CRUD MVC应用程序开发阶段的开发者而言，是实施一种分层架构</b2来分离应用程序开发中的关注点。

The challenge seems to be understanding _which layer_ exactly to place logic.挑战似乎在于理解究竟应该将逻辑放在哪个层面。

In this article, we'll learn about the following:在本文中，我们将了解以下内容：

- Clean Architecture, and why we should separate the concerns of large applications into layers.整洁架构，以及为什么我们应该将大型应用程序的关注点分离到不同的层中。
- The 6 most common types of application logic and which layer they belong to.6种最常见的应用程序逻辑类型及其所属的层级。

## 整洁架构/分层架构
The Clean Architecture / Layered Architecture

Robert Martin wrote about _Clean Architecture_ in his book of the same name. Although a bit of a challenging read (took me 2 really good reads), it's amazing. It teaches you about how to organize and group code into components, and then how to organize an application that connects those components to things like databases, APIs, web servers and other external things that we need to power applications.罗伯特·马丁在他的同名著作中论述了_整洁架构_。虽然这本书读起来有点难度（我足足认真读了两遍才弄懂），但内容非常精彩。它会教你如何将代码组织和分组为组件，以及如何构建一个应用程序，将这些组件与数据库、API、Web服务器以及其他我们为应用程序提供支持所需的外部事物连接起来。

A really simplified version of what the clean architecture might look like:一种极为简化的整洁架构可能的样子：

![Simplified Clean Architecture](https://khalilstemmler.com/img/blog/clean-architecture/group.svg)

### 领域层 Domain Layer

In one layer (domain) we have all of the important stuff: the entities, business logic, rules and events. This is the irreplaceable stuff in our software that we can't just swap out for another library or framework. It's also the stuff that's much less likely to need to change because it represents _what our business does_.在一个层面（领域）中，包含了所有重要内容：实体、业务逻辑、规则和事件。这是我们软件中不可替代的部分，不能简单地用其他库或框架替换。这部分内容也不太可能需要更改，因为它代表了我们业务的实际运作。

For example, if we're an app that sells books, we sell books. If we're an app that finds parking spots, the domain layer contains the _core logic_ to find parking spots.例如，如果我们是一个卖书的应用程序，我们就卖书。如果我们是一个寻找停车位的应用程序，那么领域层就包含了寻找停车位的核心逻辑。

Because we're unlikely to change the core essense of what our business does, the domain layer is the most [stable layer](https://khalilstemmler.com/wiki/stable-dependency-principle/).由于我们不太可能改变业务核心本质，因此领域层是最[稳定的层](https://khalilstemmler.com/wiki/stable-dependency-principle/)。

The domain layer assumes a kind of **higher-level policy** that everything else relies on.领域层承担着一种其他所有部分都依赖的高层策略。

### 基础设施（其他所有内容）层
Infra (everything-else) layer

The other layer (infra) contains everything that actually spins up the code in the domain layer to execute.另一层（基础设施层）包含了所有能实际启动领域层中的代码以执行的东西。

## 扩展的整洁架构
Clean architecture expanded

We can **generally** express the clean architecture as _domain_ and _infrastructure_.我们通常可以将整洁架构表示为领域和基础设施。

Stuff that's specific to our business is **domain**, and the adapter-stuff that just hooks into the technologies that enable us to run a web app (database, web servers, controllers, caches, etc) is the **infrastructure**.我们业务特有的内容属于**领域**，而那些仅用于连接使我们能够运行Web应用程序的技术（数据库、Web服务器、控制器、缓存等）的适配性内容则属于**基础设施**。

But the devil is in the details. 但细节决定成败。

If we wipe our glasses off, a more detailed view of the clean architecture would look like this.如果我们擦一擦眼镜，就能更清晰地看到整洁架构的详细样子了。

![](https://khalilstemmler.com/img/blog/software-architecture-design/app-logic-layers.svg)

---

For [trivially small applications](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/), this might seem like overkill. But for applications that are expected to live a long life, be maintained by larger teams, and make / save a company money, it's vital to figure out how to separate the concerns and where to put logic.对于[极其简单的小型应用程序](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/when-crud-mvc-isnt-enough/)，这可能看起来有些多余。但对于那些预期使用寿命长、由更大团队维护且能为公司盈利或省钱的应用程序而言，弄清楚如何分离关注点以及逻辑应放在何处至关重要。

Failure to address that complexity and solve it with a better architecture can turn a project _legacy-mode_, real quick.如果不能解决这种复杂性并通过更好的架构加以应对，项目很快就会陷入_遗留模式_。

Without further ado, here are the 6 most common types of application logic that find their way into large applications.废话不多说，以下是大型应用中常见的6种应用逻辑类型。

## 1. 展示逻辑
1.Presentation Logic

> Logic that's concerned with how we present something to the user.与我们如何向用户呈现内容相关的逻辑。

Most apps used by consumers have front-ends. This type of logic is entirely concerned with _how we present something to the user_.大多数消费者使用的应用程序都有前端。这类逻辑完全与我们如何向用户呈现内容有关。

It's the HTML, CSS and JavaScript that we write that turns a blank page into a well-designed, living, breathing front-end application.正是我们编写的HTML、CSS和JavaScript，将一个空白页面变成了一个设计精良、生动鲜活的前端应用程序。

```sass
.container
  background: white;
  color: blue;
```

### 傻瓜式用户界面不应包含任何业务规则
Dumb UIs should contain no business rules

There's a principle called **Dumb UI**.有一种原则叫做**傻瓜式用户界面**。

The idea is to keep the UI logic divorced from any **domain-layer** logic, because the domain-layer logic acts as dependency to _everything else_ in the architecture.其理念是将用户界面逻辑与任何**领域层**逻辑分离，因为领域层逻辑在架构中是_其他所有部分_的依赖项。

The front-end is **volatile**. That means it's constantly requiring changes. Due to that, it wouldn't be a good idea to locate logic (domain logic, specifically) that was important to other components in the architecture, because that would have the potential to consistently break the app.前端是不稳定的。这意味着它不断需要变更。正因为如此，将对架构中其他组件很重要的逻辑（特别是领域逻辑）放在前端并不是个好主意，因为这可能会持续破坏应用程序。

**Stable Dependency Principle**: If you're interested in this phenomenon of what makes a dependency stable and what makes it unstable, check [this](https://khalilstemmler.com/wiki/stable-dependency-principle/) out.稳定依赖原则：如果你对是什么让依赖稳定、什么让依赖不稳定这一现象感兴趣，可以查看[这个](https://khalilstemmler.com/wiki/stable-dependency-principle/)。

### 智能组件 和 傻瓜式组件
Smart and dumb components

Modern front-end JavaScript frameworks like React and Angular have popularized **smart (container) components** and **dumb (functional) components**.像React和Angular这样的现代前端JavaScript框架已经普及了**智能（容器）组件**和**纯（功能）组件**。

There may be a good separation of concerns between those two, where **smart** components hold the state and methods that manipulate the state, leaving **dumb components** to simply project the view, but front-end is still primarily **presentation** logic and should contain little to no other types of logic (besides some validation logic).这两者之间可能存在良好的关注点分离，其中**智能**组件持有状态和操作状态的方法，而 **dumb 组件**则仅负责呈现视图，但前端仍然主要是**展示**逻辑，应该几乎不包含其他类型的逻辑（除了一些验证逻辑）。

To the backend, front-end is an **infrastructural** concern that we provide data access / adapters to through RESTful APIs and the like.对于后端而言，前端是一个基础设施方面的问题，我们通过RESTful API等方式为其提供数据访问和适配器。

## 2. 数据访问/适配器逻辑
2.Data Access / Adapter Logic

> Logic concerned with how we enable access to infrastructure layer concern like caches, databases, front-ends, etc.该逻辑关注的是我们如何实现对缓存、数据库、前端等基础设施层相关内容的访问。

We can't get very far with just a plain ol' JavaScript/TypeScript objects that represent our domain layer.仅仅依靠那些代表我们领域层的普通JavaScript/TypeScript对象，我们无法取得太大进展。

We need to hook this thing up to the internet and enable a front-end to connect to it! Which web server do we want to use? Express.js? Hapi?我们需要把这个东西连接到互联网上，并启用一个前端来连接它！我们想使用哪个Web服务器呢？是Express.js？还是Hapi？

We also need to figure out how we'll persist our domain objects. Want to use a SQL database? NoSQL?我们还需要弄清楚如何持久化我们的领域对象。是想用SQL数据库？还是NoSQL数据库？

What about caching? 缓存呢？

Oh, and how do make use of cool external services like Stripe for billing or Pusher for real-time chat? We need to write adapters for those so that our inner layers can use them.哦，那如何利用像Stripe这样用于计费的优秀外部服务，或者像Pusher这样用于实时聊天的外部服务呢？我们需要为这些服务编写适配器，以便我们的内层可以使用它们。

That's right. This layer is all about defining the **adapters** to the outside world. Simplify usage for the inner layers by encapsulating the complexity of [persisting an aggregate to a database](https://khalilstemmler.com/articles/typescript-domain-driven-design/repository-dto-mapper/) by creating a **Repository** class to do that.没错。这一层的全部意义就在于定义与外部世界的**适配器**。通过创建一个**仓储**类来封装将聚合[持久化到数据库](https://khalilstemmler.com/articles/typescript-domain-driven-design/repository-dto-mapper/)的复杂性，从而简化内层的使用。

Here are several common things to do at this layer:在这一层，有几件常见的事情要做：

- **RESTful APIs**: Define a RESTful API with Express.js and create controllers to accept requests.**RESTful API**：使用Express.js定义一个RESTful API，并创建控制器来接收请求。
- **Production middleware**:Write Express.js controller middleware to protect your API from things like DDos and brute force login attempts.**生产中间件**：编写Express.js控制器中间件，以保护你的API免受分布式拒绝服务攻击（DDos）和暴力登录尝试等威胁。
- **Database Access**: Create repositories that contain methods that perform CRUD on a database. Use either an ORM like Sequelize and TypeORM or raw queries to do this.**数据库访问**：创建包含对数据库执行CRUD操作的方法的存储库。可以使用Sequelize和TypeORM等对象关系映射（ORM）工具，也可以使用原始查询来实现。
- **Billing Integrations**: Create an adapter to a payment processor like Stripe or Paypal so that it can be used by inner layers.**账单集成**：创建一个与Stripe或Paypal等支付处理器的适配器，以便内层可以使用它。

## 3. 应用逻辑/用例
3.Application Logic / Use Cases

> Logic that defines the actual features of our app定义我们应用程序实际功能的逻辑

[Use cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) are the features of our app.[用例](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/)是我们应用程序的功能。

Once all the use-cases of our application have been identified and then developed, we are _objectively_ done.一旦我们应用程序的所有用例都已确定并开发完成，我们就客观上完成了。

**Done**: "Done" is a word that I don't throw around often. It has different meanings to everyone. However, we can get closer to a shared understanding of _done_ if we: figure out the use cases, and figure out who or what should be able to execute those use cases (actors or agents- because robots/servers are actors too). Once that happens, I'm more confident about saying we're _done_.完成：“完成”这个词我不常说。它对每个人来说都有不同的含义。不过，如果我们能做到以下几点，就能更接近对“完成”的共同理解：弄清楚用例，以及弄清楚谁或什么应该能够执行这些用例（参与者或智能体——因为机器人/服务器也是参与者）。一旦做到这些，我就更有信心说我们完成了。

### CQS / CQRS

Use Cases are either `COMMANDS` or `QUERIES` if we're following the [Command-Query Segregation](https://khalilstemmler.com/articles/oop-design-principles/command-query-segregation/) principle.如果我们遵循“命令-查询分离”原则，用例要么是`COMMANDS`，要么是`QUERIES`。

### 用例是特定于应用程序的
Use Cases are application specific

Your company might have several applications within it.贵公司内部可能有多个应用程序。

Take Google for example. Google has **Google Drive**, **Google Docs**, **Google Maps**, etc.以谷歌为例。谷歌拥有**谷歌云端硬盘**、**谷歌文档**、**谷歌地图**等产品。

Each of these applications has their own set of use cases, like this:这些应用程序都有各自的一组用例，如下所示：

**Google Drive 谷歌云端硬盘**

- `shareFolder(folderId: FolderId, users: UserCollection)`: Shares a folder with other users in the Google enterprise.`shareFolder(folderId: FolderId, users: UserCollection)`：与Google企业中的其他用户共享文件夹。
- `createFolder(parentFolderId: FolderId, name: string)`: Creates a folder.`createFolder(parentFolderId: FolderId, name: string)`：创建文件夹。
- `createDocument(parentFolderId: FolderId)`: Creates a Google Docs document.`createDocument(parentFolderId: FolderId)`：创建一个Google Docs文档。

**Google Docs 谷歌文档**

- `shareDocument(users: UserCollection, visibility: VisibilityType)`: Shares a document with several users.`shareDocument(users: UserCollection, visibility: VisibilityType)`：与多个用户共享文档。
- `deleteDocument(documentId: DocumentId)`: Deletes a document.`deleteDocument(documentId: DocumentId)`：删除文档。

**Google Maps 谷歌地图**

- `getTripRoutes (start: Location, end: Location, time?: Date)`: Gets all routes for a trip.`getTripRoutes (start: Location, end: Location, time?: Date)`：获取行程的所有路线。
- `startTrip (start: Location, end: Location)`: Starts a trip now.`startTrip (start: Location, end: Location)`：立即开始行程。

A more common and simple example is deploying an **Admin** panel. You might need a separate dashboard from your main app in order to do a couple of admin-y things.一个更常见且简单的例子是部署一个**管理**面板。你可能需要一个与主应用程序分开的仪表板，以便执行一些管理相关的操作。


I usually plan and build software around use cases because it makes the code a lot easier to reason about, and improves how rapidly you can complete projects.我通常围绕用例来规划和开发软件，因为这样做会让代码更容易理解，也能加快项目的完成速度。  
  
I have a [free ebook](https://khalilstemmler.com/resources/names-construct-structure/) called "Name, Construct & Structure" where you can learn more about this approach to designing readable codebases.我有一本名为《命名、构建与结构》的免费电子书，在这本书中，你可以了解更多关于这种设计可读性代码库的方法。  
  
If you're more into the nitty-gritty of how to actually learn to code using Use-Case Driven Development, first [read this article on Use Cases](https://khalilstemmler.com/articles/enterprise-typescript-nodejs/application-layer-use-cases/) (it's my favourite article).如果你更想深入了解如何运用用例驱动开发来实际学习编程，那么首先读一读这篇关于用例的文章（这是我最喜欢的文章）。  
  
If you want more, check out my book on [software design and architecture](https://solidbook.io/) where I walk you through the process of Use-Case Driven Development.如果你想了解更多内容，可以看看我的关于《软件设计与架构》的书，其中我会带你了解用例驱动开发的过程。

## 4. 领域服务逻辑
4.Domain Service logic

> Core business logic that doesn't quite fit within the confines of a single entity.不太适合局限于单一实体范围内的核心业务逻辑。

Now we're in the **domain layer**. And [Domain-Driven Design](https://khalilstemmler.com/articles/domain-driven-design-intro/) is the best way to approach creating a rich domain model.现在我们处于**领域层**。而[领域驱动设计](https://khalilstemmler.com/articles/domain-driven-design-intro/)是构建丰富领域模型的最佳方法。

In DDD, we always try to locate domain logic closest to the [entity](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/) it pertains to.在领域驱动设计（DDD）中，我们总是试图将领域逻辑放置在与其相关的[实体](https://khalilstemmler.com/articles/typescript-domain-driven-design/entities/)最近的位置。

There comes situations where that logic spills into perhaps two or more entities, and it doesn't quite seem to make sense to locate that logic in one or the other.在某些情况下，这种逻辑可能会延伸到两个或更多的实体中，而将这种逻辑放在其中一个实体或另一个实体中似乎都不太合理。

We use domain services to ensure that we don't lose that **business rule** within one specific application's **use case**, but instead keep it within the domain layer so that it can be used by every application that relies on it.我们使用领域服务来确保不会将该**业务规则**局限于某个特定应用的**用例**中，而是将其保留在领域层，以便所有依赖它的应用都能使用。

## 5. 验证逻辑
5.Validation logic

> Logic that dictates what it means for a domain object to be valid.规定领域对象有效的意义的逻辑。

Validation logic is another **domain layer** concern, not an infrastructure one.验证逻辑是领域层的另一个关注点，而非基础设施层的。

Let's say that we wanted to create a `User` entity. And `User` contained a property called `email:string`.假设我们想要创建一个`User`实体。而`User`包含一个名为`email:string`的属性。

```typescript
interface UserProps {
  userEmail: string;
}
class User extends Entity<UserProps> {
  private constructor (props: UserProps, id?: UniqueEntityId) {
    super(props, id)
  }

  public static create (props: UserProps, id?: UniqueEntityId): Result<User> {
    const propsResult = Guard.againstNullOrUndefined(props.userEmail);
    if (!propsResult.succeeded) {
      return Result.fail<User>(propsResult.error);
    }

    return Result.ok<User>(new User(props, id))
  }
}
```

What's stopping someone from creating a `User` with an invalid `userEmail:string`?是什么阻止了有人创建一个带有无效`userEmail:string`的`User`呢？

```typescript
const userOrError: Result<User> = User.create({ userEmail: 'diddle' });
userOrError.isSuccess // true
```

That's what we use [Value Objects](https://khalilstemmler.com/articles/typescript-value-object/) for. We can encapsulate the validation rule with a **Value Object** for `userEmail`.这就是我们使用[值对象](https://khalilstemmler.com/articles/typescript-value-object/)的原因。我们可以用**值对象**为`userEmail`封装验证规则。

If we change the type of `userEmail` to be strictly-typed instead of _string-ly_ typed like this:如果我们将`userEmail`的类型改为严格类型，而不是像这样的_字符串_类型：

```typescript
interface UserProps {
  userEmail: UserEmail;
}
```

And then create a `UserEmail` value object...然后创建一个`UserEmail`值对象……

```typescript
import { TextUtil } from '../utils'
import { Result, Guard } from '../../core'

interface UserEmailProps {
  email: string;
}

export class UserEmail extends ValueObject<UserEmailProps> {

  // Private constructor. No one can say "new UserEmail('diddle')"
  private constructor (props: UserEmailProps) {
    super(props);
  }

  // Factory method, can do UserEmail.create() 
  public static create (props: UserEmailProps): Result<UserEmail> {
    if (Guard.againstNullOrUndefined(props.email) || 
      !TextUtil.isValidEmail(props.email)) {
        return Result.fail<UserEmail>("Email not provided or not valid.");
    }  else {
      return Result.ok<UserEmail>(new UserEmail(props));
    }
  }
}
```

Now, there's no way to create an invalid `User`.现在，无法创建无效的`User`。

## 6. 核心业务逻辑/实体逻辑
6.Core business logic / entity logic

> Logic that belongs to a single entity.属于单个实体的逻辑。

The most important is where the family jewels of the application are: the entity.最重要的是应用程序的核心所在：实体。

And if the entity has a reference to other related entities, the [aggregate root](https://khalilstemmler.com/articles/typescript-domain-driven-design/aggregate-design-persistence/).如果该实体引用了其他相关实体，那么它就是[聚合根](https://khalilstemmler.com/articles/typescript-domain-driven-design/aggregate-design-persistence/)。

Core business logic that lives here are:这里存在的核心业务逻辑包括：

- Initial / default values 初始值/默认值
- Protecting [class invariants](https://khalilstemmler.com/wiki/invariant/) (what changes are allowed, and _when_)保护[类不变量](https://khalilstemmler.com/wiki/invariant/)（允许哪些更改，以及_何时_更改）
- Creating **Domain Events** for changes, creations, deletions, and anything else relevant to the business. It's through domain events that complex business logic can be chained.为变更、创建、删除以及其他任何与业务相关的事项创建**领域事件**。复杂的业务逻辑可以通过领域事件形成链条。

## 需要遵循的一些原则
Some principles to follow

### 永远不要过度设计
Never over-engineer

You should know when you need to use a layered architecture. Typically, it makes most sense when your application **has a lot of business rules**. In that case, it's a good idea to implement a layered architecture in order to keep the concerns of **persistence logic** (for example), separate from **validation logic** and the **core business rules** of the Domain Layer.你应该知道何时需要使用分层架构。通常，当你的应用程序**有很多业务规则**时，这种架构最有意义。在这种情况下，实施分层架构是个好主意，以便将**持久化逻辑**（例如）的关注点与**验证逻辑**和领域层的**核心业务规则**分离开来。

---

## 结论 
Conclusion

In this article, we covered the 6 main types of logic in large application development.在本文中，我们介绍了大型应用程序开发中的6种主要逻辑类型。

Here they are in summary: 以下是它们的摘要：

- **Presentation Logic**: Logic that's concerned with how we present something to the user.**展示逻辑**：与我们如何向用户展示内容相关的逻辑。
- **Data Access / Adapter Logic**: Logic concerned with how we enable access to infrastructure layer concern like caches, databases, front-ends, etc.**数据访问/适配器逻辑**：与我们如何实现对缓存、数据库、前端等基础设施层关注点的访问相关的逻辑。
- **Application Logic / Use Cases**: Logic that defines the actual features of our app**应用逻辑/用例**：定义我们应用程序实际功能的逻辑
- **Domain Service logic**: Core business that doesn't quite fit within the confines of a single entity.**领域服务逻辑**：不适合局限于单个实体范围内的核心业务。
- **Validation logic**: Logic that dictates what it means for a domain object to be valid.**验证逻辑**：规定领域对象有效的含义的逻辑。
- **Core business logic / entity logic**: Logic that belongs to a single entity.**核心业务逻辑/实体逻辑**：属于单个实体的逻辑。