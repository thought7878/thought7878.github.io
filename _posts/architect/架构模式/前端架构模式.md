[2025年你需要了解的前端架构模式](https://youtu.be/ixee55xm_d8?si=JJN5M4WN-H3BJLt_)

视频讲述了2025年*需了解的前端架构模式*，包括*各类架构模式的原理、优缺点、适用场景*，以及*前端架构的重要性和选择建议*等内容，具体如下：


## 前端架构的重要性、关键影响因素
[00:28]
*前端架构**易被忽视**，但现代前端应用复杂度高，其**是开发关键部分***。*架构不仅是文件结构，更关乎应用各层交互*。

### 为什么需要架构？
**它能带来：**
- `灵活性 flexibility`：便于修改替换部分功能、明确组件边界。它允许*修改或替换应用程序的不同部分，而不会影响其他部分*；它是关于在组件之间有清晰的界限，使维护应用程序更容易。
- `可测试性 testability`：*各层易测试*，各个层更易于测试。
- `可扩展性 scalability`：*清晰职责分离应对应用增长*，随着应用程序的增长，*明确的关注点分离有助于管理复杂性*。

![[_posts/architect/架构模式/media/c1101a9e72605e8a78582173fe8f0489_MD5.jpeg]]


### 影响架构重要性的因素
- `项目规模`：大型项目需更多结构，*更大的应用程序需要更多的结构来保持维护*。
- `团队规模`：10-15人团队需良好架构，*参与项目的人越多，体系结构就变得越重要*。
- `项目生命周期`：*长期项目需坚实架构避免技术债务*，且架构虽可能减缓初始开发，但长期利于扩展和功能开发。

![[_posts/architect/架构模式/media/feaed7ce669eaada96cf28c37117bbdc_MD5.jpeg]]


## MVC（模型-视图-控制器）架构模式
[03:06]
MVC有36年以上历史，虽在现代前端应用不常用，但含基础概念，有助于理解其他模式。

### 三层
**MVC 将*应用程序*分为三个主要层：**
`模型`：*应用数据和业务逻辑*，这一层通常由后端、数据库和有时 API 表示。
`视图`：*负责显示数据*，这是用户在屏幕上实际看到的 UI，显示数据的UI。它还可以包括用户界面逻辑，如打开模型窗口。
`控制器`：*连接模型和视图，模型与视图之间的桥梁*。它处理用户输入、更新模型、并告诉视图要显示什么。

![[_posts/architect/架构模式/media/c629b8e249be74f205736ab171ba4b7f_MD5.jpeg]]

### 工作流程
`工作流程`：1.用户输入 → 2.视图捕获并传递给控制器 → 3.控制器处理并与模型交互 → 4.模型更新数据 → 5.控制器和模型更新视图 → 6.用户看到更新UI。

`第一步`，用户输入：用户点击一个按钮，输入一些东西，滚动，滑动，基本上任何类型的交互。
`第二步`，视图捕获输入并将其传递给控制器。在这个阶段，视图本身不处理事件。它只是将其转发到控制器。
`第三步`，控制器处理输入并与模型交互。控制器接收输入并决定如何处理它。如果该动作需要更新数据库，则控制器向模型发送请求。*例如*，如果用户点击删除项目，控制器告诉模型将其从数据库中删除。
`第四步`，模型更新数据。模型，通常是后端或状态管理系统，处理请求、修改数据。在我们的 delete 示例中，它从数据库中删除实体。
`第五步`，控制器和模型都可以更新视图。问题是模型如何将更改传达给视图？有两种常见的方法，*第一种是观察者模式*，视图订阅来自模型的更新，并自动作出反应和流同步（Flow synchronization），视图在需要时显式地向模型请求更新。
`第六步`，最后，更改反映在用户界面中，用户看到更新的 UI。


![[_posts/architect/架构模式/media/05bc21b9d1b26a63a12a02d29d9d54fa_MD5.jpeg]]

### 使用案例
#### 纯前端
可用于纯前端：
`模型`为Redux等状态管理系统，`视图`为React等组件，`控制器`层是否存在因应用结构而异。
mvc 不需要后端服务器，你可以有一个纯粹的前端 mvc 结构。
模型是你的状态管理系统，比如 redux；
视图是react、vue 的组件；
控制器，这部分有点棘手，有人说我们没有控制器，在现代前端应用程序中，因为视图直接更新模型；其他人则认为Hook、可组合件 Composable、中间件充当控制器。

*例如*，用户在帖子上点击点赞，视图捕获事件并将其发送到控制器，控制器更新模型，增加数据库中的计数，模型将更新了的喜欢计数发送回视图，视图更新 UI 以显示新的喜欢计数。

![[_posts/architect/架构模式/media/9cf46c03493df77952fc3978ae1fd575_MD5.jpeg]]

#### 全栈
[07:30]

`视图`为前端UI框架。
`控制器`为API层，处理客户端通信的层。
`模型`为后端业务逻辑和数据库。

所以在这种结构中，前端只处理 ui 逻辑，不处理任何业务逻辑；API 或控制器，处理通信和请求；后端的模型，处理和存储数据。

![[_posts/architect/架构模式/media/7617ec47dd6baabc4f1dea1eef17fccf_MD5.jpeg]]

#### 分层 MVC
[08:00]

当你在开发一个巨大的应用程序时，会发生什么呢？
不是有一个巨大的 MVC 结构，我们把它分解成更小的单元。这被称为`分层 MVC`，其中*每个功能、模型或页面具有其自己的 MVC 结构*，拆分为分层MVC（*按功能拆分多个独立MVC单元*）。

*例如*，在 Redux store中，我们可以将store拆分为多个单元、切片，每个处理不同的功能。在 React 或 Vue 中，*每个页面*都可以有自己状态、逻辑和控制器，比如实用程序utility、钩子hook、可组合对象composable。

**因此，我们有多个较小的 MVC 一起工作，而不是一个大的 MVC。**


![[_posts/architect/架构模式/media/76000ce1d91df9ca39d3b2dfd74cdc27_MD5.jpeg]]


### 瘦客户端与胖客户端的差异及对MVC的影响
[08:37]
`瘦客户端 Thin Client`*将大部分处理放在服务器，客户端仅处理UI和用户交互*，常见于*传统多页应用和静态网站*，依赖服务器，响应慢；
`胖客户端 Fat/Thick Client`*在客户端执行大量逻辑，减少服务器负载*，*多数交互无需整页刷新，可离线工作，现代Web应用常用*。*优点是*，在强大设备上响应快、可离线；*缺点是*，但客户端负担重。这就是 SPA、Progressive Web App 应用程序、本地优先应用程序，依赖胖客户端的原因。它改善了用户体验，但它将更多的复杂性转移到了前端。有了胖客户端，我们可以完全在客户端实现 mvc。

![[_posts/architect/架构模式/media/586606470e13ec2992e7f0553b96031c_MD5.jpeg]]

![[_posts/architect/架构模式/media/e66b4fcd677292e2b46f92642637afd2_MD5.jpeg]]

对应MVC，
`瘦客户端+后端的MVC中`，**客户端**仅渲染数据和发送用户操作，**控制器（API）** 连接客户端和后端，**模型（后端）** 处理业务逻辑和数据，前端简单轻量但依赖服务器；
`胖客户端+后端的MVC中`，**客户端视图**除显示数据外，还*管理状态、处理逻辑、离线存储数据*，**控制器（API）** 仍为桥梁，后端模型更轻量，且可在客户端实现完整MVC（*模型*为状态管理系统，*控制器*含组合式、钩子、中间件或API调用）。例如，在 react 应用程序中使用 redux，当用户单击删除项目时，视图捕捉到了事件，控制器更新模型（redux store），视图根据store的变化自动渲染

![[_posts/architect/架构模式/media/2c58c863375db98c72c10e75068419f8_MD5.jpeg]]


### 优点、缺点
[11:23]
`优点`是易理解、易开发维护。这种模式清晰、逻辑性强，易于开发和维护。
`缺点`是：
- **存在胖控制器问题**（控制器功能过多）。*出现这个问题的原因*是视图不处理事件并将它们推到控制器，这就产生了臃肿的控制器，它们做的事情太多了。
- **模型和控制器之间的边界模糊**。有时不清楚什么应该在模型中，什么应该在控制器中。
- **视图功能超出纯UI层**。*视图也负责用于接收来自模型的更新*，这使得它不仅仅是一个纯粹的 UI。视图只应该显示 ui，但在现代应用程序中，它们*还处理事件并观察状态变化。这使测试和维护复杂化*。
- 最后一个问题是，MVC 是在 1979 年引入的，**主要适用于具有展示层的经典 Web 应用程序，不适用于现代复杂的 Web 应用程序**，具有客户端侧逻辑和客户端侧数据存储。不适用于现代复杂前端应用，适用于中小型应用，*不适用于SPA、客户端逻辑复杂、本地优先应用*。

![[_posts/architect/架构模式/media/311e024129cf35e75440fefdd08b2203_MD5.jpeg]]

**让我们看看胖控制器的问题**。控制器应该是视图和模型之间的桥梁。实际上包括*向服务器发送请求，处理 API 响应，和后端数据同步*（例如，如果我们使用 WebSocket实时更新），控制器还*管理客户端缓存*和其他一些事情。
*控制器最终做的事情超出了它应该做的事情，成为一个巨大的臃肿层*。我认为这是因为 MVC 是在 1979 年引入的。它不应该被用于复杂的 Web 应用程序。当时，客户端状态管理还不存在。当我们试图遵循 mvc，是在强迫现代网络应用程序遵循不是为他们而建的结构。

![[_posts/architect/架构模式/media/2be37d34543be8a03cc65d2a987b6c49_MD5.jpeg]]

## MVP（模型-视图-演示者）架构模式
[13:54]
MVP由MVC演变而来，视图不直接与模型通信，所有交互经演示者，演示者承担视图中的观察者逻辑，使视图成为纯UI层，系统更可预测、易测试、结构更清晰。分为监督控制器型MVP（视图处理简单更新，复杂逻辑经演示者，优点是减少模板代码、开发快，缺点是视图难测试维护，适用于简单UI）和被动视图型MVP（视图完全被动，所有逻辑由演示者处理，优点是边界清晰、各部分易测试，缺点是需更多代码处理基础UI任务，适用于UI逻辑复杂或注重可测试性和长期扩展性的应用）。MVP优点是关注点分离更好、可测试性更高，缺点是可能出现胖演示者问题、表达性不足（未明确后端同步等处理位置），适用于MVC的适用场景及客户端逻辑更复杂的应用。


## MVVM（模型-视图-视图模型）架构模式
[16:58]
MVVM核心是分离视图逻辑（UI相关，不修改核心数据，如弹窗、按钮禁用等）和业务逻辑（修改数据，如改用户名、付款等）。包含视图（UI）、视图模型（处理UI逻辑，更新视图、与模型交互，确保UI与数据同步）、模型（处理业务逻辑和实际数据），关键概念是双向绑定（视图与视图模型相互影响，一方变化另一方自动更新，如Vue中的数据绑定）。与MVC、MVP相比，视图模型存储UI数据，MVC和MVP未区分业务与UI数据；视图与模型隔离，多个视图可共享一个视图模型，一个视图不能有多个视图模型；视图模型包含UI的数据和行为，无显示控件；视图变化时视图模型通过双向绑定更新自身状态，需更新模型时视图模型直接修改模型。MVVM优点是关注点分离清晰、可扩展性好、易测试维护，缺点是学习曲线陡、表达性不足（未明确API请求等处理位置），适用于UI逻辑复杂、需测试、用户交互多、有实时验证表单或动态UI更新的应用，不适用于简单静态网站。


## 层级MVC（HMVC）架构模式
[21:14]
HMVC是MVC的扩展，解决MVC的可扩展性问题。传统MVC在应用增长时，控制器可能处理过多事务（如与多个模型交互、处理多源数据），导致代码混乱、测试难、修改慢。HMVC将应用拆分为多个独立MVC模块，每个模块处理特定功能，仅通过控制器与其他模块交互。例如Angular的功能模块就是前端HMVC的实现，大型Angular应用中各功能（用户、订单、仪表盘）有独立模块及组件、服务、状态管理。HMVC优点是模块化（应用拆分为小模块，利于独立开发、维护、测试，有错误边界）、促进代码复用，缺点是学习曲线陡、模块间可能不一致（不同开发者或团队采用不同标准），适用于大型应用、多团队负责不同部分的系统、从多API和服务获取数据的前端应用，不适用于中小型应用。


## MVVM-C（带协调器的模型-视图-视图模型）架构模式
[24:09]
MVVM-C在MVVM基础上新增协调器，负责管理导航和屏幕过渡。MVVM中无明确导航处理位置（视图仅UI、模型仅原始数据、视图模型处理导航会臃肿），协调器解决此问题，将导航逻辑从视图模型中移出。其优点是关注点分离（导航逻辑与UI、业务逻辑完全分离）、可测试性更好（可独立单元测试导航逻辑），缺点是增加架构复杂度（新增一层），适用于导航场景复杂的应用（如电商结账流程）。


## VIPER架构模式
[25:29]VIPER包含视图（被动视图，仅显示UI和转发用户操作，无逻辑）、演示者（为视图准备数据，确保格式正确）、交互器（处理业务逻辑，负责获取和修改数据）、实体（原始数据，无逻辑，仅结构化信息）、路由器（管理屏幕过渡和导航）。各组件交互为视图仅与演示者通信，演示者与交互器通信，交互器处理实体数据，路由器负责导航。VIPER多用于移动开发，也可用于前端Web应用，比传统MV模式结构更清晰，各部分更独立易单元测试，适用于大型应用或多团队开发不同模块的场景。其依赖关系为视图依赖演示者，演示者依赖交互器和路由器，交互器依赖实体，实体不依赖任何部分，还可将交互器拆分为服务，实体拆分为模型实体。优点是基于用例设计应用、明确API处理位置（交互器）、明确导航处理位置（路由器）、关注点分离更好、可扩展性好，缺点是需编写大量模板代码（如多个接口），适用于复杂长期应用，不适用于小型应用（MV模式更合适）。


## 整洁架构模式
[28:00]
整洁架构有四层，从内到外为实体（核心业务逻辑，不关注UI、数据库、框架，如银行应用中的交易规则）、用例（应用逻辑，处理数据但不存储，如获取最近100笔银行交易）、接口适配器（连接用例和框架，转换数据格式，如确保数据适合UI或数据库）、框架和驱动（如UI框架、数据库、外部API，非核心业务逻辑，可替换），依赖规则为依赖指向内部，内层不了解外层。即使无后端（如离线优先应用，用IndexedDB存储数据）或为纯UIWeb应用（核心逻辑为UI相关，后端为框架），也可应用整洁架构。优点是可测试性高（各层可独立测试）、数据库无关（应用与数据库解耦，易修改数据库）、UI无关（UI框架隔离，易修改视图），缺点是入门门槛高（需经验丰富且自律的团队）、复杂度高（实现需管理多层，小型项目不必要）。


## 六边形架构（端口和适配器架构）模式
[32:04]
六边形架构核心是业务逻辑，周围是输入端口（驱动端，如用户事件、WebSocket、服务器事件，控制应用）和输出端口（被驱动端，如UI、客户端存储、本地存储，被应用逻辑控制），利于分布式开发，不同团队可独立开发应用不同部分（如团队负责业务逻辑和端口，UI团队负责适配器和UI），通过集成测试和模拟测试组件。可添加契约（如类型、JSON模式、OpenAPI规范），用响应验证器（如Zod、Joy、Yup）和集成测试确保适配器与端口交互符合规范，防止API意外变更，确保前后端同步。适用于有业务逻辑的前端、本地优先应用、与多个接口（REST API、GraphQL、SLI）交互或有多个UI的应用，不适用于简单应用、小型团队和项目（复杂度高且无明显收益）。与整洁架构相比，整洁架构较新，源于六边形架构，关注单一应用内的层级分离，分为实体、用例、控制器、基础设施；六边形架构较旧但有效，适用于系统含多个分布式部分的情况，关注服务与外部接口的交互，若有多个接口，六边形架构更合适。


## 尖叫架构概念
[36:03]
尖叫架构由Robert Martin提出，不关注模型间交互，而是代码结构和实体命名，要求软件系统架构仅看顶层结构（如包名、模型名、目录）就能识别，即架构“彰显”应用目的和用途，无需深入细节。与领域驱动设计（DDD）有相似之处，均关注以业务模型描述架构，不围绕技术细节（如React、MongoDB）构建应用，而以应用功能命名（如待办列表应用的“任务”“待办项”，用户管理系统的“用户”）。实现需关注业务领域（围绕核心业务概念构建代码库，用领域特定名称命名模型和功能）、按功能组织（每个功能包含所需逻辑、数据处理和UI组件，而非按层级）、隐藏技术细节（将框架、数据库、API等抽象到低层模块，不放在顶层）。在系统设计面试中，应优先关注架构而非组织方式，架构是难逆转的关键决策（应用增长后重构架构难、成本高，企业常因预算问题难彻底重写旧架构），而文件结构和命名约定易修改，无需过多关注。


## 垂直切片架构模式
[40:18]
垂直切片是现代且广泛使用的架构风格，解决整洁架构等分层架构未明确层内功能组织的问题，以功能（业务场景）为导向，将应用垂直拆分为独立功能切片，每个切片包含自身的实体、用例、控制器和外部接口，功能自包含。可与其他架构模式结合（如MVP应用中，为每个功能创建切片，每个切片内部遵循MVP架构）。优点是代码组织更好（功能自包含，代码库模块化、易管理）、便于多团队协作（切片独立，多团队可同时开发不同切片），缺点是可能过度工程化（简单功能严格遵循垂直切片导致复杂度和模板代码增加）、团队间可能不一致（各团队独立开发切片，结构可能不同，可通过通用设计指南、代码检查和格式化规则、开发者跨团队轮岗解决）。适用于大型应用（功能多，利于代码组织和团队协作）、跨职能团队（团队可全权负责特定功能从端到端的开发，促进协作和功能快速交付），不适用于简单应用（如简单全栈应用、瘦Web客户端）、小型团队和项目（架构复杂度无明显收益）。


## 前端架构总结与建议
[43:38]
视频未涵盖所有前端架构模式，重点介绍了常用模式（如MVC、MVP、整洁架构）及部分少用但有价值的模式（如移动开发常用的VIPER，可借鉴其思想到前端），前端开发者常从后端开发借鉴概念，这很正常。现代前端应用（如本地优先应用、高交互UI应用、Figma等状态密集型应用）复杂度高，不仅是渲染视图，还需管理状态、缓存、数据持久化、与后端同步，前端架构应更受关注。架构模式无需严格遵循，可根据需求调整（如增加或移除层），因无两个应用完全相同，需定制架构。架构模式提供开发者通用语言（如提及模型、控制器、视图，多数开发者能理解），利于沟通。