## Why

**微前端架构**是一种*将前端应用拆分成多个小型、自治的前端应用，并将它们组合在一起形成一个完整应用*的架构模式。_它借鉴了微服务架构的思想_，旨在**解决大型前端应用在开发、部署和维护过程中面临的问题：**

### 开发阶段的问题

#### 1. 代码复杂度高

- **难以理解和维护**：*大型前端应用*通常包含*大量的代码*，代码之间的*依赖关系错综复杂*。新加入的开发人员很难快速理解整个项目的架构和逻辑，在修改代码时容易引入新的问题。*例如*，在一个包含数万行代码的单页面应用中，可能存在大量的嵌套组件和复杂的状态管理逻辑，开发人员在调试或添加新功能时，需要花费大量时间去梳理代码逻辑。
- **开发效率低下**：由于代码量庞大，每次修改代码后进行*编译和构建的时间会很长*，这会大大降低开发效率。而且，在一个庞大的代码库中*搜索和定位*需要修改的代码也变得困难。

#### 2. 技术栈限制

- **无法灵活选择**：在传统的大型前端应用中，*通常会选择一种技术栈*（如 React、Vue 或 Angular）贯穿整个项目。*但不同的业务场景可能适合不同的技术栈*，单一技术栈的选择可能会限制开发团队充分发挥技术优势。*例如*，某些页面需要高性能的渲染，可能更适合使用 WebGL 相关技术，但由于整个项目采用了传统的前端框架，很难引入新的技术栈。
- **升级困难**：随着技术的不断发展，前端框架和库也在不断更新。在大型应用中，升级整个项目的技术栈是一件非常困难的事情，可能会涉及到大量的代码修改和兼容性问题。

#### 3. 团队协作困难

- **代码冲突频繁**：多个开发团队或成员同时在一个代码库中开发时，很容易出现代码冲突。特别是在大型项目中，不同团队负责不同的功能模块，但这些模块之间可能存在依赖关系，代码冲突的解决变得更加复杂。
- **沟通成本高**：大型项目通常需要多个团队协作开发，团队之间的沟通成本会显著增加。不同团队对需求的理解可能存在差异，而且在协调开发进度和解决问题时需要花费大量的时间和精力。

### 部署阶段的问题

#### 1. 部署时间长

- **构建和打包耗时**：大型前端应用的代码量和资源文件较多，在部署前需要进行编译、打包等操作，这些操作通常需要花费很长时间。例如，一个包含大量图片、样式和脚本文件的电商应用，在部署时的构建过程可能需要十几分钟甚至更长时间。
- **部署流程复杂**：大型应用的部署流程通常比较复杂，需要经过多个环节，如代码拉取、环境配置、测试、上线等。任何一个环节出现问题都可能导致部署失败，而且排查问题也比较困难。

#### 2. 部署风险大

- **牵一发而动全身**：在传统的大型前端应用中，一个小的代码修改可能会影响到整个应用的稳定性。由于所有功能都集成在一个项目中，部署时一旦出现问题，可能会导致整个应用无法正常使用。例如，修改了一个页面的样式，可能会影响到其他页面的布局或功能。
- **回滚困难**：如果部署后发现问题需要回滚，由于应用的复杂性，回滚操作可能会非常困难。特别是在涉及到数据库和服务器端的交互时，回滚可能会导致数据不一致等问题。

### 维护阶段的问题

#### 1. 扩展性差

- **添加新功能困难**：随着业务的发展，大型前端应用需要不断添加新的功能。但在一个已经很庞大的代码库中添加新功能可能会受到现有代码结构的限制，需要对整个项目进行大规模的重构才能实现。例如，一个社交应用在发展过程中需要添加直播功能，但原有的代码结构可能不支持这种功能的快速集成。
- **难以应对变化**：市场需求和业务规则不断变化，大型前端应用需要能够快速响应这些变化。但由于其复杂性，对应用进行修改和调整变得困难，可能无法及时满足业务的需求。

#### 2. 性能优化困难

- **资源加载缓慢**：大型应用通常包含大量的资源文件，如图片、脚本和样式文件等，这些资源的加载会影响应用的性能。而且，由于代码结构复杂，很难对资源加载进行有效的优化。例如，一个新闻资讯应用可能会加载大量的图片和广告脚本，导致页面加载速度缓慢。
- **内存管理复杂**：在大型前端应用中，内存管理变得更加复杂。大量的组件和数据可能会导致内存泄漏，影响应用的性能和稳定性。而且，由于代码的复杂性，很难定位和解决内存泄漏问题。

## What

### 核心概念

- **微前端**：每个微前端是一个*相对独立的前端应用*，有自己的代码库、开发团队和部署方式。它们*可以使用不同的技术栈开发*，如 React、Vue 或 Angular 等。
- **主应用**：负责协调和集成各个微前端，提供整体的布局和导航，通常还包含一些全局的功能，如身份验证、主题管理等。

### 实现方式

#### 1. 基于路由的集成

- **原理**：主应用*根据用户访问的 URL 路径，动态加载不同的微前端应用*。这种方式类似于后端的路由机制，通过路由配置*将不同的路径映射到对应的微前端*。
- **示例**：在一个电商应用中，主应用可以将 `/products` 路径映射到产品列表微前端，将 `/cart` 路径映射到购物车微前端。

```javascript
// 主应用路由配置示例（使用 React Router）
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import ProductListMicroApp from "./ProductListMicroApp";
import CartMicroApp from "./CartMicroApp";

const App = () => {
  return (
    <Router>
      <Routes>
        <Route path="/products" element={<ProductListMicroApp />} />
        <Route path="/cart" element={<CartMicroApp />} />
      </Routes>
    </Router>
  );
};

export default App;
```

#### 2. 基于组件的集成

- **原理**：将微前端*封装成独立的组件*，主应用像使用普通组件一样引入和使用这些*微前端组件*。这种方式更注重*组件级别的复用和组合*。
- **示例**：*使用 Web Components 技术*将微前端封装成自定义元素，主应用可以直接在 HTML 中使用这些自定义元素。

```html
<!-- 主应用 HTML -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Main App</title>
  </head>

  <body>
    <my-product-list></my-product-list>
    <my-cart></my-cart>
    <script src="product-list-microapp.js"></script>
    <script src="cart-microapp.js"></script>
  </body>
</html>
```

#### 3. 基于构建的集成

- **原理**：*在构建阶段将各个微前端合并成一个整体的应用*。每个微前端独立开发和构建，然后通过构建工具（如 Webpack）将它们打包在一起。
- **示例**：*使用 Module Federation*（Webpack 5 引入的特性）实现微前端的构建集成。主应用可以动态加载远程微前端的模块。参考：[[模块联邦（Module Federation）-QW]]

```javascript
// 主应用 Webpack 配置示例
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
  // ...其他配置
  plugins: [
    new ModuleFederationPlugin({
      remotes: {
        productList: "productList@http://localhost:3001/remoteEntry.js",
        cart: "cart@http://localhost:3002/remoteEntry.js",
      },
    }),
  ],
};
```

### 优点

- **技术栈无关**：不同的微前端*可以使用不同的技术栈*开发，团队可以根据项目需求和成员技能选择最合适的技术。例如，一个团队擅长 React，另一个团队擅长 Vue，他们可以分别使用自己熟悉的技术栈开发不同的微前端。
- **独立开发和部署**：每个微前端*可以独立开发、测试和部署*，提高了开发效率和灵活性。一个微前端的更新不会影响其他微前端，降低了部署风险。
- **可维护性和可扩展性**：将大型前端应用拆分成多个小型的微前端，每个微前端的*代码量和复杂度降低*，更容易维护和扩展。当需要添加新功能时，可以开发一个新的微前端并集成到主应用中。

### 缺点

- **集成复杂度**：将多个微前端集成到一个主应用中*需要处理很多细节*，如*通信、样式冲突、资源加载*等，增加了开发的复杂度。
- **性能开销**：多个微前端的加载和初始化可能会*带来一定的性能开销*，特别是在网络环境较差的情况下，用户可能需要等待更长的时间才能看到完整的应用。
- **团队协作挑战**：不同的微前端可能由不同的团队开发，需要良好的沟通和协作机制来确保各个微前端之间的兼容性和一致性。

### 适用场景

- **大型企业级应用**：这类应用通常*功能复杂、代码量大*，采用微前端架构可以*将不同的业务模块拆分成独立的微前端*，便于不同团队分工开发和维护。
- **多团队协作项目**：多个团队同时参与一个前端项目时，微前端架构可以让每个团队专注于自己负责的微前端，提高开发效率和团队协作效率。
