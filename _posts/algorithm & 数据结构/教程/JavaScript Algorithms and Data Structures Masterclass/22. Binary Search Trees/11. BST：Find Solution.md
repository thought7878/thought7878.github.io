```js

class Node{
  constructor(val) {
    this.value = val;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree{
  constructor() {
    this.root = null;
  }

  // 通过逆中序（右→根→左）+ 缩进模拟树的垂直结构（向右旋转90°看）
  printTree(root, space = 0, gap = 4) {
    if (!root) return;
    
    // 先打印右子树
    this.printTree(root.right, space + gap, gap);
    // 打印当前节点（带缩进）
    console.log(' '.repeat(space) + root.value);
    // 再打印左子树
    this.printTree(root.left, space + gap, gap);
  }



  /* 
  - 首先创建新节点
  - 从根节点开始检查
    - 若不存在节点，树为空（无根节点），新节点直接作为根节点
    - 若存在节点（根结点），*比较新节点与当前节点数值大小（循环起点）*
    - 若新节点值大
      - 检查当前节点右侧是否有节点
        - 有，则currentNode移动到该节点，重复比较步骤
        - 无，则将新节点插入到当前节点右侧（循环终点）
    - 若新节点值小
      - 检查当前节点的左侧是否有节点
        - 有，则currentNode移动到该节点，重复比较步骤
        - 无，则将新节点插入到当前节点左侧（循环终点）
    - 若新节点值等于当前节点
      - 返回整棵树（循环终点）
  
  */
  insert(val) {
    const newNode = new Node(val);

    // 若不存在节点，树为空（无根节点），新节点直接作为根节点
    if (!this.root) {
      this.root = newNode;
      return this;
    } 

    // 若存在节点（根结点），*比较新节点与当前节点数值大小（循环起点）*
    let currentNode = this.root;
    while (currentNode) {
      // 若新节点值大
      if (newNode.value > currentNode.value) {
        // 检查当前节点右侧是否有节点
        if (currentNode.right) { // 有，则currentNode移动到该节点，重复比较步骤
          currentNode = currentNode.right;
          // continue;
        } else { // 无，则将新节点插入到当前节点右侧（循环终点）
          currentNode.right = newNode;
          return this;
        }
      } else if (newNode.value < currentNode.value) { // 若新节点值小
        // 检查当前节点的左侧是否有节点
        if (currentNode.left) { // 有，则currentNode移动到该节点，重复比较步骤
          currentNode = currentNode.left;
          // continue;
        } else { // 无，则将新节点插入到当前节点左侧（循环终点）
          currentNode.left = newNode;
          return this;
        }
      } else {// 若新节点值等于当前节点
        return this;
      }
    }
  }

  /* 
  
  **伪代码/pseudo code：**
  - 边界情况：如果没有root，return null
  - 循环开始，终止条件是currentNode有值
    - 比较currentNode.value与val的大小
      - 如果currentNode.value等于val
        - 找到了，return currentNode，终止循环
      - 如果currentNode.value小于val
        - currentNode.right是否存在
          - 是，currentNode移动到right，继续循环
          - 否，没找到，return null，终止循环
      - 如果currentNode.value大于val
        - currentNode.left是否存在
          - 是，currentNode移动到left，继续循环
          - 否，没找到，return null，终止循环
  */
  find(val) {
    // 边界情况：如果没有root，return null
    if (!this.root) return null;

    // 循环开始，终止条件是currentNode有值
    let currentNode = this.root;
    while (currentNode) {
      // 比较currentNode.value与val的大小
      // 如果currentNode.value等于val
      if (currentNode.value === val) {
        // 找到了，return currentNode，终止循环
        return currentNode;
      } else if (val>currentNode.value) {// 如果currentNode.value小于val
        // currentNode.right是否存在
        if (currentNode.right) {// 是，currentNode移动到right，继续循环
          currentNode = currentNode.right;
          continue;
        } else {// 否，没找到，return null，终止循环
          return null;
        }
      } else {// 如果currentNode.value大于val
        // currentNode.left是否存在
        if (currentNode.left) {// 是，currentNode移动到left，继续循环
          currentNode = currentNode.left;
          continue;
        } else {// 否，没找到，return null，终止循环
          return null;
        }
      }
    }
  }
  
}

const bst = new BinarySearchTree();

// bst.root = new Node(18);
// bst.root.left = new Node(10);
// bst.root.left.left = new Node(5);
// bst.root.left.right = new Node(12);

// insert
bst.printTree(bst.root);
bst.insert(18).insert(10).insert(5).insert(12).insert(28).insert(22).insert(38);
bst.printTree(bst.root);

// find()
console.log(bst.find(38));
console.log(bst.find(23));
console.log(bst.find(1));
```

视频讲述了在二叉搜索树（BST）类中实现 find 方法及相关优化的过程，具体如下：

## 初始化 find 方法及根节点判断

[00:00]
首先添加接受值的 find 方法，先检查根节点是否存在，若根节点为空，直接返回 false，例如创建新二叉搜索树 t，执行 t.find(1)会返回 false。

## 定义关键变量与循环条件

[00:51]
创建 current 变量并赋值为根节点，创建 found 变量初始化为 false；使用 while 循环，循环条件为未找到目标（found 为 false）且 current 存在，防止循环无限进行，避免到达树末端后仍继续循环。

## 循环内的节点比较与移动逻辑

[02:00]
在循环中，若目标值小于当前节点值，将 current 更新为当前节点的左子节点；若目标值大于当前节点值，将 current 更新为当前节点的右子节点；若目标值等于当前节点值，将 found 设为 true，循环因条件不满足而结束。

## 方法返回值的调整与两种方法设计

[03:11]
最初考虑返回当前节点，后发现查找不存在的值时会返回 null，更倾向于返回 false 或 undefined；最终决定实现两种方法，一种是 containsValue 方法，仅返回 true（找到目标）或 false（未找到目标），另一种是 find 方法，找到目标时返回对应节点，未找到时返回表示不存在的特定值。
