```js
class Node {
  constructor(val) {
    this.value = val;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  // 通过逆中序（右→根→左）+ 缩进模拟树的垂直结构（向右旋转90°看）
  printTree(root, space = 0, gap = 4) {
    if (!root) return;

    // 先打印右子树
    this.printTree(root.right, space + gap, gap);
    // 打印当前节点（带缩进）
    console.log(" ".repeat(space) + root.value);
    // 再打印左子树
    this.printTree(root.left, space + gap, gap);
  }

  /* 
  ## 首先创建新节点
  ## 从根节点开始检查
    ## 若不存在节点，树为空（无根节点），新节点直接作为根节点
    ## 若存在节点（根结点），*比较新节点与当前节点数值大小（循环起点）*
    ## 若新节点值大
      ## 检查当前节点右侧是否有节点
        ## 有，则currentNode移动到该节点，重复比较步骤
        ## 无，则将新节点插入到当前节点右侧（循环终点）
    ## 若新节点值小
      ## 检查当前节点的左侧是否有节点
        ## 有，则currentNode移动到该节点，重复比较步骤
        ## 无，则将新节点插入到当前节点左侧（循环终点）
    ## 若新节点值等于当前节点
      ## 返回整棵树（循环终点）
  
  */
  insert(val) {
    const newNode = new Node(val);

    // 若不存在节点，树为空（无根节点），新节点直接作为根节点
    if (!this.root) {
      this.root = newNode;
      return this;
    }

    // 若存在节点（根结点），*比较新节点与当前节点数值大小（循环起点）*
    let currentNode = this.root;
    while (currentNode) {
      // 若新节点值大
      if (newNode.value > currentNode.value) {
        // 检查当前节点右侧是否有节点
        if (currentNode.right) {
          // 有，则currentNode移动到该节点，重复比较步骤
          currentNode = currentNode.right;
        } else {
          // 无，则将新节点插入到当前节点右侧（循环终点）
          currentNode.right = newNode;
          return this;
        }
      } else if (newNode.value < currentNode.value) {
        // 若新节点值小
        // 检查当前节点的左侧是否有节点
        if (currentNode.left) {
          // 有，则currentNode移动到该节点，重复比较步骤
          currentNode = currentNode.left;
          continue;
        } else {
          // 无，则将新节点插入到当前节点左侧（循环终点）
          currentNode.left = newNode;
          return this;
        }
      } else {
        // 若新节点值等于当前节点
        return this;
      }
    }
  }
}

const bst = new BinarySearchTree();

// bst.root = new Node(18);
// bst.root.left = new Node(10);
// bst.root.left.left = new Node(5);
// bst.root.left.right = new Node(12);

// insert
bst.printTree(bst.root);
bst.insert(18).insert(10).insert(5).insert(12).insert(28).insert(22).insert(38);
bst.printTree(bst.root);
```

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/0e76d31a051dcb8f5b0eaf2b1be31d4b_MD5.jpeg]]

---

视频围绕二叉搜索树（BST）*插入操作的代码编写*展开，详细讲解了插入逻辑、特殊情况处理及代码优化，具体如下：

## 回顾 BST 结构与前期问题

[00:00]
提及 BST 节点类包含值和左右指针，Bst 类初始根节点为空；指出前期视频中构建的树不符合 BST 规则（如 10 左侧存在大于 10 的值、14 左侧有 13 等），并修正为有效 BST（如将 14 左侧改为 11）。

## 插入方法基础逻辑：处理空树情况
[01:15]
定义插入方法接收一个值，先创建新节点；若树为空（根节点为空），则将根节点设为新节点并返回，完成插入（如插入 10 作为根节点）。

## 插入方法核心逻辑：非空树遍历与插入
[02:16]
非空树时，创建 current 变量从根节点开始遍历，通过 while true 循环持续查找插入位置；若插入值小于 current 值，检查 current 左子节点，为空则将新节点设为 current 左子节点并返回，否则更新 current 为 current 左子节点继续遍历；若插入值大于 current 值，检查 current 右子节点，为空则将新节点设为 current 右子节点并返回，否则更新 current 为 current 右子节点继续遍历（如插入 3、2、13、11、16、7 等值构建有效 BST）。

## 插入方法特殊情况：处理重复值

[08:50]
指出未处理重复值时插入已存在值（如 10）会导致无限循环；提出处理方案，在遍历中检查插入值是否等于 current 值，若是则返回 undefined（或其他标识）以忽略重复值，避免无限循环。

## 插入代码优化：简化逻辑

[10:57]
说明原代码中部分 else 语句可简化，因在值小于/大于 current 值的分支中，满足条件时会返回，无需 else 包裹后续逻辑，简化后代码更简洁但逻辑不变，属于代码风格调整。
