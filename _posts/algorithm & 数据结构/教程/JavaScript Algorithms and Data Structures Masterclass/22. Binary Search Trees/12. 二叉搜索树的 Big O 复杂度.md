Big O of Binary Search Trees

视频讲述了二叉搜索树（BST）中**插入和搜索操作的时间复杂度**（Big O），包括*最好、平均及最坏情况*，还解释了*对数时间复杂度的含义及优化方向*，具体如下：

## 视频主题与目标

[00:00]
聚焦二叉搜索树，不实现新方法，而是复习已添加的方法，重点分析其性能（时间复杂度），探讨树节点数量增长（如从 10 个到 100 万个）时，插入和搜索操作在最好、平均、最坏情况下所需时间的变化。

## 插入与搜索的时间复杂度

[00:29]
**最好和平均情况下时间复杂度为 O(log n)**，此处 *log n 实际是以 2 为底的对数*，在 Big O 表示中*简化去掉底数*；
同时提及后续会解释该结论的由来，并建议未了解对数概念或未看课程开头 Big O 部分视频的观众回顾相关内容。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/91938506c05e906c21bb82a1694e9f0a_MD5.jpeg]]

## O(log n)时间复杂度的优势与原理

[01:11]
O(log n)是稳定的时间复杂度，从图表可看出其增长缓慢；以二叉搜索树的插入操作为例，7 个节点的树插入 59 需 3 次比较，节点数翻倍的树插入 61 仅需多 1 次比较（共 4 次），因树保持有序，节点数翻倍时步骤数仅增加 1，这种关系符合二进制对数特征。

## 对比 O(log n)与其他时间复杂度的性能

[03:11]
结合大 O 复杂度图表，O(log n)增长极其缓慢，性能优于平方时间（n²）、线性时间（n）及 n log n，仅略逊于常数时间，进一步凸显其在二叉搜索树插入和搜索操作中的高效性。

## 二叉搜索树时间复杂度的非绝对性与最坏情况

[03:59]
O(log n)并非绝对保证，最坏情况无法保证该复杂度；以单侧扁平的二叉搜索树（类似链表结构）为例，若树有 100 万个节点且保持单侧结构，插入和搜索步骤会随节点数增长呈线性增加，时间复杂度为 O(n)。

## 二叉搜索树性能优化方案

[05:17]
避免存储单侧扁平的二叉搜索树，若需使用可排序的树结构，可通过重写二叉搜索树选择不同根节点（如选 3 或 4），重新构建树并合理放置节点，以提升搜索和插入操作的速度，使时间复杂度回归到较优水平。
