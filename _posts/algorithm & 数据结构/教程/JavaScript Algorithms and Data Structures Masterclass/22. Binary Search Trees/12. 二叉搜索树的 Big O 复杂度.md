Big O of Binary Search Trees

视频讲述了二叉搜索树（BST）中**插入和搜索操作的时间复杂度**（Big O），包括*最好、平均及最坏情况*，还解释了*对数时间复杂度的含义及优化方向*，具体如下：

## 视频主题与目标

[00:00]
聚焦二叉搜索树，不实现新方法，而是复习已添加的方法，重点分析其性能（时间复杂度），探讨树节点数量增长（如从 10 个到 100 万个）时，插入和搜索操作在最好、平均、最坏情况下所需时间的变化。

## 插入与搜索的时间复杂度

[00:29]
**最好和平均情况下时间复杂度为 O(log n)**，此处 *log n 实际是以 2 为底的对数*，在 Big O 表示中*简化去掉底数*；
同时提及后续会解释该结论的由来，并建议未了解对数概念或未看课程开头 Big O 部分视频的观众回顾相关内容。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/91938506c05e906c21bb82a1694e9f0a_MD5.jpeg]]

## O(log n)时间复杂度的优势与原理

[01:11]
**O(log n)是稳定的时间复杂度，从图表可看出其增长缓慢**；以二叉搜索树的插入操作为例，*7 个节点*的树插入 59 *需 3 次比较*，*节点数翻倍*的树插入 61 仅*需多 1 次比较*（共 4 次），**因树保持有序，节点数翻倍时步骤数仅增加 1**，这种关系符合二进制对数特征。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/9c5b979f7a06ea51f5d26ab4297e940f_MD5.jpeg]]

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/c2071a931303e2ff7046189b0c609907_MD5.jpeg]]

## 对比 O(log n)与其他时间复杂度的性能

[03:11]
结合*大 O 复杂度图表*，*O(log n)增长极其缓慢，性能优于平方时间（n²）、线性时间（n）及 n log n*，**仅略逊于常数时间**，进一步凸显其在二叉搜索树插入和搜索操作中的高效性。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/10. Searching Algorithms/media/68aee72103229937e28b6868bb1f7b34_MD5.jpeg]]


## 二叉搜索树时间复杂度的非绝对性与最坏情况

[03:59]
*O(log n)并非绝对保证，最坏情况无法保证该复杂度*；
以*单侧扁平的二叉搜索树*（类似链表结构）为例，若树有 100 万个节点且保持单侧结构，**插入和搜索步骤会随节点数增长呈线性增加，时间复杂度为 O(n)**。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/22. Binary Search Trees/media/3eca98548f5ba9bd528a0aa2b2e8efbf_MD5.jpeg]]


[05:17]
*避免存储单侧扁平的二叉搜索树*，若需使用可排序的树结构，*可通过重写二叉搜索树选择不同根节点*（如选 3 或 4），*重新构建树并合理放置节点*，以提升搜索和插入操作的速度，使时间复杂度回归到较优水平。
