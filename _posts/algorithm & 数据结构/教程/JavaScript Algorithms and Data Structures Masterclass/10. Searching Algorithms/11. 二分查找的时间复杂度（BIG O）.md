11. Binary Search BIG O


视频讲述了二分查找的时间复杂度相关内容，包括*不同情况下的时间复杂度、通过实例验证时间复杂度推导过程、二分查找的使用前提*等，具体如下：

## 不同情况的时间复杂度
[00:00]
二分查找的**最好情况时间复杂度为O(1)**，即*第一次选中的中间位置元素*就是要找的目标元素，*仅需一次操作*；
**最坏和平均情况时间复杂度均为O(log n)**，并提及若对对数及大O中对数应用不熟悉，可观看相关简短视频。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/10. Searching Algorithms/media/c0f7b64d0571001d591a95479ad154ea_MD5.jpeg]]

## 演示二分查找过程
[01:00]
在含16个元素的有序数组中搜索13（实际不存在），
第一步选中间值19，因13小于19缩小查找范围；
第二步选子数组中间值9，因13大于9再次缩小范围；
第三步选子数组中间值14，因13小于14继续缩小；
第四步检查最后子数组元素11，确定13不在数组中，共4步，同时举例说明寻找存在元素（如9需2步、14需3步）的情况。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/10. Searching Algorithms/media/ade4a0f3de1544c92eaf9eff159959bf_MD5.jpeg]]

## 通过数组扩容验证时间复杂度关系
[02:45]
将数组元素从16个翻倍至32个，搜索目标元素32，第一步选中间值16，因32大于16缩小范围；后续逐步选取中间值24、28、30比较，最终找到32，共5步，验证了元素数量与查找步数呈以2为底的对数关系（log₂n），简化为log n，且数组规模翻倍时仅需额外增加1步操作。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/10. Searching Algorithms/media/fce9090864bafa703eab375661dfa0e0_MD5.jpeg]]

## 二分查找的性能优势与使用前提
[05:03]
指出在大O复杂度速查图中，O(log n)性能优异，位于低端，宏观视角下与O(1)接近，二分查找速度极快；强调二分查找的前提是数据必须有序，若数据无序则无法使用，需采用效率更低的线性搜索，同时提及后续学习二叉树、图等内容时会再次遇到含log n的时间复杂度。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/10. Searching Algorithms/media/68aee72103229937e28b6868bb1f7b34_MD5.jpeg]]