Writing Our Own Queue From Scratch


视频讲述了如何*基于单向链表从头构建队列数据结构，对比了队列与栈的差异*，并演示了队列核心方法的实现与测试，具体如下：

## 队列构建基础与前置知识要求
[00:00]
明确*队列将基于单向链表构建*，而非数组，与之前基于链表构建栈的思路类似；
提醒观众需先完成单向链表部分学习，若未掌握相关知识可能会对后续内容感到困惑。


## 队列属性、节点结构定义
[00:23]
`队列类`包含*first（队首）、last（队尾）和size（队列大小）* 三个属性；
队列中每个元素对应一个`节点类`，节点包含*值*（存储元素数据）和*指向下一个节点的指针*（维护链表连接）。


## 添加与移除的两种可选方式及效率对比
[00:40]
*第一种*是在链表末尾添加元素、从开头移除元素，*第二种*是在开头添加元素、从末尾移除元素；
在单向链表中，*从末尾移除元素（类似栈的pop操作）需遍历整个链表，效率较低*，
因此确定**选择“末尾添加、开头移除”的方式实现队列**。


## 队列入队（enqueue）方法实现逻辑
[03:34]
入队方法接收一个值，首先用该值创建新节点；
若队列为空（size为0或first不存在），则将新节点同时设为队首（first）和队尾（last）；
若队列非空，将当前队尾节点的next指向新节点，再将队尾指针（last）移动到新节点；
最后将队列size加1，并返回递增后的size。


## 队列出队（dequeue）方法实现逻辑
[05:59]
出队方法不接收参数，首先检查队列是否为空（first不存在），若为空则返回null；
若队列非空，用temp变量存储当前队首节点（后续需返回该节点的值）；
若队列中仅存在一个元素（first等于last），则将队尾（last）设为null；
之后将队首指针（first）更新为原队首节点的next；
最后将队列size减1，并返回temp变量存储的原队首节点的值。


## 队列与栈的核心差异对比
[08:44]
`队列`遵循 **“先进先出（FIFO）”原则**，`栈`遵循 **“后进先出（LIFO）”原则**；
**二者共同点**是*均仅支持添加和移除两种核心操作*，但操作顺序完全不同，且*队列基于链表实现时是“末尾添加、开头移除”，栈基于链表实现时是“开头添加、开头移除”*。


## 队列功能测试与特性说明
[08:24]
通过创建队列实例，执行多次入队操作添加元素，再执行出队操作移除元素，验证出队操作能正确返回最先入队的元素，且当队列元素全部移除后，first和last设为null、size恢复为0；说明该队列可无限扩展，无索引操作相关问题，添加和移除元素的操作均为常数时间复杂度。


## 后续内容预告
[10:03]
预告下一个视频将总结栈和队列的相关内容，讨论二者的大O表示法（时间复杂度和空间复杂度）。