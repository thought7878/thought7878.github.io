Singly Linked List: Reverse Solution


视频讲述了在单链表上实现反转功能的方法，包括*辅助验证的print方法介绍、反转逻辑的实现步骤、代码运行验证、反转过程的逐步拆解*，具体如下：

## print方法的作用
[00:00]
添加`print方法`并非必需完成的任务，之前未提及，*主要用于直观验证反转是否成功*。它不返回值，直接打印控制台，*将链表所有节点值按顺序排成数组输出*（虽违背链表使用意义，但简便直观，不为效率只为观察变化），通过对比反转前后打印的数组顺序，可确认反转是否成功。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/19. Singly Linked Lists/media/65d0ceb1092e2ab5a91b7330562846d4_MD5.jpeg]]

## 所需变量与初始设置
[01:22]
实现反转需**三个变量跟踪节点**，分别是`当前节点`、`下一个节点`、`前一个节点`（即将连接的后方节点）。
先创建node变量指向头节点，因要交换头尾，此时头节点会变成尾节点，且不能直接让尾节点等于头节点（避免头节点改变后出错），node变量还会在循环中使用；同时将previous变量初始化为null（因初始时当前节点前方无节点，且需确保列表末尾尾节点.next为null）。


## 循环方式与循环条件
[02:03]
选择*用for循环实现反转*（以往多用while循环，此处为展示可行性），循环条件为i从0开始，i小于当前节点长度，i自增，通过该循环可遍历整个链表以完成反转操作。


## 循环内反转核心逻辑
[02:21]
首先创建next变量并设为当前节点.next（保存下一个节点，便于后续继续处理）；接着将当前节点的next指向previous（初始时previous为null，后续会更新）；然后更新previous为原来的当前节点，更新当前节点为之前保存的next节点，通过这样的步骤移动节点位置，逐步完成链表反转。


## 进行代码运行验证
[04:42]
先执行list.print查看当前链表节点值数组顺序，再执行list.reverse进行反转，之后再次打印，观察到打印的数组顺序与反转前相反（如原顺序对应值反转后变为102012535999），且检查头节点设置正确、尾节点.next为null，确认反转功能有效。


## 逐步拆解反转过程
[05:04]
以初始节点值情况为例，多次循环演示反转步骤。第一次循环，node指向头节点，next设为node.next（如201），node.next指向null（previous初始值），更新previous为头节点值（如100），node设为next（201）；后续循环重复类似操作，每次将当前节点.next指向previous，更新previous和node，直至循环结束（因for循环基于长度，元素数量确定时循环次数固定），清晰展示链表如何通过逐步调整节点指向完成反转。
