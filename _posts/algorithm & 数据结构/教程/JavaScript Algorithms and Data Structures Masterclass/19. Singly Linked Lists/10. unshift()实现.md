Singly Linked List: Unshift Solution


视频讲述了单链表（Singly Linked List）中*unshift方法的编写、问题排查与修复过程*，以及*该方法与数组头部插入操作的差异*，具体如下：

## unshift方法编写步骤（初始版）
[00:00]
首先定义unshift方法，接收要添加的值；创建新节点，将传入的值传入新节点；检查边界情况，若链表无head（为空），则将head和tail都设为新节点；若链表非空，将新节点的next属性设为当前head，再更新head为新节点；最后增加链表长度并返回整个链表。
## 测试与问题发现
[02:56]
测试时发现，*当链表为空时执行unshift操作，新节点的next属性会自引用（指向自身），再次执行unshift添加其他内容会出错，且尾部结构也异常*；
经排查，问题在于初始代码中没有else语句，导致链表为空时，在设置head和tail为新节点后，仍会执行非空链表时的逻辑（将新节点next设为当前head，即自身）。

## 问题修复
[05:12]
在代码中添加else语句，使“将新节点next设为当前head、更新head为新节点”的逻辑仅在链表非空时执行，“将head和tail设为新节点”的逻辑仅在链表为空时执行；修复后重新测试，链表为空时执行unshift操作，新节点无异常自引用，功能正常。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/19. Singly Linked Lists/media/04b1b6bcc6393dce14925caabec964a9_MD5.jpeg]]

## unshift与数组头部插入对比
[01:45]
单链表执行unshift操作，无论链表长度（即使有百万项），*只需完成新节点创建、指针指向调整和head更新，无需其他后台操作*；
而数组在头部添加元素时，即使有百万项，*整个数组需重新索引，每个元素都要获得新索引，效率较低*。
## 后续内容预告
[05:48]
完成unshift方法后，接下来将讲解单链表中基于位置或索引获取值的get方法和设置值的set方法，这两种方法逻辑会稍微复杂。