```js

  /*
  向双向链表的开头添加一个节点。
  1 <-> 2 <-> 3
  h           t 

  伪代码/pseudo code：
  - 新建Node对象  
  - 如果是空list
    - head/tail为新Node对象
    - length+1
  - 如果不是空list
    - head.previous=newNode
    - newNode.next=head
    - head=newNode
    - length+1
  */
  unshift(val) {
    let newNode = new Node(val);
    if (this.length === 0) {
      this.head = this.tail = newNode;
    } else {
      this.head.previous = newNode;
      newNode.next = this.head;
      this.head = newNode;
    }
    this.length++;

    return newNode;
  }

```


视频讲述了双向链表中unshift操作的*具体步骤、边界情况处理以及对应的伪代码*，具体如下：

- **unshift操作核心目的**：*向双向链表的开头添加一个节点*，该操作与单向链表中的类似操作有相似之处，但需处理双向链表额外的连接关系。
- **unshift操作具体步骤（非空列表）**：首先找到当前的头节点并创建新节点，接着让新节点的next指针指向当前头节点，然后让旧头节点的previous指针指向新节点，最后将新节点设为头节点，完成节点添加。
- **unshift操作边界情况处理（空列表）**：若链表为空，执行unshift操作时，无需处理新旧节点的指针连接，直接将链表的头节点和尾节点都指向新创建的节点即可。
- **unshift操作伪代码逻辑**：第一步用传入的值创建新节点；第二步判断链表长度，若为零（空列表），将头和尾都设为新节点，若不为零（非空列表），先将头节点的previous属性指向新节点，再将新节点的next属性指向当前头节点，然后更新头节点为新节点；第三步增加链表长度计数；第四步返回整个链表。
- **unshift操作关键注意事项重申**：再次强调操作流程，先创建新节点，再建立新节点与原头节点的双向指针连接（新节点next指向原头节点、原头节点previous指向新节点），最后更新头节点标识，明确原头节点不再作为头节点，新节点成为新头节点，同时需重点关注列表为空时头、尾节点均指向新节点的边界情况。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/20. Doubly Linked Lists/media/69f90569fa3b82e825f9830045761541_MD5.jpeg]]