
```js

  /* 
  移除链表开头的节点。
  1 <-> 2 <-> 3
  h           t 
  伪代码/pseudo code：
    - 边界情况：
    - 链表没有node：return null。
    - 只有一个node：head=null，tail=null，length=0。
    - 其他情况：
      - newHead=head.next
      - head.next=null，newHead.previous=null
      - 更新head=newHead
      - 更新length-1
  */
  shift() {
    if (!this.head) return null;

    let shiftedNode = this.head;

    if (this.length === 1) {
      this.head = null;
      this.tail = null;
      this.length = 0;
    } else {
      let newHead = this.head.next;
      this.head.next = null;
      newHead.previous = null;
      this.head = newHead;
      this.length--;
    }

    return shiftedNode;
  }
  
```

视频讲述了向双向链表添加shift操作的相关内容，包括*shift操作的定义、双向链表与单向链表shift操作的对比、具体实现步骤及伪代码逻辑*，具体如下：

- **明确shift操作定义及易混淆点**：shift操作的功能是*移除链表开头的节点*，同时指出shift常与unshift、push、pop混淆，其中push和pop操作相对简单，而shift和unshift易被记错，需明确区分shift针对链表开头节点的移除功能。
- **对比单向与双向链表shift操作差异**：单向链表移除开头节点时，只需获取当前头节点，将其.next设为新头，并把旧头节点.next设为null后返回旧头；双向链表操作基本类似，但多了一个链接处理，需额外将新头节点的.previous设为null，切断两个连接后返回旧头，且此场景下双向链表无实际优势。
- **阐述双向链表shift操作伪代码逻辑**：首先处理边界情况，若链表长度为0或无出头节点，返回未定义；若长度为1，移除节点后需将头和尾都设为null；否则将当前头存储为oldHead，更新头为oldHead.next，设置新头.previous为null、oldHead.next为null，最后减少链表长度并返回oldHead。
- **说明后续内容安排**：完成双向链表shift操作的讲解后，接下来将给出该操作的具体解决方案。


![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/20. Doubly Linked Lists/media/7e38b452a1d11a9321f0dfa8ae88a9d6_MD5.jpeg]]