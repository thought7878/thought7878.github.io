Depth First InOrder Intro

视频讲述了二叉树深度优先搜索中的*中序遍历方法*，包括*中序遍历的定义、遍历过程示例、伪代码逻辑*以及与其他遍历方式的对比，具体如下：

## 中序遍历定义及核心顺序

[00:00]
中序遍历是深度优先搜索的一种顺序，核心规则为“先遍历整个左子树，再访问当前节点，最后遍历整个右子树”，改变左子树、节点、右子树的处理顺序会完全改变输出结果。

## 中序遍历具体过程示例

[00:29]
以根节点为 10 的二叉树（10 的左子树为 6，6 的左子树为 3、右子树为 8；10 的右子树为 15，15 的右子树为 20）为例，遍历过程为：先遍历 10 的左子树，即先到 6，再遍历 6 的左子树到 3（3 是叶子节点，访问 3），返回访问 6，再遍历 6 的右子树到 8（8 是叶子节点，访问 8）；回到 10，访问 10；最后遍历 10 的右子树，到 15，再遍历 15 的右子树到 20（访问 20），最终输出结果为“3、6、8、10、15、20”。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/23. Tree Traversal/media/552e87b15fe5492c6eff81c374f17966_MD5.jpeg]]


## 中序遍历伪代码逻辑

[01:05]
伪代码核心在于辅助函数中，先递归遍历当前节点的左子树，再将当前节点值存入变量（或列表/数组），最后递归遍历当前节点的右子树，最终目标是构建按访问顺序排列的节点值列表/数组，或直接打印访问顺序。

  **我的伪代码/pseudo code：**
  - 创建函数inOrder，输入是node，输出是visited（遍历node的数组）
  - 创建变量visited（保存遍历过的node）
  - 边界条件：如果node没值，返回
  - 有左子节点，递归调用自己recurseNode(左子节点)；没有左子节点，什么也不做或return。
  - 将node放入visited
  - 有右子节点，递归调用自己recurseNode(右子节点)；没有右子节点，什么也不做或return。


## 中序遍历与其他遍历方式的对比

[01:48]
与先序遍历（先访问节点，再处理左子树，最后处理右子树）、后序遍历（先遍历到最左端和最右端，最后访问节点）相比，中序遍历仅需修改一行代码（调整左子树、节点、右子树的处理顺序）即可实现，若已有先序遍历或后序遍历的代码基础，修改后可快速实现中序遍历。

## 学习建议

[02:00]
建议结合前两个视频（先序遍历、后序遍历）的代码，通过修改一行代码（调整左、中、右的处理顺序）自行实现中序遍历，以更清晰地理解中序遍历逻辑并与其他遍历方式对比。
