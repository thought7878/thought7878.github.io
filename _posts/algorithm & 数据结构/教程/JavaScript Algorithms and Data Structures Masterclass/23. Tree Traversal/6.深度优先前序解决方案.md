Depth First PreOrder Solution

```js
  /*

  伪代码/pseudo code：
  ## 创建变量visited（保存遍历过的node）
  ## 创建函数preOrder，输入是node，输出是遍历node的数组
  ## 如果node有值，将node放入visited；没值，返回
  ## 判断node是否有左右子节点
    ## 有左子节点，递归调用自己preOder(左子节点)；没有左子节点，return。
    ## 有右子节点，递归调用自己preOder(右子节点)；没有右子节点，return。

  */
  preOrder(root) {

    let visited = [];
    function recurseNode(node) {
      if (!node) return;

      visited.push(node);

      if (node.left) {
        recurseNode(node.left);
      } else {
        return;
      }
      if (node.right) {
        recurseNode(node.right);
      } else {
        return;
      }
    }

    recurseNode(root);

    return visited;
  }

```

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/23. Tree Traversal/media/e51964a296532bcf39332905da84b429_MD5.jpeg]]

---

视频讲述了深度优先搜索*前序遍历的实现方法、代码执行过程及原理*，具体如下：

## 定义前序遍历函数及内部变量

[00:00]
先定义名为“dfs 前序遍历”的函数，在函数内部创建用于存储最终结果的 data 变量，以及初始设为根节点的 current 变量，还编写了接受节点参数的嵌套辅助函数 traverse。

## 辅助函数 traverse 的功能逻辑

[00:35]
traverse 函数首先将传入节点的值推入 data 变量，然后检查该节点是否存在左子节点，若存在则调用 traverse 函数处理左子节点，之后再检查是否存在右子节点，若存在则调用 traverse 函数处理右子节点。

## 说明函数调用及 current 变量作用

[01:29]
需调用 traverse 函数，可使用 current 变量（设为根节点）调用，也可直接调用 traverse(root)；设置 current 变量是为了允许用户在大型树结构中指定起始节点，而非必须从根节点开始遍历。

## 验证遍历结果

[02:06]
以包含节点 10、6、15、3、8、20 的树为例，运行代码后，深度优先搜索前序遍历的正确结果为 10、6、3、8、15、20。

## 逐步解析代码执行过程与调用栈变化

[02:48]
创建树对象并设置断点，逐步执行代码，观察调用栈变化。从根节点 10 开始，将 10 加入 data 后处理左子节点 6，把 6 加入 data 再处理其左子节点 3，3 加入 data 后因无左右子节点，处理完 3 返回 6 处理右子节点 8，8 加入 data 后无左右子节点，处理完 8 返回 10 处理右子节点 15，15 加入 data 后处理右子节点 20，20 加入 data 后无左右子节点，最终所有节点处理完毕，调用栈中调用依次弹出。

## 总结前序遍历核心逻辑

[06:29]
*递归地访问一个节点，然后访问该节点的整个左子树，接着访问该节点的整个右子树*，调整此过程顺序可得到不同的遍历方式。
