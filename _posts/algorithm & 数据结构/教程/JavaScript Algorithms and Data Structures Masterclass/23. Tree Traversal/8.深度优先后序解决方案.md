Depth First PostOrder Solution  


```js
  /* 

  **我的伪代码/pseudo code：**
  - 创建变量visited（保存遍历过的node）
  - 创建函数postOrder，输入是node，输出是visited（遍历node的数组）
  - 边界条件：如果node没值，返回
  - 判断node是否有左右子节点
    - 有左子节点，递归调用自己recurseNode(左子节点)；没有左子节点，什么也不做或return。
    - 有右子节点，递归调用自己recurseNode(右子节点)；没有右子节点，什么也不做或return。
  - 后序遍历，放在最后处理：将node放入visited
  */
  postOrder(root) {
    
    let visited = [];
    
    function recurseNode(node) {
      if (!node) return;
      if (node.left) recurseNode(node.left);
      if (node.right) recurseNode(node.right);
      // 后序遍历，放在最后处理
      visited.push(node);
    }

    recurseNode(root);
    return visited;
  }

```


---

视频讲述了二叉树深度优先后序遍历（Depth First PostOrder）的原理、代码实现及验证过程，具体如下：

- **后序遍历核心规则介绍**：明确后序遍历的顺序为，对任意节点，先探索其整个左侧子树，再探索整个右侧子树，最后访问该节点本身，并将节点值添加到存储列表中。
- **后序遍历代码结构设计**：首先定义深度优先后序搜索函数，创建用于存储节点数据的数据数组；接着定义遍历辅助函数，该函数接收节点参数，先判断节点左子树是否存在，若存在则递归遍历左子节点，再判断节点右子树是否存在，若存在则递归遍历右子节点，最后将当前节点值压入数据数组；最后调用遍历辅助函数，传入根节点作为参数。
- **后序与前序遍历代码差异说明**：指出后序遍历与前序遍历代码结构基本相同，核心差异在于访问节点（将节点值压入数组）的步骤顺序，后序遍历是在探索完左右子树后执行该步骤，前序遍历则是先访问节点再探索子树。
- **后序遍历功能验证与结果展示**：通过运行代码验证后序遍历功能是否正常，以特定二叉树为例，说明其正确的后序遍历结果顺序为3、8、6、15、20、10，并对比前序遍历（10、6、3、8、15、20）的结果，进一步明确两种遍历方式的顺序区别。