Depth First InOrder Solution  

```js
  /* 
  **我的伪代码/pseudo code：**
  - 创建函数inOrder，输出是visited（遍历node的数组）
  - 创建变量visited（保存遍历过的node）
  - 边界条件：如果node没值，返回
  - 有左子节点，递归调用自己recurseNode(左子节点)；没有左子节点，什么也不做或return。
  - 将node放入visited（中序遍历，放在中间处理）
  - 有右子节点，递归调用自己recurseNode(右子节点)；没有右子节点，什么也不做或return。
  */
  inOrder(root) {
    
    let visited = [];
    function recurseNode(node) {
      if (!node) return;

      if (node.left) recurseNode(node.left);
      // 中序遍历，放在中间处理
      visited.push(node);
      if (node.right) recurseNode(node.right);

    }

    recurseNode(root);

    return visited;
  }

```

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/23. Tree Traversal/media/58964ed3350bfeb2124b935c0da6feeb_MD5.jpeg]]

---

视频讲述了二叉树深度优先搜索（DFS）中的中序遍历实现方法、代码优化思路，以及提及后续将讨论遍历方法的优缺点和选择依据，具体如下：

- **中序遍历核心逻辑与实现**：中序遍历遵循“先遍历左子树，再访问当前节点，最后遍历右子树”的规则；实现时只需在之前深度优先搜索解决方案的基础上修改一行代码，通过复制原有代码并调整处理顺序，先处理左子树，再将当前节点值推入数据数组，最后处理右子树。
- **中序遍历实例验证**：以具体树结构为例，遍历过程为：先不断深入左子树直至无路径可走，将节点值3推入数组，返回后访问节点6，再处理其右子树，之后返回节点10，访问该节点后继续处理右子树；调用树的DFS中序遍历方法，得到结果3、6、8、10、15、20，与预期一致。
- **代码优化方式**：可去掉代码中的条件判断，直接调用左节点和右节点进行遍历，通过检查节点是否为真值（非零）来达到与条件判断相同的效果；视频作者个人偏好保留条件判断的稍冗长写法，但也认可简洁写法的合理性，且该优化方式适用于深度优先搜索的三种遍历（前序、中序、后序）解决方案。
- **深度优先搜索遍历特点及后续计划**：深度优先搜索的三种方式（前序、中序、后序）均是纵向处理树结构，而非横向来回切换；后续将添加简短视频，讨论深度优先搜索（DFS）与广度优先搜索（BFS）的优缺点，以及不同场景下选择哪种遍历方法的依据。