Depth First PostOrder Intro


视频围绕树的深度优先后序遍历展开，对比前序遍历说明其差异，并讲解实现思路与示例结果，具体如下：

## 后序遍历概念引入及与前序遍历差异

[00:00]
后序遍历是对前序遍历代码顺序的细微调整，仅改变一行代码顺序就会显著改变输出顺序。前序遍历是先访问节点，再处理左子树，最后处理右子树；后序遍历则是先处理左子树和右子树，最后访问节点，从名称可体现“顺序在后”的特点。

## 后序遍历具体遍历过程示例

[01:26]
以根节点为 10，左子树包含 6（左子树 3、右子树 8），右子树包含 15（右子树 20）的树为例，详细说明后序遍历过程。从 10 开始暂不访问，先深入左子树，依次处理 3、8，再访问 6；接着处理 10 的右子树，深入 15 的右子树处理 20，再访问 15；最后访问 10，根节点在该示例中最后被访问。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/23. Tree Traversal/media/9844c1277c893d949eb610bd2bb4fbe7_MD5.jpeg]]


## 后序遍历代码实现思路

[02:32]
说明实现后序遍历只需调整代码顺序，与前序遍历代码大部分内容相同。需创建存储访问值的数组，编写接受节点的辅助函数，递归执行：若存在左属性则在左属性上调用辅助函数，若存在右属性则遍历右属性，最后将节点值存入访问数组；用当前节点调用辅助函数，最终返回值数组。

**我的伪代码/pseudo code：**
  - 创建变量visited（保存遍历过的node）
  - 创建函数postOrder，输入是node，输出是visited（遍历node的数组）
  - 边界条件：如果node没值，返回
  - 判断node是否有左右子节点
    - 有左子节点，递归调用自己recurseNode(左子节点)；没有左子节点，什么也不做或return。
    - 有右子节点，递归调用自己recurseNode(右子节点)；没有右子节点，什么也不做或return。
  - 将node放入visited


## 视频内容及相关资源提示

[03:49]
提示若使用示例中的树，可尝试修改代码（时间紧张可复制粘贴调整顺序）实现后序遍历并验证是否得到预期结果；同时展示了该视频所属的“JS Algorithms and Data Structures_23. Tree Traversal”系列视频选集，包含树遍历相关的多种 Intro 及 Solution 视频，还提及视频的播放设置、字幕设置、互动功能等相关操作选项。
