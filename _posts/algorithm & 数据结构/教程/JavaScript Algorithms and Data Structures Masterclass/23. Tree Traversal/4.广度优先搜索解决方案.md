Breadth First Search Solution

```js


/* 
代码测试在BinarySearchTree.js的traversal

**我的伪代码/Pseudo Code：**
- 创建函数 traversal：
	- 输入是tree
	- 输出是包含树节点的数组
- 创建变量queue（保存即将遍历的tree节点），初始值是tree.root；变量visited（保存已经遍历的tree节点）
- while循环，终结条件是queue不为空
	- 取出queue的头节点（这里使用数组，链表还需修改头节点），放入visited
	- 判断刚操作的节点是否有左右子节点
		- 有，依次放入queue中
		- 没有，什么也不做

*/
function traversal(tree) {
  let queue = [tree.root];
  let visited=[]
  let currentNode = null;

  while (queue.length !== 0) {
    currentNode = queue.shift();
    visited.push(currentNode);
    if (currentNode.left) {
      queue.push(currentNode.left);
    }
    if (currentNode.right) {
      queue.push(currentNode.right);
    }
  }

  return visited;
}
```

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/23. Tree Traversal/media/957056008b09e9971bdc52af0e209971_MD5.jpeg]]


---


视频讲述了如何用 JavaScript*实现树的广度优先搜索（BFS）*，包括*方法定义、核心逻辑、代码演示、原理扩展*，具体如下：

## 定义 BFS 方法及初始化所需变量

[00:00]
定义名为 bfs 的无参方法，用于访问树的每个节点；初始化两个空数组，一个作为存储最终结果的数据数组，另一个作为实现 BFS 的队列，并将树的根节点放入队列（执行 Q.push(this.root)）。

## 设置 BFS 循环条件与节点处理逻辑

[00:58]
循环条件设为 while q.length（空数组长度为 0，视为假值，队列有元素时循环继续）；在循环内，通过 q.shift()从队列开头取出节点并存入 node 变量，再将该节点（或节点值，为直观展示）加入数据数组；随后检查节点是否有左子节点和右子节点，若存在则依次加入队列，实现先进先出的访问顺序。

## 演示 BFS 执行过程与预期结果

[03:32]
以根节点为 10、左子节点 6、右子节点 15，6 的子节点为 3 和 8，15 的子节点为 20 的树为例，演示 BFS 执行流程；预期遍历结果为 10、6、15、3、8、20，即按树的层级横向遍历所有节点，最终运行代码验证该结果。

## 扩展 BFS 适用范围与核心原理

[06:05]
说明 BFS 不仅适用于二叉树，若为三叉树或其他多叉树，可通过添加多个子节点判断或循环遍历所有子节点的方式适配；强调 BFS 的核心原理始终是利用队列的先进先出特性，跟踪待访问节点并逐步扩展访问范围。
