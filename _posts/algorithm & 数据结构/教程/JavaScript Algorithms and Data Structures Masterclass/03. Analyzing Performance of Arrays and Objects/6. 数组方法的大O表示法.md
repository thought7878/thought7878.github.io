6. Big O of Array Methods

视频讲述了JavaScript中*数组常用内置方法的时间复杂度*（以大O表示法呈现），并解释了*不同方法时间复杂度差异的原因*，同时*对比了数组与对象的适用场景*，具体如下：

## 开篇说明与学习建议
[00:00]
介绍视频主题是*简要讲解数组内置方法的大O表示法*，强调*无需记住*所有内容，重点是*理解时间复杂度数值的由来*，为后续内容做铺垫。

![[_posts/algorithm & 数据结构/教程/JavaScript Algorithms and Data Structures Masterclass/03. Analyzing Performance of Arrays and Objects/media/324c42dec6dd644230ee0d40c688e8e8_MD5.jpeg]]

## 首尾增删的时间复杂度
[00:24]
`push`（末尾添加）和`pop`（末尾删除）是**常数时间操作O(1)**，无需重新索引，无论数组元素数量多少，耗时都稳定；
`shift`（开头删除）和`unshift`（开头添加）是**线性时间操作O(n)**，*因为会导致所有元素重新索引*，元素数量越多，耗时越长。

## 合并、切片、拼接的时间复杂度
[01:12]
`concat`（合并数组）、`slice`（返回数组部分或全部副本）、`splice`（移除并添加元素）均为**线性时间操作O(n)**。
`concat`合并两个数组理论上可表示为O(n+m)（m为第二个数组大小），但**简化为O(n)**，耗时与最终新数组总大小成比例；
`slice`耗时随复制元素数量增长而增长；
`splice`因灵活*可在数组不同位置操作，但即使在中间操作，也需移动后续元素重新索引*，故**简化为O(n)**。


## 排序的时间复杂度
[03:09]
`array.sort()`**时间复杂度为O(n * log n)**，*排序需进行元素比较和移动，仅遍历一次元素无法完成，步骤更复杂，耗时超过O(n)*，具体推导后续会详细讲解。


## 遍历类的时间复杂度
[04:03]
`map`、`filter`、`reduce`、`forEach`等方法均为**线性时间操作O(n)**，这些方法*需遍历数组每个元素并执行相应操作*（如统计、布尔测试等），**数组规模增大时，耗时随之增加**。


## 数组与对象的适用场景对比
[04:52]
**`对象`几乎所有操作高效，但*无顺序***；
`数组`适合***需要顺序*的场景**，使用时*建议优先从尾部增删元素*（push、pop），*避免从头部（shift、unshift）或中间增删*，**因后者会引发元素重新索引的“连锁反应”（保证顺序）**。


## 视频内容收尾与后续预告
[05:31]
说明本次关于数组和对象的内容结束，若对大O复杂度有疑问，后续会深入讨论，且后续还将讲解排序、链表等内容，届时会介绍链表作为有序数据结构能在开头常数时间增删元素的原理。