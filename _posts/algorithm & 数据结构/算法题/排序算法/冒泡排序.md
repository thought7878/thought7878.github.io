参考：[[20、排序算法专题（上）#冒泡排序]]

以下是用 JavaScript 实现**冒泡排序（Bubble Sort）**的代码。冒泡排序是一种简单的排序算法，其核心思想是通过多次遍历数组，将相邻的元素进行比较并交换位置，从而使较大的元素逐步“冒泡”到数组的末尾。

---

### **解题思路**

1. **问题分析**：
   - 冒泡排序的基本思想是：通过多次遍历数组，每次将未排序部分的最大值移动到数组的末尾。
   - 每次遍历后，最大的元素会被放置在正确的位置上，因此下一轮可以减少一次比较。

2. **核心思想**：
   - 外层循环控制遍历的次数。
   - 内层循环负责比较相邻的两个元素，并根据大小关系交换它们的位置。
   - 如果某次遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。

3. **算法步骤**：
   - 初始化外层循环，执行 `n-1` 次（`n` 是数组长度）。
   - 在内层循环中，从数组开头开始，比较相邻的两个元素。
     - 如果前一个元素大于后一个元素，则交换它们的位置。
   - 如果某次遍历中没有发生交换，则提前结束排序。

4. **时间复杂度**：
   - 最坏情况：O(n²)（数组完全逆序）。
   - 最好情况：O(n)（数组已经有序，且有优化逻辑）。
5. **空间复杂度**：O(1)，原地排序。

---

### **代码实现**

```javascript
function bubbleSort(arr) {
    const n = arr.length;

    for (let i = 0; i < n - 1; i++) {
        let swapped = false; // 标记是否发生交换

        // 内层循环：比较相邻元素
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true; // 标记发生了交换
            }
        }

        // 如果本轮没有发生交换，说明数组已经有序
        if (!swapped) break;
    }

    return arr; // 返回排序后的数组
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const arr1 = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort(arr1)); // 输出: [11, 12, 22, 25, 34, 64, 90]

const arr2 = [5, 1, 4, 2, 8];
console.log(bubbleSort(arr2)); // 输出: [1, 2, 4, 5, 8]

const arr3 = [1, 2, 3, 4, 5];
console.log(bubbleSort(arr3)); // 输出: [1, 2, 3, 4, 5]（已经有序）
```

---

### **运行结果**

对于输入：
#### 示例 1:
```plaintext
输入: [64, 34, 25, 12, 22, 11, 90]
输出: [11, 12, 22, 25, 34, 64, 90]
```

#### 示例 2:
```plaintext
输入: [5, 1, 4, 2, 8]
输出: [1, 2, 4, 5, 8]
```

#### 示例 3:
```plaintext
输入: [1, 2, 3, 4, 5]
输出: [1, 2, 3, 4, 5]
```

---

### **代码详解**

1. **外层循环**：
   - 控制排序的轮数，最多需要 `n-1` 轮。
   - 每轮结束后，最大的元素会被放置在正确的位置上。

2. **内层循环**：
   - 比较相邻的两个元素。
   - 如果前一个元素大于后一个元素，则交换它们的位置。

3. **优化逻辑**：
   - 使用 `swapped` 标志位，如果某轮遍历中没有发生交换，则说明数组已经有序，可以提前结束排序。

4. **返回结果**：
   - 排序完成后，返回排序后的数组。

---

### **总结**

- 冒泡排序的核心思想是通过多次遍历，将较大的元素逐步“冒泡”到数组的末尾。
- 通过引入 `swapped` 标志位，可以在数组已经有序的情况下提前终止排序，从而提高效率。
- 时间复杂度为 O(n²)，适合小规模数据排序；对于大规模数据，性能较差。
- 空间复杂度为 O(1)，是一种原地排序算法。