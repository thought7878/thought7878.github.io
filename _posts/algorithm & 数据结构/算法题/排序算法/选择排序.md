参考：[[20、排序算法专题（上）#选择排序]]

以下是用 JavaScript 实现**选择排序（Selection Sort）** 的代码。选择排序是一种简单的排序算法，其核心思想是：每次从未排序部分中找到最小值，并将其放置到已排序部分的末尾。

---

### **解题思路**

1. **问题分析**：
   - 选择排序的基本思想是：通过多次遍历数组，每次从未排序部分中选出最小值，并将其与当前轮次的第一个元素交换位置。
   - 每次遍历后，已排序部分会增加一个元素，未排序部分会减少一个元素。

2. **核心思想**：
   - 外层循环控制当前轮次的起始位置。
   - 内层循环负责在未排序部分中找到最小值的索引。
   - 将最小值与当前轮次的第一个元素交换位置。

3. **算法步骤**：
   - 初始化外层循环，从第一个元素开始，执行 `n-1` 次（`n` 是数组长度）。
   - 在内层循环中，从未排序部分中找到最小值的索引。
   - 如果最小值的索引不是当前轮次的起始位置，则交换两个元素的位置。

4. **时间复杂度**：
   - 最坏情况：O(n²)（无论数组是否有序，都需要两次嵌套循环）。
   - 最好情况：O(n²)（无法提前终止）。
5. **空间复杂度**：O(1)，原地排序。

---

### **代码实现**

```javascript
function selectionSort(arr) {
    const n = arr.length;

    for (let i = 0; i < n - 1; i++) {
        let minIndex = i; // 假设当前轮次的第一个元素是最小值

        // 内层循环：在未排序部分中找到最小值的索引
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小值的索引
            }
        }

        // 如果最小值的索引不是当前轮次的起始位置，则交换两个元素
        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }
    }

    return arr; // 返回排序后的数组
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const arr1 = [64, 25, 12, 22, 11];
console.log(selectionSort(arr1)); // 输出: [11, 12, 22, 25, 64]

const arr2 = [5, 3, 8, 6, 2];
console.log(selectionSort(arr2)); // 输出: [2, 3, 5, 6, 8]

const arr3 = [1, 2, 3, 4, 5];
console.log(selectionSort(arr3)); // 输出: [1, 2, 3, 4, 5]（已经有序）
```

---

### **运行结果**

对于输入：
#### 示例 1:
```plaintext
输入: [64, 25, 12, 22, 11]
输出: [11, 12, 22, 25, 64]
```

#### 示例 2:
```plaintext
输入: [5, 3, 8, 6, 2]
输出: [2, 3, 5, 6, 8]
```

#### 示例 3:
```plaintext
输入: [1, 2, 3, 4, 5]
输出: [1, 2, 3, 4, 5]
```

---

### **代码详解**

1. **外层循环**：
   - 控制当前轮次的起始位置。
   - 每轮结束后，已排序部分会增加一个元素，未排序部分会减少一个元素。

2. **内层循环**：
   - 从未排序部分中找到最小值的索引。
   - 如果找到更小的值，则更新最小值的索引。

3. **交换操作**：
   - 如果最小值的索引不是当前轮次的起始位置，则交换两个元素的位置。

4. **返回结果**：
   - 排序完成后，返回排序后的数组。

---

### **总结**

- 选择排序的核心思想是通过多次遍历，每次从未排序部分中选出最小值，并将其放置到已排序部分的末尾。
- 时间复杂度为 O(n²)，适合小规模数据排序；对于大规模数据，性能较差。
- 空间复杂度为 O(1)，是一种原地排序算法。
- 选择排序的优点是交换次数较少（最多 n-1 次），但比较次数始终为 O(n²)。
