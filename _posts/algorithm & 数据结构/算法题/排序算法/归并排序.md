参考：[[21、排序算法专题（下）#归并排序]]

以下是用 JavaScript 实现**归并排序（Merge Sort）** 的代码。归并排序是一种分治算法，其核心思想是：将数组分成两半，分别对每一半进行排序，然后将两个有序的部分合并成一个整体。

---

### **解题思路**

1. **问题分析**：
   - 归并排序的基本思想是**分治法（Divide and Conquer）**。
   - 将数组递归地分成两半，直到每个子数组只有一个元素（此时子数组天然有序）。
   - 然后将两个有序的子数组合并成一个有序数组。

2. **核心思想**：
   - **分解**：递归地将数组分成两半，直到每个子数组长度为 1。
   - **合并**：将两个有序的子数组合并成一个有序数组。
     - 使用两个指针分别指向两个子数组的起始位置。
     - 比较两个指针所指的元素，将较小的元素放入结果数组，并移动对应的指针。
     - 当一个子数组的所有元素都被处理完后，将另一个子数组的剩余部分直接加入结果数组。

3. **算法步骤**：
   - 定义一个辅助函数 `merge(left, right)`，用于合并两个有序数组。
   - 定义主函数 `mergeSort(arr)`：
     - 如果数组长度小于等于 1，则直接返回数组（递归终止条件）。
     - 找到数组的中间位置，将数组分成左右两部分。
     - 对左右两部分递归调用 `mergeSort`。
     - 合并左右两部分的结果。

4. **时间复杂度**：
   - 最坏情况、最好情况和平均情况均为 O(n log n)。
5. **空间复杂度**：O(n)，需要额外的空间存储合并后的数组。

---

### **代码实现**

```javascript
function mergeSort(arr) {
    // 如果数组长度小于等于 1，则直接返回数组
    if (arr.length <= 1) return arr;

    // 找到数组的中间位置
    const mid = Math.floor(arr.length / 2);

    // 将数组分成左右两部分
    const left = mergeSort(arr.slice(0, mid)); // 左半部分
    const right = mergeSort(arr.slice(mid));  // 右半部分

    // 合并两个有序数组
    return merge(left, right);
}

// 辅助函数：合并两个有序数组
function merge(left, right) {
    const result = [];
    let i = 0; // 左数组的指针
    let j = 0; // 右数组的指针

    // 比较两个数组的元素，将较小的元素加入结果数组
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }

    // 将左数组剩余部分加入结果数组
    while (i < left.length) {
        result.push(left[i]);
        i++;
    }

    // 将右数组剩余部分加入结果数组
    while (j < right.length) {
        result.push(right[j]);
        j++;
    }

    return result;
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const arr1 = [38, 27, 43, 3, 9, 82, 10];
console.log(mergeSort(arr1)); // 输出: [3, 9, 10, 27, 38, 43, 82]

const arr2 = [5, 3, 8, 6, 2];
console.log(mergeSort(arr2)); // 输出: [2, 3, 5, 6, 8]

const arr3 = [1, 2, 3, 4, 5];
console.log(mergeSort(arr3)); // 输出: [1, 2, 3, 4, 5]（已经有序）
```

---

### **运行结果**

对于输入：
#### 示例 1:
```plaintext
输入: [38, 27, 43, 3, 9, 82, 10]
输出: [3, 9, 10, 27, 38, 43, 82]
```

#### 示例 2:
```plaintext
输入: [5, 3, 8, 6, 2]
输出: [2, 3, 5, 6, 8]
```

#### 示例 3:
```plaintext
输入: [1, 2, 3, 4, 5]
输出: [1, 2, 3, 4, 5]
```

---

### **代码详解**

1. **分解数组**：
   - 通过递归将数组分成左右两部分，直到每个子数组长度为 1。

2. **合并数组**：
   - 使用两个指针分别指向两个有序子数组的起始位置。
   - 比较两个指针所指的元素，将较小的元素加入结果数组，并移动对应的指针。
   - 当一个子数组的所有元素都被处理完后，将另一个子数组的剩余部分直接加入结果数组。

3. **递归终止条件**：
   - 如果数组长度小于等于 1，则直接返回数组。

4. **返回结果**：
   - 排序完成后，返回排序后的数组。

---

### **总结**

- 归并排序的核心思想是分治法：将数组分成两半，分别排序，然后合并。
- 时间复杂度为 O(n log n)，适合处理大规模数据。
- 空间复杂度为 O(n)，需要额外的空间存储合并后的数组。
- 归并排序的优点是性能稳定，但缺点是需要额外的空间开销。