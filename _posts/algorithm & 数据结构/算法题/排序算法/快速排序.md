参考：[[21、排序算法专题（下）#快速排序]]


以下是用 JavaScript 实现**快速排序（Quick Sort）** 的代码。快速排序是一种分治算法，其核心思想是：通过选择一个“基准值”（pivot），将数组分为两部分：小于基准值的部分和大于基准值的部分，然后递归地对这两部分进行排序。

---

### **解题思路**

1. **问题分析**：
   - 快速排序的基本思想是**分治法（Divide and Conquer）**。
   - 选择一个基准值（通常是数组的第一个元素、最后一个元素或中间元素）。
   - 将数组分成两部分：
     - 左边部分包含所有小于基准值的元素。
     - 右边部分包含所有大于基准值的元素。
   - 对左右两部分递归调用快速排序。

2. **核心思想**：
   - **分区（Partition）**：
     - 遍历数组，将小于基准值的元素放到左边，大于基准值的元素放到右边。
   - **递归排序**：
     - 对分区后的左右两部分分别递归调用快速排序。
   - **合并**：
     - 将排序后的左部分、基准值和右部分拼接成最终结果。

3. **算法步骤**：
   - 定义主函数 `quickSort(arr)`：
     - 如果数组长度小于等于 1，则直接返回数组（递归终止条件）。
     - 选择基准值（通常选择数组的第一个元素）。
     - 遍历数组，将小于基准值的元素放入左数组，大于基准值的元素放入右数组。
     - 对左数组和右数组递归调用 `quickSort`。
     - 返回拼接后的结果：`[...quickSort(left), pivot, ...quickSort(right)]`。

4. **时间复杂度**：
   - 最坏情况：O(n²)（当数组已经有序时，每次分区不均匀）。
   - 最好情况和平均情况：O(n log n)。
5. **空间复杂度**：O(log n)，递归栈的最大深度为树的高度。

---

### **代码实现**

```javascript
function quickSort(arr) {
    // 如果数组长度小于等于 1，则直接返回数组
    if (arr.length <= 1) return arr;

    // 选择基准值（这里选择数组的第一个元素）
    const pivot = arr[0];
    const left = [];  // 小于基准值的元素
    const right = []; // 大于基准值的元素

    // 遍历数组，将元素分配到左数组或右数组
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    // 递归排序左数组和右数组，并拼接结果
    return [...quickSort(left), pivot, ...quickSort(right)];
}
```

---

### **优化版本：原地分区**
为了减少空间开销，可以使用原地分区的方式实现快速排序：

```javascript
function quickSort(arr, left = 0, right = arr.length - 1) {
    if (left >= right) return arr; // 递归终止条件

    const pivotIndex = partition(arr, left, right); // 分区操作
    quickSort(arr, left, pivotIndex - 1); // 对左部分递归排序
    quickSort(arr, pivotIndex + 1, right); // 对右部分递归排序

    return arr;
}

// 辅助函数：分区操作
function partition(arr, left, right) {
    const pivot = arr[right]; // 选择最右侧元素作为基准值
    let i = left - 1; // i 指向小于基准值的最后一个元素

    for (let j = left; j < right; j++) {
        if (arr[j] < pivot) {
            i++; // 扩大小于基准值的区域
            [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换元素
        }
    }

    // 将基准值放到正确的位置
    [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
    return i + 1; // 返回基准值的索引
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const arr1 = [10, 7, 8, 9, 1, 5];
console.log(quickSort([...arr1])); // 输出: [1, 5, 7, 8, 9, 10]

const arr2 = [5, 3, 8, 6, 2];
console.log(quickSort([...arr2])); // 输出: [2, 3, 5, 6, 8]

const arr3 = [1, 2, 3, 4, 5];
console.log(quickSort([...arr3])); // 输出: [1, 2, 3, 4, 5]（已经有序）

const arr4 = [3, 6, 8, 10, 1, 2, 1];
console.log(quickSort([...arr4])); // 输出: [1, 1, 2, 3, 6, 8, 10]
```

---

### **运行结果**

对于输入：
#### 示例 1:
```plaintext
输入: [10, 7, 8, 9, 1, 5]
输出: [1, 5, 7, 8, 9, 10]
```

#### 示例 2:
```plaintext
输入: [5, 3, 8, 6, 2]
输出: [2, 3, 5, 6, 8]
```

#### 示例 3:
```plaintext
输入: [1, 2, 3, 4, 5]
输出: [1, 2, 3, 4, 5]
```

#### 示例 4:
```plaintext
输入: [3, 6, 8, 10, 1, 2, 1]
输出: [1, 1, 2, 3, 6, 8, 10]
```

---

### **代码详解**

1. **选择基准值**：
   - 基准值用于将数组分为两部分：小于基准值的部分和大于基准值的部分。

2. **分区操作**：
   - 使用两个指针遍历数组，将小于基准值的元素放到左边，大于基准值的元素放到右边。

3. **递归排序**：
   - 对分区后的左右两部分分别递归调用快速排序。

4. **返回结果**：
   - 排序完成后，返回排序后的数组。

---

### **总结**

- 快速排序的核心思想是分治法：通过选择基准值将数组分为两部分，分别排序后合并。
- 时间复杂度：
  - 最坏情况：O(n²)（当数组已经有序时，每次分区不均匀）。
  - 最好情况和平均情况：O(n log n)。
- 空间复杂度为 O(log n)，递归栈的最大深度为树的高度。
- 快速排序的优点是性能高效且实现简单，但需要注意选择合适的基准值以避免最坏情况。
