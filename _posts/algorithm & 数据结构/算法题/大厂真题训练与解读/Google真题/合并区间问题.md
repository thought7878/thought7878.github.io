
> 题目描述：
> 	给出一个区间的集合，请合并所有重叠的区间。

```
示例 1:  
 	输入: [[1,3],[2,6],[8,10],[15,18]]  
 	输出: [[1,6],[8,10],[15,18]]  
 	解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

```
示例  2:  
 	输入: [[1,4],[4,5]]  
 	输出: [[1,5]]  
 	解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**命题关键字：数学问题、数组**

参考：[[25、大厂真题训练与解读——Google 真题#“合并区间”问题]]


以下是用 JavaScript 实现“合并区间”的代码。我们将使用**排序 + 遍历**的方法来解决这个问题，时间复杂度为 O(n log n)，空间复杂度为 O(n)。

---

### 解题思路

1. **问题分析**：
   - 给定一个区间的集合，要求将所有重叠的区间合并成一个区间。
   - 两个区间 `[a, b]` 和 `[c, d]` 重叠的条件是：`b >= c`（即前一个区间的结束位置大于等于后一个区间的起始位置）。

2. **核心思想**：
   - **排序**：首先按照每个区间的起始位置对区间进行升序排序。
   - **遍历合并**：
     - 初始化一个结果数组 `merged`。
     - 遍历排序后的区间：
       - 如果当前区间与 `merged` 中最后一个区间重叠，则合并它们。
       - 否则，将当前区间加入 `merged`。
   - 最终返回合并后的区间集合。

3. **算法步骤**：
   - 对区间按起始位置进行排序。
   - 初始化结果数组 `merged`，并添加第一个区间。
   - 遍历剩余区间：
     - 如果当前区间的起始位置小于等于 `merged` 中最后一个区间的结束位置，则更新 `merged` 中最后一个区间的结束位置为两者的最大值。
     - 否则，将当前区间加入 `merged`。
   - 返回 `merged`。

4. **时间复杂度**：O(n log n)，其中 n 是区间的数量（排序的时间复杂度为 O(n log n)，遍历的时间复杂度为 O(n)）。
5. **空间复杂度**：O(n)，用于存储结果数组。

---

### 代码实现

```javascript
function merge(intervals) {
    if (!intervals || intervals.length === 0) return [];

    // 按照区间的起始位置排序
    intervals.sort((a, b) => a[0] - b[0]);

    const merged = [intervals[0]]; // 初始化结果数组

    for (let i = 1; i < intervals.length; i++) {
        const current = intervals[i];
        const lastMerged = merged[merged.length - 1];

        // 如果当前区间与上一个区间重叠，则合并
        if (current[0] <= lastMerged[1]) {
            lastMerged[1] = Math.max(lastMerged[1], current[1]); // 更新结束位置
        } else {
            merged.push(current); // 否则，将当前区间加入结果数组
        }
    }

    return merged;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
console.log(merge([[1, 3], [2, 6], [8, 10], [15, 18]]));
// 输出: [[1, 6], [8, 10], [15, 18]]

console.log(merge([[1, 4], [4, 5]]));
// 输出: [[1, 5]]

console.log(merge([[1, 4], [0, 4]]));
// 输出: [[0, 4]]

console.log(merge([[1, 4], [2, 3]]));
// 输出: [[1, 4]]

console.log(merge([]));
// 输出: []
```

---

### 运行结果

```plaintext
输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
```

```plaintext
输入: [[1,4],[4,5]]
输出: [[1,5]]
```

```plaintext
输入: [[1,4],[0,4]]
输出: [[0,4]]
```

```plaintext
输入: [[1,4],[2,3]]
输出: [[1,4]]
```

```plaintext
输入: []
输出: []
```

---

### 代码详解

1. **排序区间**：
   - 使用 `sort` 方法按照区间的起始位置进行升序排序。

2. **初始化结果数组**：
   - 将排序后的第一个区间加入 `merged`。

3. **遍历剩余区间**：
   - 如果当前区间的起始位置小于等于 `merged` 中最后一个区间的结束位置，则说明两者重叠，更新 `merged` 中最后一个区间的结束位置为两者的最大值。
   - 如果不重叠，则将当前区间加入 `merged`。

4. **返回结果**：
   - 最终返回合并后的区间集合。

---

### 总结

- **排序 + 遍历**是解决本问题的经典方法。
- 时间复杂度为 O(n log n)，主要由排序决定。
- 空间复杂度为 O(n)，用于存储结果数组。
- 通过合并重叠区间，能够有效减少区间的数量，简化后续处理逻辑。