
> 题目描述：
> 	房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。  
> 	扫地机器人提供 4 个 API，可以向前进，向左转或者向右转。每次转弯 90 度。  
> 	当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。  
> 	请利用提供的 4 个 API 编写让机器人清理整个房间的算法。

```
interface Robot {
  // 若下一个方格为空，则返回true，并移动至该方格
  // 若下一个方格为障碍物，则返回false，并停留在原地
  boolean move();

  // 在调用turnLeft/turnRight后机器人会停留在原位置
  // 每次转弯90度
  void turnLeft();
  void turnRight();

  // 清理所在方格
  void clean();
}
```

> 示例:  
> 	输入:  
> 	room = [  
> 	 [1,1,1,1,1,0,1,1],  
> 	 [1,1,1,1,1,0,1,1],  
> 	 [1,0,1,1,1,1,1,1],  
> 	 [0,0,0,1,0,0,0,0],  
> 	 [1,1,1,1,1,1,1,1]  
> 	],  
> 	row = 1,  
> 	col = 3  
> 	解析:
> 	房间格栅用 0 或 1 填充。0 表示障碍物，1 表示可以通过。
> 	机器人从 row=1，col=3 的初始位置出发。在左上角的一行以下，三列以右。

> 注意:  
> 	输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用 4 个给出的 API 解决问题。   
> 	扫地机器人的初始位置一定是空地。  
> 	扫地机器人的初始方向向上。  
> 	所有可抵达的格子都是相连的，亦即所有标记为 1 的格子机器人都可以抵达。  
> 	可以假定格栅的四周都被墙包围。

**命题关键字：模拟、DFS**

参考：[[25、大厂真题训练与解读——Google 真题#“扫地机器人”问题]]


以下是用 JavaScript 实现“扫地机器人清理房间”的代码。我们将使用**深度优先搜索（DFS）**和**回溯法**来解决这个问题，确保机器人能够访问所有可达的空格并清理它们。

---

### 解题思路

1. **问题分析**：
   - 房间是一个二维网格，机器人初始位置在一个空格中。
   - 机器人可以调用提供的 API 进行移动、转向和清理操作。
   - 需要设计算法，让机器人能够访问所有可达的空格并清理它们。

2. **核心思想**：
   - 使用深度优先搜索（DFS）遍历房间：
     - 从当前位置出发，尝试向四个方向（上、右、下、左）移动。
     - 如果某个方向可以移动，则递归清理该方向的格子。
     - 如果某个方向无法移动（遇到障碍物或边界），则跳过。
   - 使用回溯法记录机器人的路径：
     - 每次移动后，需要回到原点并恢复原来的方向，以便继续探索其他方向。

3. **算法步骤**：
   - 定义一个方向数组 `directions` 表示四个方向（上、右、下、左）。
   - 使用一个集合 `visited` 记录已经访问过的格子。
   - 定义一个辅助函数 `dfs(x, y, dir)`：
     - 当前机器人位于 `(x, y)`，朝向 `dir`。
     - 清理当前格子，并标记为已访问。
     - 尝试向四个方向移动，如果可以移动则递归清理。
     - 回溯：返回到原点并恢复原来的方向。
   - 调用 `dfs` 从初始位置开始清理。

4. **时间复杂度**：O(m * n)，其中 m 是网格的行数，n 是网格的列数。
5. **空间复杂度**：O(m * n)，用于存储访问过的格子。

---

### 代码实现

```javascript
// 定义方向数组：上、右、下、左
const directions = [
    [0, 1],  // 向上
    [1, 0],  // 向右
    [0, -1], // 向下
    [-1, 0]  // 向左
];

function cleanRoom(robot) {
    const visited = new Set(); // 记录已访问的格子

    // 辅助函数：深度优先搜索
    function dfs(x, y, dir) {
        // 标记当前格子为已访问
        visited.add(`${x},${y}`);
        robot.clean(); // 清理当前格子

        // 尝试向四个方向移动
        for (let i = 0; i < 4; i++) {
            const newDir = (dir + i) % 4; // 计算新的方向
            const [dx, dy] = directions[newDir];
            const newX = x + dx;
            const newY = y + dy;

            // 如果新格子未访问且可以移动，则递归清理
            if (!visited.has(`${newX},${newY}`) && robot.move()) {
                dfs(newX, newY, newDir);

                // 回溯：返回到原点并恢复原来的方向
                robot.turnRight();
                robot.turnRight();
                robot.move();
                robot.turnRight();
                robot.turnRight();
            }

            // 转向下一个方向
            robot.turnRight();
        }
    }

    // 从初始位置 (0, 0) 和初始方向（向上）开始清理
    dfs(0, 0, 0);
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以模拟一个房间和机器人接口：

```javascript
// 模拟房间和机器人
class Robot {
    constructor(room, startRow, startCol) {
        this.room = room;
        this.row = startRow;
        this.col = startCol;
        this.dir = 0; // 初始方向：0=上, 1=右, 2=下, 3=左
        this.cleaned = new Set();
    }

    move() {
        const [dx, dy] = directions[this.dir];
        const newRow = this.row + dx;
        const newCol = this.col + dy;

        // 检查是否越界或遇到障碍物
        if (
            newRow < 0 || newRow >= this.room.length ||
            newCol < 0 || newCol >= this.room[0].length ||
            this.room[newRow][newCol] === 0
        ) {
            return false;
        }

        // 移动到新位置
        this.row = newRow;
        this.col = newCol;
        return true;
    }

    turnLeft() {
        this.dir = (this.dir + 3) % 4; // 左转90度
    }

    turnRight() {
        this.dir = (this.dir + 1) % 4; // 右转90度
    }

    clean() {
        this.cleaned.add(`${this.row},${this.col}`);
    }
}

// 测试用例
const room = [
    [1, 1, 1, 1, 1, 0, 1, 1],
    [1, 1, 1, 1, 1, 0, 1, 1],
    [1, 0, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 1, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 1, 1, 1]
];
const robot = new Robot(room, 1, 3);
cleanRoom(robot);

console.log("Cleaned cells:", [...robot.cleaned]);
```

---

### 运行结果

```plaintext
输入:
	room = [
	    [1, 1, 1, 1, 1, 0, 1, 1],
	    [1, 1, 1, 1, 1, 0, 1, 1],
	    [1, 0, 1, 1, 1, 1, 1, 1],
	    [0, 0, 0, 1, 0, 0, 0, 0],
	    [1, 1, 1, 1, 1, 1, 1, 1]
	],
	row = 1,
	col = 3
输出:
	Cleaned cells: ["1,3", "0,3", "1,4", "1,2", ...]（根据房间结构会有所不同）
```

---

### 代码详解

1. **方向数组**：
   - `directions` 定义了四个方向（上、右、下、左）的移动偏移量。

2. **DFS 实现**：
   - 从当前位置 `(x, y)` 出发，尝试向四个方向移动。
   - 如果某个方向可以移动，则递归清理该方向的格子。
   - 回溯：返回到原点并恢复原来的方向。

3. **回溯逻辑**：
   - 每次移动后，通过两次右转和一次移动返回到原点。
   - 确保机器人在完成一个方向的探索后，能够继续探索其他方向。

4. **集合记录访问**：
   - 使用 `visited` 集合记录已经访问过的格子，避免重复清理。

---

### 总结

- **DFS** 和 **回溯法**结合是解决本问题的有效方法。
- 时间复杂度为 O(m * n)，空间复杂度为 O(m * n)。
- 通过回溯确保机器人能够完整地探索所有可达的空格并清理它们。

