
> 题目描述：给你一个由  '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。  
> 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。  
> 此外，你可以假设该网格的四条边均被水包围。

> 示例 1:  
> 
> 	输入:  
> 	 11110  
> 	 11010  
> 	 11000  
> 	 00000  
> 	 
> 	输出: 1

> 示例 2:  
> 
> 	输入:  
> 	11000  
> 	11000  
> 	00100  
> 	00011  
> 	
> 	输出: 3  
> 	
> 	解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。

**命题关键字：模拟、DFS**

参考：[[25、大厂真题训练与解读——Google 真题#岛屿数量问题]]


以下是用 JavaScript 实现“计算岛屿数量”的代码。我们将使用**深度优先搜索（DFS）** 或**广度优先搜索（BFS）** 来解决这个问题，时间复杂度为 O(m * n)，空间复杂度为 O(m * n)（最坏情况下需要递归栈或队列）。

---

### 解题思路

1. **问题分析**：
   - 给定一个二维网格，其中 `'1'` 表示陆地，`'0'` 表示水。
   - 岛屿是由水平或竖直方向相邻的陆地组成的区域。
   - 要求统计网格中岛屿的数量。

2. **核心思想**：
   - 遍历网格中的每个单元格：
     - 如果当前单元格是 `'1'`，说明发现了一个新的岛屿。
     - 使用深度优先搜索（DFS）或广度优先搜索（BFS）将与该单元格相连的所有陆地标记为已访问（例如将其值设为 `'0'`），以避免重复计数。
   - 每次发现新的岛屿时，计数器加 1。

3. **算法步骤**：
   - 初始化计数器 `count = 0`。
   - 遍历网格中的每个单元格：
     - 如果当前单元格是 `'1'`，调用 DFS 或 BFS 将其所在的岛屿标记为已访问，并将计数器加 1。
   - 返回计数器的值。

4. **时间复杂度**：O(m * n)，其中 m 是网格的行数，n 是网格的列数。
5. **空间复杂度**：O(m * n)，递归栈或队列的最大深度为网格的大小。

---

### 代码实现

#### 方法 1：深度优先搜索（DFS）
```javascript
function numIslands(grid) {
    if (!grid || grid.length === 0) return 0;

    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;

    // 辅助函数：深度优先搜索
    function dfs(row, col) {
        // 边界条件检查
        if (
            row < 0 || row >= rows ||
            col < 0 || col >= cols ||
            grid[row][col] === '0'
        ) {
            return;
        }

        // 标记当前单元格为已访问
        grid[row][col] = '0';

        // 递归访问上下左右四个方向
        dfs(row - 1, col); // 上
        dfs(row + 1, col); // 下
        dfs(row, col - 1); // 左
        dfs(row, col + 1); // 右
    }

    // 遍历网格
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '1') {
                count++; // 发现新的岛屿
                dfs(i, j); // 使用 DFS 标记整个岛屿
            }
        }
    }

    return count; // 返回岛屿数量
}
```

#### 方法 2：广度优先搜索（BFS）
```javascript
function numIslands(grid) {
    if (!grid || grid.length === 0) return 0;

    const rows = grid.length;
    const cols = grid[0].length;
    let count = 0;

    // 辅助函数：广度优先搜索
    function bfs(row, col) {
        const queue = [[row, col]];

        while (queue.length > 0) {
            const [r, c] = queue.shift();

            // 边界条件检查
            if (
                r < 0 || r >= rows ||
                c < 0 || c >= cols ||
                grid[r][c] === '0'
            ) {
                continue;
            }

            // 标记当前单元格为已访问
            grid[r][c] = '0';

            // 将上下左右四个方向加入队列
            queue.push([r - 1, c]); // 上
            queue.push([r + 1, c]); // 下
            queue.push([r, c - 1]); // 左
            queue.push([r, c + 1]); // 右
        }
    }

    // 遍历网格
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '1') {
                count++; // 发现新的岛屿
                bfs(i, j); // 使用 BFS 标记整个岛屿
            }
        }
    }

    return count; // 返回岛屿数量
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
const grid1 = [
    ['1', '1', '1', '1', '0'],
    ['1', '1', '0', '1', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '0', '0', '0']
];
console.log(numIslands(grid1)); // 输出: 1

const grid2 = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
];
console.log(numIslands(grid2)); // 输出: 3

const grid3 = [
    ['0', '0', '0'],
    ['0', '0', '0']
];
console.log(numIslands(grid3)); // 输出: 0

const grid4 = [
    ['1', '0', '1'],
    ['0', '1', '0'],
    ['1', '0', '1']
];
console.log(numIslands(grid4)); // 输出: 5
```

---

### 运行结果

```plaintext
输入:
[
    ['1', '1', '1', '1', '0'],
    ['1', '1', '0', '1', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '0', '0', '0']
]
输出: 1
```

```plaintext
输入:
[
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]
输出: 3
```

---

### 代码详解

1. **初始化变量**：
   - `rows` 和 `cols` 分别表示网格的行数和列数。
   - `count` 记录岛屿的数量。

2. **遍历网格**：
   - 如果当前单元格是 `'1'`，说明发现了一个新的岛屿。
   - 调用 DFS 或 BFS 将其所在的岛屿标记为已访问。

3. **DFS/BFS 实现**：
   - **DFS**：递归访问上下左右四个方向。
   - **BFS**：使用队列逐层访问上下左右四个方向。

4. **返回结果**：
   - 最终返回岛屿的数量。

---

### 总结

- **DFS** 和 **BFS** 都可以用来解决本问题，选择哪种方法取决于个人偏好。
- 时间复杂度为 O(m * n)，空间复杂度为 O(m * n)。
- 通过将已访问的陆地标记为 `'0'`，避免了额外的空间开销。
