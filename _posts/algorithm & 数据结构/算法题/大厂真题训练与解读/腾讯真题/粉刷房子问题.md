
> 题目描述: 
> 	假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。  
> 	当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。  
> 	例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。

> 注意：
> 	所有花费均为正整数。

```

 示例：
	 输入: [[17,2,17],[16,16,5],[14,3,19]]  
	 输出: 10  
	 解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。  
	 最少花费: 2 + 5 + 3 = 10。

```

**命题关键字：动态规划、滚动数组**

参考：[[26、大厂真题训练与解读——腾讯真题#“粉刷房子”问题]]


以下是用 JavaScript 实现“粉刷房子”的代码。我们将使用**动态规划（Dynamic Programming, DP）** 来解决这个问题，时间复杂度为 O(n)，空间复杂度为 O(1)。

---

### 解题思路

1. **问题分析**：
   - 给定一个 `n x 3` 的矩阵 `costs`，表示每个房子粉刷成红色、蓝色或绿色的成本。
   - 相邻的房子不能涂成相同的颜色。
   - 要求计算粉刷完所有房子的最小成本。

2. **核心思想**：
   - 使用动态规划的思想：
     - 定义状态：`dp[i][0]`, `dp[i][1]`, `dp[i][2]` 分别表示第 `i` 号房子粉刷成红色、蓝色或绿色时的最小总成本。
     - 转移方程：
       ```plaintext
       dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]) // 红色
       dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]) // 蓝色
       dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]) // 绿色
       ```
     - 初始条件：`dp[0][0] = costs[0][0]`，`dp[0][1] = costs[0][1]`，`dp[0][2] = costs[0][2]`。
   - 最终结果：`min(dp[n-1][0], dp[n-1][1], dp[n-1][2])`。

3. **优化空间复杂度**：
   - 因为每次只依赖前一状态，可以用三个变量代替 `dp` 数组。

4. **算法步骤**：
   - 初始化三个变量分别表示当前房子粉刷成红色、蓝色或绿色的最小成本。
   - 遍历每个房子，更新三种颜色的最小成本。
   - 返回最终的最小成本。

5. **时间复杂度**：O(n)，其中 n 是房子的数量。
6. **空间复杂度**：O(1)，仅使用常量级别的额外空间。

---

### 代码实现

```javascript
function minCost(costs) {
    if (!costs || costs.length === 0) return 0;

    let red = costs[0][0]; // 当前房子粉刷成红色的最小成本
    let blue = costs[0][1]; // 当前房子粉刷成蓝色的最小成本
    let green = costs[0][2]; // 当前房子粉刷成绿色的最小成本

    for (let i = 1; i < costs.length; i++) {
        const nextRed = costs[i][0] + Math.min(blue, green); // 粉刷成红色
        const nextBlue = costs[i][1] + Math.min(red, green); // 粉刷成蓝色
        const nextGreen = costs[i][2] + Math.min(red, blue); // 粉刷成绿色

        // 更新状态
        red = nextRed;
        blue = nextBlue;
        green = nextGreen;
    }

    // 返回三种颜色中的最小成本
    return Math.min(red, blue, green);
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
console.log(minCost([[17, 2, 17], [16, 16, 5], [14, 3, 19]])); 
// 输出: 10 （解释：将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色）

console.log(minCost([[7, 6, 2], [3, 8, 4], [5, 1, 9]])); 
// 输出: 8 （解释：将 0 号房子粉刷成绿色，1 号房子粉刷成红色，2 号房子粉刷成蓝色）

console.log(minCost([[1, 2, 3]])); 
// 输出: 1 （只有一个房子，选择成本最低的颜色）

console.log(minCost([])); 
// 输出: 0 （没有房子）
```

---

### 运行结果

```plaintext
输入: [[17, 2, 17], [16, 16, 5], [14, 3, 19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
```

```plaintext
输入: [[7, 6, 2], [3, 8, 4], [5, 1, 9]]
输出: 8
解释: 将 0 号房子粉刷成绿色，1 号房子粉刷成红色，2 号房子粉刷成蓝色。
```

```plaintext
输入: [[1, 2, 3]]
输出: 1
解释: 只有一个房子，选择成本最低的颜色。
```

```plaintext
输入: []
输出: 0
解释: 没有房子，总成本为 0。
```

---

### 代码详解

1. **初始化变量**：
   - `red`、`blue` 和 `green` 分别表示当前房子粉刷成红色、蓝色或绿色的最小成本。

2. **遍历每个房子**：
   - 对于每个房子，根据前一状态计算当前房子粉刷成每种颜色的最小成本。
   - 更新 `red`、`blue` 和 `green` 的值。

3. **返回结果**：
   - 最终返回三种颜色中的最小成本。

---

### 总结

- **动态规划**是解决本问题的核心方法，能够高效地计算最小成本。
- 时间复杂度为 O(n)，空间复杂度为 O(1)。
- 通过优化空间复杂度，避免了使用额外的数组存储状态。