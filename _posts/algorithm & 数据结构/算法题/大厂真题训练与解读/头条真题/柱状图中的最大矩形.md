
> 题目描述：
> 	给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。  
> 	求在该柱状图中，能够勾勒出来的矩形的最大面积。

![[da5049a50e3befa16a726bca7f793190_MD5.png]]
以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为  [2,1,5,6,2,3]。  
![[986d2cba9c5bf6f7e9b82d1ac9cfcc96_MD5.png]]
图中阴影部分为所能勾勒出的最大矩形面积，其面积为  10  个单位。

> 示例:  
> 	输入: [2,1,5,6,2,3]  
> 	输出: 10

**命题关键字：数学问题、模拟、单调栈**

参考：[[27、大厂真题训练与解读——头条真题#柱状图中的最大矩形]]


以下是用 JavaScript 实现“柱状图中最大矩形面积”的代码。我们将使用**单调栈（Monotonic Stack）** 的方法来解决这个问题，时间复杂度为 O(n)，空间复杂度为 O(n)。

---

### 解题思路

1. **问题分析**：
   - 给定一个数组 `heights`，表示柱状图中每个柱子的高度。
   - 要求找到能够勾勒出的最大矩形面积。
   - 矩形的宽度由连续的柱子决定，高度由这些柱子中的最小高度决定。

2. **核心思想**：
   - 使用**单调栈**记录柱子的索引，确保栈中的柱子高度是递增的。
   - 遍历数组时：
     - 如果当前柱子的高度小于栈顶柱子的高度，则弹出栈顶柱子并计算以该柱子为高的矩形面积。
     - 计算矩形面积时，宽度为当前柱子与新栈顶柱子之间的距离。
   - 最终清空栈，处理剩余的柱子。

3. **算法步骤**：
   - 初始化一个栈 `stack` 和变量 `maxArea`。
   - 遍历数组 `heights`：
     - 如果当前柱子的高度小于栈顶柱子的高度，则弹出栈顶柱子并计算面积。
     - 更新 `maxArea`。
   - 清空栈，处理剩余的柱子。
   - 返回 `maxArea`。

4. **时间复杂度**：O(n)，每个柱子最多入栈和出栈一次。
5. **空间复杂度**：O(n)，用于存储栈。

---

### 代码实现

```javascript
function largestRectangleArea(heights) {
    const stack = []; // 单调栈，存储柱子的索引
    let maxArea = 0; // 最大面积

    for (let i = 0; i <= heights.length; i++) {
        // 当前柱子的高度（最后一个虚拟柱子高度为 0）
        const currentHeight = i === heights.length ? 0 : heights[i];

        // 如果当前柱子的高度小于栈顶柱子的高度，则弹出栈顶柱子并计算面积
        while (stack.length > 0 && currentHeight < heights[stack[stack.length - 1]]) {
            const topIndex = stack.pop(); // 弹出栈顶柱子的索引
            const height = heights[topIndex]; // 栈顶柱子的高度

            // 计算宽度
            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;

            // 更新最大面积
            maxArea = Math.max(maxArea, height * width);
        }

        // 将当前柱子的索引入栈
        stack.push(i);
    }

    return maxArea;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
console.log(largestRectangleArea([2, 1, 5, 6, 2, 3])); 
// 输出: 10 （解释：最大矩形面积为 10）

console.log(largestRectangleArea([2, 4])); 
// 输出: 4 （解释：最大矩形面积为 4）

console.log(largestRectangleArea([0, 0, 0])); 
// 输出: 0 （解释：所有柱子高度为 0，无法形成矩形）

console.log(largestRectangleArea([3, 6, 5, 7, 4, 8, 1, 0])); 
// 输出: 20 （解释：最大矩形面积为 20）

console.log(largestRectangleArea([])); 
// 输出: 0 （解释：没有柱子）
```

---

### 运行结果

```plaintext
输入: [2, 1, 5, 6, 2, 3]
输出: 10
解释: 最大矩形面积为 10。
```

```plaintext
输入: [2, 4]
输出: 4
解释: 最大矩形面积为 4。
```

```plaintext
输入: [0, 0, 0]
输出: 0
解释: 所有柱子高度为 0，无法形成矩形。
```

```plaintext
输入: [3, 6, 5, 7, 4, 8, 1, 0]
输出: 20
解释: 最大矩形面积为 20。
```

```plaintext
输入: []
输出: 0
解释: 没有柱子，无法形成矩形。
```

---

### 代码详解

1. **初始化栈和变量**：
   - 使用栈 `stack` 存储柱子的索引，确保栈中的柱子高度是递增的。
   - 使用变量 `maxArea` 记录最大矩形面积。

2. **遍历数组**：
   - 如果当前柱子的高度小于栈顶柱子的高度，则弹出栈顶柱子并计算面积。
   - 宽度为当前柱子与新栈顶柱子之间的距离。
   - 更新 `maxArea`。

3. **清空栈**：
   - 遍历结束后，清空栈，处理剩余的柱子。

4. **返回结果**：
   - 返回 `maxArea`。

---

### 总结

- **单调栈**是解决本问题的核心方法，能够高效地找到每个柱子左右两侧的第一个比它矮的柱子。
- 时间复杂度为 O(n)，空间复杂度为 O(n)。
- 通过巧妙地利用栈，避免了暴力解法的时间复杂度 O(n²)。
