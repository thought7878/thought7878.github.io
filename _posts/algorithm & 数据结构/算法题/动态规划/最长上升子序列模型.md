

> 题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。
> 
> 示例:  
> 输入: [10,9,2,5,3,7,101,18]  
> 输出: 4  
> 解释: 最长的上升子序列是  [2,3,7,101]，它的长度是 4。
> 
> 说明:  
> 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
> 你算法的时间复杂度应该为  O(n^2) 。  
> **进阶: 你能将算法的时间复杂度降低到  O(n log n) 吗?**


参考：[[23、普通人也能吃透的动态规划思想专题（下）#最长上升子序列模型]]

以下是用 JavaScript 实现“最长上升子序列（Longest Increasing Subsequence, LIS）”的代码。我们将分别实现**O(n²)**和**O(n log n)**两种算法。

---

### **解题思路**

#### **方法 1：动态规划（O(n²)）**
1. **问题分析**：
   - 给定一个无序数组，找到其中最长的严格递增子序列。
   - 子序列不要求连续，但必须保持原数组中的相对顺序。

2. **核心思想**：
   - 使用动态规划的思想：
     - 定义状态：`dp[i]` 表示以第 `i` 个元素结尾的最长上升子序列的长度。
     - 转移方程：对于每个 `i`，遍历所有 `j < i`，如果 `nums[j] < nums[i]`，则更新 `dp[i]`：
       ```plaintext
       dp[i] = Math.max(dp[i], dp[j] + 1)
       ```
     - 初始条件：每个元素自身构成一个长度为 1 的子序列，即 `dp[i] = 1`。
   - 最终结果：`Math.max(...dp)` 即为最长上升子序列的长度。

3. **时间复杂度**：O(n²)，空间复杂度为 O(n)。

---

#### **方法 2：贪心 + 二分查找（O(n log n)）**
1. **核心思想**：
   - 使用一个辅助数组 `tails`，`tails[i]` 表示长度为 `i+1` 的上升子序列的最小末尾值。
   - 遍历数组时，使用二分查找将当前元素插入到 `tails` 中的适当位置：
     - 如果当前元素大于 `tails` 的最后一个元素，则直接追加。
     - 否则，找到第一个大于等于当前元素的位置并替换。
   - 最终结果：`tails` 的长度即为最长上升子序列的长度。

2. **时间复杂度**：O(n log n)，空间复杂度为 O(n)。

---

### **代码实现**

#### **方法 1：动态规划（O(n²)）**
```javascript
function lengthOfLIS(nums) {
    if (nums.length === 0) return 0;

    const n = nums.length;
    const dp = new Array(n).fill(1); // 初始化 dp 数组

    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }

    return Math.max(...dp); // 返回 dp 数组中的最大值
}
```

#### **方法 2：贪心 + 二分查找（O(n log n)）**
```javascript
function lengthOfLIS(nums) {
    if (nums.length === 0) return 0;

    const tails = []; // 辅助数组，存储长度为 i+1 的上升子序列的最小末尾值

    for (const num of nums) {
        let left = 0, right = tails.length;

        // 二分查找找到第一个大于等于 num 的位置
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        // 替换或追加
        if (left === tails.length) {
            tails.push(num); // 如果 num 大于所有元素，则追加
        } else {
            tails[left] = num; // 否则替换第一个大于等于 num 的元素
        }
    }

    return tails.length; // tails 的长度即为最长上升子序列的长度
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18])); // 输出: 4
console.log(lengthOfLIS([0, 1, 0, 3, 2, 3]));           // 输出: 4
console.log(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]));         // 输出: 1
console.log(lengthOfLIS([]));                           // 输出: 0
console.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]));  // 输出: 6
```

---

### **运行结果**

对于输入：
#### 示例 1:
```plaintext
输入: [10, 9, 2, 5, 3, 7, 101, 18]
输出: 4
解释: 最长的上升子序列是 [2, 3, 7, 101]，它的长度是 4。
```

#### 示例 2:
```plaintext
输入: [0, 1, 0, 3, 2, 3]
输出: 4
```

#### 示例 3:
```plaintext
输入: [7, 7, 7, 7, 7, 7, 7]
输出: 1
```

#### 示例 4:
```plaintext
输入: []
输出: 0
```

#### 示例 5:
```plaintext
输入: [1, 3, 6, 7, 9, 4, 10, 5, 6]
输出: 6
```

---

### **代码详解**

#### **方法 1：动态规划（O(n²)）**
1. **初始化 `dp` 数组**：
   - 每个元素自身构成一个长度为 1 的子序列，即 `dp[i] = 1`。
2. **动态规划更新**：
   - 对于每个 `i`，遍历所有 `j < i`，如果 `nums[j] < nums[i]`，则尝试更新 `dp[i]`。
3. **返回结果**：
   - `Math.max(...dp)` 即为最长上升子序列的长度。

#### **方法 2：贪心 + 二分查找（O(n log n)）**
1. **初始化辅助数组 `tails`**：
   - `tails[i]` 表示长度为 `i+1` 的上升子序列的最小末尾值。
2. **遍历数组**：
   - 使用二分查找找到 `tails` 中第一个大于等于当前元素的位置。
   - 如果当前元素大于所有元素，则追加；否则替换。
3. **返回结果**：
   - `tails` 的长度即为最长上升子序列的长度。

---

### **总结**

- **动态规划（O(n²)）**适合小规模数据，代码简单直观。
- **贪心 + 二分查找（O(n log n)）**适合大规模数据，性能更优。
- 时间复杂度：
  - 动态规划：O(n²)。
  - 贪心 + 二分查找：O(n log n)。
- 空间复杂度均为 O(n)。