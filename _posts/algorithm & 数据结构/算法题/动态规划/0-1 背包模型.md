
> 有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？
> 
> 注意：每种物品都只有 1 件

参考：[[23、普通人也能吃透的动态规划思想专题（下）#0-1 背包模型]]

这是一个经典的**0-1背包问题**，可以用动态规划（Dynamic Programming, DP）来解决。以下是用 JavaScript 实现的代码。

---

### **解题思路**

1. **问题分析**：
   - 给定 `n` 件物品，每件物品有一个体积 `w[i]` 和价值 `value[i]`。
   - 背包容量为 `c`，要求选择一些物品放入背包，使得总价值最大。
   - 每种物品只能选择一次（即“0-1”特性）。

2. **核心思想**：
   - 使用动态规划的思想：
     - 定义状态：`dp[j]` 表示容量为 `j` 的背包能装下的最大价值。
     - 转移方程：对于第 `i` 件物品，如果选择它，则更新 `dp[j]`：
       ```plaintext
       dp[j] = Math.max(dp[j], dp[j - w[i]] + value[i])
       ```
     - 初始条件：`dp[0] = 0`（容量为 0 的背包最大价值为 0），其他值初始化为 0。
   - 最终结果：`dp[c]` 即为容量为 `c` 的背包能装下的最大价值。

3. **算法步骤**：
   - 初始化一个数组 `dp`，长度为 `c + 1`，所有值初始化为 0。
   - 遍历每件物品，倒序遍历背包容量（从 `c` 到 `w[i]`），更新 `dp[j]`。
   - 返回 `dp[c]`。

4. **时间复杂度**：O(n * c)，其中 n 是物品数量，c 是背包容量。
5. **空间复杂度**：O(c)，用于存储 `dp` 数组。

---

### **代码实现**

```javascript
function knapsack(w, value, c) {
    const n = w.length; // 物品数量
    const dp = new Array(c + 1).fill(0); // 初始化 dp 数组

    // 遍历每件物品
    for (let i = 0; i < n; i++) {
        // 倒序遍历背包容量，避免覆盖前面的状态
        for (let j = c; j >= w[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - w[i]] + value[i]);
        }
    }

    return dp[c]; // 返回容量为 c 的背包的最大价值
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一些测试用例：

```javascript
// 测试用例
const w1 = [2, 3, 4, 5]; // 物品体积
const value1 = [3, 4, 5, 6]; // 物品价值
const c1 = 8; // 背包容量
console.log(knapsack(w1, value1, c1)); // 输出: 10

const w2 = [1, 2, 3]; // 物品体积
const value2 = [6, 10, 12]; // 物品价值
const c2 = 5; // 背包容量
console.log(knapsack(w2, value2, c2)); // 输出: 22

const w3 = [1, 3, 4]; // 物品体积
const value3 = [15, 20, 30]; // 物品价值
const c3 = 4; // 背包容量
console.log(knapsack(w3, value3, c3)); // 输出: 30
```

---

### **运行结果**

```plaintext
输入: w = [2, 3, 4, 5], value = [3, 4, 5, 6], c = 8
输出: 10
解释: 选择物品 0 和物品 2，总价值为 3 + 7 = 10。
```

```plaintext
输入: w = [1, 2, 3], value = [6, 10, 12], c = 5
输出: 22
解释: 选择物品 1 和物品 2，总价值为 10 + 12 = 22。
```

```plaintext
输入: w = [1, 3, 4], value = [15, 20, 30], c = 4
输出: 30
解释: 选择物品 2，总价值为 30。
```

---

### **代码详解**

1. **初始化 `dp` 数组**：
   - `dp[j]` 表示容量为 `j` 的背包能装下的最大价值。
   - 初始值为 0，表示未放入任何物品时的最大价值为 0。

2. **动态规划更新**：
   - 对于每件物品 `i`，从后向前遍历背包容量 `j`（从 `c` 到 `w[i]`）。
   - 如果选择当前物品，则尝试更新 `dp[j]`：
     ```plaintext
     dp[j] = Math.max(dp[j], dp[j - w[i]] + value[i])
     ```

3. **返回结果**：
   - `dp[c]` 即为容量为 `c` 的背包能装下的最大价值。

---

### **总结**

- 本题的关键在于利用动态规划的思想，通过逐步构建子问题的解来求解最终问题。
- **转移方程**是动态规划的核心，确保正确更新每一步的最优解。
- 时间复杂度为 O(n * c)，空间复杂度为 O(c)。
- 适用于处理较大规模的输入，性能优于暴力搜索方法。
