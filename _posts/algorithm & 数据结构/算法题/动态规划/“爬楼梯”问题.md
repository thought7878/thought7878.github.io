

> 题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。  
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
> 
> 注意：给定 n 是一个正整数。
> 
> 示例 1：
> 	输入： 2  
> 	输出： 2  
> 	解释： 有两种方法可以爬到楼顶。
>	
> 	1.  1 阶 + 1 阶
> 	2.  2 阶
> 
> 示例 2：  
> 	输入： 3  
> 	输出： 3  
> 	解释： 有三种方法可以爬到楼顶。
>	
> 	1.  1 阶 + 1 阶 + 1 阶
> 	2.  1 阶 + 2 阶
> 	3.  2 阶 + 1 阶

参考：[[22、普通人也能吃透的动态规划思想专题（上）#从“爬楼梯”问题说起]]

以下是用 JavaScript 实现“爬楼梯问题”的代码。该问题是一个经典的动态规划问题，可以通过递归、记忆化递归或迭代方法解决。我们将重点介绍**迭代法**，因为它时间复杂度为 O(n)，空间复杂度为 O(1)。

---

### **解题思路**

1. **问题分析**：
   - 爬楼梯问题的核心是：每次可以爬 1 或 2 阶台阶，求到达第 `n` 阶的方法总数。
   - 这是一个典型的**斐波那契数列**问题，因为：
     - 到达第 `n` 阶的方法数 = 到达第 `n-1` 阶的方法数 + 到达第 `n-2` 阶的方法数。

2. **核心思想**：
   - 使用动态规划（Dynamic Programming, DP）的思想：
     - 定义状态：`dp[i]` 表示到达第 `i` 阶的方法数。
     - 转移方程：`dp[i] = dp[i-1] + dp[i-2]`。
     - 初始条件：`dp[1] = 1`（只有一种方法到达第 1 阶），`dp[2] = 2`（有两种方法到达第 2 阶）。
   - 为了优化空间复杂度，我们只需要两个变量存储前两个状态值。

3. **算法步骤**：
   - 初始化两个变量 `prev1` 和 `prev2` 分别表示到达第 `i-1` 阶和第 `i-2` 阶的方法数。
   - 从第 3 阶开始迭代，更新当前阶的方法数。
   - 最终返回到达第 `n` 阶的方法数。

4. **时间复杂度**：O(n)，其中 n 是楼梯的阶数。
5. **空间复杂度**：O(1)，仅使用常量级别的额外空间。

---

### **代码实现**

#### **方法 1：迭代法**
```javascript
function climbStairs(n) {
    if (n === 1) return 1; // 只有 1 阶时，只有一种方法
    if (n === 2) return 2; // 只有 2 阶时，有两种方法

    let prev1 = 2; // 到达第 2 阶的方法数
    let prev2 = 1; // 到达第 1 阶的方法数

    for (let i = 3; i <= n; i++) {
        const current = prev1 + prev2; // 当前阶的方法数
        prev2 = prev1; // 更新 prev2 为前一阶
        prev1 = current; // 更新 prev1 为当前阶
    }

    return prev1; // 返回到达第 n 阶的方法数
}
```

#### **方法 2：递归法（带记忆化）**
```javascript
function climbStairs(n) {
    const memo = {}; // 用于存储已经计算过的结果

    function helper(i) {
        if (i === 1) return 1; // 基础情况
        if (i === 2) return 2; // 基础情况
        if (memo[i] !== undefined) return memo[i]; // 如果已经计算过，直接返回

        // 递归计算并存储结果
        memo[i] = helper(i - 1) + helper(i - 2);
        return memo[i];
    }

    return helper(n); // 调用辅助函数
}
```

---

### **测试代码**

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
console.log(climbStairs(2)); // 输出: 2
console.log(climbStairs(3)); // 输出: 3
console.log(climbStairs(4)); // 输出: 5
console.log(climbStairs(5)); // 输出: 8
console.log(climbStairs(10)); // 输出: 89
```

---

### **运行结果**

```plaintext
输入: 2
输出: 2
```

```plaintext
输入: 3
输出: 3
```

```plaintext
输入: 4
输出: 5
```

```plaintext
输入: 5
输出: 8
```

```plaintext
输入: 10
输出: 89
```

---

### **代码详解**

#### **迭代法**
1. **初始化变量**：
   - `prev1` 表示到达第 `i-1` 阶的方法数。
   - `prev2` 表示到达第 `i-2` 阶的方法数。
2. **迭代更新**：
   - 从第 3 阶开始，依次计算当前阶的方法数。
   - 更新 `prev1` 和 `prev2` 的值。
3. **返回结果**：
   - 最终返回 `prev1`，即到达第 `n` 阶的方法数。

#### **递归法（带记忆化）**
1. **定义辅助函数**：
   - `helper(i)` 返回到达第 `i` 阶的方法数。
   - 使用 `memo` 缓存已经计算过的结果。
2. **递归终止条件**：
   - 如果 `i === 1` 或 `i === 2`，直接返回基础情况的结果。
3. **递归调用**：
   - 计算 `helper(i-1)` 和 `helper(i-2)`，并将结果存储到 `memo` 中。
4. **返回结果**：
   - 最终返回 `helper(n)` 的结果。

---

### **总结**

- 本题的关键在于理解爬楼梯问题与斐波那契数列的关系。
- **迭代法**通过两个变量存储状态，避免了递归调用的栈开销，性能更优。
- **递归法**虽然直观，但需要借助记忆化技术优化时间复杂度。
- 时间复杂度为 O(n)，空间复杂度为 O(1)（迭代法）或 O(n)（递归法）。
