
> 题目描述：给定一个**没有重复**数字的序列，返回其所有可能的全排列。
> 
> 示例：     
> 	输入: [1,2,3]  
> 	输出:
> 	[  
> 	 [1,2,3],  
> 	 [1,3,2],  
> 	 [2,1,3],  
> 	 [2,3,1],  
> 	 [3,1,2],  
> 	 [3,2,1]  
> 	]

参考：[[15、场景化解读：递归与回溯思想在真题中的应用]]

以下是用 JavaScript 实现“生成全排列”的代码。我们将使用**回溯算法（Backtracking）** 来解决这个问题，时间复杂度为 O(n!)，空间复杂度为 O(n)。

---

### 解题思路

1. **问题分析**：
   - 给定一个没有重复数字的序列，需要返回所有可能的排列。
   - 全排列是指将数组中的元素按所有可能的顺序重新排列。

2. **核心思想**：
   - 使用回溯法递归地生成所有排列。
   - 每次选择一个未使用的元素，加入当前排列，并标记为已使用。
   - 当当前排列长度等于数组长度时，将其加入结果。
   - 回溯时撤销选择，继续尝试其他可能的排列。

3. **算法步骤**：
   - 初始化结果数组 `result` 和一个布尔数组 `used` 用于记录元素是否已被使用。
   - 定义一个递归函数 `backtrack`：
     - 如果当前排列长度等于数组长度，则将当前排列加入结果。
     - 遍历数组中的每个元素：
       - 如果该元素未被使用，则将其加入当前排列，并标记为已使用。
       - 递归调用 `backtrack`。
       - 回溯时撤销选择，恢复状态。
   - 调用 `backtrack` 并返回结果。

4. **时间复杂度**：O(n!)，因为有 n! 种排列。
5. **空间复杂度**：O(n)，递归栈和辅助数组的空间开销。

---

### 代码实现

```javascript
function permute(nums) {
    const result = []; // 存储所有排列
    const used = new Array(nums.length).fill(false); // 标记元素是否已使用

    function backtrack(path) {
        // 如果当前排列长度等于数组长度，加入结果
        if (path.length === nums.length) {
            result.push([...path]); // 深拷贝当前排列
            return;
        }

        // 遍历数组中的每个元素
        for (let i = 0; i < nums.length; i++) {
            if (!used[i]) { // 如果当前元素未被使用
                path.push(nums[i]); // 加入当前排列
                used[i] = true; // 标记为已使用

                // 递归调用
                backtrack(path);

                // 回溯：撤销选择
                path.pop();
                used[i] = false;
            }
        }
    }

    backtrack([]); // 从空排列开始
    return result;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const nums1 = [1, 2, 3];
console.log(permute(nums1));
// 输出:
// [
//   [1, 2, 3],
//   [1, 3, 2],
//   [2, 1, 3],
//   [2, 3, 1],
//   [3, 1, 2],
//   [3, 2, 1]
// ]

const nums2 = [0, 1];
console.log(permute(nums2));
// 输出:
// [
//   [0, 1],
//   [1, 0]
// ]

const nums3 = [1];
console.log(permute(nums3));
// 输出:
// [
//   [1]
// ]
```

---

### 运行结果

```plaintext
输入: [1, 2, 3]
输出:
[
  [1, 2, 3],
  [1, 3, 2],
  [2, 1, 3],
  [2, 3, 1],
  [3, 1, 2],
  [3, 2, 1]
]
```

```plaintext
输入: [0, 1]
输出:
[
  [0, 1],
  [1, 0]
]
```

```plaintext
输入: [1]
输出:
[
  [1]
]
```

---

### 代码详解

1. **初始化结果数组和标记数组**：
   - `result` 用于存储所有排列。
   - `used` 用于标记元素是否已被使用。

2. **定义回溯函数**：
   - 如果当前排列长度等于数组长度，则将当前排列加入结果。
   - 遍历数组中的每个元素：
     - 如果该元素未被使用，则将其加入当前排列，并标记为已使用。
     - 递归调用回溯函数。
     - 回溯时撤销选择，恢复状态。

3. **返回结果**：
   - 遍历结束后，`result` 数组即为所有可能的排列。

---

### 总结

- 本题的关键在于利用回溯算法生成所有排列。
- 通过标记数组避免重复使用元素，确保每种排列唯一。
- 代码简洁高效，适合在实际开发中应用。