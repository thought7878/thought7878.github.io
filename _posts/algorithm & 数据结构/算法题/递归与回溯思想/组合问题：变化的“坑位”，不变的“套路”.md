
> 题目描述：
> 	给定一组不含重复元素的整数数组  nums，返回该数组所有可能的子集（幂集）。  
> 
> 说明：
> 	解集不能包含重复的子集。
> 
> 示例:
> 	输入: nums = [1,2,3]  
> 	输出:  
> 	[  
> 	 [3],  
> 	 [1],  
> 	 [2],  
> 	 [1,2,3],  
> 	 [1,3],  
> 	 [2,3],  
> 	 [1,2],  
> 	 []  
> 	]

参考：[[15、场景化解读：递归与回溯思想在真题中的应用]]

以下是用 JavaScript 实现“生成所有子集（幂集）”的代码。我们将使用**回溯算法（Backtracking）** 来解决这个问题，时间复杂度为 O(2^n)，空间复杂度为 O(n)。

---

### 解题思路

1. **问题分析**：
   - 给定一个不含重复元素的整数数组 `nums`，需要返回其所有可能的子集。
   - 子集是指从数组中选择任意数量的元素（包括不选）组成的所有组合。

2. **核心思想**：
   - 使用回溯法递归地生成所有子集。
   - 每次选择是否将当前元素加入子集。
   - 当遍历到数组末尾时，将当前子集加入结果。

3. **算法步骤**：
   - 初始化结果数组 `result` 和一个临时数组 `subset` 用于存储当前子集。
   - 定义一个递归函数 `backtrack(start)`：
     - 将当前子集 `subset` 加入结果。
     - 遍历从 `start` 开始的每个元素：
       - 将当前元素加入子集。
       - 递归调用 `backtrack`，并更新起始索引。
       - 回溯时撤销选择，恢复状态。
   - 调用 `backtrack(0)` 并返回结果。

4. **时间复杂度**：O(2^n)，因为有 2^n 种子集。
5. **空间复杂度**：O(n)，递归栈和辅助数组的空间开销。

---

### 代码实现

```javascript
function subsets(nums) {
    const result = []; // 存储所有子集

    function backtrack(start, subset) {
        // 将当前子集加入结果
        result.push([...subset]); // 深拷贝当前子集

        // 遍历从 start 开始的每个元素
        for (let i = start; i < nums.length; i++) {
            subset.push(nums[i]); // 加入当前元素
            backtrack(i + 1, subset); // 递归调用，更新起始索引
            subset.pop(); // 回溯：撤销选择
        }
    }

    backtrack(0, []); // 从空子集开始
    return result;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const nums1 = [1, 2, 3];
console.log(subsets(nums1));
// 输出:
// [
//   [],
//   [1],
//   [1, 2],
//   [1, 2, 3],
//   [1, 3],
//   [2],
//   [2, 3],
//   [3]
// ]

const nums2 = [0];
console.log(subsets(nums2));
// 输出:
// [
//   [],
//   [0]
// ]

const nums3 = [];
console.log(subsets(nums3));
// 输出:
// [
//   []
// ]
```

---

### 运行结果

```plaintext
输入: nums = [1, 2, 3]
输出:
[
  [],
  [1],
  [1, 2],
  [1, 2, 3],
  [1, 3],
  [2],
  [2, 3],
  [3]
]
```

```plaintext
输入: nums = [0]
输出:
[
  [],
  [0]
]
```

```plaintext
输入: nums = []
输出:
[
  []
]
```

---

### 代码详解

1. **初始化结果数组和临时数组**：
   - `result` 用于存储所有子集。
   - `subset` 用于存储当前子集。

2. **定义回溯函数**：
   - 将当前子集 `subset` 加入结果。
   - 遍历从 `start` 开始的每个元素：
     - 将当前元素加入子集。
     - 递归调用回溯函数，并更新起始索引。
     - 回溯时撤销选择，恢复状态。

3. **返回结果**：
   - 遍历结束后，`result` 数组即为所有可能的子集。

---

### 总结

- 本题的关键在于利用回溯算法生成所有子集。
- 通过控制起始索引避免重复子集，确保每种子集唯一。
- 代码简洁高效，适合在实际开发中应用。