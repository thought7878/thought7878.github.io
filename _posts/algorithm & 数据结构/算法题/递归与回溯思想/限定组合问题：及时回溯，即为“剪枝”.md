
> 题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
> 
> 示例:
> 	输入: n = 4, k = 2  
> 	输出:  
> 	[  
> 	 [2,4],  
> 	 [3,4],  
> 	 [2,3],  
> 	 [1,2],  
> 	 [1,3],  
> 	 [1,4],  
> 	]

参考：[[15、场景化解读：递归与回溯思想在真题中的应用]]

以下是用 JavaScript 实现“生成所有可能的 k 个数的组合”的代码。我们将使用**回溯算法（Backtracking）** 来解决这个问题，时间复杂度为 O(C(n, k))，其中 C(n, k) 是从 n 个元素中选择 k 个的组合数。

---

### 解题思路

1. **问题分析**：
   - 给定两个整数 `n` 和 `k`，需要返回从 `1` 到 `n` 中所有可能的 `k` 个数的组合。
   - 组合是指从数组中选择任意数量的元素，并且顺序不重要。

2. **核心思想**：
   - 使用回溯法递归地生成所有组合。
   - 每次选择一个未使用的元素加入当前组合。
   - 当组合长度等于 `k` 时，将其加入结果。
   - 回溯时撤销选择，继续尝试其他可能的组合。

3. **算法步骤**：
   - 初始化结果数组 `result` 和一个临时数组 `combination` 用于存储当前组合。
   - 定义一个递归函数 `backtrack(start)`：
     - 如果当前组合长度等于 `k`，将其加入结果。
     - 遍历从 `start` 开始的每个元素：
       - 将当前元素加入组合。
       - 递归调用 `backtrack`，并更新起始索引。
       - 回溯时撤销选择，恢复状态。
   - 调用 `backtrack(1)` 并返回结果。

4. **时间复杂度**：O(C(n, k))，即从 n 个元素中选择 k 个的组合数。
5. **空间复杂度**：O(k)，递归栈和辅助数组的空间开销。

---

### 代码实现

```javascript
function combine(n, k) {
    const result = []; // 存储所有组合

    function backtrack(start, combination) {
        // 如果当前组合长度等于 k，加入结果
        if (combination.length === k) {
            result.push([...combination]); // 深拷贝当前组合
            return;
        }

        // 遍历从 start 开始的每个元素
        for (let i = start; i <= n; i++) {
            combination.push(i); // 加入当前元素
            backtrack(i + 1, combination); // 递归调用，更新起始索引
            combination.pop(); // 回溯：撤销选择
        }
    }

    backtrack(1, []); // 从数字 1 开始
    return result;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const n1 = 4, k1 = 2;
console.log(combine(n1, k1));
// 输出:
// [
//   [1, 2],
//   [1, 3],
//   [1, 4],
//   [2, 3],
//   [2, 4],
//   [3, 4]
// ]

const n2 = 5, k2 = 3;
console.log(combine(n2, k2));
// 输出:
// [
//   [1, 2, 3],
//   [1, 2, 4],
//   [1, 2, 5],
//   [1, 3, 4],
//   [1, 3, 5],
//   [1, 4, 5],
//   [2, 3, 4],
//   [2, 3, 5],
//   [2, 4, 5],
//   [3, 4, 5]
// ]

const n3 = 1, k3 = 1;
console.log(combine(n3, k3));
// 输出:
// [
//   [1]
// ]
```

---

### 运行结果

```plaintext
输入: n = 4, k = 2
输出:
[
  [1, 2],
  [1, 3],
  [1, 4],
  [2, 3],
  [2, 4],
  [3, 4]
]
```

```plaintext
输入: n = 5, k = 3
输出:
[
  [1, 2, 3],
  [1, 2, 4],
  [1, 2, 5],
  [1, 3, 4],
  [1, 3, 5],
  [1, 4, 5],
  [2, 3, 4],
  [2, 3, 5],
  [2, 4, 5],
  [3, 4, 5]
]
```

```plaintext
输入: n = 1, k = 1
输出:
[
  [1]
]
```

---

### 代码详解

1. **初始化结果数组和临时数组**：
   - `result` 用于存储所有组合。
   - `combination` 用于存储当前组合。

2. **定义回溯函数**：
   - 如果当前组合长度等于 `k`，将其加入结果。
   - 遍历从 `start` 开始的每个元素：
     - 将当前元素加入组合。
     - 递归调用回溯函数，并更新起始索引。
     - 回溯时撤销选择，恢复状态。

3. **返回结果**：
   - 遍历结束后，`result` 数组即为所有可能的组合。

---

### 总结

- 本题的关键在于利用回溯算法生成所有组合。
- 通过控制起始索引避免重复组合，确保每种组合唯一。
- 代码简洁高效，适合在实际开发中应用。