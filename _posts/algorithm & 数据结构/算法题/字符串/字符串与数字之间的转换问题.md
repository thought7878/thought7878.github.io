
> 真题描述：请你来实现一个  atoi  函数，使其能将字符串转换成整数。  
> 首先，该函数会根据需要*丢弃无用的开头空格字符*，直到寻找到第一个非空格的字符为止。  
> 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  
> 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  
> 
> 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  
> 在任何情况下，若函数不能进行有效的转换时，请返回 0。
> 
> 说明：
> 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为  [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或  INT_MIN (−2^31) 。
> 
> 示例  1:  
> 输入: "42"  
> 输出: 42
> 
> 示例 2:  
> 输入: " -42"  
> 输出: -42  
> 解释: 第一个非空白字符为 '-', 它是一个负号。  
> 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
> 
> 示例  3:
> 输入: "4193 with words"  
> 输出: 4193  
> 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
> 
> 示例  4:
> 输入: "words and 987"  
> 输出: 0  
> 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。
> 
> 示例  5:  
> 输入: "-91283472332"  
> 输出: -2147483648  
> 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。

参考：[[8、字符串的应用——真题归纳与解读]]

实现一个 `atoi` 函数需要处理多种情况，包括去除空格、解析符号、提取数字、处理溢出等。以下是详细的解题思路和代码实现。

---

### **解题思路**

#### 核心步骤：
1. **去除前导空格**：
   - 使用字符串的 `trim()` 方法或手动跳过空格。
2. **解析符号**：
   - 检查第一个非空字符是否是正号（`+`）或负号（`-`），并记录符号。
3. **提取数字**：
   - 从符号后的第一个字符开始，提取连续的数字字符。
   - 如果遇到非数字字符，则停止提取。
4. **处理溢出**：
   - 将提取的数字转换为整数，并检查是否超出 32 位有符号整数范围 `[−2^31, 2^31 − 1]`。
   - 如果超出范围，返回 `INT_MAX` 或 `INT_MIN`。
5. **返回结果**：
   - 如果无法提取有效数字，返回 `0`。

---

### **代码实现**

```javascript
function myAtoi(s) {
    const INT_MAX = Math.pow(2, 31) - 1; // 2147483647
    const INT_MIN = -Math.pow(2, 31);   // -2147483648

    let index = 0; // 当前字符索引
    let sign = 1;  // 符号，默认为正
    let result = 0; // 最终结果
    const n = s.length;

    // 1. 去除前导空格
    while (index < n && s[index] === " ") {
        index++;
    }

    // 2. 解析符号
    if (index < n && (s[index] === "+" || s[index] === "-")) {
        sign = s[index] === "-" ? -1 : 1;
        index++;
    }

    // 3. 提取数字
    while (index < n && /[0-9]/.test(s[index])) {
        const digit = parseInt(s[index], 10);

        // 检查是否溢出
        if (result > Math.floor(INT_MAX / 10) || 
            (result === Math.floor(INT_MAX / 10) && digit > 7)) {
            return sign === 1 ? INT_MAX : INT_MIN;
        }

        // 累加结果
        result = result * 10 + digit;
        index++;
    }

    // 4. 返回结果
    return result * sign;
}

// 测试示例
console.log(myAtoi("42")); // 输出: 42
console.log(myAtoi("   -42")); // 输出: -42
console.log(myAtoi("4193 with words")); // 输出: 4193
console.log(myAtoi("words and 987")); // 输出: 0
console.log(myAtoi("-91283472332")); // 输出: -2147483648
```

---

### **代码解析**

1. **去除前导空格**：
   - 使用 `while` 循环跳过所有空格字符。
   - 如果字符串全是空格，循环结束后直接返回 `0`。

2. **解析符号**：
   - 检查当前字符是否是 `+` 或 `-`。
   - 如果是 `+`，保持默认符号 `sign = 1`；如果是 `-`，设置符号为 `sign = -1`。

3. **提取数字**：
   - 使用正则表达式 `/[0-9]/` 检查当前字符是否是数字。
   - 如果是数字，则将其累加到结果中。
   - 如果不是数字，则停止提取。

4. **处理溢出**：
   - 在每次累加数字之前，检查是否会超出 32 位有符号整数范围。
   - 如果 `result > Math.floor(INT_MAX / 10)` 或 `(result === Math.floor(INT_MAX / 10) && digit > 7)`，说明会发生溢出。
   - 根据符号返回 `INT_MAX` 或 `INT_MIN`。

5. **返回结果**：
   - 将最终结果乘以符号 `sign`，得到完整的整数值。

---

### **复杂度分析**

1. **时间复杂度**：
   - 遍历字符串一次，时间复杂度为 **O(n)**，其中 `n` 是字符串的长度。

2. **空间复杂度**：
   - 只使用了常量级别的额外空间，空间复杂度为 **O(1)**。

---

### **测试用例**

以下是一些典型的测试用例及其输出：

```javascript
console.log(myAtoi("42")); // 输出: 42
console.log(myAtoi("   -42")); // 输出: -42
console.log(myAtoi("4193 with words")); // 输出: 4193
console.log(myAtoi("words and 987")); // 输出: 0
console.log(myAtoi("-91283472332")); // 输出: -2147483648
console.log(myAtoi("2147483646")); // 输出: 2147483646
console.log(myAtoi("2147483647")); // 输出: 2147483647
console.log(myAtoi("2147483648")); // 输出: 2147483647（溢出）
console.log(myAtoi("")); // 输出: 0
console.log(myAtoi(" ")); // 输出: 0
console.log(myAtoi("+1")); // 输出: 1
console.log(myAtoi("+-12")); // 输出: 0（无效输入）
console.log(myAtoi("  +0 123")); // 输出: 0（忽略后续非数字字符）
```

---

### **总结**

- 通过逐步解析字符串，可以高效地实现 `atoi` 函数。
- 关键点在于处理空格、符号、数字提取和溢出检查。
- 时间复杂度为 **O(n)**，空间复杂度为 **O(1)**，适合处理大规模输入。
- 这种方法能够正确处理各种边界条件和异常情况，符合题目要求。