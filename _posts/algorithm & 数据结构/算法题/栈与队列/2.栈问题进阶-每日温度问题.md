
> 题目描述: 根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用  0 来代替。
> 
> 例如，给定一个列表  temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是  [1, 1, 4, 2, 1, 1, 0, 0]。
> 
> 提示：气温 列表长度的范围是  [1, 30000]。每个气温的值的均为华氏度，都是在  [30, 100]  范围内的整数。

参考：[[12、栈与队列怎么玩（上）]]

以下是用 JavaScript 实现“根据每日气温列表生成等待天数”的代码。我们将使用**单调栈（Monotonic Stack）** 来高效解决问题，时间复杂度为 O(n)，空间复杂度为 O(n)。

---

### 解题思路

1. **问题分析**：
   - 给定一个气温列表 `temperatures`，需要生成一个新的列表 `result`。
   - 对于每个位置 `i`，找到下一个比 `temperatures[i]` 更高的温度的索引，并计算两者的距离；如果不存在，则结果为 `0`。

2. **核心思想**：
   - 使用**单调递减栈**存储未处理的温度索引。
   - 遍历气温列表时，检查当前温度是否大于栈顶索引对应的温度：
     - 如果是，则弹出栈顶索引，并计算距离，更新结果数组。
     - 如果不是，则将当前索引入栈。
   - 最终，栈中剩余的索引对应的结果值为 `0`。

3. **算法步骤**：
   - 初始化一个空栈和一个结果数组 `result`，初始值全为 `0`。
   - 遍历气温列表：
     - 当前温度大于栈顶索引对应的温度时，弹出栈顶索引并计算距离，更新 `result`。
     - 将当前索引入栈。
   - 返回结果数组。

4. **时间复杂度**：O(n)，每个元素最多入栈和出栈一次。
5. **空间复杂度**：O(n)，栈和结果数组的空间开销。

---

### 代码实现

```javascript
function dailyTemperatures(temperatures) {
    const n = temperatures.length;
    const result = new Array(n).fill(0); // 初始化结果数组，默认值为 0
    const stack = []; // 单调递减栈，存储索引

    for (let i = 0; i < n; i++) {
        // 当栈不为空且当前温度大于栈顶索引对应的温度时
        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            const prevIndex = stack.pop(); // 弹出栈顶索引
            result[prevIndex] = i - prevIndex; // 计算距离并更新结果数组
        }
        // 将当前索引入栈
        stack.push(i);
    }

    return result;
}
```

---

### 测试代码

为了验证上述实现的正确性，我们可以编写一个简单的测试用例：

```javascript
// 测试用例
const temperatures1 = [73, 74, 75, 71, 69, 72, 76, 73];
console.log(dailyTemperatures(temperatures1)); // 输出: [1, 1, 4, 2, 1, 1, 0, 0]

const temperatures2 = [30, 40, 50, 60];
console.log(dailyTemperatures(temperatures2)); // 输出: [1, 1, 1, 0]

const temperatures3 = [30, 60, 90];
console.log(dailyTemperatures(temperatures3)); // 输出: [1, 1, 0]

const temperatures4 = [70, 65, 60, 55, 50];
console.log(dailyTemperatures(temperatures4)); // 输出: [0, 0, 0, 0, 0]
```

---

### 运行结果

**示例 1:**
```plaintext
输入: [73, 74, 75, 71, 69, 72, 76, 73]
输出: [1, 1, 4, 2, 1, 1, 0, 0]
```

**示例 2:**
```plaintext
输入: [30, 40, 50, 60]
输出: [1, 1, 1, 0]
```

**示例 3:**
```plaintext
输入: [30, 60, 90]
输出: [1, 1, 0]
```

**示例 4:**
```plaintext
输入: [70, 65, 60, 55, 50]
输出: [0, 0, 0, 0, 0]
```

---

### 代码详解

1. **初始化结果数组和栈**：
   - 结果数组 `result` 初始值为 `0`，表示默认情况下没有更高的温度。
   - 栈用于存储未处理的温度索引，保持栈中索引对应的温度单调递减。

2. **遍历气温列表**：
   - 当前温度大于栈顶索引对应的温度时，说明找到了更高的温度，弹出栈顶索引并计算距离。
   - 将当前索引入栈，确保栈中索引对应的温度单调递减。

3. **最终结果**：
   - 遍历结束后，栈中剩余的索引对应的温度没有更高的温度，因此结果数组中这些位置的值仍为 `0`。

---

### 总结

- 本题的关键在于利用单调栈的特性，快速找到下一个更高的温度。
- 单调栈能够将时间复杂度从 O(n²) 降低到 O(n)，非常高效。
- 代码简洁清晰，适合在实际开发中应用。
