
> 真题描述：
> 给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。  
> 
> 注意：答案中不可以包含重复的三元组。
>
> 示例：
> 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
> 满足要求的三元组集合为：
> [
> [-1, 0, 1],
> [-1, -1, 2]
> ]


这个问题是一个经典的算法问题，通常被称为*三数之和*（3Sum）。我们需要找到数组中所有满足 `a + b + c = 0` 的三元组，并且结果不能包含重复的三元组（即三个数的组合）。

### 解法：双指针法

#### 思路：
1. **排序**：
   - 首先对数组进行排序。排序后可以更方便地使用双指针来避免重复解。
2. **固定一个元素**：
   - 遍历数组，固定当前元素*作为第一个数* `nums[i]`。
   - *如果 `nums[i] > 0`，则可以直接跳过，因为后续的元素都大于 0，不可能再找到满足条件的三元组*。
3. **双指针寻找剩余两个数**：
   - 使用两个指针 `left` 和 `right` 分别指向当前元素右侧区间的起始和末尾。
   - 计算 `sum = nums[i] + nums[left] + nums[right]`：
     - 如果 `sum === 0`，记录当前三元组，并移动指针以避免重复。
     - 如果 `sum < 0`，*说明需要更大的值，因此移动左指针* `left++`。
     - 如果 `sum > 0`，*说明需要更小的值，因此移动右指针* `right--`。
4. **去重**：
   - 在遍历过程中，如果遇到与前一个元素相同的值，则跳过以避免重复解。

这种方法的时间复杂度为 **O(n²)**，空间复杂度为 **O(1)**（忽略排序的空间开销）。

---

#### 代码实现：

```javascript
function threeSum(nums) {
    const result = [];
    // 对数组进行排序
    nums.sort((a, b) => a - b);

	// 遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数
    for (let i = 0; i < nums.length - 2; i++) {
        // 如果当前元素大于 0，则后续元素也大于 0，不可能有解
        if (nums[i] > 0) break;

        // 跳过重复元素
        if (i > 0 && nums[i] === nums[i - 1]) continue;

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];

            if (sum === 0) {
                result.push([nums[i], nums[left], nums[right]]);

                // 移动指针并跳过重复元素
                while (left < right && nums[left] === nums[left + 1]) left++;
                while (left < right && nums[right] === nums[right - 1]) right--;

                left++;
                right--;
            } else if (sum < 0) {
                left++; // 需要更大的值
            } else {
                right--; // 需要更小的值
            }
        }
    }

    return result;
}

// 测试示例
const nums = [-1, 0, 1, 2, -1, -4];
console.log(threeSum(nums));
// 输出: [ [-1, -1, 2], [-1, 0, 1] ]
```

---

### 代码解析

1. **排序**：
   - 排序后的数组为 `[-4, -1, -1, 0, 1, 2]`。
   - 排序使得我们可以利用双指针高效地找到满足条件的三元组。

2. **外层循环**：
   - 遍历数组中的每个元素 `nums[i]`，将其作为固定的第一个数。
   - 如果 `nums[i] > 0`，直接退出循环，因为后续元素都不可能满足条件。

3. **双指针查找**：
   - 初始化 `left = i + 1` 和 `right = nums.length - 1`。
   - 根据 `sum` 的值调整指针的位置：
     - 如果 `sum === 0`，记录当前三元组，并移动指针以避免重复。
     - 如果 `sum < 0`，移动左指针 `left++`。
     - 如果 `sum > 0`，移动右指针 `right--`。

4. **去重**：
   - 在外层循环中，跳过与前一个元素相同的值。
   - 在内层循环中，跳过与当前指针相同的值。

---

### 示例运行过程

以 `nums = [-1, 0, 1, 2, -1, -4]` 为例：

1. 排序后数组为 `[-4, -1, -1, 0, 1, 2]`。
2. 外层循环从 `i = 0` 开始：
   - 固定 `nums[0] = -4`，初始化 `left = 1` 和 `right = 5`。
   - 计算 `sum = -4 + (-1) + 2 = -3`，移动左指针 `left++`。
   - 继续计算直到 `left >= right`，未找到解。
3. 外层循环到 `i = 1`：
   - 固定 `nums[1] = -1`，初始化 `left = 2` 和 `right = 5`。
   - 计算 `sum = -1 + (-1) + 2 = 0`，记录三元组 `[-1, -1, 2]`。
   - 移动指针并跳过重复元素。
4. 外层循环到 `i = 2`：
   - 跳过重复元素 `nums[2] = -1`。
5. 外层循环到 `i = 3`：
   - 固定 `nums[3] = 0`，初始化 `left = 4` 和 `right = 5`。
   - 计算 `sum = 0 + 1 + (-1) = 0`，记录三元组 `[0, -1, 1]`。
   - 移动指针并跳过重复元素。

最终结果为 `[[-1, -1, 2], [-1, 0, 1]]`。

---

### 时间复杂度和空间复杂度

- **时间复杂度**：O(n²)
  - 外层循环遍历数组，内层双指针查找的时间复杂度为 O(n)。
- **空间复杂度**：O(1)
  - 忽略排序的空间开销，算法本身没有使用额外的空间。

---

### 总结

通过排序和双指针的方法，我们可以高效地解决“三数之和”问题。这种方法的关键在于：
1. **利用排序简化问题**。
2. 使用双指针减少不必要的重复计算。
3. 注意去重逻辑，确保结果中不包含重复的三元组。

这种方法不仅适用于本题，还可以扩展到类似的问题（如四数之和、最接近的三数之和等）。


### 参考
[[7、数组的应用——真题归纳与解读]]
