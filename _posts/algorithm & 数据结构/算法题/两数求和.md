
> 真题描述： 
>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。  
>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
   示例:
  给定 nums = [2, 7, 11, 15], target = 9  
  因为 nums[0] + nums[1] = 2 + 7 = 9
  所以返回 [0, 1]

这个问题是一个经典的算法问题，通常被称为 *“两数之和”问题*。我们可以通过多种方法来解决它，其中*最高效的方法*是使用**哈希表**（即 JavaScript 中的对象或 `Map`）。这种方法的时间复杂度为 **O(n)**，空间复杂度也为 **O(n)**。

---

### 解法：使用哈希表

#### 思路：
1. 遍历数组中的每个元素。
2. 对于当前元素 `nums[i]`，计算目标值与它的差值 `target - nums[i]`。
3. 检查这个差值是否已经存在于哈希表中：
   - 如果存在，则说明找到了两个数，它们的和等于目标值。
   - 如果不存在，则将当前元素及其索引存入哈希表，继续遍历。
4. 最终返回找到的两个索引。

#### 代码实现：

```javascript
function twoSum(nums, target) {
    const map = new Map(); // 使用 Map 存储已访问的元素及其索引

    for (let i = 0; i < nums.length; i++) {
        const current = nums[i]; // 当前元素
        const complement = target - current; // 计算目标值与当前元素的差值

        if (map.has(complement)) {
            // 如果差值已经在哈希表中，返回结果
            return [map.get(complement), i];
        }

        // 将当前元素及其索引存入哈希表
        map.set(current, i);
    }

    // 如果没有找到解，返回空数组（题目保证有解，因此不会到达这里）
    return [];
}

// 测试示例
const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(nums, target)); // 输出: [0, 1]
```

---

### 代码解析

1. **初始化哈希表**：
   - 我们使用 `Map` 来存储数组中的元素及其索引。键是数组中的元素值，值是该元素的索引。
   - 例如，当遍历到 `nums[0] = 2` 时，哈希表会变成 `{ 2 => 0 }`。

2. **遍历数组**：
   - 对于每个元素 `nums[i]`，计算目标值与它的差值 `complement = target - nums[i]`。
   - 检查 `complement` 是否已经存在于哈希表中：
     - 如果存在，说明之前已经访问过一个元素，它的值正好是 `complement`，因此这两个数的和等于目标值。
     - 如果不存在，将当前元素及其索引存入哈希表，以便后续查找。

3. **返回结果**：
   - 一旦找到符合条件的两个数，立即返回它们的索引。
   - 根据题意，输入保证有且仅有一个答案，因此不需要处理无解的情况。

---

### 时间复杂度和空间复杂度

- **时间复杂度**：O(n)
  - 我们只需遍历数组一次，**每次操作（查找和插入）在哈希表中都是 O(1) 的时间复杂度**。
- **空间复杂度**：O(n)
  - 哈希表最多需要存储 n 个元素。

---

### 示例运行过程

以 `nums = [2, 7, 11, 15]` 和 `target = 9` 为例：

1. 初始化哈希表 `map = {}`。
2. 遍历第一个元素 `nums[0] = 2`：
   - 计算 `complement = 9 - 2 = 7`。
   - 检查 `map` 中是否包含 `7`，发现不包含。
   - 将 `2` 及其索引 `0` 存入 `map`，此时 `map = { 2 => 0 }`。
3. 遍历第二个元素 `nums[1] = 7`：
   - 计算 `complement = 9 - 7 = 2`。
   - 检查 `map` 中是否包含 `2`，发现包含。
   - 返回 `[map.get(2), 1]`，即 `[0, 1]`。

---

### 其他解法（暴力法）

如果不要求高效的解决方案，可以使用暴力法，通过双重循环逐一检查所有可能的组合。但这种方法的时间复杂度为 **O(n²)**，效率较低。

#### 暴力法代码：

```javascript
function twoSum(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
}

// 测试示例
const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(nums, target)); // 输出: [0, 1]
```

---

### 总结

- **最优解法**：使用哈希表可以在 O(n) 的时间复杂度内解决问题，适合处理大规模数据。
- **暴力法**：虽然简单易懂，但效率较低，适用于小规模数据或学习目的。

通过掌握哈希表的使用，我们可以高效地解决许多类似的查找问题！

### 参考
[[7、数组的应用——真题归纳与解读]]
