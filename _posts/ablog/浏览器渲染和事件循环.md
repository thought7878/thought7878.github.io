
浏览器渲染知识是前端开发中非常重要的一部分，**了解浏览器渲染原理，可以帮助我们更好的了解前端开发中的一些问题，比如：性能优化、页面渲染、页面优化等**。

本文主要围绕渡一的：[浏览器渲染渲染原理](https://fe.duyiedu.com/p/t_pc/course_pc_detail/video/v_65015b31e4b0b0bc2c1bdb19?product_id=course_2VKbErGXkTSzvbl9aQ9HgndEtIz)与神说要有光的：[Event loop 和 JS 引擎、渲染引擎的关系](https://zhuanlan.zhihu.com/p/371786505?utm_medium=social&utm_psn=1804644359536250880&utm_source=wechat_session)，进行一个笔记总结。

![[ablog/media/b1bf49445813d9fff7411f947c52e8a4_MD5.gif]] 

希望通过这篇文章，可以帮助大家更好的了解浏览器渲染原理。如：
- 浏览器地址栏输入 URL 后发生了什么？
- 浏览器是如何渲染页面的？
- 浏览器的整个渲染流程都做了哪些事情？
- 为什么需要 event loop？
- 为什么需要 microtask 和 macrotask？
- requestAnimationFrame 和 requestIdleCallback 有什么区别？

## 进程和线程

### 进程

一个程序运行是需要有一块属于它自己的内存空间的，那么我们可以把这个内存空间理解为一个容器，这个容器里面存放着程序运行时所需要的各种资源。而进程就是这样一个容器，它是程序运行时的一个实例，是程序运行时的一个抽象概念。每个应用程序都会至少有一个进程，进程之间是相互独立的，每个进程都有自己独立的内存空间。一个进程无法直接访问另一个进程的内存，需要通过双方同意的机制进行通信。

![[ablog/media/2b20c76f5a57a8e002c328ddd6a64818_MD5.png]]

### 线程

有了进程，我们就可以在进程中创建线程，**一个进程中的多个线程共享相同的内存空间**，每个线程有自己的栈空间和寄存器，但是共享堆空间。如果程序需要执行不同的任务，可以创建不同的线程来完成。线程是程序执行的最小单位。

把进程比做一个工厂，线程就是工厂里面的工人，工人之间共享工厂的资源，但是每个工人有自己的工作空间。在程序中，运行代码的「人」称之为「线程」。 

---

浏览器是一个多进程的应用，主要包括以下几个进程：

- 浏览器进程，主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程，主要负责页面渲染、脚本执行、事件处理等。**
- GPU 进程，主要负责 3D 绘制、页面绘制等。
- 网络进程，主要负责网络资源的加载，内部启用多个网络进程来完成不同的网络请求。
- ... 以上是最主要的几个进程 
![[ablog/media/fae9ef4cbe65dd4aedf6d880448aa977_MD5.png]]

## 浏览器渲染进程

一个 Tab 页对应一个渲染进程一个进程实例，不同的 Tab 页之间是相互独立的，互不影响。这样设计的好处是，即使一个 Tab 页崩溃了，也不会影响其他 Tab 页的正常运行。**渲染进程启动之后，会创建一个渲染主线程**，负责页面的渲染和脚本执行等，事件循环(Event Loop)就是在这个线程中运行的。

这个渲染主线程是最重要的线程，主要工作有：

- 解析 HTML，构建 DOM 树
- 解析 CSS，构建 CSSOM 树
- 将 DOM 树和 CSSOM 树结合，生成渲染树。计算样式，转换预设属性为实际的绝对值。
- 布局渲染树，计算节点的几何信息(位置、大小)。这个过程叫做 Layout，重排也是在这个阶段开始的。
- 分层，处理图层生成图层树(Layers)，这个过程是为了提高渲染性能，把不同的节点分成不同的图层，内容发生变化时，只需要重新绘制相关的图层，不需要整个页面重新绘制。
- 图层绘制，生成绘制指令，提交给合成线程。
- 合成线程，把图层绘制指令提交给 GPU，GPU 把图层绘制到屏幕上。
- 执行 javascript 代码，处理事件等。

把这一系列操作比做 Ps，Ai，Sketch 等设计软件的操作，我们在设计软件中，也是先画出设计稿，然后布局，最后生成图层，这样设计软件才能更好的渲染出我们想要的效果。 

## 浏览器渲染流程

准备工作 **由网络线程去进行网络请求得到 HTML，创建一个渲染任务，然后把这个渲染任务放入渲染主线程的消息队列中**，等待渲染主线程去执行。渲染主线程会不断的从消息队列中取出任务执行，这个过程就是 Event loop。  

![[ablog/media/0d596c8f1e6f906284f42716eeb675b5_MD5.png]]

**渲染的整个流程分为：HTML 解析、CSS 样式计算、布局、分层、绘制、分块、光栅化、画(画生成的像素点)**，这些步骤像流水线一样，上一个步骤的输出是下一个步骤的输入，最终生成页面。

#### 第一步是解析 HTML，构建 DOM 树和 CSSOM 树(Parse)

预解析线程 **在解析 HTML 前，浏览器会创建一个预解的线程，快速预览获取需要下载的外部资源，交给网络线程任务提前去下载外部 CSS 和 javascript 资源**，如果解析到 `<link>` 标签，如果这时的 CSS 资源还没有下载解析完成，渲染主线程不会停止解析 HTML，因为下载和解析 CSS 是是在预解析线程中进行的。这就是为什么 CSS 不会阻塞页面渲染的原因。

然而，存在一个问题，javascript 脚本执行时可能**在文档的解析过程中请求样式信息**，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 javascript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 javascript，最后再继续文档的解析。 

同样的我们可以利用 `preload` 和 `prefetch` 标签来提前下载资源，提高页面的加载速度。 利用 `defer` 和 `async` 属性来控制 javascript 脚本的下载和执行。

具体如下：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <!-- <link rel="icon" type="image/svg+xml" href="/vite.svg" /> -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>...</title>

        <link rel="icon" type="image/svg+xml" href="/logo.svg" />

        <!-- Preload example: Preload the main stylesheet -->
        <link rel="preload" href="/assets/index-CdkCYO3q.css" as="style" />

        <!-- Prefetch example: Prefetch a script for future use -->
        <link rel="prefetch" href="/assets/future-script.js" as="script" />

        <!-- Async example: Load a script asynchronously -->
        <script async src="/assets/async-script.js"></script>

        <!-- Defer example: Defer loading of a script until the document has been parsed -->
        <script defer src="/assets/defer-script.js"></script>

        <script type="module" crossorigin src="/assets/index-DD3X1S2t.js"></script>
        <link rel="stylesheet" crossorigin href="/assets/index-CdkCYO3q.css" />
    </head>
    <body>
        <div id="app"></div>
    </body>
</html>
```

- **`preload`：** 用于提前加载资源，比如：CSS、JS、图片等，可以提前加载资源，提高页面的加载速度。**优先级比 `prefetch` 高，会先加载当前页面立即需要的资源。**
    
- **`prefetch`：** 用于提前加载资源，比如：CSS、JS、图片等，可以提前加载资源，提高页面的加载速度。**优先级比 `preload` 低，会在浏览器空闲时加载资源。**
    
    以上两个特性只会对外部资源进行下载，不会对资源进行解析。可以看到在上面示例中，我们在后面也继续的通过 `link` 和 `script` 标签引入引用了资源。
    
- **`async`：** 用于异步加载资源，不会阻塞页面的渲染，但是会**在下载完成后立即执行。不会按照顺序执行，谁先下载完成谁先执行。**
    
- **`defer`：** 用于异步加载资源，不会阻塞页面的渲染，**会在文档解析完成后执行。并且会按照顺序执行。**
    

---

构建 CSSOM 树，CSSOM 树和 DOM 树，因为这些 HTML 和 CSS 都是字符串，如果需要提高分析表达效率等，需要转换成能够理解的数据结构，这个数据结构就是 DOM 树和 CSSOM 树。把它转化成一个树形结构的数据结构，更方便后续的操作，为 javascript 提供操作 DOM 能力。**这两个树构建不是单步进行的，而是利用预解析线程和渲染主线程交替进行的。**

样式来源于：

- `link` 标签引入的外部样式表
- `style` 标签内部的样式
- `<div style="color: red;"></div>` 这种内联样式
- [浏览器默认样式](https://github.com/iamsyygo/bloggg/blob/705826fe65d74becd21d107efe05970f8d5c9104/docs/blog/third_party/blink/renderer/core/html/resources/html.css)

除了浏览器默认样式我们无法操作外，其他样式我们都可以通过 javascript 来操作，比如：通过`document.styleSheets`获取样式表，通过`document.styleSheets[0].cssRules`获取样式规则，通过`document.styleSheets[0].insertRule()`插入样式规则等。

第一步完成后，会得到 DOM 树和 CSSOM 材，浏览器的默认样式、内部样式、外部样式、行内祥式均会包含在 CSSOM 树中。

为什么不需要 javascript 树？

因为 javascript 只需要执行一次就可以了不需要构建一个树形结构来存储 javascript 代码，而 DOM 树和 CSSOM 树是需要不断的更新的，后续可能需要通过 javascript 来操作 DOM 树和 CSSOM 树，所以需要构建一个树形结构来存储这些数据。 

注意，在解析过程中并不会等到所有的 HTML 都解析完成之后再去计算样式和布局等。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络线程去下载其余内容。

#### 第二步是样式计算(Style)

渲染主线程会遍历 DOM 树，依次为每个 DOM 节点计算出最终的样式，这个过程叫做样式计算(Style Computation)。**包含了计算 CSS 属性的权重、继承、层叠等。样式计算是一个递归的过程，从根节点开始，逐级计算每个节点的样式，直到叶子节点。将一些预设的样式属性转换为实际的像素值绝对值，比如：`em`、`rem`、`%` 转换为像素值。`red`、`blue` 转换为 `#ff0000`、`#0000ff`。** 

![[ablog/media/2f0e91352bdaf8032d776f07bac3ba0a_MD5.png]]

视频讲解：[CSS 样式计算过程](https://www.bilibili.com/video/BV1Gb4y1L7CV/?vd_source=13247d39707a1ca9263bb174061b3cb4)

#### 第三步是布局(Layout)

通过上一步的样式计算，构建了一个拥有样式的 DOM 树(渲染树)，接下来就是布局(Layout)。布局是计算节点的几何信息(位置、宽高大小)、包含块位置等等的过程。这也是“重排”(Reflow)的开始 de 起点。**布局完成后会得到一颗“布局树”。**

**布局树和 DOM 树不是一一对应的关系，布局树是 DOM 树的一个映射，只包含需要显示的节点。** 比如：`display: none`等等，这些节点不会出现在布局树中。again 比如：`::before`、`::after` 伪元素，他们不会出现在 DOM 树中，但是他们有几何信息等，会出现在布局树中。

节点的几何信息(位置、宽高大小)只有在布局阶段才能确定的，比如：包含块、相对定位、绝对定位、浮动、文档流等等。这些都是在布局阶段才能确定的。

- 元素的百分比宽高是相对于包含块的宽高计算的。
- 元素的 `margin`、`padding` 百分比是相对于包含块的宽度计算的。
- 元素的 `top`、`left`、`right`、`bottom` 百分比是相对于包含块的宽高计算的。
- ...

---


通常我们通过 `clientWidth` 、`offsetWidth`、`scrollWidth`、`getBoundingClientRect()` 等方法获取元素的几何信息，这些方法获取的信息都是在布局树上的信息。 所以在获取这些信息前，需要确保布局树已经构建完成，否则获取到的信息可能不准确。或者浏览器在我们获取信息前，先触发一次重排，确保获取到的信息是准确的。

注意的是 `getComputedStyle()` 获取的是样式计算后的样式(第二步)，不是布局树上的信息。 

#### 第四步是分层(Layer)


渲染主线程会使用一套复杂的策咯**对整个布局树中进行分层。分层的好处在于将来某一个层改变后，仅需要对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、`transform`、`opacity` 等样式都会触发分层，这些样式会触发 GPU 加速，提高页面的渲染性能。** 也可以通过 `will-change` 属性来提前告诉浏览器哪些属性会发生变化，从而提前分层，更大程度的提高页面的渲染性能。

需要注意的是虽然 `will-change` 可以提前告诉浏览器哪些属性会发生变化，但是滥用 `will-change` 会导致页面的性能下降，因为浏览器会为每一个 `will-change` 的属性创建一个图层，如果图层过多，会导致内存占用过高，反而会降低页面的性能。

#### 第五步是绘制(Paint)

生成绘制指令，为每个图层生成单独的绘制指令，比如：

- 将笔触移动到某个位置`(x, y)`
- 画一条直线到某个位置`(x, y)`
- 画一个矩形
- 使用某种颜色填充矩形
- ...

**可以看到上面的这些指令操作有点像 canvas 的操作**，因为 `canvas` 本身也是通过浏览器内置的这些绘制功能来绘制的。但是这些指令是在 GPU 上执行的，GPU 会把这些绘制指令绘制到屏幕上。例如：

- 将笔触移动到某个位置`(x, y)` -> `canvas.moveTo(x, y)`
- 画一条直线到某个位置`(x, y)` -> `canvas.lineTo(x, y)`
- 画一个矩形 -> `canvas.rect()`
- 使用某种颜色填充矩形 -> `canvas.fillStyle()`

这种绘制指令是一个个的绘制指令，浏览器会把这些绘制指令提交给合成线程，合成线程会把这些绘制指令提交给 GPU，GPU 会把这些绘制指令绘制到屏幕上。

**渲染主线程的工作到目前为止已经完成了，接下来浏览器为了提高页面的渲染性能，会把剩下的工作交由其他线程来完成。主要的核心的线程是合成线程**。

#### 第六步是分块(Tiling)

完成绘制后，渲染主线程**将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。分块的目的是将每一个图层分成一个个小块，每个小块称之为瓦片，这样可以先处理靠近视口的瓦片，不需要一次性处理整个图层，提高页面的渲染性能。** 它会从线程池中拿取多个线程来完成分块工作。分块完成后，**进入光栅化阶段。合成线程会将块信息交给 GPU 进程，以极高的速度完成光棚化。**

#### 第七步是光栅化(Raster)

完成分块后，合成线程会将块信息交给 GPU 进程，GPU 进程会以极高的速度完成光栅化。GPU 擅长处理大规模并行计算任务，这个过程可以理解为浏览器根据矢量图形的描述，在给定的分辨率下计算出每一个像素的颜色值。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。光栅化的结果，就是一块一块的位图。

光栅化（Rasterization） 光栅化（Rasterization）是计算机图形学中的一种过程，**用于将矢量图形（例如使用 SVG 或 CSS 描述的图形）转换为像素（位图）图像。这个过程的核心在于将描述形状的几何数据（如点、线、多边形）转化为屏幕上的像素网格，从而形成可见的图像。** 也就是一个将矢量图形转换为像素图像的过程。

矢量图形与像素图像的区别

- 矢量图形：由几何描述（如点、线、曲线、多边形）定义，可以在不损失质量的情况下无限缩放。矢量图形是基于数学公式的，它们只描述形状和位置，而不直接描述像素颜色。
- 像素图像：由一个个像素（像素是屏幕上的最小显示单元）组成，每个像素有一个固定的颜色值。当你放大像素图像时，它会变得模糊，因为图像是由固定数量的像素组成的。

举个例子 假设你在电脑上绘制一个简单的绿色三角形： 矢量描述：这个三角形是由三个顶点和它们之间的连接边来描述的。每个顶点都有一个位置坐标（如 (x1, y1)）和颜色信息（绿色）。 光栅化：计算机将这个三角形的描述转换为屏幕上的像素。例如，如果这个三角形覆盖了屏幕左上角的 50x50 像素区域，光栅化过程将决定哪些像素在三角形内部并应该显示为绿色。 最终结果：屏幕上显示出一个由像素组成的绿色三角形。这个三角形不再是由几何形状定义的，而是由具体的像素排列和颜色组成的图像。

光栅化的实际应用广泛应用于计算机图形渲染中，尤其在实时渲染（如视频游戏）中最为常见。它是将三维场景转化为二维图像的关键步骤之一。 

光栅化具体过程 几何计算：浏览器首先对矢量图形进行几何计算，确定每个矢量形状应该在哪些像素上显示。这就是上面第三步的布局的过程。 填充像素：然后浏览器根据这些计算，填充相应的像素点。例如，对于一个矩形，浏览器会确定哪些像素点在矩形的边界内，然后将这些像素设置为矩形的颜色。 抗锯齿：为了避免边缘锯齿状（即 "jagged edges"），浏览器还可能使用抗锯齿技术，这意味着它会对边缘处的像素进行混合，使过渡更平滑。

![[ablog/media/e1834eb494195aaf62e56eaa46e12b13_MD5.png]]

通过上述的步骤，完成了**从几何图形到像素点图像的转换**，接下来就是把这些位图(像素)绘制到屏幕上。

#### 第八步是画


最后将这些位图(像素)交由操作系统的显示设备(硬件)，显示设备会把这些位图绘制到屏幕上，用户就可以看到页面了。


为什么不直接交由渲染主线程去让计算机操作系统的显示设备绘制到屏幕上呢？而是要经过 GPU 进程处理再让其将位图交由操作系统的显示设备绘制到屏幕上呢？

安全，渲染主线程是在一个沙箱(沙盒)环境中运行的，不允许直接操作操作系统的硬件设备。GPU 进程不是在沙箱环境中运行的，可以直接操作操作系统的硬件设备，这样可以保证浏览器的安全性。 

**合成线程拿到每个层、每个块的位图(像素点)后，生成一个个指引(quad)信息。**

- 指引(quad)会标识出每个位图(像素点)应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。
- 变形(`transform`)发生在合成线程，**与渲染主线程无关**，这就是 `transform` 效率高的本质原因。
- **合成线程会把指引(quad)提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。**

`transform` 和 `position` 的区别 由于 `transform` 是在合成线程中进行的(第八步非常靠后的)，所以 `transform` 的性能要比 `position` 高。 

## Event loop 事件循环


**为什么浏览器要在渲染线程中处理这么多事情(单线程)？**

因为在 javascript 最开始设计只是被用来做表单处理，这不会有什么特别大的计算量，就没有采用多线程架构，而是在一个线程内进行 dom 操作和逻辑计算，渲染和 javascript 执行相互阻塞。 避免复杂性，如果浏览器使用多线程来处理渲染任务，会引入很多复杂性(dom 操作获取同步等)。多线程编程需要处理线程同步、死锁等问题，这会增加浏览器的实现难度和维护成本。

**事件循环是浏览器渲染主线程工作的核心机制(方式)，是浏览器渲染主线程如何有序的处理这么多事情的关键。**

**渲染主线程是如何有序地处理这么多事情的？**

- 当正在执行一段 javascript 代码途中，用户点击一个按钮触发一个 callback 函数，渲染线程是去处理这个 callback 还是继续执行试下的 javascript 代码？
- 当正在执行一段 javascript 代码途中，定时器时间到达需要执行 callback 函数，渲染线程是去处理这个 callback 还是继续执行试下的 javascript 代码？
- ...

之所以能够这么繁忙的有序的处理这么多事情，是因为**渲染主线程通过一个调度系统有秩序的去排队执行**，这个调度系统就是 Event loop。

 Event loop 并不是 javascript 引擎提供，它是宿主环境为了集合**渲染任务和 javascript 代码执行**，也为了处理 javascript 代码执行时的高优先级任务而设计的机制。  

![[ablog/media/46a275f7527310546016519c00a7b453_MD5.png]]

- 在开始的时候，渲染主线程进入一个无限循环，这个循环就是 Event loop。
- Event loop 会不断的从消息(任务|事件)队列中取出任务执行。
- 每次循环当调用栈为空时，都会检查是否有任务需要执行，如果有就从消息队列中取出一个任务执行，没有就休眠等待。
- **其他线程可以往消息队列末尾中添加任务，比如：定时器到达、事件触发等，唤醒 Event loop 继续执行。**
- 这样的有条不紊的执行任务，就是 Event loop 的工作原理，就是为什么渲染主线程能够有序的处理这么多事情的原因。
- 整个过程称之为“事件循环”。
- 每一个消息任务完整地执行后，其他消息任务才会被执行。

---

一次 loop 的执行过程： 浏览器通过事件循环机制协调 javascript 引擎和 UI 渲染的工作。Event loop 是一个不断循环的过程。它会持续重复检查调用栈和消息队列，当调用栈为空时，会从消息队列中取出一个任务执行，并在合适的时机更新 UI。

## 消息队列


在上面有说过，Event loop 是一个为了解决 javascript 引擎和 UI 渲染的协调问题而设计的机制，**也为了处理 javascript 代码执行时的高优先级任务。**  那么 Event loop 是如何处理 javascript 代码执行时的高优先级任务的呢？

**总不能按照先推入消息队列的任务先执行，后推入消息队列的任务后执行吧？假如有更紧急的任务需要执行，怎么办？** 不可能每次都是按照任务 1->任务 2->任务 3->...->任务 n 的顺序执行，这样会导致一些高优先级任务无法及时执行。

**所以 Event loop 会把消息队列分成两个部分，一个是 macrotask(宏任务)，一个是 microtask(微任务)。不然不同的浏览器会有不同的实现，但是大体上都是这样的。** 

目前在 chrome 浏览器实现中，至少有以下几种队列：

- 微任务队列：Promise、process.nextTick、MutationObserver。「优先级最高」。
- 交互队列：用户交互事件，比如：click、keyup、mousemove 等。「优先级次之」。
- 延时队列，也是宏任务队列：setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI rendering(UI 渲染)。「优先级中」。

不同的任务有不同的任务类型，把相同的任务类型放在一个类型的队列中，按照先进先出的顺序执行。 

![[ablog/media/848a3aa70a92aa230fc8abdc93f05574_MD5.png]]

微任务 micro tasks 就像是一个急事的绿色快速通道，优先级最高。**一次事件循环中，浏览器从不同的队列中取出任务执行，直到所有队列都为空为止，然后进入下一次事件循环。**

 不同的浏览器对队列类型的优先级也是有所不同的，**但是无论在什么浏览器中，必须要有一个微任务队列，且优先级是最高的，这是 W3C 规范要求的。其他队列由浏览器自行去决定** 

最后，在 javascript 中产生异步编程的原因是因为浏览器 UI 渲染和 javascript 代码执行是在**单线程**中进行的，是单线程的。**Event loop 是事件循环是异步编程实现的核心机制(方式)。**

## 生命周期

我们可以把一次事件循环(Event loop)表示为一个生命周期，分为以下几个阶段：

- 渲染主线程首先会执行同步任务，这些任务包括解析 HTML、构建 DOM 树、构建 CSSOM 树、生成渲染树、布局渲染树、分层、图层绘制、提交给合成线程等。
- 执行完同步任务后，Event loop 检查是否有微任务(microtask)需要执行，如果有就执行微任务。
- 微任务执行完后，Event loop 检查是否有交互任务需要执行，如果有就执行交互任务。
- 交互任务执行完后，Event loop 检查是否有延时任务(macrotask)需要执行，如果有就执行延时任务。
- 开始渲染前渲染主线程会检查是否有需要重新渲染的任务。
- 在重新渲染之前，检查是否有 requestAnimationFrame 任务，如果有就执行。
- 在开始渲染前会检查距离下一帧还有多少时间，如果有空闲时间，会执行 requestIdleCallback 任务。
- 开始渲染，生成绘制指令等，提交给合成线程进行渲染。
- 开始下一轮的 Event loop，检查是否有延时异步任务(macrotask)需要执行，如果有就执行。 
![[ablog/media/d7c078dbff22084c81757535e0042fad_MD5.png]]

`requestIdleCallback` 会在每次 check 结束后发现如果距离下一帧的刷新还有时间，就执行。如果时间不够，就下一帧再处理。 如果每一帧都没时间，可以提供 timeout 参数指定最长的等待时间，如果一直没时间执行这个逻辑，那么就算拖延这次帧渲染也要执行。 

每一帧的渲染时间大概是 16.6ms，如果 javascript 代码执行时间过长，会导致帧渲染时间过长，会导致页面卡顿。 不管是同步任务、微任务、交互任务、延时任务、requestAnimationFrame、requestIdleCallback，都有可能影响页面的渲染性能，所以我们在编写代码时，要尽量减少这些任务的执行时间，避免页面卡顿。

---

其实上面的步骤是一个正常的渲染流程，这个是一个同步的渲染流程。 但是如果我们在执行 javascript 代码时，存在更新 DOM 的操作，并且在更新 DOM 的操作后，立即读取 DOM 的信息值，比如通过 `getBoundingClientRect()` 读取元素的几何信息，浏览器在反复的权衡性能和实时性的情况下，为了让数据的准确性，会强制执行一次渲染，也就是我们常说的重排(reflow)。浏览器渲染主线程会**立即异步执行一次渲染**。所以应该尽量避免这种情况的发生，减少页面的重排。比如


```js
const elements = [...document.querySelectorAll('.foo')];

// 每次循环都会触发一次 reflow
for (const element of elements) {
    // 添加一个 class 可能会修改元素的几何信息
    element.classList.add('bar');

    // 之后立即读取元素的几何信息，会强制执行一次渲染
    element.getBoundingClientRect();
}
```

```js
// 这种方式可能导致 getBoundingClientRect() 获取到的几何信息不准确
const elements = [...document.querySelectorAll('.foo')];

// 先获取所有元素的几何信息
const rects = elements.map((element) => element.getBoundingClientRect());

// 之后再添加 class
elements.forEach((element) => element.classList.add('bar'));
```

```js
// 这种和方式一差不多，但是只会触发一次 reflow
const elements = [...document.querySelectorAll('.foo')];

// 添加 class 不会立即执行渲染
elements.forEach((element) => element.classList.add('bar'));

// 之后再读取元素的几何信息
// 在 index 为 0 的时候触发 reflow
// 其他 index 不存在更新 DOM 操作，不会触发 reflow
elements.forEach((element) => element.getBoundingClientRect());
```

