[【干货】浏览器是如何运作的？](https://www.bilibili.com/video/BV1x54y1B7RE/?share_source=copy_web&vd_source=9c1e19a73fa7bd23bb37aa8d7467d862)

**但浏览器获取到网页数据后，浏览器又是如何将数据转换为视图的？**

视频讲述了浏览器的运作原理，包括其发展史、结构组成、进程线程概念、渲染流程及优化方法等，具体如下：

## 了解浏览器工作原理的意义
[00:21] 
能让开发者*写出更好的代码和提供更好的用户体验*，对于前端工程师而言，*就像赛车手了解自己的赛车一样重要*。

## 浏览器发展史
[00:50] 
1991年波罗斯里建立第一代网络浏览器Word wide web，仅支持显示文本图片；
1993年MOIE问世，可同时显示文本和图像；
1994年网景浏览器发布，虽功能有限但大受欢迎；
1995年微软发布IE1.0、2.0，引发第一次浏览器大战，后IE占据极高市场份额；
网景公司在基金会推动下开发火狐浏览器，2004年发布1.0版本，拉开第二次浏览器大战序幕；
2003年苹果发布safari浏览器并于2005年*开源其内核WEBKIT*；
2008年谷歌*基于WEBKIT创建chrome项目*，发展迅速成为全球最受欢迎浏览器；
2015年微软放弃IE，推出*基于WEBKIT内核*的edge浏览器。
截至2020年5月，chrome占据60%多的市场份额。

## 浏览器的框架结构
[03:25] 
大致分为*用户界面、浏览器引擎、渲染引擎*。

`用户界面`展示除标签页窗口外的其他内容；

![[_posts/browser/media/fc58bb72bcd7152d7e2a210b40015967_MD5.jpeg]]

`浏览器引擎`在用户界面和渲染引擎间传递数据；

`渲染引擎`**负责渲染页面内容**，其下有*网络模块、JS解释器、数据存储持久层*等功能模块。**渲染引擎即浏览器内核**，不同浏览器内核不同，如IE使用trident，FIREFOX使用*Gecko*，safari使用*WEBKIT*，chrome使用基于WEBKIT改造优化的*Blink*，opera和edge也使用blink。

![[_posts/browser/media/4a39ed49e9b34f5a190e9f365f51c683_MD5.jpeg]]


## 进程和线程的概念
[04:59] 
`进程`是操作系统进行资源分配和调度的基本单元，是程序的基本执行实体，可申请和拥有计算机资源，**一个进程可并发多个线程**，进程间通过IPC通信；
`线程`是操作系统能进行运算调度的最小单位，同一进程下的线程可直接通信、共享数据。

![[_posts/browser/media/405bffcba5c4f691bb1517a9d9333db9_MD5.jpeg]]


## 浏览器的多进程结构
[06:39] 
*早期浏览器*是单进程结构，存在*不稳定、不安全、运行效率低*等问题。

*现在采用多进程结构*，包括`浏览器进程`（控制除标签页外的用户界面，协调其他进程）、`网络进程`（发起和接受网络请求）、`GPU进程`（负责整个浏览器界面渲染）、`插件进程`（控制网站使用的所有插件，非扩展）、`渲染器进程`（控制显示tab标签内的所有内容）。

chrome有四种进程模型，默认情况下为每个网站实例创建一个渲染器进程。

![[_posts/browser/media/a65e6908d3a07dfe815026ed8aac225d_MD5.jpeg]]


## 输入内容时浏览器的内部操作
[09:34] 
浏览器进程的UI线程捕捉输入内容，若为网址，启动网络线程进行DNS域名解析，连接服务器获取数据；若为关键词，使用默认搜索引擎查询。

![[_posts/browser/media/ce63630a02685372f4122ac22e9e627e_MD5.mp4]]


## 网络线程获取数据后的处理
[10:12]～[10:56]
网络线程通过safe process检查站点是否为恶意站点，安全校验通过后通知UI线程，UI线程创建渲染器进程，浏览器进程通过IPC管道将数据传递给渲染器进程，进入渲染流程。

## 渲染器进程的渲染流程
[10:36] ～[]

### DOM 阶段（构建DOM树）
[10:36]、[10:49]～[12:39]

**渲染器进程的核心任务**是把HTML、CSS、JS、图片等资源，渲染成用户可以交互的页面。

`DOM`（Document Object Model 文档对象模型）是*浏览器对页面在其内部的表示形式*，是程序员可以*通过JS与之交互的**数据结构**和**API***。

渲染器进程的`主线程`**解析HTML构造DOM树**。解析过程中遇到`<script>`标签会停止HTML解析，*加载、解析、执行JS*。

- **JS**
[11:40]
解析HTML过程中，遇到*同步*的`<script>`标签，会停止HTML解析，*加载、解析、执行JS*。
阻塞DOM的构建。*优化JS的方法：*
	script标签放在HTML底部；
	给script标签加`defer`、`async`，*异步*加载JS；

为什么不等DOM构建完后，再加载、解析、执行JS？
	因为JS可能会修改DOM。如果JS修改了DOM，之前的HTML的解析、DOM的构建，就没有意义了

- **CSS、图片**
解析HTML过程中，遇到CSS、图片，通过网络下载、或从缓存加载。不会阻塞HTML的解析、DOM的构建。
CSS会阻塞CSSOM的构建。


### Style 阶段（构建CSSOM）
[12:35]～[13:07]
`主线程`*解析CSS*，确定每个DOM节点的样式（计算后的样式）。


### Layout 阶段（构建layout树）
[13:07]～[]
根据DOM树和CSSOM（样式）生成 `layout树`，确定每个节点的尺寸（宽高）、在页面上的位置（坐标）。

`主线程`通过遍历DOM和CSSOM（计算后的样式），生成Layout Tree。


### Paint 阶段
[13:57]～[]
生成绘制记录表（Paint Record），*确定绘制顺序*；

### 栅格化（Rastering）
[14:40]～[]
生成layer树并传递给合成器线程；
合成器线程将图层分成图块传给栅格线程栅格化，栅格化完成后合成器线程生成合成器帧，通过IPC传回浏览器进程，再传到GPU进程渲染后展示到屏幕。

## 重排和重绘
[17:30]～[]
*改变元素尺寸、位置属性会**触发重排***，*即重新进行样式计算、布局、绘制及后续流程*；*改变元素颜色属性会**触发重绘**，即重新进行样式计算和绘制。两者都会占用主线程，可能与JS抢占执行时间*。

## 优化方法
[18:36] 
*一是使用requestAnimationFrame API*，将JS任务分成小块，在每一帧时间用完前暂停JS执行归还主线程；
*二是利用CSS的transform属性实现动画*，其直接运行在合成器线程和栅格化线程，不占用主线程，节省运算时间。