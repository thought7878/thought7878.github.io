# 定义
    
- **全称**：XSS（Cross - Site Scripting），即跨站脚本攻击。它是一种常见的网络安全漏洞，攻击者通过在目标网站中注入恶意脚本，使用户在访问受影响的页面时浏览器执行这些恶意脚本，从而获取用户的敏感信息、篡改页面内容或执行其他恶意操作。

# 攻击原理
    
- **注入点寻找**：攻击者首先会寻找目标网站中可以注入脚本的位置。这些位置通常是**用户输入能够在页面上显示的地方，例如评论区、留言板、搜索框等**。例如，*一个网站的评论区允许用户输入文本内容，并且这些内容会直接在页面上展示*，而没有进行足够的安全处理，这就可能成为一个注入点。
- **恶意脚本注入**：攻击者利用注入点，将恶意脚本（通常是 JavaScript 脚本）注入到目标页面中。恶意脚本的形式多样，比如可以是一个窃取用户登录凭证的脚本，如`document.cookie`用于获取用户的 Cookie 信息，也可以是一个修改页面内容的脚本，如修改页面显示的价格信息。
- **脚本执行**：当用户访问包含恶意脚本的页面时，浏览器会将这些恶意脚本当作正常的脚本进行执行。因为浏览器会解析并执行页面中的所有脚本，只要这些脚本在语法上是正确的并且符合浏览器的执行规则。

# XSS 攻击的类型
    
- **反射型 XSS**：
	- **原理**：也称为非持久型 XSS。这种类型的攻击中，恶意脚本通过一个中间媒介（如一个 URL 链接）传递给受害者。*当受害者点击这个包含恶意脚本的链接时，服务器会接收并处理这个请求，然后将包含恶意脚本的页面内容反射回受害者的浏览器进行执行*。例如，一个网站有一个搜索功能，攻击者构造一个恶意的搜索链接，如`https://example.com/search?q=<script>alert('XSS')</script>`，当用户点击这个链接时，服务器会将这个包含恶意脚本的查询结果返回并在浏览器中执行。
	- **特点**：反射型 XSS 通常需要用户*点击一个特制的链接*才能触发攻击，攻击不具有持久性，每次攻击都需要用户手动触发。
- **存储型 XSS**：
	- **原理**：又称为持久型 XSS。攻击者将恶意脚本*存储在目标网站的服务器上*，如*存储在数据库中的用户评论、文章内容等地方。当其他用户访问包含恶意脚本的页面时，浏览器就会执行这些脚本*。例如，攻击者在一个论坛的评论区发布一条包含恶意脚本的评论，只要网站没有对评论内容进行安全过滤，之后访问这个评论的用户都会受到攻击。
	- **特点**：存储型 XSS 的恶意脚本存储在服务器上，具有持久性。一旦脚本被存储，它就会在用户访问相关页面时自动执行，影响范围可能很广。
- **DOM - based XSS**：
	- **原理**：这种攻击主要依赖于浏览器的 DOM（Document Object Model）操作。攻击者通过*修改页面的 DOM 结构来执行恶意脚本*。通常是利用网站中 JavaScript 代码对用户输入处理不当的情况。例如，一个网页中的 JavaScript 代码*使用`document.write()`函数来将用户输入的内容直接写入页面，攻击者可以通过构造恶意输入来注入脚本*，如`document.write('<script>alert("XSS")</script>')`。
	- **特点**：DOM - based XSS 攻击完全在浏览器端进行，不涉及服务器对数据的处理不当。攻击是通过操纵 DOM 树来实现的，使得恶意脚本能够在浏览器中执行。

# 危害
    
- **信息窃取**：最常见的危害之一是窃取用户的敏感信息，如登录凭证（用户名和密码）、个人身份信息、银行卡信息等。通过恶意脚本获取用户的 Cookie 后，攻击者可以利用这些信息进行非法登录等操作。
- **页面篡改**：攻击者可以修改页面内容，传播虚假信息或破坏网站的正常展示。例如，修改电商网站上商品的价格、修改新闻网站的新闻内容等。
- **钓鱼攻击**：利用 XSS 攻击可以创建虚假的登录页面或其他诱骗用户输入敏感信息的页面，让用户误以为是在正常的网站环境下操作，从而获取用户的信息。
- **恶意传播**：通过修改页面内容，攻击者可以在页面上添加恶意链接或自动传播恶意脚本，进一步扩大攻击范围。

# 如何阻止 XSS 攻击

1. **输入验证与过滤**
    
    - **严格的输入验证**：*对用户输入的内容进行严格的验证*，确保其符合预期的格式和内容类型。例如，对于一个只允许输入数字的输入框，要验证用户输入是否确实为数字。如果是用于接收电子邮件地址的输入框，要使用正则表达式等技术验证其是否符合电子邮件的格式。如验证电子邮件地址可以使用类似`^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9 -]+\.[a-zA-Z0-9-.]+$`的正则表达式。
    - **过滤特殊字符**：*对用户输入的内容进行过滤，去除或转义可能导致 XSS 攻击的特殊字符*。特别是对于`<`、`>`、`&`、`"`、`'`等 HTML 和 JavaScript 中的关键字符。例如，将`<`转义为`&lt;`，`>`转义为`&gt;`。在许多编程语言中都有相应的函数来进行这种转义操作。如在 Python 中，可以使用`html.escape()`函数来转义 HTML 中的特殊字符。
    - **限制输入长度**：*设置合理的输入长度限制，防止攻击者输入过长的恶意内容*。例如，对于评论区的输入，限制评论长度为一定的字符数，这样可以避免攻击者输入大量的恶意脚本。

2. **输出编码与转义**
    
    - **HTML 编码**：在将用户输入的内容输出到 HTML 页面时，进行 HTML 编码。这意味着将特殊字符转换为 HTML 实体，使得浏览器将其作为普通文本而不是脚本标签来处理。例如，当在页面上显示用户评论时，要确保评论内容经过 HTML 编码。*如果评论中有一个`<script>`标签，经过编码后它将以文本形式显示，而不会被浏览器当作脚本执行*。
    - **JavaScript 编码（在 JavaScript 环境中输出）**：如果要在 JavaScript 代码中使用用户输入的内容，需要进行 JavaScript 编码。例如，当使用`document.write()`函数来输出用户输入的内容时，要对内容进行 JavaScript 编码，以防止脚本注入。这可以通过对特殊字符进行转义来实现，如将单引号`'`转义为`\'`，双引号`"`转义为`\"`。
    - **CSS 编码（在 CSS 环境中输出）**：在将用户输入的内容用于 CSS 样式（如通过内联样式或者动态添加样式规则）时，也需要进行 CSS 编码。防止攻击者通过注入 CSS 样式来执行恶意脚本或者进行其他恶意操作。例如，对用户输入的颜色值进行验证和编码，确保其符合 CSS 颜色值的格式，并且不会包含恶意的 CSS 规则。

3. **设置安全的 HTTP 头**
    
    - **Content - Security - Policy（CSP）头**：CSP 是一种强大的安全机制，它允许网站管理员*定义哪些脚本来源是可信的，从而限制浏览器可以加载和执行的脚本*。例如，可以设置 CSP 头来指定只有来自本网站域名下的脚本才能被执行，如`Content - Security - Policy: script - src 'self';`。这可以有效地防止外部恶意脚本的注入和执行。
	    - 参考 [[CSP-内容安全策略]]。

	- **X - XSS - Protection 头**：*这个头可以启用浏览器内置的 XSS 防护机制*。虽然浏览器的防护机制不是绝对可靠的，但它可以作为一种额外的防御层。例如，可以设置`X - XSS - Protection: 1; mode = block`，这样当浏览器检测到可能的 XSS 攻击时，会尝试阻止页面的加载。

4. **谨慎使用 JavaScript 的 DOM 操作**
    
    - **避免使用危险的 DOM 方法**：如尽量避免使用`document.write()`等可能会直接将用户输入的内容写入页面并执行的方法。如果必须使用，要确保对输入内容进行严格的验证和编码。
    - **正确处理用户输入的 DOM 更新**：当使用 JavaScript 更新 DOM 树来显示用户输入的内容时，要使用安全的方法。例如，使用`textContent`或`innerText`属性来设置文本内容，而不是`innerHTML`（因为`innerHTML`会解析 HTML 标签，可能会导致脚本注入）。例如，`document.getElementById('output').textContent = userInput;`会将用户输入作为纯文本显示，而不会执行其中可能包含的脚本。

5. **定期安全审计和更新**
    
    - **代码审计**：定期对网站的代码进行安全审计，检查是否存在可能导致 XSS 攻击的漏洞。这包括检查所有用户输入的处理点、输出的渲染方式以及 JavaScript 代码中的 DOM 操作等。可以使用自动化的安全扫描工具和手动的代码审查相结合的方式。
    - **更新软件和框架**：保持网站所使用的软件（如内容管理系统、Web 框架等）为最新版本。软件供应商通常会修复已知的安全漏洞，及时更新可以减少 XSS 攻击的风险。例如，如果使用一个流行的 Web 框架，要关注其官方发布的安全更新，并及时应用这些更新到网站中。


# 参考
[[33.跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？]]