# 定义
    
- **全称**：CSRF（Cross - Site Request Forgery），即跨站请求伪造。它是一种网络安全漏洞，攻击者*通过诱导用户在已登录目标网站的状态下，访问恶意网站，在恶意网站下，利用用户的身份认证信息（如 Cookie）在目标网站执行非用户本意的操作*。

# 攻击原理
    
- **利用用户认证状态**：用户在登录目标网站（如银行网站、电商网站等）后，浏览器会保存用户的身份认证信息，通常是通过 Cookie 来保存。当用户访问包含恶意请求的第三方网站时，*由于浏览器会自动携带与目标网站相关的 Cookie，攻击者就可以利用这一点*。

- **构造恶意请求**：*攻击者在恶意网站中构造一个看似合法的请求，这个请求的目标是用户已经登录的目标网站*。例如，在一个银行转账的场景中，攻击者可以构造一个包含转账操作的 HTML 表单或 JavaScript 脚本。表单的`action`属性指向银行网站的转账接口，并且通过隐藏的输入字段设置转账金额和收款账户等信息。

- **诱导用户访问**：攻击者通过各种方式（如发送欺骗性的链接、在恶意广告中嵌入链接等）诱导用户访问包含恶意请求的网站。*当用户访问这个网站时，浏览器会自动发送用户在目标网站的身份认证信息（Cookie），并且执行恶意请求，**就好像是用户自己在目标网站发起的操作一样***。

# CSRF 攻击的类型
    
- **自动发起的请求**：
	- **利用 HTML 标签**：攻击者可以使用`<img>`、`<iframe>`、`<script>`等 HTML 标签来自动发起请求。例如，使用`<img src="https://bank.example.com/transfer?amount=1000&account=attacker - account"/>`，当用户访问包含这个标签的页面时，浏览器会尝试加载图片，实际上就会向银行网站发送一个转账请求。虽然浏览器可能因为图片加载失败而显示错误，但请求已经被发送。
	- **利用 JavaScript**：通过 JavaScript 代码来发起请求也是常见的方式。例如，`var xhr = new XMLHttpRequest(); xhr.open("POST", "https://bank.example.com/transfer", true); xhr.setRequestHeader("Content - type", "application/x - www - form - urlencoded"); xhr.send("amount = 1000&account = attacker - account");`。如果用户访问的页面包含这样的脚本，就会向银行网站发送转账请求。
- **用户触发的请求**：
	- **利用表单欺骗**：攻击者构造一个看似正常的表单，如一个虚假的抽奖表单。当用户填写并提交表单时，实际上是在向目标网站发送恶意请求。例如，表单的`action`属性指向用户的电商账户修改密码接口，而用户以为是在参加抽奖活动，从而在不知情的情况下修改了自己的密码。

# 危害
    
- **资金损失**：在金融相关的网站中，CSRF 攻击可能导致用户资金被盗转。攻击者可以构造转账、支付等请求，将用户账户中的资金转移到自己的账户。
- **信息篡改**：可以修改用户在目标网站上的个人信息，如修改密码、修改收货地址等。这可能导致用户账户被攻击者控制，或者用户的购物、通信等信息被篡改。
- **恶意操作**：在社交网络等网站上，可能导致用户发布恶意内容、关注或取消关注某些用户等非用户本意的操作，影响用户的声誉和正常的社交活动。

# 对比 XSS

和 XSS 不同的是，*CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击*。


# 如何防止 CSRF 攻击

1. **使用 CSRF 令牌（Token）**
    
    - **原理**：CSRF 令牌是一种用于验证请求是否来自合法用户的机制。服务器在生成页面时，会为每个用户生成一个唯一的、随机的令牌，并将其包含在页面的表单或隐藏字段中。当用户提交表单或发起请求时，这个令牌会一起被发送到服务器。服务器会验证接收到的令牌是否与之前为该用户生成的令牌一致。如果一致，说明请求是合法的；如果不一致，就拒绝请求。
    - **示例**：在一个 Web 应用的登录表单中，服务器在渲染表单时会生成一个类似`csrf_token = 'abcdef123456'`的令牌，并将其作为隐藏字段放在表单中，如`<input type="hidden" name="csrf_token" value="abcdef123456">`。当用户提交表单时，服务器会检查接收到的`csrf_token`的值是否与之前生成的一致。
    - **适用场景**：适用于各种包含用户操作的表单，如登录、注册、修改密码、转账等操作的表单，是防止 CSRF 攻击最常用的方法之一。

2. **验证请求来源（Referer 检查）**
    
    - **原理**：服务器可以检查请求的来源（通过`Referer`头信息），确保请求是来自合法的页面。例如，如果一个转账请求应该是从银行网站的内部页面发起的，那么服务器可以检查`Referer`头是否是银行网站的域名。如果不是，就拒绝请求。
    - **局限性**：这种方法有一定的局限性。首先，`Referer`头信息可能因为浏览器设置、代理服务器等原因而不准确。其次，在一些跨域场景或者同域下的复杂架构中，`Referer`头的验证可能会出现误判。例如，当网站使用了 CDN（内容分发网络）时，`Referer`头可能会显示 CDN 的域名而不是实际的网站域名。
    - **适用场景**：可以作为一种辅助的验证方法，与其他防止 CSRF 攻击的方法结合使用。在一些对安全性要求不是特别高，且请求来源相对固定的场景下可以使用。

3. **Same - Site Cookie 属性**
    
    - **原理**：`Same - Site`是 Cookie 的一个属性，用于限制 Cookie 在跨站请求中的发送。它有三个取值：`Strict`、`Lax`和`None`。`Strict`模式下，只有当请求来自与 Cookie 设置的域名完全相同的站点，并且请求方式是顶级导航（如用户在地址栏输入网址或通过点击网站内的链接）时，浏览器才会发送 Cookie。`Lax`模式相对宽松一些，在一些安全的跨站请求场景下（如通过`GET`方法的链接跳转）也允许发送 Cookie。`None`模式则不限制 Cookie 的跨站发送，和没有设置`Same - Site`属性时类似。
    - **示例**：在设置用户登录后的 Cookie 时，可以将`Same - Site`属性设置为`Strict`，如`Set - Cookie: session_id = 123456; Same - Site = Strict`。这样，当用户访问恶意网站并尝试发起跨站请求时，浏览器不会发送这个带有用户登录信息的 Cookie，从而防止 CSRF 攻击。
    - **适用场景**：适用于保护用户登录后的会话信息，防止利用用户会话进行的 CSRF 攻击。不过，在使用`Same - Site`属性时，需要考虑对网站功能的影响，特别是一些涉及跨站操作（如第三方登录、跨站资源共享等）的功能。

4. **双重 Cookie 验证**
    
    - **原理**：这种方法需要在客户端和服务器端进行配合。首先，服务器在用户访问页面时，除了设置正常的会话 Cookie 外，还会设置一个额外的、具有特定名称（如`csrf_cookie`）的 Cookie，其值为一个随机的令牌。同时，在页面中的每个表单或关键的请求中，都会包含一个隐藏字段，其值是从这个`csrf_cookie`中读取的。当服务器接收到请求时，会检查请求中的隐藏字段的值是否与`csrf_cookie`中的值一致。
    - **示例**：服务器在用户访问页面时，设置`Set - Cookie: csrf_cookie = abcdef123456`。在表单中包含`<input type="hidden" name="csrf_value" value="abcdef123456">`。当用户提交表单时，服务器检查`csrf_value`的值是否与`csrf_cookie`中的值相同。
    - **适用场景**：可以作为一种替代 CSRF 令牌的方法，尤其适用于一些不适合在表单中添加额外隐藏字段的场景，如通过 JavaScript 直接发起的请求。不过，这种方法也有一定的复杂性，需要注意 Cookie 的安全性和隐私问题。


## 相关资料
[Understanding CSRF attacks](https://vercel.com/blog/understanding-csrf-attacks)
