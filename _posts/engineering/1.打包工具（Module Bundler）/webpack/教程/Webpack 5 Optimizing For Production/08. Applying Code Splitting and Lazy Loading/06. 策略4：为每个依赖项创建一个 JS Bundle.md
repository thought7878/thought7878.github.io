Strategy #4: Creating a JS Bundle For Each Dependency

视频讲述了 Webpack 5 中 **“为每个依赖项单独创建 JS 包”的代码拆分策略**，包括*配置调整、实际效果、优缺点及适用场景*，具体如下：

## 策略核心与目标

[00:00]
*此前视频将 node_modules 中依赖合并为一个 JS 包*，
**本策略与之相反，目标是将每个依赖项单独打包**。

## 调整 Webpack 配置

[00:24]
*基本保留原有缓存组，仅修改用于指定包名称的选项*；
**若基于同一缓存组生成多个包，需用函数而非字符串命名**；
该函数会*依据正则表达式，从模块绝对路径中提取 node_modules 之后的片段作为包的高层名称*。

![[_posts/engineering/1.打包工具（Module Bundler）/webpack/教程/Webpack 5 Optimizing For Production/08. Applying Code Splitting and Lazy Loading/media/902355fb834e01e3d1e199c4294d6fc2_MD5.jpeg]]

## 打包结果与数量说明

[02:06]
运行包分析器后，示例中*生成了七个包：*
虽 node_modules 文件夹包含更多包，但 **Webpack 仅会打包应用程序实际使用的包**，无需担心生成上百个小包，**具体数量取决于应用程序大小**，且**通常仅包含 package.json dependencies 列出的常规依赖项及其依赖**。

![[_posts/engineering/1.打包工具（Module Bundler）/webpack/教程/Webpack 5 Optimizing For Production/08. Applying Code Splitting and Lazy Loading/media/dbc4dc2ae1175428ccc064a1f12e7766_MD5.jpeg]]

## 应用运行与网络请求情况

[03:26]
在浏览器中打开应用，确认生成大量包后应用仍能正常运行；
通过开发者工具网络面板可看到，浏览器需加载七个 JavaScript 文件来运行该页面。

![[_posts/engineering/1.打包工具（Module Bundler）/webpack/教程/Webpack 5 Optimizing For Production/08. Applying Code Splitting and Lazy Loading/media/c3246d0c3768ad50a8c789ef14709ceb_MD5.jpeg]]

![[_posts/engineering/1.打包工具（Module Bundler）/webpack/教程/Webpack 5 Optimizing For Production/08. Applying Code Splitting and Lazy Loading/media/61dbe1ad19b35854d13f09a17550bc33_MD5.jpeg]]

## 策略优缺点与适用场景

[04:16]
**优点**是*能优化每个包的大小，使所有捆绑包尽可能小*；
**缺点**是*会产生大量包，导致浏览器首次访问网站时需发起大量 HTTP 请求*。

*该策略仅在使用 HTTP 工具时才有意义，因 HTTP 工具在多请求场景下性能表现良好*；
且后续（第二次、第三次及以后）访问时，*浏览器会从缓存获取数据*，可提升加载速度，这也是该策略被认为有效的原因。

