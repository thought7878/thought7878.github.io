## 源代码
**index.js**
```js
import { minus } from './minus';
import { sum } from './sum';

console.log(sum(1, 2));
console.log(minus(1, 2));
```

**minus.js**
```js
export const minus = (a, b) => {
  return a - b;
};
```

**sum.js**
```js
export const sum = (a, b) => {
  return a + b;
};
```

## 运行时代码（webpack构建后）
**bundle.js**
```js

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   minus: () => (/* binding */ minus)
/* harmony export */ });
const minus = (a, b) => {
  return a - b;
};


/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sum: () => (/* binding */ sum)
/* harmony export */ });
const sum = (a, b) => {
  return a + b;
};


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _minus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);



console.log((0,_sum__WEBPACK_IMPORTED_MODULE_1__.sum)(1, 2));
console.log((0,_minus__WEBPACK_IMPORTED_MODULE_0__.minus)(1, 2));

})();

/******/ })()
;
```

# webpack 运行时代码的分析

详细解释这个webpack打包后的bundle.js文件。

## 整体结构分析

这个打包文件是一个典型的webpack输出，包含了所有模块和webpack运行时代码。整个文件被包裹在一个立即执行函数表达式（IIFE）中，防止变量污染全局作用域。

## 模块定义部分

```javascript
var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   minus: () => (/* binding */ minus)
/* harmony export */ });
const minus = (a, b) => {
  return a - b;
};
/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
// ... sum module code ...
```

模块数组包含了三个模块：
- 索引0：空模块（入口模块的占位符）
- 索引1：[minus.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/minus.js)模块，导出minus函数
- 索引2：[sum.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/sum.js)模块，导出sum函数

## 模块缓存机制

```javascript
var __webpack_module_cache__ = {};
```

用于缓存已加载的模块，避免重复执行相同模块。

## webpack_require函数

```javascript
function __webpack_require__(moduleId) {
  // 检查模块是否已在缓存中
  var cachedModule = __webpack_module_cache__[moduleId];
  if (cachedModule !== undefined) {
    return cachedModule.exports;
  }
  // 创建新模块并放入缓存
  var module = __webpack_module_cache__[moduleId] = {
    exports: {}
  };
  // 执行模块函数
  __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  // 返回模块的导出
  return module.exports;
}
```

这是webpack实现的模块加载函数，模拟了Node.js的require机制，是webpack模块系统的核心。

## 运行时辅助函数

1. `__webpack_require__.d`：定义导出属性的getter函数
2. `__webpack_require__.o`：检查对象是否有特定属性的简写
3. `__webpack_require__.r`：在导出对象上定义`__esModule`标记

## 入口模块执行

```javascript
var __webpack_exports__ = {};
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _minus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _sum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);

console.log((0,_sum__WEBPACK_IMPORTED_MODULE_1__.sum)(1, 2));
console.log((0,_minus__WEBPACK_IMPORTED_MODULE_0__.minus)(1, 2));
})();
```

这是你的入口文件[src/index.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/index.js)的编译版本：
1. 导入minus函数：`var _minus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);`
2. 导入sum函数：`var _sum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);`
3. 调用并输出结果：
   - `console.log((0,_sum__WEBPACK_IMPORTED_MODULE_1__.sum)(1, 2));` 输出3
   - `console.log((0,_minus__WEBPACK_IMPORTED_MODULE_0__.minus)(1, 2));` 输出-1

## 工作流程总结

1. [index.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/index.js)导入[minus.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/minus.js)和[sum.js](file:///Users/ll/Desktop/learn-notes/frontend/react/learn-demoes/webpack-learn-demo/src/sum.js)中的函数
2. webpack将这些文件处理为模块（索引1是minus模块，索引2是sum模块）
3. 当执行到入口文件时，通过`__webpack_require__(1)`和`__webpack_require__(2)`分别加载两个模块
4. 模块执行后返回包含对应函数的对象
5. 最终调用这些函数并输出计算结果

整个打包机制的目标是让原本在不同文件中的模块能够在浏览器环境中正确加载和执行，同时保持模块间的依赖关系和ES6模块语法特性。