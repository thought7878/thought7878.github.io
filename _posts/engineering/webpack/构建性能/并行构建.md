# 为什么要并行构建

**受限于 Node.js 的单线程架构**，原生 Webpack 对所有资源文件做的所有解析、转译、合并操作*本质上都是在同一个线程内串行执行，CPU 利用率极低*。因此，理所当然地，*社区出现了一些以多进程方式运行 Webpack或 Webpack 构建过程某部分工作的方案*(从而提升单位时间利用率)，例如：
- [Thread-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Floaders%2Fthread-loader%2F)：Webpack 官方出品，同样以多进程方式**加载资源**；
- [HappyPack](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack)：不维护了，多进程方式运行资源加载(Loader)逻辑；

- [Parallel-Webpack](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fparallel-webpack)：多进程方式*运行多个 Webpack 构建实例*；
- [TerserWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fterser-webpack-plugin%23terseroptions)：支持*多进程方式执行代码压缩、uglify 功能*。

**这些方案的核心设计都很类似：** 针对某种计算任务创建子进程，之后将运行所需参数通过 IPC 传递到子进程并启动计算操作，计算完毕后子进程再将结果通过 IPC 传递回主进程，寄宿在主进程的组件实例，再将结果提交给 Webpack。













# 参考
[[14 Webpack 都有哪些实现并行构建的方法？]]