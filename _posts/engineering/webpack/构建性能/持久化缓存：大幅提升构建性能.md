
# 缓存原理

那么，**为什么开启持久化缓存之后，构建性能会有如此巨大的提升呢？**
一言蔽之，Webpack5 会*将首次构建出的 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，后面再运行的时候，就可以跳过许多耗时的编译动作，直接复用缓存数据*。

回过头来看看 Webpack 的构建过程，大致上可划分为**三个阶段：**

![[engineering/教程/Webpack5 核心原理与应用实践/media/0007aa99d42380bfd9ce3abfce8fadf9_MD5.webp]]

- 初始化阶段：
	- 主要是根据配置信息设置/初始化内置的各类插件。
- 构建阶段/Make：
	- 从`entry`模块开始，执行
	- 读入文件内容；
	- 调用 Loader 转译文件内容；
	- 调用 [acorn](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Facorn) 生成 AST 结构；
	- 分析 AST，确定模块依赖列表；
	- 遍历模块依赖列表，对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— ModuleGraph 对象。
- 生成阶段/Seal：
	- 遍历模块依赖图，对每一个模块执行：
		- 代码转译？？？，如 `import` 转换为 `require` 调用；
		- 分析运行时依赖。
	- 合并模块代码与运行时代码，生成 chunk；
	- 执行产物优化操作，如 Tree-shaking；
	- 将最终结果写出到产物文件。

**过程中存在许多 CPU 密集型操作**。例如调用 Loader 链加载文件时，遇到 babel-loader、eslint-loader、ts-loader 等工具时*可能需要重复生成 AST*；*分析模块依赖时则需要遍历 AST，执行大量运算*；Seal 阶段也同样存在*大量 AST 遍历，以及代码转换、优化操作*，等等。假设业务项目中有 1000 个文件，则每次执行 `npx webpack` 命令时，都需要从 0 开始执行 1000 次构建、生成逻辑。

而 Webpack5 的持久化缓存功能则**将构建结果保存到文件系统中，在下次编译时对比每一个文件的内容哈希或时间戳，未发生变化的文件跳过编译操作，直接使用缓存副本，减少重复计算**；**发生变更的模块**则重新执行编译流程。*缓存执行时机如下图：*

![[engineering/教程/Webpack5 核心原理与应用实践/media/21781e8ece576c6be0eaa1c6681bbefd_MD5.webp]]

如图，**Webpack 在首次构建完毕后将 Module、Chunk、ModuleGraph 三类对象的状态序列化并记录到缓存文件中；在下次构建开始时，尝试读入并恢复这些对象的状态，从而跳过执行 Loader 链、解析 AST、解析依赖等耗时操作，提升编译性能**。


# 参考
[[13 如何使用 Webpack 持久化缓存大幅提升构建性能？]]