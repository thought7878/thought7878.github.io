# 图片懒加载：前端性能优化的核心技术

`图片懒加载（Image Lazy Loading）`是前端性能优化中最基础且效果显著的技术之一，它通过**延迟加载非关键图片资源**，*显著提升页面加载速度、减少带宽消耗、改善用户体验*。

## 为什么需要图片懒加载？

### 性能问题现状

- 据HTTP Archive统计，**图片平均占网页总资源的50%以上**
- *未优化的图片可导致：*
  - 首屏加载时间延长3-5秒
  - 带宽消耗增加2-3倍
  - 移动端数据费用显著增加
  - 服务器压力增大

### 懒加载带来的收益

| 指标          | 优化前   | 懒加载后  | 改善幅度  |
| ----------- | ----- | ----- | ----- |
| 首屏加载时间      | 3.8s  | 1.2s  | ↓ 68% |
| 初始请求数       | 45    | 12    | ↓ 73% |
| 初始资源大小      | 2.1MB | 480KB | ↓ 77% |
| TTI (可交互时间) | 4.2s  | 1.8s  | ↓ 57% |

## 图片懒加载工作原理

### 核心思想

**"按需加载"** - 只加载用户即将看到或可能看到的图片，而非一次性加载所有图片。

### 实现流程

1. **初始加载**：只加载视口内或关键区域的图片
2. **占位处理**：为非关键图片设置占位符（如低质量缩略图、纯色背景）
3. **监测触发**：当用户滚动接近图片时触发加载
4. **资源替换**：将占位符替换为实际高清图片
5. **状态管理**：标记已加载图片，避免重复请求

## 实现方法对比

### 1. 传统方法：Scroll 事件监听（不推荐）

```javascript
function lazyLoadImages() {
  const images = document.querySelectorAll('img[data-src]');
  
  images.forEach(img => {
    const rect = img.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    
    // 当图片距离视口顶部300px内时加载
    if (rect.top <= viewportHeight + 300) {
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
    }
  });
}

// 初始加载和滚动时触发
lazyLoadImages();
window.addEventListener('scroll', _.throttle(lazyLoadImages, 100));
window.addEventListener('resize', _.throttle(lazyLoadImages, 100));
```

**缺点**：
- `getBoundingClientRect()` 触发重排(reflow)，性能开销大
- 需要手动处理节流和边界情况
- 无法精确控制交叉比例
- 移动端滚动事件处理复杂

### 2. 现代方法：IntersectionObserver API（推荐）

```javascript
const lazyImages = document.querySelectorAll('img[data-src]');

const imageObserver = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.removeAttribute('data-src');
      
      // 加载完成后停止观察（可选）
      observer.unobserve(img);
      
      // 添加加载完成的过渡效果
      img.onload = () => {
        img.style.transition = 'opacity 0.3s';
        img.style.opacity = 1;
      };
    }
  });
}, {
  rootMargin: '100px 0px', // 提前100px加载
  threshold: 0.01           // 1%可见即触发
});

lazyImages.forEach(img => {
  imageObserver.observe(img);
});
```

**优势**：
- 浏览器原生实现，*性能开销极低*
- *无需手动计算位置*
- 支持精确的交叉比例控制
- 自动处理各种滚动场景

## HTML 原生懒加载（无需JS）

现代浏览器已支持原生图片懒加载，通过`loading`属性实现：

```html
<!-- 延迟加载（推荐用于非关键图片） -->
<img src="placeholder.jpg" 
     data-src="actual-image.jpg"
     loading="lazy"
     alt="示例图片">

<!-- 立即加载（关键图片） -->
<img src="hero-image.jpg" 
     loading="eager"
     alt="关键图片">
```

**浏览器支持**：
- Chrome 76+
- Firefox 75+
- Edge 79+
- Safari 15.4+
- 不支持的浏览器会忽略该属性，回退到常规加载

**最佳实践**：
- 将`loading="lazy"`用于**非关键图片**（内容下方、侧边栏等）
- **关键图片**（首屏、logo等）使用`loading="eager"`或不设置
- 始终提供`src`属性作为占位或低质量预览图

## 框架集成方案

### React 实现

**自定义Hook封装**：

```jsx
import { useEffect, useRef } from 'react';

function useLazyImage({ src, placeholder, onLoad }) {
  const imgRef = useRef(null);
  
  useEffect(() => {
    const img = imgRef.current;
    if (!img || !src) return;
    
    const observer = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting) {
        const image = new Image();
        image.src = src;
        image.onload = () => {
          img.src = src;
          onLoad?.();
          observer.unobserve(img);
        };
      }
    }, {
      rootMargin: '100px',
      threshold: 0.05
    });
    
    observer.observe(img);
    
    return () => observer.disconnect();
  }, [src, onLoad]);
  
  return {
    ref: imgRef,
    src: placeholder || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
  };
}

// 使用组件
function LazyImage({ src, alt, className }) {
  const { ref, src: imgSrc } = useLazyImage({
    src,
    placeholder: 'path/to/placeholder.jpg',
    onLoad: () => console.log('Image loaded')
  });
  
  return (
    <img 
      ref={ref}
      src={imgSrc} 
      alt={alt} 
      className={`${className} transition-opacity duration-300`}
      style={{ opacity: imgSrc === src ? 1 : 0.7 }}
    />
  );
}
```

### Vue 3 实现

**自定义指令**：

```javascript
// lazy-image.js
export default {
  mounted(el, binding) {
    const imgSrc = binding.value;
    
    const observer = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting) {
        const img = new Image();
        img.src = imgSrc;
        img.onload = () => {
          el.src = imgSrc;
          el.style.opacity = '1';
          observer.unobserve(el);
        };
      }
    }, {
      rootMargin: '100px',
      threshold: 0.1
    });
    
    // 保存observer实例以便后续操作
    el._lazyObserver = observer;
    observer.observe(el);
  },
  unmounted(el) {
    if (el._lazyObserver) {
      el._lazyObserver.disconnect();
      delete el._lazyObserver;
    }
  }
};

// 在main.js中注册
import lazyImage from './directives/lazy-image';
app.directive('lazy', lazyImage);

// 使用
<img v-lazy="'path/to/actual-image.jpg'" 
     src="path/to/placeholder.jpg" 
     alt="示例图片"
     class="opacity-70 transition-opacity duration-300">
```

## 高级技巧与最佳实践

### 1. 渐进式图片加载

结合低质量图像占位符(LQIP)和SVG模糊效果：

```html
<img 
  src="lqip-base64.jpg" 
  data-src="high-quality.jpg"
  class="lqip"
  alt="渐进式加载图片">

<style>
.lqip {
  filter: blur(8px);
  transition: filter 0.3s;
}
.lqip.loaded {
  filter: blur(0);
}
</style>

<script>
// 加载完成后移除模糊效果
const img = document.querySelector('.lqip');
img.onload = () => {
  img.classList.add('loaded');
};
</script>
```

### 2. 响应式图片与srcset

```html
<img 
  src="small.jpg"
  data-src="medium.jpg"
  data-srcset="small.jpg 480w, medium.jpg 768w, large.jpg 1200w"
  sizes="(max-width: 600px) 480px, 800px"
  class="lazy"
  alt="响应式图片">
```

JavaScript处理：

```javascript
const img = entry.target;
if (img.dataset.srcset) {
  img.srcset = img.dataset.srcset;
  img.sizes = img.dataset.sizes || '(max-width: 600px) 480px, 800px';
}
if (img.dataset.src) {
  img.src = img.dataset.src;
}
```

### 3. 预加载临近图片

```javascript
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.intersectionRatio > 0.2) { // 20%可见时预加载
      const img = entry.target;
      if (!img.dataset.loaded) {
        const highRes = new Image();
        highRes.src = img.dataset.src;
        highRes.onload = () => {
          img.src = img.dataset.src;
          img.dataset.loaded = 'true';
          img.classList.add('loaded');
        };
      }
    }
  });
}, {
  rootMargin: '300px 0px', // 提前300px预加载
  threshold: 0.2
});
```

### 4. 处理图片高度塌陷

懒加载可能导致页面布局跳动，解决方案：

**方案1：固定宽高比容器**

```css
.image-container {
  position: relative;
  padding-top: 75%; /* 4:3 宽高比 */
}

.lazy-image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
```

**方案2：使用aspect-ratio CSS属性**

```css
.lazy-image {
  width: 100%;
  aspect-ratio: 16/9;
  object-fit: cover;
}
```

**方案3：内联宽高属性**

```html
<img src="placeholder.jpg" 
     data-src="image.jpg"
     width="800"
     height="600"
     alt="带宽高属性的图片">
```

## 性能优化技巧

### 1. 智能加载策略

```javascript
// 根据网络状况调整加载策略
const shouldLoadHighRes = () => {
  if ('connection' in navigator) {
    // 2G网络下只加载低质量图片
    return navigator.connection.effectiveType !== 'slow-2g';
  }
  return true;
};

// 根据用户交互预测
let userIsScrollingFast = false;
let lastScrollTime = 0;

window.addEventListener('scroll', () => {
  const now = Date.now();
  userIsScrollingFast = (now - lastScrollTime) < 100; // 快速滚动
  lastScrollTime = now;
});

// 快速滚动时只加载关键图片
const loadThreshold = userIsScrollingFast ? 0.5 : 0.1;
```

### 2. 资源优先级管理

```javascript
function loadImage(url, priority = 'low') {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = url;
    link.as = 'image';
    link.onload = resolve;
    link.onerror = reject;
    
    // 设置资源加载优先级
    if (priority === 'high') {
      link.fetchPriority = 'high';
    } else if (priority === 'low') {
      link.fetchPriority = 'low';
    }
    
    document.head.appendChild(link);
  });
}

// 使用
loadImage('critical-image.jpg', 'high')
  .then(() => console.log('高优先级图片加载完成'));
```

### 3. 缓存已加载图片

```javascript
const imageCache = new Map();

function getCachedImage(src) {
  if (imageCache.has(src)) {
    return Promise.resolve(imageCache.get(src));
  }
  
  return new Promise((resolve) => {
    const img = new Image();
    img.src = src;
    img.onload = () => {
      imageCache.set(src, img);
      resolve(img);
    };
  });
}

// 使用缓存
entries.forEach(entry => {
  if (entry.isIntersecting) {
    const img = entry.target;
    getCachedImage(img.dataset.src).then(cachedImg => {
      img.src = cachedImg.src;
      observer.unobserve(img);
    });
  }
});
```

## SEO 与无障碍考虑

### 1. SEO最佳实践

- **保留alt属性**：确保搜索引擎能理解图片内容
- **提供结构化数据**：使用JSON-LD标记图片
- **关键图片不懒加载**：首屏核心内容图片应直接加载
- **服务器端渲染(SSR)**：对SEO关键页面，考虑SSR实现

### 2. 无障碍访问(ARIA)

```html
<div class="image-container" role="region" aria-label="产品展示图">
  <img 
    src="placeholder.jpg" 
    data-src="product.jpg"
    alt="最新款智能手表正面图，显示圆形表盘和金属表带"
    aria-hidden="true" <!-- 防止占位图被读屏器读取 -->
  >
  <noscript>
    <img src="product.jpg" alt="智能手表图片">
  </noscript>
</div>
```

### 3. 无JS环境降级

```html
<img 
  src="placeholder.jpg" 
  data-src="actual.jpg"
  alt="示例图片">

<noscript>
  <img src="actual.jpg" alt="示例图片">
</noscript>
```

## 常见问题与解决方案

### 1. 图片加载闪烁问题

**原因**：占位图与实际图片尺寸不一致  
**解决方案**：
- 使用固定宽高比容器
- 设置CSS过渡效果
- 使用相同宽高比的占位图

```css
.lazy-image {
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}
.lazy-image.loaded {
  opacity: 1;
}
```

### 2. 移动端快速滚动时图片加载不及时

**解决方案**：
- 增大`rootMargin`（如'300px 0px'）
- 降低`threshold`值（如0.01）
- 实现预加载机制

### 3. 图片加载失败处理

```javascript
img.onerror = () => {
  img.src = 'fallback.jpg'; // 备用图片
  img.classList.add('error');
  console.error(`图片加载失败: ${img.dataset.src}`);
  
  // 添加重试机制
  img.dataset.retryCount = (parseInt(img.dataset.retryCount) || 0) + 1;
  if (img.dataset.retryCount < 3) {
    setTimeout(() => {
      img.src = img.dataset.src; // 重新尝试
    }, 1000 * img.dataset.retryCount);
  }
};
```

### 4. SPA路由切换时的图片处理

在SPA应用中，路由切换时需要重新初始化懒加载：

```javascript
// Vue Router示例
router.afterEach((to, from) => {
  // 清理旧页面的观察器
  if (window.imageObserver) {
    window.imageObserver.disconnect();
  }
  
  // 初始化新页面的懒加载
  setTimeout(() => {
    initLazyLoading();
  }, 100);
});

function initLazyLoading() {
  const images = document.querySelectorAll('img[data-src]');
  window.imageObserver = new IntersectionObserver(/*...*/);
  images.forEach(img => window.imageObserver.observe(img));
}
```

## 性能指标与测试

### 关键性能指标

| 指标 | 目标值 | 测量方式 |
|------|--------|----------|
| LCP (最大内容绘制) | < 2.5s | Chrome DevTools, Lighthouse |
| TTI (可交互时间) | < 3.5s | Web Vitals库 |
| CLS (累积布局偏移) | < 0.1 | Chrome DevTools |
| 初始图片请求数 | < 10 | Network面板 |

### 测试工具

1. **Lighthouse**：全面的性能审计工具
2. **WebPageTest**：多地点、多设备测试
3. **Chrome DevTools**：
   - Performance面板：分析加载过程
   - Network面板：查看资源加载顺序
   - Rendering选项：显示布局变化

### 实际测试案例

```bash
# 使用Lighthouse测试懒加载效果
lighthouse https://example.com --view

# 模拟慢速网络
# 在Chrome DevTools中:
# Network > Throttling > Slow 3G
```

## 最佳实践总结

1. **分层加载策略**：
   - 首屏关键图片：直接加载或eager加载
   - 次要内容图片：lazy加载
   - 远离视口图片：延迟加载

2. **技术选型建议**：
   - 现代应用：优先使用IntersectionObserver
   - 简单场景：考虑HTML原生loading属性
   - 需要兼容旧浏览器：IntersectionObserver polyfill

3. **性能优化组合**：
   - 懒加载 + 响应式图片(srcset)
   - 懒加载 + WebP/AVIF格式
   - 懒加载 + CDN优化
   - 懒加载 + 图片压缩

4. **用户体验考量**：
   - 提供加载状态反馈
   - 避免布局跳动
   - 实现平滑过渡效果
   - 考虑用户滚动行为模式

## 结论

图片懒加载是前端性能优化的**必备技术**，合理实施可带来显著的性能提升：

- **首屏加载时间减少50%以上**
- **带宽消耗降低60-70%**
- **用户体验评分提升20-30%**

随着IntersectionObserver API的普及和HTML原生懒加载的支持，实现高质量的图片懒加载变得越来越简单。关键在于**根据具体场景选择合适的实现方式**，并结合响应式图片、格式优化等技术，构建全面的图片性能优化策略。

记住：**不是所有图片都适合懒加载**，关键内容图片应优先加载，而*远离用户当前视口的图片*才是懒加载的最佳候选。通过科学的策略和精心的实现，图片懒加载将成为提升Web应用性能的有力武器。


## 参考资料
[[09：图片懒加载业务场景分析]]
